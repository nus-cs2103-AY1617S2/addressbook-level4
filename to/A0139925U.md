# A0139925U
###### \java\seedu\tache\commons\events\ui\PopulateRecurringGhostTaskEvent.java
``` java
package seedu.tache.commons.events.ui;

import javafx.collections.ObservableList;
import seedu.tache.commons.events.BaseEvent;
import seedu.tache.model.task.ReadOnlyTask;

/**
 * Represents a selection change in the Task List Panel
 */
public class PopulateRecurringGhostTaskEvent extends BaseEvent {


    private final ObservableList<ReadOnlyTask> allRecurringGhostTasks;

    public PopulateRecurringGhostTaskEvent(ObservableList<ReadOnlyTask> allRecurringGhostTasks) {
        this.allRecurringGhostTasks = allRecurringGhostTasks;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public ObservableList<ReadOnlyTask> getAllRecurringGhostTasks() {
        return allRecurringGhostTasks;
    }
}
```
###### \java\seedu\tache\commons\events\ui\TaskPanelConnectionChangedEvent.java
``` java
package seedu.tache.commons.events.ui;

import javafx.collections.ObservableList;
import seedu.tache.commons.events.BaseEvent;
import seedu.tache.model.task.ReadOnlyTask;

/**
 * Represents a selection change in the Task List Panel.
 */
public class TaskPanelConnectionChangedEvent extends BaseEvent {


    private final ObservableList<ReadOnlyTask> newConnection;

    public TaskPanelConnectionChangedEvent(ObservableList<ReadOnlyTask> newConnection) {
        this.newConnection = newConnection;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public ObservableList<ReadOnlyTask> getNewConnection() {
        return newConnection;
    }
}
```
###### \java\seedu\tache\logic\commands\CompleteCommand.java
``` java
package seedu.tache.logic.commands;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;

import seedu.tache.commons.core.Messages;
import seedu.tache.logic.commands.exceptions.CommandException;
import seedu.tache.model.task.ReadOnlyTask;
import seedu.tache.model.task.Task;
import seedu.tache.model.task.UniqueTaskList;

/**
 * Edits the details of an existing task in the task manager.
 */
public class CompleteCommand extends Command implements Undoable {

    public static final String COMMAND_WORD = "complete";
    public static final String SHORT_COMMAND_WORD = "c";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Completes the task identified "
            + "by the index number used in the last tasks listing. "
            + "Existing values will be overwritten by the input values.\n"
            + "Parameters: INDEX1 (must be a positive integer), INDEX2, INDEX3, ... \n"
            + "Example: " + COMMAND_WORD + " 1, 2, 6, 8";

    public static final String MESSAGE_COMPLETED_TASK_SUCCESS = "Completed Task(s): \n%1$s";
    public static final String MESSAGE_NOT_COMPLETED = "At least one task's index must be provided.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";

    private final List<Integer> indexList;

    private boolean commandSuccess;
    private List<ReadOnlyTask> completedList;

    /**
     * @param filteredTaskListIndex the index of the task in the filtered task list to edit
     * @param completeTaskDescriptor details to edit the task with
     */
    public CompleteCommand(List<Integer> indexList) {
        assert indexList.size() > 0;
        this.indexList = indexList;

        // converts indexList from one-based to zero-based.
        for (int i = 0; i < indexList.size(); i++) {
            this.indexList.set(i, indexList.get(i) - 1);
        }
        Collections.reverse(indexList);
        commandSuccess = false;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = new ArrayList<ReadOnlyTask>(model.getFilteredTaskList());
        completedList = new ArrayList<ReadOnlyTask>();

        //Check all indexes are valid before proceeding
        for (int i = 0; i < indexList.size(); i++) {
            if (indexList.get(i) >= lastShownList.size()) {
                commandSuccess = false;
                throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }
        }

        for (int i = 0; i < indexList.size(); i++) {
            ReadOnlyTask taskToEdit = lastShownList.get(indexList.get(i));
            Task completedTask = createCompletedTask(taskToEdit);
            try {
                if (taskToEdit.getRecurState().isRecurring()) {
                    model.updateTask(createMasterRecurringTask(taskToEdit), completedTask);
                } else {
                    model.updateTask(taskToEdit, completedTask);
                }
            } catch (UniqueTaskList.DuplicateTaskException dpe) {
                commandSuccess = false;
                throw new CommandException(MESSAGE_DUPLICATE_TASK);
            }
            completedList.add(completedTask);
        }
        commandSuccess = true;
        undoHistory.push(this);
        //model.updateCurrentFilteredList();
        //model.getFilteredTaskList();

        return new CommandResult(String.format(MESSAGE_COMPLETED_TASK_SUCCESS, getSuccessMessage(completedList)));
    }

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     */
    private static Task createCompletedTask(ReadOnlyTask taskToEdit) {
        assert taskToEdit != null;
        if (taskToEdit.getRecurState().isGhostRecurring()) {
            //List<Date> tempList = (ArrayList<Date>) ((ArrayList<Date>) taskToEdit.getRecurState()
             //                           .getRecurCompletedList()).clone();
            List<Date> tempList = taskToEdit.getRecurState().getRecurCompletedList();
            tempList.add(new Date(taskToEdit.getRecurState().getRecurDisplayDate()));
            ((Task) taskToEdit).getRecurState().setRecurDisplayDate("");
            return new Task(taskToEdit.getName(), taskToEdit.getStartDateTime(), taskToEdit.getEndDateTime(),
                            taskToEdit.getTags(), taskToEdit.getTimedStatus(), taskToEdit.getActiveStatus(),
                            taskToEdit.getRecurState().isRecurring(), taskToEdit.getRecurState().getRecurInterval(),
                            tempList);
        } else {
            return new Task(taskToEdit.getName(), taskToEdit.getStartDateTime(), taskToEdit.getEndDateTime(),
                            taskToEdit.getTags(), taskToEdit.getTimedStatus(), false,
                            taskToEdit.getRecurState().isRecurring(), taskToEdit.getRecurState().getRecurInterval(),
                            taskToEdit.getRecurState().getRecurCompletedList());
        }
    }

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     */
    private static Task createUncompletedTask(ReadOnlyTask taskToEdit) {
        assert taskToEdit != null;

        return new Task(taskToEdit.getName(), taskToEdit.getStartDateTime(), taskToEdit.getEndDateTime(),
                            taskToEdit.getTags(), taskToEdit.getTimedStatus(), true,
                            taskToEdit.getRecurState().isRecurring(), taskToEdit.getRecurState().getRecurInterval(),
                            taskToEdit.getRecurState().getRecurCompletedList());

    }

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     */
    private static Task createMasterRecurringTask(ReadOnlyTask taskToEdit) {
        assert taskToEdit != null;
        ((Task) taskToEdit).getRecurState().setRecurDisplayDate("");
        return new Task(taskToEdit.getName(), taskToEdit.getStartDateTime(), taskToEdit.getEndDateTime(),
                            taskToEdit.getTags(), taskToEdit.getTimedStatus(), taskToEdit.getActiveStatus(),
                            taskToEdit.getRecurState().isRecurring(), taskToEdit.getRecurState().getRecurInterval(),
                            taskToEdit.getRecurState().getRecurCompletedList());

    }

    /**
     * Creates and returns a formatted String message with the details of {@code completedList}
     */
    private static String getSuccessMessage(List<ReadOnlyTask> completedList) {
        assert completedList != null;
        String successMessage = "";
        for (int i = 0; i < completedList.size(); i++) {
            successMessage += completedList.get(i).getAsText();
        }
        return successMessage;
    }

    @Override
    public boolean isUndoable() {
        return commandSuccess;
    }

    @Override
    public String undo() throws CommandException {
        for (int i = 0; i < completedList.size(); i++) {
            try {
                ReadOnlyTask original = completedList.get(i);
                ReadOnlyTask revert = createUncompletedTask(completedList.get(i));
                model.updateTask(original, revert);
            } catch (UniqueTaskList.DuplicateTaskException dpe) {
                throw new CommandException(MESSAGE_DUPLICATE_TASK);
            }
        }
        return String.format(MESSAGE_COMPLETED_TASK_SUCCESS, completedList);
    }
}
```
###### \java\seedu\tache\logic\commands\DeleteCommand.java
``` java
    private void checkPartOfRecurringTask(ReadOnlyTask taskToEdit) throws IllegalValueException {
        if (taskToEdit.getRecurState().isGhostRecurring()) {
            throw new IllegalValueException(MESSAGE_PART_OF_RECURRING_TASK);
        }
    }

```
###### \java\seedu\tache\logic\commands\EditCommand.java
``` java
package seedu.tache.logic.commands;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Optional;

import seedu.tache.commons.core.EventsCenter;
import seedu.tache.commons.core.Messages;
import seedu.tache.commons.events.ui.JumpToListRequestEvent;
import seedu.tache.commons.exceptions.IllegalValueException;
import seedu.tache.commons.util.CollectionUtil;
import seedu.tache.logic.commands.exceptions.CommandException;
import seedu.tache.model.recurstate.RecurState.RecurInterval;
import seedu.tache.model.tag.UniqueTagList;
import seedu.tache.model.task.DateTime;
import seedu.tache.model.task.Name;
import seedu.tache.model.task.ReadOnlyTask;
import seedu.tache.model.task.Task;
import seedu.tache.model.task.UniqueTaskList;
import seedu.tache.model.task.UniqueTaskList.DuplicateTaskException;

/**
 * Edits the details of an existing task in the task manager.
 */
public class EditCommand extends Command implements Undoable {

    public static final String COMMAND_WORD = "edit";
    public static final String SHORT_COMMAND_WORD = "e";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Edits the details of the task identified "
            + "by the index number used in the last tasks listing. "
            + "Existing values will be overwritten by the input values.\n"
            + "Parameters: INDEX (must be a positive integer) change <parameter1> to <new_value1> and "
            + "<parameter2> to <new_value2>...\n"
            + "Example: " + COMMAND_WORD + " 1 change startdate to 10 nov and change starttime to 3.30pm";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Task: \n%1$s";
    public static final String MESSAGE_NOT_EDITED = "At least one field to edit must be provided.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";
    public static final String MESSAGE_INVALID_DATE_RANGE = "Start date can not be before end date";
    public static final String MESSAGE_PART_OF_RECURRING_TASK =
                        "This task is part of a recurring task and cannot be edited.";

    public static final String SPECIAL_CASE_TIME_STRING = "23:59:59";

    private final int filteredTaskListIndex;
    private final EditTaskDescriptor editTaskDescriptor;

    private boolean commandSuccess;
    private ReadOnlyTask taskToEdit;
    private ReadOnlyTask originalTask;

    /**
     * @param filteredTaskListIndex the index of the task in the filtered task list to edit
     * @param editTaskDescriptor details to edit the task with
     */
    public EditCommand(int filteredTaskListIndex, EditTaskDescriptor editTaskDescriptor) {
        assert filteredTaskListIndex > 0;
        assert editTaskDescriptor != null;

        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;

        this.editTaskDescriptor = new EditTaskDescriptor(editTaskDescriptor);
        commandSuccess = false;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        taskToEdit = lastShownList.get(filteredTaskListIndex);
        cloneOriginalTask(taskToEdit);
        Task editedTask;
        try {
            checkPartOfRecurringTask(taskToEdit);
            editedTask = createEditedTask(taskToEdit, editTaskDescriptor);
            try {
                model.updateTask(taskToEdit, editedTask);
            } catch (UniqueTaskList.DuplicateTaskException dpe) {
                throw new CommandException(MESSAGE_DUPLICATE_TASK);
            }
            //model.updateCurrentFilteredList();
            commandSuccess = true;
            undoHistory.push(this);
            EventsCenter.getInstance().post(new JumpToListRequestEvent(model.getFilteredTaskListIndex(taskToEdit)));
            return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
        } catch (IllegalValueException e) {
            return new IncorrectCommand(e.getMessage()).execute();
        }
    }

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     * @throws IllegalValueException if date or time could not be parsed
     */
    private static Task createEditedTask(ReadOnlyTask taskToEdit,
                                             EditTaskDescriptor editTaskDescriptor) throws IllegalValueException {
        assert taskToEdit != null;

        Name updatedName = editTaskDescriptor.getName().orElseGet(taskToEdit::getName);
        Optional<DateTime> updatedStartDateTime;
        Optional<DateTime> updatedEndDateTime;
        if (taskToEdit.getStartDateTime().isPresent()) {
            updatedStartDateTime = Optional.of(new DateTime(taskToEdit.getStartDateTime().get()));
        } else {
            updatedStartDateTime = Optional.empty();
        }
        if (taskToEdit.getEndDateTime().isPresent()) {
            updatedEndDateTime = Optional.of(new DateTime(taskToEdit.getEndDateTime().get()));
        } else {
            updatedEndDateTime = Optional.empty();
        }
        if (editTaskDescriptor.getStartDate().isPresent()) {
            if (updatedStartDateTime.isPresent()) {
                updatedStartDateTime.get().setDateOnly(editTaskDescriptor.getStartDate().get());
            } else {
                updatedStartDateTime = Optional.of(new DateTime(editTaskDescriptor.getStartDate().get()));
                updatedStartDateTime.get().setDefaultTime();
            }
        }
        if (editTaskDescriptor.getEndDate().isPresent()) {
            if (updatedEndDateTime.isPresent()) {
                updatedEndDateTime.get().setDateOnly(editTaskDescriptor.getEndDate().get());
            } else {
                updatedEndDateTime = Optional.of(new DateTime(editTaskDescriptor.getEndDate().get()));
                updatedEndDateTime.get().setDefaultTime();
            }
        }
        if (editTaskDescriptor.getStartTime().isPresent()) {
            if (updatedStartDateTime.isPresent()) {
                updatedStartDateTime.get().setTimeOnly(editTaskDescriptor.getStartTime().get());
            } else {
                updatedStartDateTime = Optional.of(new DateTime(editTaskDescriptor.getStartTime().get()));
            }
        }
        if (editTaskDescriptor.getEndTime().isPresent()) {
            if (updatedEndDateTime.isPresent()) {
                updatedEndDateTime.get().setTimeOnly(editTaskDescriptor.getEndTime().get());
            } else {
                updatedEndDateTime = Optional.of(new DateTime(editTaskDescriptor.getEndTime().get()));
            }
        }
        boolean isTimed;
        if (updatedStartDateTime.isPresent() || updatedEndDateTime.isPresent()) {
            isTimed = true;
        } else {
            isTimed = false;
        }
        UniqueTagList updatedTags = editTaskDescriptor.getTags().orElseGet(taskToEdit::getTags);

        updatedEndDateTime = checkFloatingToNonFloatingCase(editTaskDescriptor, updatedStartDateTime,
                                                                updatedEndDateTime);
        checkValidDateRange(updatedStartDateTime, updatedEndDateTime);
        checkSpecialCase(editTaskDescriptor, updatedEndDateTime);

        return new Task(updatedName, updatedStartDateTime, updatedEndDateTime,
                            updatedTags, isTimed, true, false, RecurInterval.NONE, new ArrayList<Date>());

    }

    private static Optional<DateTime> checkFloatingToNonFloatingCase(EditTaskDescriptor editTaskDescriptor,
                                Optional<DateTime> updatedStartDateTime, Optional<DateTime> updatedEndDateTime)
                                throws IllegalValueException {
        if (!updatedEndDateTime.isPresent() && !editTaskDescriptor.getEndDate().isPresent()) {
            if (updatedStartDateTime.isPresent()) {
                //Floating Task to Non-Floating, do not allow start date only
                Optional<DateTime> temp = Optional.of(updatedStartDateTime.get());
                return temp;
            }
        }
        return updatedEndDateTime;
    }

    private static void checkValidDateRange(Optional<DateTime> updatedStartDateTime,
                                                Optional<DateTime> updatedEndDateTime) throws IllegalValueException {
        if (updatedStartDateTime.isPresent() && updatedEndDateTime.isPresent()) {
            if (updatedStartDateTime.get().compareTo(updatedEndDateTime.get()) == 1) {
                throw new IllegalValueException(MESSAGE_INVALID_DATE_RANGE);
            }
        }
    }

    private static void checkSpecialCase(EditTaskDescriptor editTaskDescriptor,
                            Optional<DateTime> updatedEndDateTime) throws IllegalValueException {
        //Special case End Date -> Today will result in a default timing of 2359 instead of 0000
        if (editTaskDescriptor.getEndDate().isPresent() && updatedEndDateTime.isPresent()
                && !editTaskDescriptor.getEndTime().isPresent()) {
            if ((new DateTime(editTaskDescriptor.getEndDate().get()).isToday())
                        && updatedEndDateTime.get().getDate().before(new Date())) {
                updatedEndDateTime.get().setTimeOnly(SPECIAL_CASE_TIME_STRING);
            }
        }
    }

    /**
     * Stores the details to edit the task with. Each non-empty field value will replace the
     * corresponding field value of the task.
     */
    public static class EditTaskDescriptor {
        private Optional<Name> name = Optional.empty();
        private Optional<String> startDate = Optional.empty();
        private Optional<String> endDate = Optional.empty();
        private Optional<String> startTime = Optional.empty();
        private Optional<String> endTime = Optional.empty();
        private Optional<UniqueTagList> tags = Optional.empty();

        public EditTaskDescriptor() {}

        public EditTaskDescriptor(EditTaskDescriptor toCopy) {
            this.name = toCopy.getName();
            this.startDate = toCopy.getStartDate();
            this.endDate = toCopy.getEndDate();
            this.startTime = toCopy.getStartTime();
            this.endTime = toCopy.getEndTime();
            this.tags = toCopy.getTags();
        }

        /**
         * Returns true if at least one field is edited.
         */
        public boolean isAnyFieldEdited() {
            return CollectionUtil.isAnyPresent(this.name, this.startDate, this.endDate,
                                               this.startTime, this.endTime, this.tags);
        }

        public void setName(Optional<Name> name) {
            assert name != null;
            this.name = name;
        }

        public Optional<Name> getName() {
            return name;
        }

        public void setStartDate(Optional<String> date) {
            assert date != null;
            this.startDate = date;
        }

        public Optional<String> getStartDate() {
            return startDate;
        }

        public void setEndDate(Optional<String> date) {
            assert date != null;
            this.endDate = date;
        }

        public Optional<String> getEndDate() {
            return endDate;
        }

        public void setStartTime(Optional<String> startTime) {
            assert startTime != null;
            this.startTime = startTime;
        }

        public Optional<String> getStartTime() {
            return startTime;
        }

        public void setEndTime(Optional<String> endTime) {
            assert endTime != null;
            this.endTime = endTime;
        }

        public Optional<String> getEndTime() {
            return endTime;
        }

        public void setTags(Optional<UniqueTagList> tags) {
            assert tags != null;
            this.tags = tags;
        }

        public Optional<UniqueTagList> getTags() {
            return tags;
        }
    }

    private void cloneOriginalTask(ReadOnlyTask taskToEdit) {
        //Workaround as Java could not deep copy taskToEdit for some fields
        DateTime workAroundStartDateTime = null;
        DateTime workAroundEndDateTime = null;
        try {
            if (taskToEdit.getStartDateTime().isPresent()) {
                workAroundStartDateTime = new DateTime(taskToEdit.getStartDateTime().get().getAmericanDateTime());
            }
            if (taskToEdit.getEndDateTime().isPresent()) {
                workAroundEndDateTime = new DateTime(taskToEdit.getEndDateTime().get().getAmericanDateTime());
            }
        } catch (IllegalValueException e1) {
            e1.printStackTrace();
        }
        originalTask = new Task(taskToEdit.getName(), Optional.ofNullable(workAroundStartDateTime),
                                        Optional.ofNullable(workAroundEndDateTime), taskToEdit.getTags(),
               taskToEdit.getTimedStatus(), taskToEdit.getActiveStatus(), taskToEdit.getRecurState().isRecurring(),
               taskToEdit.getRecurState().getRecurInterval(), taskToEdit.getRecurState().getRecurCompletedList());
    }

    private void checkPartOfRecurringTask(ReadOnlyTask taskToEdit) throws IllegalValueException {
        if (taskToEdit.getRecurState().isGhostRecurring()) {
            throw new IllegalValueException(MESSAGE_PART_OF_RECURRING_TASK);
        }
    }

```
###### \java\seedu\tache\logic\commands\ListCommand.java
``` java
    public ListCommand() {
        this.filter = "uncompleted";
    }

    public ListCommand(String filter) {
        assert filter != null;
        this.filter = filter;
    }

    @Override
    public CommandResult execute() {
        switch(filter) {
        case FILTER_COMPLETED:
            model.updateFilteredListToShowCompleted();
            break;
        case FILTER_TIMED:
            model.updateFilteredListToShowTimed();
            break;
        case FILTER_FLOATING:
            model.updateFilteredListToShowFloating();
            break;
        case FILTER_DUE_TODAY:
            model.updateFilteredListToShowDueToday();
            break;
        case FILTER_DUE_THIS_WEEK:
            model.updateFilteredListToShowDueThisWeek();
            break;
        case FILTER_OVERDUE:
            model.updateFilteredListToShowOverdueTasks();
            break;
        case FILTER_ALL:
            model.updateFilteredListToShowAll();
            break;
        case FILTER_UNCOMPLETED:
        default:
            model.updateFilteredListToShowUncompleted();
            return new CommandResult(String.format(MESSAGE_SUCCESS, StringUtil.capitalizeFirstCharacter(filter)));
        }
        return new CommandResult(String.format(MESSAGE_SUCCESS, StringUtil.capitalizeFirstCharacter(filter)));
    }
}
```
###### \java\seedu\tache\logic\Logic.java
``` java
    /** Returns the filtered list of tasks */
    ObservableList<ReadOnlyTask> getFullTaskList();

```
###### \java\seedu\tache\logic\LogicManager.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getFilteredTaskList() {
        model.updateFilteredListToShowUncompleted();
        return model.getFilteredTaskList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFullTaskList() {
        List<ReadOnlyTask> concatenated = new ArrayList<>();
        Collections.addAll(concatenated, model.getTaskManager().getTaskList().toArray());
        Collections.addAll(concatenated, model.getAllRecurringGhostTasks().toArray());
        return FXCollections.observableList(concatenated);
    }

```
###### \java\seedu\tache\logic\parser\CliSyntax.java
``` java
    /* Parameter delimiter definitions */
    public static final String DELIMITER_PARAMETER = new String(";");
    public static final String DELIMITER_INDEX = new String(",");
    public static final String DELIMITER_EDIT_PARAMETER = new String(" ");

    /* Natural Language Processing definitions */
    public static final String KEYWORD_EDIT_PARAMETER_VALUE = "to";
    public static final String KEYWORD_EDIT_PARAMETER = "change";
    public static final String KEYWORD_EDIT_MULTI_PARAMETER = "and";

    /* Parameter names definitions */
    public static final String[] PARAMETER_NAME = {"name", "n"};
    public static final String[] PARAMETER_START_DATE = {"start_date", "startdate", "sd"};
    public static final String[] PARAMETER_END_DATE = {"end_date", "enddate", "ed"};
    public static final String[] PARAMETER_START_TIME = {"start_time", "starttime", "st"};
    public static final String[] PARAMETER_END_TIME = {"end_time", "endtime", "et"};
    public static final String[] PARAMETER_TAG = {"tag", "t"};

    /* List filter definitions */
    public static final String FILTER_COMPLETED = "completed";
    public static final String FILTER_UNCOMPLETED = "uncompleted";
    public static final String FILTER_ALL = "all";
```
###### \java\seedu\tache\logic\parser\CompleteCommandParser.java
``` java
package seedu.tache.logic.parser;

import static seedu.tache.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.tache.logic.parser.CliSyntax.DELIMITER_INDEX;

import java.util.ArrayList;
import java.util.List;

import seedu.tache.commons.util.StringUtil;
import seedu.tache.logic.commands.Command;
import seedu.tache.logic.commands.CompleteCommand;
import seedu.tache.logic.commands.IncorrectCommand;


/**
 * Parses input arguments and creates a new EditCommand object
 */
public class CompleteCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the EditCommand
     * and returns an EditCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;
        String[] preambleFields = args.trim().split(DELIMITER_INDEX);
        if (preambleFields.length == 0 || args.trim().equals("")) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, CompleteCommand.MESSAGE_USAGE));
        }

        List<Integer> indexList = new ArrayList<Integer>();
        for (int i = 0; i < preambleFields.length; i++) {
          //Checking all arguments are valid and creating list
            String currentIndex = preambleFields[i].trim();
            if (!StringUtil.isUnsignedInteger(currentIndex)) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                                                CompleteCommand.MESSAGE_USAGE));
            } else {
                indexList.add(Integer.parseInt(currentIndex));
            }
        }

        return new CompleteCommand(indexList);
    }

}
```
###### \java\seedu\tache\logic\parser\EditCommandParser.java
``` java
package seedu.tache.logic.parser;

import static seedu.tache.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.tache.logic.parser.CliSyntax.DELIMITER_EDIT_PARAMETER;
import static seedu.tache.logic.parser.CliSyntax.DELIMITER_PARAMETER;
import static seedu.tache.logic.parser.CliSyntax.KEYWORD_EDIT_MULTI_PARAMETER;
import static seedu.tache.logic.parser.CliSyntax.KEYWORD_EDIT_PARAMETER;
import static seedu.tache.logic.parser.CliSyntax.KEYWORD_EDIT_PARAMETER_VALUE;
import static seedu.tache.logic.parser.CliSyntax.PARAMETER_END_DATE;
import static seedu.tache.logic.parser.CliSyntax.PARAMETER_END_TIME;
import static seedu.tache.logic.parser.CliSyntax.PARAMETER_NAME;
import static seedu.tache.logic.parser.CliSyntax.PARAMETER_START_DATE;
import static seedu.tache.logic.parser.CliSyntax.PARAMETER_START_TIME;
import static seedu.tache.logic.parser.CliSyntax.PARAMETER_TAG;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Optional;

import seedu.tache.commons.exceptions.IllegalValueException;
import seedu.tache.logic.commands.Command;
import seedu.tache.logic.commands.EditCommand;
import seedu.tache.logic.commands.EditCommand.EditTaskDescriptor;
import seedu.tache.logic.commands.IncorrectCommand;
import seedu.tache.model.tag.UniqueTagList;
import seedu.tache.model.task.Name;


/**
 * Parses input arguments and creates a new EditCommand object
 */
public class EditCommandParser {

    public static final String MESSAGE_INVALID_PARAMETER = "Invalid parameter given. Valid parameters" +
                                                   " include name, start_date, start_time, end_date, end_time and tags";

    /**
     * Parses the given {@code String} of arguments in the context of the EditCommand
     * and returns an EditCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;
        if (args.contains(DELIMITER_PARAMETER)) {
            return parseStructuredArguments(args);
        } else {
            return parseNaturalLanguageArguments(args);
        }
    }

    /**
     * Parses the given {@code String} of arguments that is of a natural language format in the context of the
     * EditCommand and returns an EditCommand object for execution.
     */
    private Command parseNaturalLanguageArguments(String args) {
        String argsInProcess = args;
        //Manual expression matching due to regex matching criteria being too broad
        Optional<Integer> index = ParserUtil.parseIndex(argsInProcess.trim().split(" ")[0]);
        if (index.isPresent()) {
            //Process index
            int indexOfIndex = argsInProcess.indexOf(new String("" +  index.get()));
            argsInProcess = argsInProcess.substring(indexOfIndex + new String("" +  index.get()).length());

            return processNaturalMultiParameterEdit(index, argsInProcess);

        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    EditCommand.MESSAGE_USAGE));
        }
    }

    /**
     * Parses the given {@code String} of arguments that is of a structured format in the context of the
     * EditCommand and returns an EditCommand object for execution.
     */
    private Command parseStructuredArguments(String args) {
        String[] preambleFields = args.split(DELIMITER_PARAMETER);
        Optional<Integer> index = ParserUtil.parseIndex(preambleFields[0]);

        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        EditTaskDescriptor editTaskDescriptor = new EditTaskDescriptor();

        for (int i = 1; i < preambleFields.length; i++) {
            try {
                String updateParameter = preambleFields[i].substring(0, preambleFields[i].replaceAll("^\\s+", "")
                                         .indexOf(DELIMITER_EDIT_PARAMETER) + 1).trim();
                String updateValue = preambleFields[i].substring(preambleFields[i].replaceAll("^\\s+", "")
                                     .indexOf(DELIMITER_EDIT_PARAMETER) + 1).trim();

                if (ParserUtil.isFoundIn(updateParameter, PARAMETER_NAME)) {
                    editTaskDescriptor.setName(Optional.of(new Name(updateValue)));
                } else if (ParserUtil.isFoundIn(updateParameter, PARAMETER_START_DATE)) {
                    editTaskDescriptor.setStartDate(Optional.of(updateValue));
                } else if (ParserUtil.isFoundIn(updateParameter, PARAMETER_END_DATE)) {
                    editTaskDescriptor.setEndDate(Optional.of(updateValue));
                } else if (ParserUtil.isFoundIn(updateParameter, PARAMETER_START_TIME)) {
                    editTaskDescriptor.setStartTime(Optional.of(updateValue));
                } else if (ParserUtil.isFoundIn(updateParameter, PARAMETER_END_TIME)) {
                    editTaskDescriptor.setEndTime(Optional.of(updateValue));
                } else if (ParserUtil.isFoundIn(updateParameter, PARAMETER_TAG)) {
                    editTaskDescriptor.setTags(parseTagsForEdit(Arrays.asList(updateValue
                                                                              .split(DELIMITER_EDIT_PARAMETER))));
                } else {
                    throw new IllegalValueException(MESSAGE_INVALID_PARAMETER);
                }
            } catch (IllegalValueException ive) {
                return new IncorrectCommand(ive.getMessage());
            }
        }
        if (!editTaskDescriptor.isAnyFieldEdited()) {
            return new IncorrectCommand(EditCommand.MESSAGE_NOT_EDITED);
        }
        return new EditCommand(index.get(), editTaskDescriptor);
    }

    /**
     * Process the given {@code String} of arguments that contains only multiple parameters of interest
     * that is of a natural language format and returns an EditCommand object for execution.
     */
    private Command processNaturalMultiParameterEdit (Optional<Integer> index, String argsInProcess) {
        String[] argsInProcessElements = argsInProcess.trim().split(DELIMITER_EDIT_PARAMETER);
        ArrayList<String> updateParameterList = new ArrayList<String>();
        ArrayList<String> updateValueList = new ArrayList<String>();

        if (!argsInProcessElements[0].equals(KEYWORD_EDIT_PARAMETER)) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    EditCommand.MESSAGE_USAGE));
        }

        boolean processingParameter = false;
        String currentParameter = "";
        String currentValue = "";
        for (int i = 1; i < argsInProcessElements.length; i++) {
            if (ParserUtil.isValidParameter(argsInProcessElements[i]) && !processingParameter) {
                if (argsInProcessElements[i + 1] != null
                        && argsInProcessElements[i + 1].equals(KEYWORD_EDIT_PARAMETER_VALUE)) {
                    processingParameter = true;
                    currentParameter = argsInProcessElements[i];
                    i++;
                    continue;
                }
            }
            if (processingParameter) {
                if (argsInProcessElements[i].equals(KEYWORD_EDIT_MULTI_PARAMETER)
                        && (i + 1 < argsInProcessElements.length)
                        && ParserUtil.isValidParameter(argsInProcessElements[i + 1])
                        && (i + 2 < argsInProcessElements.length)
                        && argsInProcessElements[i + 2].equals(KEYWORD_EDIT_PARAMETER_VALUE)) {
                    processingParameter = false;
                    updateParameterList.add(currentParameter);
                    updateValueList.add(currentValue.trim());
                    currentValue = "";
                } else if (i + 1 == argsInProcessElements.length) {
                    currentValue += " " + argsInProcessElements[i];
                    processingParameter = false;
                    updateParameterList.add(currentParameter);
                    updateValueList.add(currentValue.trim());
                    currentValue = "";
                } else {
                    currentValue += " " + argsInProcessElements[i];
                }
            }
        }

        String structuredArgument = index.get() + DELIMITER_PARAMETER;
        for (int i = 0; i < updateParameterList.size(); i++) {
            structuredArgument += updateParameterList.get(i) + DELIMITER_EDIT_PARAMETER
                                + updateValueList.get(i) + DELIMITER_EDIT_PARAMETER + DELIMITER_PARAMETER;
        }
        return parseStructuredArguments(structuredArgument);
    }

    /**
     * Parses {@code Collection<String> tags} into an {@code Optional<UniqueTagList>} if {@code tags} is non-empty.
     * If {@code tags} contain only one element which is an empty string, it will be parsed into a
     * {@code Optional<UniqueTagList>} containing zero tags.
     */
    private Optional<UniqueTagList> parseTagsForEdit(Collection<String> tags) throws IllegalValueException {
        assert tags != null;

        if (tags.isEmpty()) {
            return Optional.empty();
        }
        Collection<String> tagSet = tags.size() == 1 && tags.contains("") ? Collections.emptySet() : tags;
        return Optional.of(ParserUtil.parseTags(tagSet));
    }

}
```
###### \java\seedu\tache\logic\parser\FindCommandParser.java
``` java
        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindCommand(keywordSet);
    }

}
```
###### \java\seedu\tache\logic\parser\HelpCommandParser.java
``` java
package seedu.tache.logic.parser;

import static seedu.tache.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import seedu.tache.logic.commands.AddCommand;
import seedu.tache.logic.commands.ClearCommand;
import seedu.tache.logic.commands.Command;
import seedu.tache.logic.commands.CompleteCommand;
import seedu.tache.logic.commands.DeleteCommand;
import seedu.tache.logic.commands.EditCommand;
import seedu.tache.logic.commands.ExitCommand;
import seedu.tache.logic.commands.FindCommand;
import seedu.tache.logic.commands.HelpCommand;
import seedu.tache.logic.commands.IncorrectCommand;
import seedu.tache.logic.commands.ListCommand;
import seedu.tache.logic.commands.LoadCommand;
import seedu.tache.logic.commands.SaveCommand;
import seedu.tache.logic.commands.SelectCommand;
import seedu.tache.logic.commands.UndoCommand;


/**
 * Parses input arguments and creates a new HelpCommand object
 */
public class HelpCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the HelpCommand
     * and returns an HelpCommand object for execution.
     */
    public Command parse(String args) {
        String trimmedArgs = args.trim();
        if (!trimmedArgs.equals("")) {
            switch(trimmedArgs) {
            case AddCommand.COMMAND_WORD:
            case ClearCommand.COMMAND_WORD:
            case CompleteCommand.COMMAND_WORD:
            case DeleteCommand.COMMAND_WORD:
            case EditCommand.COMMAND_WORD:
            case ExitCommand.COMMAND_WORD:
            case FindCommand.COMMAND_WORD:
            case ListCommand.COMMAND_WORD:
            case LoadCommand.COMMAND_WORD:
            case SaveCommand.COMMAND_WORD:
            case SelectCommand.COMMAND_WORD:
            case UndoCommand.COMMAND_WORD:
                return new HelpCommand(trimmedArgs);
            default:
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
            }
        } else {
            return new HelpCommand();
        }
    }

}
```
###### \java\seedu\tache\logic\parser\ListCommandParser.java
``` java
package seedu.tache.logic.parser;

import static seedu.tache.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.tache.logic.parser.CliSyntax.FILTER_ALL;
import static seedu.tache.logic.parser.CliSyntax.FILTER_COMPLETED;
import static seedu.tache.logic.parser.CliSyntax.FILTER_DUE_THIS_WEEK;
import static seedu.tache.logic.parser.CliSyntax.FILTER_DUE_TODAY;
import static seedu.tache.logic.parser.CliSyntax.FILTER_FLOATING;
import static seedu.tache.logic.parser.CliSyntax.FILTER_OVERDUE;
import static seedu.tache.logic.parser.CliSyntax.FILTER_TIMED;
import static seedu.tache.logic.parser.CliSyntax.FILTER_UNCOMPLETED;

import seedu.tache.logic.commands.Command;
import seedu.tache.logic.commands.IncorrectCommand;
import seedu.tache.logic.commands.ListCommand;


/**
 * Parses input arguments and creates a new ListCommand object
 */
public class ListCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the ListCommand
     * and returns an ListCommand object for execution.
     */
    public Command parse(String args) {
        String trimmedArgs = args.trim();
        if (!trimmedArgs.equals("")) {
            switch(trimmedArgs) {
            case FILTER_COMPLETED:
            case FILTER_UNCOMPLETED:
            case FILTER_TIMED:
            case FILTER_FLOATING:
            case FILTER_DUE_TODAY:
            case FILTER_DUE_THIS_WEEK:
            case FILTER_OVERDUE:
            case FILTER_ALL:
                return new ListCommand(trimmedArgs);
            default:
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
            }
        } else {
            return new ListCommand();
        }
    }

}
```
###### \java\seedu\tache\logic\parser\ParserUtil.java
``` java
    private static final Pattern FORMAT_INDEX_ARGS = Pattern.compile("(?<targetIndex>.+)");

    private static final Pattern FORMAT_NAME = Pattern.compile("^\".+\"");
    private static final Pattern FORMAT_DATE = Pattern.compile("^[0-3]?[0-9]/[0-1]?[0-9]/(?:[0-9]{2})?[0-9]{2}$"
                                                               + "|^[0-3]?[0-9]-[0-1]?[0-9]-(?:[0-9]{2})?[0-9]{2}$"
                                                               + "|^[0-3]{1}[0-9]{1}[0-1]{1}[0-9]{1}"
                                                               + "(?:[0-9]{2})?[0-9]{2}$");
    private static final Pattern FORMAT_TIME = Pattern.compile("^[0-2][0-9][0-5][0-9]|^([0-1][0-2]|[0-9])"
                                                               + "([.][0-5][0-9])?\\s?(am|pm){1}");
    private static final Pattern FORMAT_DURATION = Pattern.compile("^\\d+\\s?((h|hr|hrs)|(m|min|mins))");
```
###### \java\seedu\tache\logic\parser\ParserUtil.java
``` java
    /**
     * Returns True if input is a valid date
     * Returns False otherwise.
     */
    public static boolean isValidDate(String input) {
        final Matcher matcher = FORMAT_DATE.matcher(input.trim());
        return matcher.matches();
    }

    /**
     * Returns True if input is a valid time
     * Returns False otherwise.
     */
    public static boolean isValidTime(String input) {
        final Matcher matcher = FORMAT_TIME.matcher(input.trim());
        return matcher.matches();
    }

    /**
     * Returns True if input is a valid duration
     * Returns False otherwise.
     */
    public static boolean isValidDuration(String input) {
        final Matcher matcher = FORMAT_DURATION.matcher(input.trim());
        return matcher.matches();
    }

    /**
     * Returns True if input is a valid name
     * Returns False otherwise.
     */
    public static boolean isValidName(String input) {
        final Matcher matcher = FORMAT_NAME.matcher(input.trim());
        return matcher.matches();
    }

    /**
     * Returns True if input is a valid parameter
     * Returns False otherwise.
     */
    public static boolean isValidParameter(String input) {
        return ParserUtil.isFoundIn(input, PARAMETER_NAME, PARAMETER_START_DATE, PARAMETER_END_DATE,
                PARAMETER_START_TIME, PARAMETER_END_TIME, PARAMETER_TAG);
    }
```
###### \java\seedu\tache\model\Model.java
``` java
    /** Updates the filter of the filtered task list to show all uncompleted tasks */
    void updateFilteredListToShowUncompleted();

    /** Updates the filter of the filtered task list to show all completed tasks */
    void updateFilteredListToShowCompleted();

```
###### \java\seedu\tache\model\Model.java
``` java
    /** Updates the filter of the current filtered task list to reflect changes */
    //void updateCurrentFilteredList();
}
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    public static final int MARGIN_OF_ERROR = 1;
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    public static final String TASK_LIST_TYPE_FOUND = "Found Tasks";
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    private final TaskManager taskManager;
    private final FilteredList<ReadOnlyTask> filteredTasks;

    private Set<String> latestKeywords;
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowUncompleted() {
        updateFilteredTaskList(new PredicateExpression(new ActiveQualifier(true)));
        updateFilteredTaskListType(TASK_LIST_TYPE_UNCOMPLETED);

    }

    @Override
    public void updateFilteredListToShowCompleted() {
        updateFilteredTaskList(new PredicateExpression(new ActiveQualifier(false)));
        updateFilteredTaskListType(TASK_LIST_TYPE_COMPLETED);
    }

```
###### \java\seedu\tache\model\ModelManager.java
``` java
    private void retainLatestKeywords(Set<String> keywords) {
        latestKeywords = keywords;
    }

//    public void updateCurrentFilteredList() {
//        switch(filteredTaskListType) {
//        case TASK_LIST_TYPE_ALL:
//            updateFilteredListToShowAll();
//            break;
//        case TASK_LIST_TYPE_COMPLETED:
//            updateFilteredListToShowCompleted();
//            break;
//        case TASK_LIST_TYPE_UNCOMPLETED:
//            updateFilteredListToShowUncompleted();
//            break;
//        case TASK_LIST_TYPE_TIMED:
//            updateFilteredListToShowTimed();
//            break;
//        case TASK_LIST_TYPE_FLOATING:
//            updateFilteredListToShowFloating();
//            break;
//        case TASK_LIST_TYPE_FOUND:
//            updateFilteredTaskList(latestKeywords);
//            break;
//        case TASK_LIST_TYPE_DUE_TODAY:
//            updateFilteredListToShowDueToday();
//            break;
//        case TASK_LIST_TYPE_DUE_THIS_WEEK:
//            updateFilteredListToShowDueThisWeek();
//            break;
//        default:
//        }
//    }
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    private class NameQualifier implements Qualifier {
        private Set<String> nameKeyWords;

        NameQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            String[] nameElements = task.getName().fullName.split(" ");
            boolean partialMatch = false;
            //Remove square brackets
            String trimmedNameKeywords = nameKeyWords.toString()
                                         .substring(1, nameKeyWords.toString().length() - 1).toLowerCase();
            for (int i = 0; i < nameElements.length; i++) {
                if (computeLevenshteinDistance(trimmedNameKeywords, nameElements[i].toLowerCase()) <= MARGIN_OF_ERROR) {
                    partialMatch = true;
                    break;
                }
            }
            return nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(task.getName().fullName, keyword))
                    .findAny()
                    .isPresent()
                    || partialMatch;
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords);
        }
    }
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    private class ActiveQualifier implements Qualifier {
        private boolean isActive;

        ActiveQualifier(boolean isActive) {
            this.isActive = isActive;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            if (isActive) {
                return task.getActiveStatus();
            } else {
                return !task.getActiveStatus();
            }
        }

        @Override
        public String toString() {
            return "active=" + isActive;
        }
    }

```
###### \java\seedu\tache\model\ModelManager.java
``` java
    private class DateTimeQualifier implements Qualifier {
        private Set<String> dateTimeKeyWords;

        DateTimeQualifier(Set<String> dateTimeKeyWords) {
            this.dateTimeKeyWords = dateTimeKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            if (task.getStartDateTime().isPresent()) {
                for (int i = 0; i < dateTimeKeyWords.size(); i++) {
                    if (dateTimeKeyWords.toArray()[i].equals(task.getStartDateTime().get().getDateOnly()) ||
                                dateTimeKeyWords.toArray()[i].equals(task.getStartDateTime().get().getTimeOnly())) {
                        return true;
                    }
                }
            }
            if (task.getEndDateTime().isPresent()) {
                for (int i = 0; i < dateTimeKeyWords.size(); i++) {
                    if (dateTimeKeyWords.toArray()[i].equals(task.getEndDateTime().get().getDateOnly()) ||
                                dateTimeKeyWords.toArray()[i].equals(task.getEndDateTime().get().getTimeOnly())) {
                        return true;
                    }
                }
            }
            return false;
        }

        @Override
        public String toString() {
            return "datetime=" + String.join(", ", dateTimeKeyWords);
        }

    }

    private class MultiQualifier implements Qualifier {
        private Set<String> multiKeyWords;
        private NameQualifier nameQualifier;
        private DateTimeQualifier dateTimeQualifier;
        private ActiveQualifier activeQualifier;
        private TagQualifier tagQualifier;

        MultiQualifier(Set<String> multiKeyWords) {
            this.multiKeyWords = multiKeyWords;
            nameQualifier = new NameQualifier(multiKeyWords);
            dateTimeQualifier = new DateTimeQualifier(multiKeyWords);
            activeQualifier = new ActiveQualifier(true);
            tagQualifier = new TagQualifier(multiKeyWords);
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return (nameQualifier.run(task) || dateTimeQualifier.run(task)
                        || tagQualifier.run(task)) && activeQualifier.run(task);
        }

        @Override
        public String toString() {
            return "multi=" + String.join(", ", multiKeyWords);
        }

    }

    private class TagQualifier implements Qualifier {
        private Set<String> tagKeywords;

        TagQualifier(Set<String> tagKeywords) {
            this.tagKeywords = tagKeywords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            if (task.getTags().toSet().size() != 0) {
                Set<Tag> tagElements = (Set<Tag>) task.getTags().toSet();
                boolean validMatch = false;
                //Remove square brackets
                String trimmedTagKeywords = tagKeywords.toString()
                                             .substring(1, tagKeywords.toString().length() - 1).toLowerCase();
                for (Tag tag: tagElements) {
                    if (computeLevenshteinDistance(trimmedTagKeywords, tag.tagName.toLowerCase())
                                    <= MARGIN_OF_ERROR) {
                        validMatch = true;
                        break;
                    }
                }
                return validMatch;
            }
            return false;
        }

        @Override
        public String toString() {
            return "tag=" + String.join(", ", tagKeywords);
        }
    }

    private class ActiveTimedQualifier implements Qualifier {
        private TimedQualifier timedQualifier;
        private ActiveQualifier activeQualifier;

        ActiveTimedQualifier(boolean isTimed) {
            timedQualifier = new TimedQualifier(isTimed);
            activeQualifier = new ActiveQualifier(true);
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return timedQualifier.run(task) && activeQualifier.run(task);
        }

        @Override
        public String toString() {
            return "activetimed";
        }

    }

    private int computeLevenshteinDistance(CharSequence str1, CharSequence str2) {
        int[][] distance = new int[str1.length() + 1][str2.length() + 1];

        for (int i = 0; i <= str1.length(); i++) {
            distance[i][0] = i;
        }
        for (int j = 1; j <= str2.length(); j++) {
            distance[0][j] = j;
        }
        for (int i = 1; i <= str1.length(); i++) {
            for (int j = 1; j <= str2.length(); j++) {
                distance[i][j] =
                 minimum(
                    distance[i - 1][j] + 1,
                    distance[i][j - 1] + 1,
                    distance[i - 1][j - 1] +
                        ((str1.charAt(i - 1) == str2.charAt(j - 1)) ? 0 : 1));
            }
        }
        return distance[str1.length()][str2.length()];
    }

    private int minimum(int a, int b, int c) {
        return Math.min(Math.min(a, b), c);
    }

    private ObservableList<ReadOnlyTask> populateUncompletedRecurringDatesAsTask() {
        List<ReadOnlyTask> concatenated = new ArrayList<>();
        for (int i = 0; i < filteredTasks.size(); i++) {
            if (filteredTasks.get(i).getRecurState().isRecurring()) {
                if (filteredTaskListType.equals(TASK_LIST_TYPE_DUE_TODAY)) {
                    Collections.addAll(concatenated, filteredTasks.get(i)
                                                .getUncompletedRecurList(new Date()).toArray());
                } else if (filteredTaskListType.equals(TASK_LIST_TYPE_DUE_TODAY)) {
                    Calendar dateThisWeek = Calendar.getInstance();
                    dateThisWeek.setTime(new Date());
                    dateThisWeek.add(Calendar.WEEK_OF_YEAR, 1);
                    Collections.addAll(concatenated, filteredTasks.get(i)
                                                .getUncompletedRecurList(dateThisWeek.getTime()).toArray());
                } else {
                    Collections.addAll(concatenated, filteredTasks.get(i).getUncompletedRecurList().toArray());
                }
            }
        }
        Collections.addAll(concatenated, filteredTasks.toArray());
        return FXCollections.observableList(concatenated);
    }

    public ObservableList<ReadOnlyTask> getAllRecurringGhostTasks() {
        List<ReadOnlyTask> concatenated = new ArrayList<>();
        for (int i = 0; i < taskManager.getTaskList().size(); i++) {
            if (taskManager.getTaskList().get(i).getRecurState().isRecurring()) {
                Collections.addAll(concatenated, taskManager.getTaskList().get(i)
                                            .getUncompletedRecurList(null).toArray());
            }
        }
        return FXCollections.observableList(concatenated);
    }
```
###### \java\seedu\tache\model\recurstate\RecurState.java
``` java
package seedu.tache.model.recurstate;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;

import seedu.tache.model.task.DateTime;

public class RecurState {
    public enum RecurInterval { NONE, DAY, WEEK, MONTH, YEAR };

    private boolean recurringStatus;
    private RecurInterval interval;
    private List<Date> recurCompletedList;
    private String recurDisplayDate;

    public RecurState() {
        this.recurringStatus = false;
        this.interval = RecurInterval.NONE;
        this.recurCompletedList = new ArrayList<Date>();
        this.recurDisplayDate = "";
    }

    public RecurState(boolean isRecurring, RecurInterval interval, List<Date> recurCompletedList) {
        this.recurringStatus = isRecurring;
        this.interval = interval;
        this.recurCompletedList = recurCompletedList;
        this.recurDisplayDate = "";
    }

    public boolean isRecurring() {
        return recurringStatus;
    }

    public boolean getRecurringStatus() {
        return recurringStatus;
    }

    public void setRecurringStatus(boolean isRecurring) {
        this.recurringStatus = isRecurring;
    }

    public RecurInterval getRecurInterval() {
        return interval;
    }

    public void setRecurInterval(RecurInterval interval) {
        this.interval = interval;
    }

    public boolean isMasterRecurring() {
        return isRecurring() && this.recurDisplayDate.equals("");
    }

    public boolean isGhostRecurring() {
        return isRecurring() && !this.recurDisplayDate.equals("");
    }

    public List<Date> getRecurCompletedList() {
        return this.recurCompletedList;
    }

    public void setRecurCompletedList(List<Date> recurCompletedList) {
        this.recurCompletedList = recurCompletedList;
    }

    public List<Date> getUncompletedRecurDates(DateTime startDateTime, DateTime endDateTime, Date filterEndDate) {
        List<Date> uncompletedRecurList = new ArrayList<Date>();
        if (isRecurring()) {
            Calendar calendarCurrent = Calendar.getInstance();
            calendarCurrent.setTime(new Date(startDateTime.getAmericanDateOnly()
                                        + " " + startDateTime.getTimeOnly()));

            Calendar calendarEnd = Calendar.getInstance();
            calendarEnd.setTime(new Date(endDateTime.getAmericanDateOnly()
                                        + " " + endDateTime.getTimeOnly()));
            calendarEnd.add(Calendar.SECOND, 1);

            //Populate 'Ghost' Task
            while (calendarCurrent.getTime().before(calendarEnd.getTime())
                    && (filterEndDate == null || calendarCurrent.getTime().before(filterEndDate))) {

                if (!isRecurCompleted(calendarCurrent.getTime())) {
                    uncompletedRecurList.add(calendarCurrent.getTime());
                }

                if (interval.equals(RecurInterval.DAY)) {
                    calendarCurrent.add(Calendar.DATE, 1);
                } else if (interval.equals(RecurInterval.WEEK)) {
                    calendarCurrent.add(Calendar.WEEK_OF_YEAR, 1);
                } else if (interval.equals(RecurInterval.MONTH)) {
                    calendarCurrent.add(Calendar.MONTH, 1);
                } else if (interval.equals(RecurInterval.YEAR)) {
                    calendarCurrent.add(Calendar.YEAR, 1);
                }
            }
        }
        return uncompletedRecurList;

    }

    public boolean isRecurCompleted(Date recurCompleted) {
        DateFormat outputFormatter = new SimpleDateFormat("MM/dd/yyyy");
        for (int i = 0; i < getRecurCompletedList().size(); i++) {
            if (outputFormatter.format(getRecurCompletedList().get(i))
                                .equals(outputFormatter.format(recurCompleted))) {
                return true;
            }
        }
        return false;
    }

    public String getRecurDisplayDate() {
        return this.recurDisplayDate;
    }

    public void setRecurDisplayDate(String recurDisplayDate) {
        this.recurDisplayDate = recurDisplayDate;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof RecurState // instanceof handles nulls
                && this.recurringStatus == ((RecurState) other).getRecurringStatus()
                && this.interval.equals(((RecurState) other).getRecurInterval())
                && this.recurCompletedList.equals(((RecurState) other).getRecurCompletedList())
                && this.recurDisplayDate.equals(((RecurState) other).getRecurDisplayDate())); // state check
    }
}
```
###### \java\seedu\tache\model\task\DateTime.java
``` java
package seedu.tache.model.task;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.List;

import org.ocpsoft.prettytime.PrettyTime;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

import seedu.tache.commons.exceptions.IllegalValueException;


public class DateTime implements Comparable {

    private static final String EXPLICIT_DATE_TREE_IDENTIFIER = "EXPLICIT_DATE";
    private static final String EXPLICIT_TIME_TREE_IDENTIFIER = "EXPLICIT_TIME";

    public static final String MESSAGE_DATE_CONSTRAINTS = "Unknown date format. It is recommended to "
                                        + "interchangeably use the following few formats:"
                                        + "\nMM-DD-YY hh:mm:ss or MM/DD/YY 10.30pm";

    public static final String DEFAULT_TIME_STRING = "00:00:00";

    private final Date date;

    /**
     * Validates given date.
     *
     * @throws IllegalValueException if given date string is invalid.
     */
    public DateTime(String date) throws IllegalValueException {
        assert date != null;
        String trimmedStartDate = date.trim();
        List<DateGroup> temp = new Parser().parse(trimmedStartDate);
        if (temp.isEmpty()) {
            throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS);
        }
        this.date = temp.get(0).getDates().get(0);
        String syntaxTree = temp.get(0).getSyntaxTree().toStringTree();
        boolean hasExplicitDate = syntaxTree.contains(EXPLICIT_DATE_TREE_IDENTIFIER);
        boolean hasExplicitTime = syntaxTree.contains(EXPLICIT_TIME_TREE_IDENTIFIER);
        if (hasExplicitDate ^ hasExplicitTime) {
            if (hasExplicitDate) {
                this.date.setHours(0);
                this.date.setMinutes(0);
                this.date.setSeconds(0);
            }
        }
    }

    /**
     * Creates a copy of the given DateTime.
     * @throws IllegalValueException if source date string is invalid
     */
    public DateTime(DateTime source) throws IllegalValueException {
        this(source.getAmericanDateTime());
    }

    @Override
    public String toString() {
        return new PrettyTime().format(date);
    }

    public String getDateOnly() {
        SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
        return sdf.format(date);
    }

    public void setDateOnly(String date) throws IllegalValueException {
        List<DateGroup> temp = new Parser().parse(date);
        if (temp.isEmpty()) {
            throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS);
        }
        Date parsedDate = temp.get(0).getDates().get(0);
        this.date.setDate(parsedDate.getDate());
        this.date.setMonth(parsedDate.getMonth());
        this.date.setYear(parsedDate.getYear());
    }

    public void setTimeOnly(String time) throws IllegalValueException {
        List<DateGroup> temp = new Parser().parse(time);
        if (temp.isEmpty()) {
            throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS);
        }
        Date parsedTime = temp.get(0).getDates().get(0);
        this.date.setHours(parsedTime.getHours());
        this.date.setMinutes(parsedTime.getMinutes());
        this.date.setSeconds(parsedTime.getSeconds());
    }

    public void setDefaultTime() throws IllegalValueException {
        setTimeOnly(DEFAULT_TIME_STRING);
    }

    public String getTimeOnly() {
        SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss");
        return sdf.format(date);
    }

    public String getAmericanDateTime() {
        SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss");
        return sdf.format(date);
    }

    public String getAmericanDateOnly() {
        SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy");
        return sdf.format(date);
    }

    @Override
    public int compareTo(Object other) {
        assert other instanceof DateTime;
        if (this.equals(other)) {
            return 0;
        } else if (date.after(((DateTime) other).getDate())) {
            return 1;
        } else {
            return -1;
        }
    }

```
###### \java\seedu\tache\model\task\Task.java
``` java
    public RecurState getRecurState() {
        return recurState;
    }

    public void setRecurState(RecurState recurState) {
        this.recurState = recurState;
    }

    @Override
    public List<Task> getUncompletedRecurList() {
        assert startDateTime.isPresent();
        assert endDateTime.isPresent();

        List<Task> uncompletedRecurList = new ArrayList<Task>();
        List<Date> uncompletedRecurDates = this.recurState.getUncompletedRecurDates(startDateTime.get(),
                                                                                    endDateTime.get(), null);
        for (int i = 0; i < uncompletedRecurDates.size(); i++) {
            Task temp = new Task(this);
            DateFormat df = new SimpleDateFormat("MM/dd/yyyy");
            String tempDate = df.format(uncompletedRecurDates.get(i));
            temp.getRecurState().setRecurDisplayDate(tempDate);
            uncompletedRecurList.add(temp);
        }

        return uncompletedRecurList;
    }

    @Override
    public List<Task> getUncompletedRecurList(Date filterEndDate) {
        assert startDateTime.isPresent();
        assert endDateTime.isPresent();

        List<Task> uncompletedRecurList = new ArrayList<Task>();
        List<Date> uncompletedRecurDates = this.recurState.getUncompletedRecurDates(startDateTime.get(),
                                                                                    endDateTime.get(), filterEndDate);
        for (int i = 0; i < uncompletedRecurDates.size(); i++) {
            Task temp = new Task(this);
            DateFormat df = new SimpleDateFormat("MM/dd/yyyy");
            String tempDate = df.format(uncompletedRecurDates.get(i));
            temp.getRecurState().setRecurDisplayDate(tempDate);
            uncompletedRecurList.add(temp);
        }

        return uncompletedRecurList;
    }
```
###### \java\seedu\tache\ui\HotkeyManager.java
``` java
package seedu.tache.ui;

import javax.swing.KeyStroke;

import com.tulskiy.keymaster.common.HotKey;
import com.tulskiy.keymaster.common.HotKeyListener;
import com.tulskiy.keymaster.common.Provider;

import javafx.application.Platform;
import javafx.stage.Stage;

public class HotkeyManager {
    public static final String DEFAULT_HOTKEY_COMBINATION = "control alt D";

    private Provider hotkeyManager;
    private Stage stage;
    private String hotkeyCombination;

    public HotkeyManager(Stage stage) {
        this.stage = stage;
        this.hotkeyCombination = DEFAULT_HOTKEY_COMBINATION;
    }

    public HotkeyManager(Stage stage, String hotkeyCombination) {
        this.stage = stage;
        this.hotkeyCombination = hotkeyCombination;
    }

    /**
     * Bind show/hide (toggle) hotkey
     */
    private void bindToggleSystemHotkey() {
        if (hotkeyManager == null) {
            hotkeyManager = Provider.getCurrentProvider(false);
        }
        hotkeyManager.register(KeyStroke.getKeyStroke(hotkeyCombination), new HotKeyListener() {
            public void onHotKey(HotKey hotKey) {
                System.out.println(hotKey);
                if (stage.isFocused()) {
                    if (stage.isIconified()) {
                        Platform.runLater(()-> {
                            stage.setIconified(false); });
                    } else {
                        Platform.runLater(()-> {
                            stage.setIconified(true); });
                    }
                } else {
                    Platform.runLater(()-> {
                        stage.setIconified(false);
                        stage.toFront(); });
                }
            }
        });
    }

    /**
     * Starts binding of toggle hotkey
     */
    public void start() {
        bindToggleSystemHotkey();
    }

    /**
     * Stops binding of toggle hotkey
     */
    public void stop() {
        if (hotkeyManager != null) {
            hotkeyManager.reset();
            hotkeyManager.stop();
        }
    }
}
```
###### \java\seedu\tache\ui\MainWindow.java
``` java
    public CalendarPanel getCalendarPanel() {
        return this.calendarPanel;
    }

    void releaseResources() {
        calendarPanel.freeResources();
    }

}
```
###### \java\seedu\tache\ui\TaskListPanel.java
``` java
    public void resetConnections(ObservableList<ReadOnlyTask> taskList) {
        setConnections(taskList);
    }
```
###### \java\seedu\tache\ui\UiManager.java
``` java
    @Subscribe
    private void handleTaskPanelConnectionChangedEvent(TaskPanelConnectionChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        if (mainWindow.getTaskListPanel() != null) {
            mainWindow.getTaskListPanel().resetConnections(event.getNewConnection());
        }
    }

    @Subscribe
    private void handlePopulateRecurringGhostTaskEvent(PopulateRecurringGhostTaskEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        if (mainWindow.getTaskListPanel() != null) {
            mainWindow.getCalendarPanel().addAllEvents(event.getAllRecurringGhostTasks());;
        }
    }

    @Subscribe
    public void handleUpdateNotificationsEvent(TaskManagerChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        notificationManager.updateNotifications(event);
    }

}
```
