# A0140023E
###### /java/guitests/EditCommandTest.java
``` java
    @Test
    public void edit_invalidValues_failure() {
        // TODO constraints for date-time fields are also checked in other tests as they are constrained differently
        commandBox.runCommand("edit 1 //comments");
        assertResultMessage(Name.MESSAGE_NAME_CONSTRAINTS);

        commandBox.runCommand("edit 1 by yesterday");
        assertResultMessage(Deadline.MESSAGE_DEADLINE_CONSTRAINTS);

        commandBox.runCommand("edit 1 from yesterday to tmr");
        assertResultMessage(StartEndDateTime.MESSAGE_STARTDATETIME_CONSTRAINTS);

        commandBox.runCommand("edit 1 from tmr to yesterday");
        assertResultMessage(StartEndDateTime.MESSAGE_ENDDATETIME_CONSTRAINTS);

        commandBox.runCommand("edit 1 from 2 days later to 1 day later");
        assertResultMessage(StartEndDateTime.MESSAGE_STARTENDDATETIME_CONSTRAINTS);

        commandBox.runCommand("edit 1 t/*&");
        assertResultMessage(Tag.MESSAGE_TAG_CONSTRAINTS);
    }

```
###### /java/seedu/address/commons/util/StringUtilTest.java
``` java
    //---------------- Tests for replace --------------------------------------
    // TODO EP
    @Test
    public void replace_startIndexNegative_exceptionThrown() {
        assertOutOfBoundsExceptionThrown("01234", -1, 1, "Valid replacement");
    }

    // assertOutOfBoundsExceptionThrown("01234", 0, -1, "Valid replacement"); // negative end index

    @Test
    public void replace_startIndexLargerThanEndIndex_exceptionThrown() {
        assertOutOfBoundsExceptionThrown("01234", 1, 0, "Valid replacement");
    }
    // rename this method
    @Test
    public void replace_endIndexSuperLarge_expectedNewString() {
        String s = "01234";
        assertEquals(StringUtil.replace(s, s.length(), 1000, "Valid replacement"), "01234Valid replacement");
    }

    // boundary value less than length by 1, length(), length() + 1
    @Test
    public void replace_startIndexLessThanLength_expectedNewString() {
        String s = "01234";
        assertEquals(StringUtil.replace(s, s.length() - 1, s.length(), "Valid replacement"), "0123Valid replacement");
    }
    @Test
    public void replace_startIndexEqualToLength_expectedNewString() {
        String s = "01234";
        assertEquals(StringUtil.replace(s, s.length(), s.length(), "Valid replacement"), "01234Valid replacement");
    }
    @Test
    public void replace_startIndexGreaterThanLength_exceptionThrown() {
        String s = "01234";
        assertOutOfBoundsExceptionThrown(s, s.length() + 1, 1, "Valid replacement");
    }

    @Test
    public void replace_withinBounds_expectedNewString() {
        assertEquals(StringUtil.replace("01234", 0, 1, "Valid replacement"), "Valid replacement1234");
    }

    private void assertOutOfBoundsExceptionThrown(String s, int startIndex, int endIndex, String replacement) {
        thrown.expect(StringIndexOutOfBoundsException.class);
        StringUtil.replace(s, startIndex, endIndex, replacement);
    }

}
```
###### /java/seedu/address/logic/LogicManagerTest.java
``` java
        // TODO should this be done in another way?
        // Starting Test Date Time is set to one day after today so that dates in the past is not
        // generated to prevent a PastDateTimeException from occuring. Furthermore the precision
        // is truncated to seconds as Natty does not parse milliseconds
        private ZonedDateTime startTestDateTime = ZonedDateTime.now().truncatedTo(ChronoUnit.SECONDS).plusDays(1);

        private Task accept() throws Exception {
            Name name = new Name("Accept Changes");
            StartEndDateTime startEndDateTime =
                    new StartEndDateTime(startTestDateTime.plusDays(2), startTestDateTime.plusDays(4));
            Tag tag1 = new Tag("tag1");
            Tag tag2 = new Tag("longertag2");
            UniqueTagList tags = new UniqueTagList(tag1, tag2);
            // Note that a task is generated with a StartEndDateTime as that would be more complex
            // than a task with Deadline or a Task with no Deadline and StartEndDateTime, thus
            // making test cases more likely to fail
            return new Task(name, Optional.empty(), Optional.of(startEndDateTime), tags);
        }

        /**
         * Generates a valid task using the given seed.
         * Running this function with the same parameter values guarantees the returned task will have the same state
         * if it is using the same instance of {@link TestDataHelper}.
         * Each unique seed will generate a unique task object.
         *
         * @param seed used to generate the task data field values
         */
        private Task generateTaskWithStartEndDateTime(int seed) throws Exception {
            return new Task(
                    new Name("Task" + seed),
                    Optional.empty(),
                    Optional.of(new StartEndDateTime(startTestDateTime.plusDays(seed + 1),
                            startTestDateTime.plusDays(seed + 2))),
                    new UniqueTagList(new Tag("tag" + Math.abs(seed)), new Tag("tag" + Math.abs(seed + 1)))
            );
        }

        /** Generates the correct add command based on the task given */
        private String generateAddCommand(Task task) {
            // The date-times are transformed into a format that Natty can parse
            // TODO use a human format
            StringBuffer cmd = new StringBuffer();

            cmd.append("add ");

            cmd.append(task.getName().toString());

            if (task.getDeadline().isPresent()) {
                cmd.append(" by ");
                // TODO change the format
                cmd.append(task.getDeadline().get().getDateTime().format(DateTimeUtil.DATE_TIME_FORMAT));
            }

            if (task.getStartEndDateTime().isPresent()) {
                // TODO change the format
                StartEndDateTime startEndDateTime = task.getStartEndDateTime().get();
                cmd.append(" from ");
                cmd.append(startEndDateTime.getStartDateTime().format(DateTimeUtil.DATE_TIME_FORMAT));
                cmd.append(" to ");
                cmd.append(startEndDateTime.getEndDateTime().format(DateTimeUtil.DATE_TIME_FORMAT));
            }

            UniqueTagList tags = task.getTags();
            for (Tag t: tags) {
                cmd.append(" t/").append(t.tagName);
            }

            return cmd.toString();
        }

```
###### /java/seedu/address/logic/LogicManagerTest.java
``` java
        /**
         * Generates a Task object with given name. Other fields will have some dummy values.
         */
        private Task generateTaskWithName(String name) throws Exception {
            // Note that a task is generated with a StartEndDateTime as that would be more complex
            // than a task with Deadline or a Task with no Deadline and StartEndDateTime, thus
            // making test cases more likely to fail
            return new Task(
                    new Name(name),
                    Optional.empty(),
                    Optional.of(new StartEndDateTime(startTestDateTime.plusDays(3), startTestDateTime.plusDays(6))),
                    new UniqueTagList(new Tag("tag"))
            );
        }
    }
}
```
###### /java/seedu/address/logic/parser/AddCommandParserTest.java
``` java
public class AddCommandParserTest {
    // TODO make logicmanagertest test some simple add and edit
    // TODO fixed dates like 25 Apr can fail if it is in the past
    // TODO see who else is using ExpectedException
    // TODO fuzzy equals

    @Rule
    public ExpectedException exception = ExpectedException.none();

    private static Task actualTask;

    //TODO
    @Test
    public void testAdd() throws PastDateTimeException, IllegalValueException, CommandException {
        Name name = new Name("stand by me");
        Deadline deadline = new Deadline(ZonedDateTime.now().plusDays(1).truncatedTo(ChronoUnit.MINUTES));
        Task expectedTask = new Task(name, Optional.of(deadline), Optional.empty(), new UniqueTagList());

        Command command = new AddCommandParser().parse("stand by me by tmr");
        command.setData(new ModelManagerMock());
        CommandResult result = command.execute();
        actualTask.setDeadline(new Deadline(
                actualTask.getDeadline().get().getDateTime().truncatedTo(ChronoUnit.MINUTES)));
        assertEquals(expectedTask, actualTask);
        System.out.println(actualTask);
        System.out.println(result.feedbackToUser);
    }


    @Test
    public void testEdit() throws PastDateTimeException, IllegalValueException, CommandException {
        Model model = new ModelManagerMock();

        addSampleTaskWithDeadline(model);

        editTaskCommand(model, "1 by 2 days later");

        Deadline deadline = new Deadline(ZonedDateTime.now().plusDays(2).truncatedTo(ChronoUnit.MINUTES));
        Task expectedTask = new Task(new Name("stand by me"), Optional.of(deadline), Optional.empty(),
                new UniqueTagList());
        actualTask.setDeadline(new Deadline(
                actualTask.getDeadline().get().getDateTime().truncatedTo(ChronoUnit.MINUTES)));

        assertEquals(expectedTask, actualTask);
    }

    @Test
    public void testEdit2() throws PastDateTimeException, IllegalValueException, CommandException {
        Model model = new ModelManagerMock();
        addSampleTaskWithDeadline(model);

        editTaskCommand(model, "1 Pass rose from Uncle to Jane by 5 days later");

        Deadline deadline = new Deadline(ZonedDateTime.now().plusDays(5).truncatedTo(ChronoUnit.MINUTES));
        Task expectedTask = new Task(new Name("Pass rose from Uncle to Jane"), Optional.of(deadline), Optional.empty(),
                new UniqueTagList());
        actualTask.setDeadline(new Deadline(
                actualTask.getDeadline().get().getDateTime().truncatedTo(ChronoUnit.MINUTES)));

        assertEquals(expectedTask, actualTask);
    }

    @Test
    public void testEdit3() throws PastDateTimeException, IllegalValueException, CommandException {
        Model model = new ModelManagerMock();

        addSampleTaskWithDeadline(model);

        editTaskCommand(model, "1 by 8 days from 25 Apr");

        Deadline deadline = new Deadline(ZonedDateTime.now().withMonth(4).withDayOfMonth(25).plusDays(8)
                .truncatedTo(ChronoUnit.MINUTES));
        Task expectedTask = new Task(new Name("stand by me"), Optional.of(deadline), Optional.empty(),
                new UniqueTagList());
        actualTask.setDeadline(new Deadline(
                actualTask.getDeadline().get().getDateTime().truncatedTo(ChronoUnit.MINUTES)));

        assertEquals(expectedTask, actualTask);
    }


    @Test
    public void testEditSpecial1() throws PastDateTimeException, IllegalValueException, CommandException {
        Model model = new ModelManagerMock();

        addSampleTaskWithDeadline(model);

        exception.expect(CommandException.class);
        exception.expectMessage(EditCommand.EditTaskDescriptor.MESSAGE_NEED_START_END_DATE_TIME);

        editTaskCommand(model, "1 by 8 days later from 25 Apr");

        Deadline deadline = new Deadline(ZonedDateTime.now().withMonth(4).withDayOfMonth(25).plusDays(8)
                .truncatedTo(ChronoUnit.MINUTES));
        Task expectedTask = new Task(new Name("stand by me"), Optional.of(deadline), Optional.empty(),
                new UniqueTagList());
        actualTask.setDeadline(new Deadline(
                actualTask.getDeadline().get().getDateTime().truncatedTo(ChronoUnit.MINUTES)));

        assertEquals(expectedTask, actualTask);
    }

    @Test
    public void testEditSpecial2()
            throws PastDateTimeException, InvalidDurationException, IllegalValueException, CommandException {
        Model model = new ModelManagerMock();

        addSampleTaskWithStartEndDateTime(model);

        editTaskCommand(model, "1 by 8 days later from 25 Apr");

        ZonedDateTime startDateTime =
                ZonedDateTime.now().withMonth(4).withDayOfMonth(25).truncatedTo(ChronoUnit.MINUTES);
        ZonedDateTime endDateTime =
                ZonedDateTime.now().withMonth(4).withDayOfMonth(28).truncatedTo(ChronoUnit.MINUTES);
        StartEndDateTime startEndDateTime = new StartEndDateTime(startDateTime, endDateTime);
        Task expectedTask = new Task(new Name("by 8 days later"), Optional.empty(), Optional.of(startEndDateTime),
                new UniqueTagList());

        StartEndDateTime actualStartEndDateTime = actualTask.getStartEndDateTime().get();
        actualTask.setStartEndDateTime(new StartEndDateTime(
                actualStartEndDateTime.getStartDateTime().truncatedTo(ChronoUnit.MINUTES),
                actualStartEndDateTime.getEndDateTime().truncatedTo(ChronoUnit.MINUTES)));

        assertEquals(expectedTask, actualTask);
    }

    private void addSampleTaskWithDeadline(Model model) throws CommandException {
        Command command = new AddCommandParser().parse("stand by me by tmr");
        command.setData(model);
        command.execute();
    }

    private void addSampleTaskWithStartEndDateTime(Model model) throws CommandException {
        Command command = new AddCommandParser().parse("stand by me from 23 Apr to 28 Apr");
        command.setData(model);
        command.execute();
    }

    private void editTaskCommand(Model model, String args) throws CommandException {
        Command command = new EditCommandParser().parse(args);
        command.setData(model);
        command.execute();
    }

    private class ModelManagerMock extends ModelManager {
        @Override
        public synchronized void addTask(Task task) throws UniqueTaskList.DuplicateTaskException {
            AddCommandParserTest.actualTask = task;
            super.addTask(task);
        }

        // TODO move this to EditCommandParserTest
        @Override
        public void updateTask(int filteredTaskListIndex, ReadOnlyTask editedTask)
                throws UniqueTaskList.DuplicateTaskException {
            try {
                AddCommandParserTest.actualTask = new Task(editedTask);
            } catch (IllegalValueException e) {
                throw new AssertionError("Copying a valid task should always result in a valid task");
            }
            super.updateTask(filteredTaskListIndex, editedTask);
        }
    }

}
```
###### /java/seedu/address/logic/parser/DateTimeUtilTest.java
``` java
// TODO improve test and naming
public class DateTimeUtilTest {
    @Rule
    public final ExpectedException exception = ExpectedException.none();

    @Test
    public void parseDateTimeString_validDateTimes_noExceptionThrown() throws IllegalValueException {
        //org.apache.log4j.Logger.getRootLogger().setLevel(Level.INFO);

        // Random days of the week
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().with(TemporalAdjusters.next(DayOfWeek.SATURDAY)),
                DateTimeUtil.parseDateTimeString("Sat"));
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().with(TemporalAdjusters.next(DayOfWeek.WEDNESDAY)),
                DateTimeUtil.parseDateTimeString("Wed"));
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().with(TemporalAdjusters.next(DayOfWeek.FRIDAY)),
                DateTimeUtil.parseDateTimeString("Fri"));

        // Random date with month
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().withMonth(4).withDayOfMonth(25),
                DateTimeUtil.parseDateTimeString("25 Apr"));

        // Random month with year, Natty infers that it's 1st day of month
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().withYear(2017).withMonth(1).withDayOfMonth(1),
                DateTimeUtil.parseDateTimeString("Jan 2017"));

        // Random relative date
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().plusDays(2),
                DateTimeUtil.parseDateTimeString("2 days after"));

        // Random explicit date
        assertEqualsIgnoresMilliAndBelow(
                ZonedDateTime.of(LocalDate.of(2016, 5, 2), LocalTime.now(), DateTimeUtil.TIME_ZONE),
                DateTimeUtil.parseDateTimeString("2016-05-02"));
    }

    @Test
    public void parseDateTimeString_invalidDateTime_throwsException() throws IllegalValueException {
        assertInvalidDateTime("Not a date");
    }
    @Test
    public void parseDateTimeString_invalidDateTimeWithSymbols_throwsException() throws IllegalValueException {
        assertInvalidDateTime("We.d");
    }

    @Test
    public void parseDateTimeString_multipleDateTimes_throwsException() throws IllegalValueException {
        assertMultipleDateTimesFound("Wed ~ Thur");
    }

    @Test
    public void parseDateTimeString_multipleDateTimeAlternatives_throwsException() throws IllegalValueException {
        assertMultipleDateTimeAlternativesFound("Wed or Thur");
    }
    @Test
    public void parseDateTimeString_recurringDateTime_throwsException() throws IllegalValueException {
        assertRecurringDateTimesFound("every Friday");
    }

    public void assertInvalidDateTime(String dateTime) throws IllegalValueException {
        exception.expect(IllegalValueException.class);
        exception.expectMessage(String.format(DateTimeUtil.MESSAGE_NOT_VALID_DATE_TIME, dateTime));
        DateTimeUtil.parseDateTimeString(dateTime);
    }

    public void assertMultipleDateTimesFound(String dateTime) throws IllegalValueException {
        exception.expect(IllegalValueException.class);
        exception.expectMessage(String.format(DateTimeUtil.MESSAGE_MULTIPLE_DATE_TIMES_FOUND, dateTime));
        DateTimeUtil.parseDateTimeString(dateTime);
    }

    public void assertMultipleDateTimeAlternativesFound(String dateTime) throws IllegalValueException {
        exception.expect(IllegalValueException.class);
        exception.expectMessage(String.format(DateTimeUtil.MESSAGE_MULTIPLE_DATE_TIME_ALTERNATIVES_FOUND, dateTime));
        DateTimeUtil.parseDateTimeString(dateTime);
    }

    public void assertRecurringDateTimesFound(String dateTime) throws IllegalValueException {
        exception.expect(IllegalValueException.class);
        exception.expectMessage(String.format(DateTimeUtil.MESSAGE_RECURRING_DATE_TIME_FOUND, dateTime));
        DateTimeUtil.parseDateTimeString(dateTime);
    }

    @Test
    public void isSingleDateTimeString() {
        // Not dates
        assertFalse(DateTimeUtil.isSingleDateTimeString("Hello World"));
        assertFalse(DateTimeUtil.isSingleDateTimeString("Not a date"));
        assertFalse(DateTimeUtil.isSingleDateTimeString("We.d"));

        // multiple date groups separated by unknown tokens
        assertFalse(DateTimeUtil.isSingleDateTimeString("Wed ~ Thursday"));
        assertFalse(DateTimeUtil.isSingleDateTimeString("Wed ` Thursday"));
        assertFalse(DateTimeUtil.isSingleDateTimeString("Wed plus Thursday"));

        // recurring dates
        assertFalse(DateTimeUtil.isSingleDateTimeString("every Friday"));

        // multiple date alternatives
        assertFalse(DateTimeUtil.isSingleDateTimeString("Wed or Thur"));
        assertFalse(DateTimeUtil.isSingleDateTimeString("Wed and Thur"));


        // valid single dates
        assertTrue(DateTimeUtil.isSingleDateTimeString("Sat"));
    }

    // TODO all these also
    @Test
    public void testingOnly() throws IllegalValueException {
        assertNotEqualsIgnoresMilliAndBelow(
                ZonedDateTime.now().withMonth(4).withDayOfMonth(25).withHour(20).withMinute(0).withSecond(0)
                        .plusDays(2),
                DateTimeUtil.parseDateTimeString("2 days after 8pm 25 Apr"));

        assertNotEqualsIgnoresMilliAndBelow(
                ZonedDateTime.now().withMonth(4).withDayOfMonth(25).withHour(20).withMinute(0).withSecond(0)
                        .plusHours(2),
                DateTimeUtil.parseDateTimeString("2 hours after 8pm 25 Apr"));

    }

    @Test
    public void parseEditedDateTimeString() throws IllegalValueException {
        ZoneId fixedRandomZoneId = ZoneId.of("Asia/Tokyo");
        ZonedDateTime fixedRandomDateTime = ZonedDateTime.of(2015, 4, 1, 3, 4, 5, 2, fixedRandomZoneId);

        // relative date
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().plusDays(2),
                DateTimeUtil.parseEditedDateTimeString("2 days later", fixedRandomDateTime));
        // relative time
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().plusHours(24),
                DateTimeUtil.parseEditedDateTimeString("24 hours later", fixedRandomDateTime));

        // relative date respective to another date
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().withMonth(4).withDayOfMonth(25).plusDays(2),
                DateTimeUtil.parseEditedDateTimeString("2 days after 25 Apr", fixedRandomDateTime));

        // relative date respective to another date-time
        assertEqualsIgnoresMilliAndBelow(
                ZonedDateTime.now().withMonth(4).withDayOfMonth(25).withHour(20).withMinute(0).withSecond(0)
                        .plusDays(2),
                DateTimeUtil.parseEditedDateTimeString("2 days after 25 Apr 8pm", fixedRandomDateTime));

        // relative date respective to another date-time with time-zone
        // PST and America/Los_Angeles is equivalent but Natty supports only certain time-zone suffixes
        // PST is an example of daylights saving time
        assertEqualsIgnoresMilliAndBelow(
                ZonedDateTime.of(Year.now().getValue(), 4, 25, 20, 0, 0, 0, ZoneId.of("America/Los_Angeles"))
                        .plusDays(5),
                DateTimeUtil.parseEditedDateTimeString("5 days after 25 Apr 8pm PST", fixedRandomDateTime));

        // relative date respective to another date-time with time-zone offset
        assertEqualsIgnoresMilliAndBelow(
                ZonedDateTime.of(Year.now().getValue(), 4, 25, 20, 0, 0, 0, ZoneId.of("+1000"))
                        .plusDays(3),
                DateTimeUtil.parseEditedDateTimeString("3 days after 25 Apr 8pm +1000", fixedRandomDateTime));


        // relative date respective to another date with time
        // note that this does not work because Natty is not working correctly
        assertNotEqualsIgnoresMilliAndBelow(
                ZonedDateTime.now().withMonth(4).withDayOfMonth(25).withHour(20).withMinute(0).withSecond(0)
                        .plusHours(2),
                DateTimeUtil.parseEditedDateTimeString("2 hours after 25 Apr 8pm", fixedRandomDateTime));
        // TODO
        assertNotEqualsIgnoresMilliAndBelow(
                ZonedDateTime.of(Year.now().getValue(), 4, 25, 20, 0, 0, 0, ZoneId.of("America/Los_Angeles"))
                        .plusDays(5),
                DateTimeUtil.parseEditedDateTimeString("5 days after 8pm PST 25 Apr", fixedRandomDateTime));
    }

    // Extract this for use in other tests
    /**
     * Asserts that two zoned date-times are equal ignoring milliseconds and below.
     */
    private void assertEqualsIgnoresMilliAndBelow(ZonedDateTime expected, ZonedDateTime actual) {
        ChronoUnit truncationUnit = ChronoUnit.SECONDS;
        ZonedDateTime expectedTruncated = expected.truncatedTo(truncationUnit);
        ZonedDateTime actualTruncated = actual.truncatedTo(truncationUnit);
        System.out.println(expectedTruncated);
        System.out.println(actualTruncated);
        // converting to Instant so we compare without caring about timezones
        assertEquals(expectedTruncated.toInstant(), actualTruncated.toInstant());
    }

    /**
     * Asserts that two zoned date-times are not equal ignoring milliseconds and below.
     */
    private void assertNotEqualsIgnoresMilliAndBelow(ZonedDateTime expected, ZonedDateTime actual) {
        ChronoUnit truncationUnit = ChronoUnit.SECONDS;
        ZonedDateTime expectedTruncated = expected.truncatedTo(truncationUnit);
        ZonedDateTime actualTruncated = actual.truncatedTo(truncationUnit);
        // converting to Instant so we compare without caring about timezones
        assertNotEquals(expectedTruncated.toInstant(), actualTruncated.toInstant());
    }
}
```
###### /java/seedu/address/model/task/NameTest.java
``` java
    @Test
    public void isValidName() {
        // invalid name
        assertFalse(Name.isValidName("")); // empty string
        assertFalse(Name.isValidName(" ")); // space only (0x20)
        assertFalse(Name.isValidName("\t")); // tab only
        assertFalse(Name.isValidName("\n")); // new line only
        assertFalse(Name.isValidName("\u000B")); // Vertical tab only
        assertFalse(Name.isValidName("\f")); // form feed only
        assertFalse(Name.isValidName("\r")); // carriage return only
        assertFalse(Name.isValidName("//")); // only slashes
        assertFalse(Name.isValidName("fetch colleague/boss")); // contains forward slashes

        // valid name
        assertTrue(Name.isValidName("assignment")); // alphabets only
        assertTrue(Name.isValidName("12345")); // numbers only
        assertTrue(Name.isValidName("2nd draft")); // alphanumeric characters
        assertTrue(Name.isValidName("Software Engineering Exam")); // with capital letters
        assertTrue(Name.isValidName("Super duper the long task")); // long names
        assertTrue(Name.isValidName("#$!$#!$!@#$!@!~@~!")); // tons of random symbols
        assertTrue(Name.isValidName("Whee~~~~")); // alphabets with symbols
        assertTrue(Name.isValidName("Omg!!")); // alphabets with symbols
        assertTrue(Name.isValidName("你好吗?")); // Valid UTF-16 string with symbols
    }
}
```
###### /java/seedu/address/testutil/TaskBuilder.java
``` java
/**
 * A Task Builder class that allow us to construct a Task by chaining calls for convenience in testing.
 */
```
###### /java/seedu/address/testutil/TaskBuilder.java
``` java
    public TaskBuilder withDeadline(Deadline deadline) throws IllegalValueException {
        task.setDeadline(deadline);
        return this;
    }

    public TaskBuilder withStartEndDateTime(StartEndDateTime startEndDateTime) throws IllegalValueException {
        task.setStartEndDateTime(startEndDateTime);
        return this;
    }

```
###### /java/seedu/address/testutil/TestTask.java
``` java
    public TestTask() {
        // Initialize TestTask with empty deadlines, startEndDateTime and tags because they are optional.
        // this will allow us to conveniently create TestTasks through TaskBuilder without being forced
        // to specify the optional fields
        deadline = Optional.empty();
        startEndDateTime = Optional.empty();
        tags = new UniqueTagList();
    }

    /**
     * Creates a copy of {@code taskToCopy} by shallow copying only the data.
     * Shallow copying reduces the overhead of copying the data.
     */
    public TestTask(TestTask taskToCopy) {
        name = taskToCopy.getName();
        deadline = taskToCopy.getDeadline();
        startEndDateTime = taskToCopy.getStartEndDateTime();
        tags = taskToCopy.getTags();
    }

```
###### /java/seedu/address/testutil/TestTask.java
``` java
    public void setDeadline(Deadline dateTime) {
        this.deadline = Optional.of(dateTime);
    }

    public void setStartEndDateTime(StartEndDateTime startEndDateTime) {
        this.startEndDateTime = Optional.of(startEndDateTime);
    }

```
###### /java/seedu/address/testutil/TestTask.java
``` java
    @Override
    public Optional<Deadline> getDeadline() {
        return deadline;
    }

    @Override
    public Optional<StartEndDateTime> getStartEndDateTime() {
        return startEndDateTime;
    }

```
###### /java/seedu/address/testutil/TestTask.java
``` java
    public String getAddCommand() {
        StringBuilder sb = new StringBuilder();
        sb.append("add " + getName().value + " ");

        if (getDeadline().isPresent()) {
            sb.append(" by ");
            // TODO change the format
            sb.append(getDeadline().get().getDateTime().format(DateTimeUtil.DATE_TIME_FORMAT));
        }

        if (getStartEndDateTime().isPresent()) {
            // TODO change the format
            StartEndDateTime startEndDateTime = getStartEndDateTime().get();
            sb.append(" from ");
            sb.append(startEndDateTime.getStartDateTime().format(DateTimeUtil.DATE_TIME_FORMAT));
            sb.append(" to ");
            sb.append(startEndDateTime.getEndDateTime().format(DateTimeUtil.DATE_TIME_FORMAT));
        }

        getTags().asObservableList().stream().forEach(s -> sb.append("t/" + s.tagName + " "));
        return sb.toString();
    }
}
```
###### /java/seedu/address/testutil/TypicalTestTasks.java
``` java
    // TODO naming of tasks as names does not seem to be a good idea, and not descriptive enough
    // for example helpMe and iAmCode are to be manually added in test cases but it is not clear
    // conversely the name shows what the task contains, so it can be helpful
    public TestTask amuseFriend, bet, count, dog, elephant, flipTable, goondu, helpMe, iAmCode;

    public TypicalTestTasks() {
        // Starting Test Date Time is set to one day after today so that dates in the past is not
        // generated to prevent a PastDateTimeException from occuring. Furthermore the precision
        // is truncated to seconds as Natty does not parse milliseconds
        ZonedDateTime startTestDateTime = ZonedDateTime.now().truncatedTo(ChronoUnit.SECONDS).plusDays(1);
        try {
            // floating task with a tag
            amuseFriend = new TaskBuilder().withName("Amuse friend").withTags("friends").build();
            // TODO flip the order of tags and test cases can fail, see TestUtil::compareCardAndPerson
            // using list compare instead of set compare
            // floating task with two tags
            bet = new TaskBuilder().withName("Bet dog race").withTags("luck", "money").build();
            // floating task with no tags
            count = new TaskBuilder().withName("Count chickens before they hatch").build();
            // task with deadlines
            dog = new TaskBuilder().withName("Dog naming")
                    .withDeadline(new Deadline(startTestDateTime.plusDays(3))).build();
            // task with start and end dates
            elephant = new TaskBuilder().withName("Elephant riding")
                    .withStartEndDateTime(new StartEndDateTime(startTestDateTime.plusHours(2),
                                                               startTestDateTime.plusHours(3)))
                    .build();
            // some other random floating tasks
            flipTable = new TaskBuilder().withName("Flip table").build();
            goondu = new TaskBuilder().withName("Goondu goon").build();

            // Manually added
            // TODO maybe to use non-floating tasks here
            helpMe = new TaskBuilder().withName("Help me").build();
            iAmCode = new TaskBuilder().withName("I am code").build();
        } catch (PastDateTimeException e) {
            e.printStackTrace();
            assert false : "not possible";
        } catch (InvalidDurationException e) {
            e.printStackTrace();
            assert false : "not possible";
        } catch (IllegalValueException e) {
            e.printStackTrace();
            assert false : "not possible";
        }
    }

    public static void loadTaskListWithSampleData(TaskList taskList) {
        for (TestTask task : new TypicalTestTasks().getTypicalTasks()) {
            try {
                taskList.addTask(new Task(task));
            } catch (UniqueTaskList.DuplicateTaskException e) {
                assert false : "the taskList should not already contain any of the typical tasks.";
            } catch (IllegalValueException e) {
                assert false : "Copying a valid task should always result in a valid task.";
            }
        }
    }

    public TestTask[] getTypicalTasks() {
        return new TestTask[]{amuseFriend, bet, count, dog, elephant, flipTable, goondu};
    }

```
