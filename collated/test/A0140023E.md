# A0140023E
###### /java/guitests/EditCommandTest.java
``` java
    @Test
    public void edit_invalidValues_failure() {
        // TODO constraints for date-time fields are also checked in other tests as they are constrained differently
        commandBox.runCommand("edit 1 //comments");
        assertResultMessage(Name.MESSAGE_NAME_CONSTRAINTS);

        commandBox.runCommand("edit 1 by yesterday");
        assertResultMessage(Deadline.MESSAGE_DEADLINE_CONSTRAINTS);

        commandBox.runCommand("edit 1 from yesterday to tmr");
        assertResultMessage(StartEndDateTime.MESSAGE_PAST_START_DATETIME_CONSTRAINTS);

        commandBox.runCommand("edit 1 from tmr to yesterday");
        assertResultMessage(StartEndDateTime.MESSAGE_PAST_END_DATETIME_CONSTRAINTS);

        commandBox.runCommand("edit 1 from 2 days later to 1 day later");
        assertResultMessage(StartEndDateTime.MESSAGE_INVALID_DURATION_CONSTRAINTS);

        commandBox.runCommand("edit 1 t/*&");
        assertResultMessage(Tag.MESSAGE_TAG_CONSTRAINTS);
    }

```
###### /java/guitests/EmptyDataTest.java
``` java
    @Test
    public void taskList_dataFileDoesNotExist_initEmptyTaskList() throws Exception {
        Task[] expectedList = new Task[0];
        assertTrue(taskListPanel.isListMatching(expectedList));
    }
}
```
###### /java/onlythree/imanager/commons/util/StringUtilTest.java
``` java
    //---------------- Tests for replace --------------------------------------
    @Test
    public void replace_startIndexNegative_exceptionThrown() {
        assertOutOfBoundsExceptionThrown("01234", -1, 1, "Valid replacement");
    }

    @Test
    public void replace_startIndexLargerThanEndIndex_exceptionThrown() {
        assertOutOfBoundsExceptionThrown("01234", 1, 0, "Valid replacement");
    }
    // rename this method
    @Test
    public void replace_endIndexSuperLarge_expectedNewString() {
        String s = "01234";
        assertEquals(StringUtil.replace(s, s.length(), 1000, "Valid replacement"), "01234Valid replacement");
    }

    // boundary value less than length by 1, length(), length() + 1
    @Test
    public void replace_startIndexLessThanLength_expectedNewString() {
        String s = "01234";
        assertEquals(StringUtil.replace(s, s.length() - 1, s.length(), "Valid replacement"), "0123Valid replacement");
    }
    @Test
    public void replace_startIndexEqualToLength_expectedNewString() {
        String s = "01234";
        assertEquals(StringUtil.replace(s, s.length(), s.length(), "Valid replacement"), "01234Valid replacement");
    }
    @Test
    public void replace_startIndexGreaterThanLength_exceptionThrown() {
        String s = "01234";
        assertOutOfBoundsExceptionThrown(s, s.length() + 1, 1, "Valid replacement");
    }

    @Test
    public void replace_withinBounds_expectedNewString() {
        assertEquals(StringUtil.replace("01234", 0, 1, "Valid replacement"), "Valid replacement1234");
    }

    private void assertOutOfBoundsExceptionThrown(String s, int startIndex, int endIndex, String replacement) {
        thrown.expect(StringIndexOutOfBoundsException.class);
        StringUtil.replace(s, startIndex, endIndex, replacement);
    }

}
```
###### /java/onlythree/imanager/logic/LogicManagerTest.java
``` java
    // TODO maybe to take out these tests and put elsewhere
    @Test
    public void execute_add_invalidTaskData() {
        assertCommandFailure("add invalid name with slash/ from tmr to 2 days after",
                Name.MESSAGE_NAME_CONSTRAINTS);
        assertCommandFailure("add valid name by yesterday t/validTag",
                Deadline.MESSAGE_DEADLINE_CONSTRAINTS);
        assertCommandFailure("add valid name from yesterday to tmr t/validTag",
                StartEndDateTime.MESSAGE_PAST_START_DATETIME_CONSTRAINTS);
        assertCommandFailure("add valid name from tmr to yesterday t/validTag",
                StartEndDateTime.MESSAGE_PAST_END_DATETIME_CONSTRAINTS);
        assertCommandFailure("add valid name from 3 days later to 2 days later t/validTag",
                StartEndDateTime.MESSAGE_INVALID_DURATION_CONSTRAINTS);
        assertCommandFailure("add Valid Name from 2 days later to 3 days later t/invalid_-[.tag",
                Tag.MESSAGE_TAG_CONSTRAINTS);
    }

```
###### /java/onlythree/imanager/logic/LogicManagerTest.java
``` java
        // TODO should this be done in another way?
        // Starting Test Date Time is set to one day after today so that dates in the past is not
        // generated to prevent a PastDateTimeException from occuring. Furthermore the precision
        // is truncated to seconds as Natty does not parse milliseconds
        private ZonedDateTime startTestDateTime = ZonedDateTime.now().truncatedTo(ChronoUnit.SECONDS).plusDays(1);

        private Task accept() throws Exception {
            Name name = new Name("Accept Changes");
            StartEndDateTime startEndDateTime =
                    new StartEndDateTime(startTestDateTime.plusDays(2), startTestDateTime.plusDays(4));
            Tag tag1 = new Tag("tag1");
            Tag tag2 = new Tag("longertag2");
            UniqueTagList tags = new UniqueTagList(tag1, tag2);
            // Note that a task is generated with a StartEndDateTime as that would be more complex
            // than a task with Deadline or a Task with no Deadline and StartEndDateTime, thus
            // making test cases more likely to fail
            return new Task(name, Optional.empty(), Optional.of(startEndDateTime), tags);
        }

        /**
         * Generates a valid task using the given seed.
         * Running this function with the same parameter values guarantees the returned task will have the same state
         * if it is using the same instance of {@link TestDataHelper}.
         * Each unique seed will generate a unique task object.
         *
         * @param seed used to generate the task data field values
         */
        private Task generateTaskWithStartEndDateTime(int seed) throws Exception {
            return new Task(
                    new Name("Task" + seed),
                    Optional.empty(),
                    Optional.of(new StartEndDateTime(startTestDateTime.plusDays(seed + 1),
                            startTestDateTime.plusDays(seed + 2))),
                    new UniqueTagList(new Tag("tag" + Math.abs(seed)), new Tag("tag" + Math.abs(seed + 1)))
            );
        }

        /** Generates the correct add command based on the task given */
        private String generateAddCommand(Task task) {
            // The date-times are transformed into a format that Natty can parse
            StringBuffer cmd = new StringBuffer();

            cmd.append("add ");

            cmd.append(task.getName().toString());

            if (task.getDeadline().isPresent()) {
                cmd.append(" by ");
                cmd.append(task.getDeadline().get().getDateTime().format(DateTimeFormats.TEST_FORMAT));
            }

            if (task.getStartEndDateTime().isPresent()) {
                StartEndDateTime startEndDateTime = task.getStartEndDateTime().get();
                cmd.append(" from ");
                cmd.append(startEndDateTime.getStartDateTime().format(DateTimeFormats.TEST_FORMAT));
                cmd.append(" to ");
                cmd.append(startEndDateTime.getEndDateTime().format(DateTimeFormats.TEST_FORMAT));
            }

            UniqueTagList tags = task.getTags();
            for (Tag t: tags) {
                cmd.append(" t/").append(t.tagName);
            }

            return cmd.toString();
        }

```
###### /java/onlythree/imanager/logic/LogicManagerTest.java
``` java
        /**
         * Generates a Task object with given name. Other fields will have some dummy values.
         */
        private Task generateTaskWithName(String name) throws Exception {
            // Note that a task is generated with a StartEndDateTime as that would be more complex
            // than a task with Deadline or a Task with no Deadline and StartEndDateTime, thus
            // making test cases more likely to fail
            return new Task(
                    new Name(name),
                    Optional.empty(),
                    Optional.of(new StartEndDateTime(startTestDateTime.plusDays(3), startTestDateTime.plusDays(6))),
                    new UniqueTagList(new Tag("tag"))
            );
        }
    }
}
```
###### /java/onlythree/imanager/logic/parser/AddCommandParserTest.java
``` java
public class AddCommandParserTest {
    @Rule
    public ExpectedException exception = ExpectedException.none();

    private static Task actualTask;

    @Test
    public void parse_withRequiredFieldsOnly_expectCorrectTask()
            throws PastDateTimeException, IllegalValueException, CommandException {
        Name name = new Name("only name");
        Task expectedTask = new Task(name, Optional.empty(), Optional.empty(), new UniqueTagList());

        parseAndExecute("only name");

        assertEquals(expectedTask, actualTask);
    }

    @Test
    public void parse_withTags_expectCorrectTask()
            throws PastDateTimeException, IllegalValueException, CommandException {
        Name name = new Name("fill me up");
        Task expectedTask = new Task(name, Optional.empty(), Optional.empty(), new UniqueTagList("tag1", "tag2"));

        parseAndExecute(" fill me up t/tag1 t/tag2");

        assertEquals(expectedTask, actualTask);
    }

    @Test
    public void parse_withDeadline_expectCorrectTask()
            throws PastDateTimeException, IllegalValueException, CommandException {
        Name name = new Name("stand by me");
        Deadline deadline = new Deadline(ZonedDateTime.now().plusDays(1));
        Task expectedTask = new Task(name, Optional.of(deadline), Optional.empty(), new UniqueTagList());

        parseAndExecute(" stand by me by tmr");

        assertEqualsTaskIgnoreDeadlineSeconds(expectedTask, actualTask);
    }

    @Test
    public void parse_withStartEndDateTime_expectCorrectTask()
            throws PastDateTimeException, IllegalValueException, CommandException, InvalidDurationException {
        Name name = new Name("vacation");
        StartEndDateTime startEndDateTime =
                new StartEndDateTime(ZonedDateTime.now().plusDays(3), ZonedDateTime.now().plusDays(7));
        Task expectedTask = new Task(name, Optional.empty(), Optional.of(startEndDateTime), new UniqueTagList());

        parseAndExecute(" vacation from 3 days after to 7 days after");

        assertEqualsTaskIgnoreStartEndDateTimeSeconds(expectedTask, actualTask);

    }

    @Test
    public void parse_withDeadlineAndStartEndDateTime_expectsException()
            throws PastDateTimeException, IllegalValueException, CommandException, InvalidDurationException {
        exception.expect(CommandException.class);
        exception.expectMessage(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));

        parseAndExecute(" by tmr from 3 days after to 7 days after");
    }

    private void parseAndExecute(String args) throws CommandException {
        Command command = new AddCommandParser().parse(args);
        command.setData(new ModelManagerMock());
        command.execute();
    }


    private class ModelManagerMock extends ModelManager {
        @Override
        public synchronized void addTask(Task task) {
            AddCommandParserTest.actualTask = task;
            super.addTask(task);
        }
    }

}
```
###### /java/onlythree/imanager/logic/parser/DateTimeUtilTest.java
``` java
public class DateTimeUtilTest {
    @Rule
    public final ExpectedException exception = ExpectedException.none();

    private ZoneId someZoneId = ZoneId.of("Asia/Tokyo");
    private ZonedDateTime someDateTime = ZonedDateTime.of(2015, 4, 1, 3, 4, 5, 2, someZoneId);

    @Test
    public void isSingleDateTimeString() {
        // Not dates
        assertFalse(DateTimeUtil.isSingleDateTimeString("Hello World"));
        assertFalse(DateTimeUtil.isSingleDateTimeString("Not a date"));
        assertFalse(DateTimeUtil.isSingleDateTimeString("We.d"));

        // multiple date groups separated by unknown tokens
        assertFalse(DateTimeUtil.isSingleDateTimeString("Wed ~ Thursday"));
        assertFalse(DateTimeUtil.isSingleDateTimeString("Wed ` Thursday"));
        assertFalse(DateTimeUtil.isSingleDateTimeString("Wed plus Thursday"));

        // recurring dates
        assertFalse(DateTimeUtil.isSingleDateTimeString("every Friday"));

        // multiple date alternatives
        assertFalse(DateTimeUtil.isSingleDateTimeString("Wed or Thur"));
        assertFalse(DateTimeUtil.isSingleDateTimeString("Wed and Thur"));

        // valid single dates
        assertTrue(DateTimeUtil.isSingleDateTimeString("Sat"));
    }

    @Test
    public void parseDateTimeString_validDateTimeString_dateTimeReturned() throws IllegalValueException {
        // Random days of the week
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().with(TemporalAdjusters.next(DayOfWeek.SATURDAY)),
                DateTimeUtil.parseDateTimeString("Sat"));
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().with(TemporalAdjusters.next(DayOfWeek.WEDNESDAY)),
                DateTimeUtil.parseDateTimeString("Wed"));
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().with(TemporalAdjusters.next(DayOfWeek.FRIDAY)),
                DateTimeUtil.parseDateTimeString("Fri"));

        // Random date with month
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().withMonth(4).withDayOfMonth(25),
                DateTimeUtil.parseDateTimeString("25 Apr"));

        // Random month with year, Natty infers that it's 1st day of month
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().withYear(2017).withMonth(1).withDayOfMonth(1),
                DateTimeUtil.parseDateTimeString("Jan 2017"));

        // Random relative date
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().plusDays(2),
                DateTimeUtil.parseDateTimeString("2 days after"));

        // Random explicit date
        assertEqualsIgnoresMilliAndBelow(
                ZonedDateTime.of(LocalDate.of(2016, 5, 2), LocalTime.now(), DateTimeFormats.SYSTEM_TIME_ZONE),
                DateTimeUtil.parseDateTimeString("2016-05-02"));
    }

    @Test
    public void parseDateTimeString_invalidDateTime_throwsException() throws IllegalValueException {
        testInvalidDateTime("Not a date");
    }
    @Test
    public void parseDateTimeString_invalidDateTimeWithSymbols_throwsException() throws IllegalValueException {
        testInvalidDateTime("We.d");
    }

    @Test
    public void parseDateTimeString_multipleDateTimes_throwsException() throws IllegalValueException {
        testMultipleDateTimesFound("Wed ~ Thur");
    }

    @Test
    public void parseDateTimeString_multipleDateTimeAlternatives_throwsException() throws IllegalValueException {
        testMultipleDateTimeAlternativesFound("Wed or Thur");
    }
    @Test
    public void parseDateTimeString_recurringDateTime_throwsException() throws IllegalValueException {
        testRecurringDateTimesFound("every Friday");
    }

    @Test
    public void parseDateTimeString_unrecognizedNaturalLanguage_expectStrangeOutput() throws IllegalValueException {
        assertNotEqualsIgnoresMilliAndBelow(
                ZonedDateTime.now().withMonth(4).withDayOfMonth(25).withHour(20).withMinute(0).withSecond(0)
                        .plusDays(2),
                DateTimeUtil.parseDateTimeString("2 days after 8pm 25 Apr"));

        assertNotEqualsIgnoresMilliAndBelow(
                ZonedDateTime.now().withMonth(4).withDayOfMonth(25).withHour(20).withMinute(0).withSecond(0)
                        .plusHours(2),
                DateTimeUtil.parseDateTimeString("2 hours after 8pm 25 Apr"));

    }

    @Test
    public void parseEditedDateTimeString_relativeDateTime_expectCorrectOutput() throws IllegalValueException {
        // relative date
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().plusDays(2),
                DateTimeUtil.parseEditedDateTimeString("2 days later", someDateTime));
        // relative time
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().plusHours(24),
                DateTimeUtil.parseEditedDateTimeString("24 hours later", someDateTime));

        // relative date respective to another date
        assertEqualsIgnoresMilliAndBelow(ZonedDateTime.now().withMonth(4).withDayOfMonth(25).plusDays(2),
                DateTimeUtil.parseEditedDateTimeString("2 days after 25 Apr", someDateTime));

        // relative date respective to another date-time
        assertEqualsIgnoresMilliAndBelow(
                ZonedDateTime.now().withMonth(4).withDayOfMonth(25).withHour(20).withMinute(0).withSecond(0)
                        .plusDays(2),
                DateTimeUtil.parseEditedDateTimeString("2 days after 25 Apr 8pm", someDateTime));

        // relative date respective to another date-time with time-zone
        // PST and America/Los_Angeles is equivalent but Natty supports only certain time-zone suffixes
        // PST is an example of daylights saving time
        assertEqualsIgnoresMilliAndBelow(
                ZonedDateTime.of(Year.now().getValue(), 4, 25, 20, 0, 0, 0, ZoneId.of("America/Los_Angeles"))
                        .plusDays(5),
                DateTimeUtil.parseEditedDateTimeString("5 days after 25 Apr 8pm PST", someDateTime));

        // relative date respective to another date-time with time-zone offset
        assertEqualsIgnoresMilliAndBelow(
                ZonedDateTime.of(Year.now().getValue(), 4, 25, 20, 0, 0, 0, ZoneId.of("+1000"))
                        .plusDays(3),
                DateTimeUtil.parseEditedDateTimeString("3 days after 25 Apr 8pm +1000", someDateTime));

        // relative date respective to another date with time
        // note that this does not work because Natty is not working correctly
        assertNotEqualsIgnoresMilliAndBelow(
                ZonedDateTime.now().withMonth(4).withDayOfMonth(25).withHour(20).withMinute(0).withSecond(0)
                        .plusHours(2),
                DateTimeUtil.parseEditedDateTimeString("2 hours after 25 Apr 8pm", someDateTime));
        assertNotEqualsIgnoresMilliAndBelow(
                ZonedDateTime.of(Year.now().getValue(), 4, 25, 20, 0, 0, 0, ZoneId.of("America/Los_Angeles"))
                        .plusDays(5),
                DateTimeUtil.parseEditedDateTimeString("5 days after 8pm PST 25 Apr", someDateTime));
    }

    private void testInvalidDateTime(String dateTime) throws IllegalValueException {
        exception.expect(IllegalValueException.class);
        exception.expectMessage(String.format(DateTimeUtil.MESSAGE_NOT_VALID_DATE_TIME, dateTime));
        DateTimeUtil.parseDateTimeString(dateTime);
    }

    private void testMultipleDateTimesFound(String dateTime) throws IllegalValueException {
        exception.expect(IllegalValueException.class);
        exception.expectMessage(String.format(DateTimeUtil.MESSAGE_MULTIPLE_DATE_TIMES_FOUND, dateTime));
        DateTimeUtil.parseDateTimeString(dateTime);
    }

    private void testMultipleDateTimeAlternativesFound(String dateTime) throws IllegalValueException {
        exception.expect(IllegalValueException.class);
        exception.expectMessage(String.format(DateTimeUtil.MESSAGE_MULTIPLE_DATE_TIME_ALTERNATIVES_FOUND, dateTime));
        DateTimeUtil.parseDateTimeString(dateTime);
    }

    private void testRecurringDateTimesFound(String dateTime) throws IllegalValueException {
        exception.expect(IllegalValueException.class);
        exception.expectMessage(String.format(DateTimeUtil.MESSAGE_RECURRING_DATE_TIME_FOUND, dateTime));
        DateTimeUtil.parseDateTimeString(dateTime);
    }

    private void assertEqualsIgnoresMilliAndBelow(ZonedDateTime expected, ZonedDateTime actual) {
        assertEqualsIgnoresUnitBelow(expected, actual, ChronoUnit.SECONDS);
    }
    private void assertNotEqualsIgnoresMilliAndBelow(ZonedDateTime expected, ZonedDateTime actual) {
        assertNotEqualsIgnoresUnitBelow(expected, actual, ChronoUnit.SECONDS);
    }
}
```
###### /java/onlythree/imanager/logic/parser/EditCommandParserTest.java
``` java
public class EditCommandParserTest {
    @Rule
    public ExpectedException exception = ExpectedException.none();

    private static Task actualTask;

    @Test
    public void parse_withDeadlineExplicitDate_expectCorrectTask()
            throws PastDateTimeException, IllegalValueException, CommandException {
        Model model = new ModelManagerMock();

        addSampleTaskWithDeadline(model);

        parseEditAndExecute(model, " 1 by 14 Aug");

        Deadline deadline = new Deadline(
                ZonedDateTime.now().plusDays(1).with(LocalDate.of(Year.now().getValue(), 8, 14)));
        Task expectedTask = new Task(new Name("stand by me"), Optional.of(deadline), Optional.empty(),
                new UniqueTagList());

        assertEqualsTaskIgnoreDeadlineSeconds(expectedTask, actualTask);
    }

    @Test
    public void parse_withDeadlineExplicitTime_expectCorrectTask()
            throws PastDateTimeException, IllegalValueException, CommandException {
        Model model = new ModelManagerMock();

        addSampleTaskWithDeadline(model);

        parseEditAndExecute(model, " 1 by 2pm");

        Deadline deadline = new Deadline(ZonedDateTime.now().plusDays(1).with(LocalTime.of(14, 0)));
        Task expectedTask = new Task(new Name("stand by me"), Optional.of(deadline), Optional.empty(),
                new UniqueTagList());

        assertEqualsTaskIgnoreDeadlineSeconds(expectedTask, actualTask);
    }

    @Test
    public void parse_withDeadlineExplicitDateTime_expectCorrectTask()
            throws PastDateTimeException, IllegalValueException, CommandException {
        Model model = new ModelManagerMock();

        addSampleTaskWithDeadline(model);

        parseEditAndExecute(model, " 1 by 17 Oct 7pm");

        Deadline deadline = new Deadline(ZonedDateTime.of(Year.now().getValue(), 10, 17, 19, 0, 0, 0,
                DateTimeFormats.SYSTEM_TIME_ZONE));
        Task expectedTask = new Task(new Name("stand by me"), Optional.of(deadline), Optional.empty(),
                new UniqueTagList());

        assertEqualsTaskIgnoreDeadlineSeconds(expectedTask, actualTask);
    }

    @Test
    public void parse_withDeadlineRelativeDate_expectCorrectTask()
            throws PastDateTimeException, IllegalValueException, CommandException {
        Model model = new ModelManagerMock();

        addSampleTaskWithDeadline(model);

        parseEditAndExecute(model, " 1 by 2 days later");

        Deadline deadline = new Deadline(ZonedDateTime.now().plusDays(2));
        Task expectedTask = new Task(new Name("stand by me"), Optional.of(deadline), Optional.empty(),
                new UniqueTagList());

        assertEqualsTaskIgnoreDeadlineSeconds(expectedTask, actualTask);
    }

    @Test
    public void parse_withDeadlineRelativeToAnotherDate_expectCorrectTask()
            throws PastDateTimeException, IllegalValueException, CommandException {
        Model model = new ModelManagerMock();

        addSampleTaskWithDeadline(model);

        parseEditAndExecute(model, " 1 by 8 days from 3 Sep");

        Deadline deadline = new Deadline(ZonedDateTime.now().withMonth(9).withDayOfMonth(3).plusDays(8));

        Task expectedTask = new Task(new Name("stand by me"), Optional.of(deadline), Optional.empty(),
                new UniqueTagList());

        assertEqualsTaskIgnoreDeadlineSeconds(expectedTask, actualTask);
    }

    @Test
    public void parse_withDeadlineLookingLikeRelativeToAnotherDate_expectException()
            throws PastDateTimeException, IllegalValueException, CommandException {
        Model model = new ModelManagerMock();

        addSampleTaskWithDeadline(model);

        exception.expect(CommandException.class);
        exception.expectMessage(EditCommand.EditTaskDescriptor.MESSAGE_NEED_START_END_DATE_TIME);

        // later is not recognized as a token by Natty so it is interpreted that there is start date-time
        parseEditAndExecute(model, " 1 by 8 days later from 3 Sep");
    }

    @Test
    public void parse_withDeadlineLookingLikeRelativeToAnotherDate_expectCorrectTask()
            throws PastDateTimeException, InvalidDurationException, IllegalValueException, CommandException {
        Model model = new ModelManagerMock();

        addSampleTaskWithStartEndDateTime(model);

        parseEditAndExecute(model, " 1 by 8 days later from 3 Sep");

        ZonedDateTime startDateTime = ZonedDateTime.now().withMonth(9).withDayOfMonth(3);
        ZonedDateTime endDateTime = ZonedDateTime.now().withMonth(10).withDayOfMonth(28);
        StartEndDateTime startEndDateTime = new StartEndDateTime(startDateTime, endDateTime);
        Task expectedTask = new Task(new Name("by 8 days later"), Optional.empty(), Optional.of(startEndDateTime),
                new UniqueTagList());

        assertEqualsTaskIgnoreStartEndDateTimeSeconds(expectedTask, actualTask);
    }

    @Test
    public void parse_withDeadlineRelativeDateWithDateLookingName_expectCorrectTask()
            throws PastDateTimeException, IllegalValueException, CommandException {
        Model model = new ModelManagerMock();
        addSampleTaskWithDeadline(model);

        parseEditAndExecute(model, " 1 Pass rose from Uncle to Jane by 5 days after");

        Deadline deadline = new Deadline(ZonedDateTime.now().plusDays(5));
        Task expectedTask = new Task(new Name("Pass rose from Uncle to Jane"), Optional.of(deadline), Optional.empty(),
                new UniqueTagList());

        assertEqualsTaskIgnoreDeadlineSeconds(expectedTask, actualTask);
    }

    private void addSampleTaskWithDeadline(Model model) throws CommandException {
        Command command = new AddCommandParser().parse("stand by me by tmr");
        command.setData(model);
        command.execute();
    }

    private void addSampleTaskWithStartEndDateTime(Model model) throws CommandException {
        Command command = new AddCommandParser().parse("stand by me from 23 Apr to 28 Oct");
        command.setData(model);
        command.execute();
    }

    private void parseEditAndExecute(Model model, String args) throws CommandException {
        Command command = new EditCommandParser().parse(args);
        command.setData(model);
        command.execute();
    }

    private class ModelManagerMock extends ModelManager {
        @Override
        public void updateTask(int filteredTaskListIndex, ReadOnlyTask editedTask) {
            try {
                EditCommandParserTest.actualTask = new Task(editedTask);
            } catch (IllegalValueException e) {
                throw new AssertionError("Copying a valid task should always result in a valid task");
            }
            super.updateTask(filteredTaskListIndex, editedTask);
        }
    }
}
```
###### /java/onlythree/imanager/model/task/DeadlineTest.java
``` java
public class DeadlineTest {
    @Rule
    public ExpectedException exception = ExpectedException.none();

    /*
     * Invalid equivalence partitions for constructor: null, null and date-time in past allowed,
     *                                                 date-time in past and not allowed
     * Valid EP for constructor: date-time in past and allowed, current date-time, future date-time
     */
    @Test
    public void constructorPastDateTimeNotAllowed_null_expectsAssertionError() throws PastDateTimeException {
        exception.expect(AssertionError.class);
        new Deadline(null);
    }

    @Test
    public void constructorPastDateTimeAllowed_null_expectsAssertionError() throws PastDateTimeException {
        exception.expect(AssertionError.class);
        new Deadline(null, true);
    }

    /*
     * Boundary values for past date-time: 1 nanoseconds before
     *                                     Random past date-time
     *                                     Current date-time (not tested because time moves)
     *                                     1 minute after
     * (note that we cannot use one nanosecond later because it takes time for the deadline to construct)
     */
    @Test
    public void constructorPastDateTimeNotAllowed_dateTimeOneNanoBefore_expectsException()
            throws PastDateTimeException {
        expectPastDateTimeExceptionThrown();
        new Deadline(TestDateTimeHelper.getOneNanoBeforeCurrentDateTime());
    }

    @Test
    public void constructorPastDateTimeNotAllowed_somePastDateTime_expectsException()
            throws PastDateTimeException {
        expectPastDateTimeExceptionThrown();
        new Deadline(TestDateTimeHelper.getDaysBeforeCurrentDateTime(1));
    }

    @Test
    public void constructorPastDateTimeNotAllowed_dateTimeOneMinLater_success()
            throws PastDateTimeException {
        Deadline deadline = new Deadline(TestDateTimeHelper.getMinutesAfterCurrentDateTime(1));
        assertNotNull(deadline);
    }

    /*
     * Boundary values for past date-time and allowed : 1 nanoseconds before
     *                                                  Random past date-time
     *                                                  Current date-time (not tested because time moves)
     *                                                  1 minute after
     * (note that we cannot use one nanosecond later because it takes time for the deadline to construct)
     */
    @Test
    public void constructorPastDateTimeAllowed_dateTimeOneNanoBefore_success()
            throws PastDateTimeException {
        Deadline deadline = new Deadline(TestDateTimeHelper.getOneNanoBeforeCurrentDateTime(), true);
        assertNotNull(deadline);
    }

    @Test
    public void constructorPastDateTimeAllowed_somePastDateTime_success()
            throws PastDateTimeException {
        Deadline deadline = new Deadline(TestDateTimeHelper.getDaysBeforeCurrentDateTime(1), true);
        assertNotNull(deadline);
    }

    @Test
    public void constructorPastDateTimeAllowed_dateTimeOneNanoLater_success()
            throws PastDateTimeException {
        Deadline deadline = new Deadline(TestDateTimeHelper.getMinutesAfterCurrentDateTime(1), true);
        assertNotNull(deadline);
    }

    // some date-time in future and past date-time not allowed
    @Test
    public void constructorPastDateTimeNotAllowed_someFutureDateTime_success() throws PastDateTimeException {
        Deadline deadline = new Deadline(TestDateTimeHelper.getDaysAfterCurrentDateTime(3));
        assertNotNull(deadline);
    }

    // some date-time in future and past date-time allowed
    @Test
    public void constructorPastDateTimeAllowed_someFutureDateTime_success() throws PastDateTimeException {
        Deadline deadline = new Deadline(TestDateTimeHelper.getDaysAfterCurrentDateTime(3), true);
        assertNotNull(deadline);
    }

    private void expectPastDateTimeExceptionThrown() {
        exception.expect(PastDateTimeException.class);
        exception.expectMessage(Deadline.MESSAGE_DEADLINE_CONSTRAINTS);
    }

}
```
###### /java/onlythree/imanager/model/task/NameTest.java
``` java
    @Test
    public void isValidName_invalidName_falseReturned() {
        assertFalse(Name.isValidName("")); // empty string
        assertFalse(Name.isValidName(" ")); // space only (0x20)
        assertFalse(Name.isValidName("\t")); // tab only
        assertFalse(Name.isValidName("\n")); // new line only
        assertFalse(Name.isValidName("\u000B")); // Vertical tab only
        assertFalse(Name.isValidName("\f")); // form feed only
        assertFalse(Name.isValidName("\r")); // carriage return only
        assertFalse(Name.isValidName("//")); // only slashes
        assertFalse(Name.isValidName("fetch colleague/boss")); // contains forward slashes
    }

    @Test
    public void isValidName_validName_trueReturned() {
        assertTrue(Name.isValidName("assignment")); // alphabets only
        assertTrue(Name.isValidName("12345")); // numbers only
        assertTrue(Name.isValidName("2nd draft")); // alphanumeric characters
        assertTrue(Name.isValidName("Software Engineering Exam")); // with capital letters
        assertTrue(Name.isValidName("Super duper the long task")); // long names
        assertTrue(Name.isValidName("#$!$#!$!@#$!@!~@~!")); // tons of random symbols
        assertTrue(Name.isValidName("Whee~~~~")); // alphabets with symbols
        assertTrue(Name.isValidName("Omg!!")); // alphabets with symbols
        assertTrue(Name.isValidName("你好吗?")); // Valid UTF-16 string with symbols
    }
}
```
###### /java/onlythree/imanager/model/task/StartEndDateTimeTest.java
``` java
public class StartEndDateTimeTest {
    @Rule
    public ExpectedException exception = ExpectedException.none();

    /*
     * Past date times not allowed EP: [past start date-time]
     *                                 [past end date-time]
     *                                 [past start and end date-time]
     *                                 [future start and end date-time]
     */
    @Test
    public void constructorPastDateTimeNotAllowed_pastStartDateTime_expectsException()
            throws PastDateTimeException, InvalidDurationException {
        expectPastStartDateTimeExceptionThrown();
        ZonedDateTime startDateTime = TestDateTimeHelper.getOneNanoBeforeCurrentDateTime();
        ZonedDateTime endDateTime = TestDateTimeHelper.getDaysAfterCurrentDateTime(4);
        new StartEndDateTime(startDateTime, endDateTime);
    }

    @Test
    public void constructorPastDateTimeNotAllowed_pastEndDateTime_expectsException()
            throws PastDateTimeException, InvalidDurationException {
        expectPastEndDateTimeExceptionThrown();
        ZonedDateTime startDateTime = TestDateTimeHelper.getDaysAfterCurrentDateTime(2);
        ZonedDateTime endDateTime = TestDateTimeHelper.getOneNanoBeforeCurrentDateTime();
        new StartEndDateTime(startDateTime, endDateTime);
    }

    @Test
    public void constructorPastDateTimeNotAllowed_pastStartEndDateTime_expectsException()
            throws PastDateTimeException, InvalidDurationException {
        expectPastStartDateTimeExceptionThrown();
        ZonedDateTime startDateTime = TestDateTimeHelper.getOneNanoBeforeCurrentDateTime();
        ZonedDateTime endDateTime = TestDateTimeHelper.getOneNanoBeforeCurrentDateTime();
        new StartEndDateTime(startDateTime, endDateTime);
    }

    @Test
    public void constructorPastDateTimeNotAllowed_futureStartEndDateTime_success()
            throws PastDateTimeException, InvalidDurationException {
        ZonedDateTime startDateTime = TestDateTimeHelper.getMinutesAfterCurrentDateTime(3);
        ZonedDateTime endDateTime = TestDateTimeHelper.getDaysAfterCurrentDateTime(2);
        StartEndDateTime startEndDateTime = new StartEndDateTime(startDateTime, endDateTime);
        assertNotNull(startEndDateTime);
    }

    /*
     * Past date times allowed EP: [past start date-time]
     *                                 [past end date-time]
     *                                 [past start and end date-time]
     *                                 [future start and end date-time]
     */

    @Test
    public void constructorPastDateTimeAllowed_pastStartDateTime_success()
            throws PastDateTimeException, InvalidDurationException {
        ZonedDateTime startDateTime = TestDateTimeHelper.getOneNanoBeforeCurrentDateTime();
        ZonedDateTime endDateTime = TestDateTimeHelper.getDaysAfterCurrentDateTime(1);
        StartEndDateTime startEndDateTime = new StartEndDateTime(startDateTime, endDateTime, true);
        assertNotNull(startEndDateTime);
    }

    @Test
    public void constructorPastDateTimeAllowed_pastEndDateTime_exceptionThrown()
            throws PastDateTimeException, InvalidDurationException {
        expectInvalidDurationExceptionExceptionThrown();
        ZonedDateTime startDateTime = TestDateTimeHelper.getDaysAfterCurrentDateTime(3);
        ZonedDateTime endDateTime = TestDateTimeHelper.getOneNanoBeforeCurrentDateTime();
        new StartEndDateTime(startDateTime, endDateTime, true);
    }

    @Test
    public void constructorPastDateTimeAllowed_pastStartEndDateTime_success()
            throws PastDateTimeException, InvalidDurationException {
        ZonedDateTime startDateTime = TestDateTimeHelper.getDaysBeforeCurrentDateTime(6);
        ZonedDateTime endDateTime = TestDateTimeHelper.getDaysBeforeCurrentDateTime(3);
        StartEndDateTime startEndDateTime = new StartEndDateTime(startDateTime, endDateTime, true);
        assertNotNull(startEndDateTime);
    }

    @Test
    public void constructorPastDateTimeAllowed_futureStartEndDateTime_success()
            throws PastDateTimeException, InvalidDurationException {
        ZonedDateTime startDateTime = TestDateTimeHelper.getMinutesAfterCurrentDateTime(3);
        ZonedDateTime endDateTime = TestDateTimeHelper.getDaysAfterCurrentDateTime(7);
        StartEndDateTime startEndDateTime = new StartEndDateTime(startDateTime, endDateTime, true);
        assertNotNull(startEndDateTime);
    }

    /*
     * Past date times allowed and invalid duration EP: [past start date-time before end date-time]
     *                                                  [past start date-time equal end date-time]
     *                                                  [past start date-time after end date-time]
     *                                                  [past end date-time before start date-time]
     *                                                  [past end date-time equal start date-time]
     *                                                  [past end date-time after start date-time]
     */
    @Test
    public void constructorPastDateTimeAllowed_pastStartDateTimeBeforeEndDateTime_success()
            throws PastDateTimeException, InvalidDurationException {
        ZonedDateTime startDateTime = TestDateTimeHelper.getOneNanoBeforeCurrentDateTime();
        ZonedDateTime endDateTime = TestDateTimeHelper.getDaysAfterCurrentDateTime(2);
        StartEndDateTime startEndDateTime = new StartEndDateTime(startDateTime, endDateTime, true);
        assertNotNull(startEndDateTime);
    }

    // side effect, the end date-time is also in the past
    @Test
    public void constructorPastDateTimeAllowed_pastStartDateTimeEqualEndDateTime_expectsException()
            throws PastDateTimeException, InvalidDurationException {
        expectInvalidDurationExceptionExceptionThrown();
        ZonedDateTime startDateTime = TestDateTimeHelper.getOneNanoBeforeCurrentDateTime();
        ZonedDateTime endDateTime = startDateTime;
        new StartEndDateTime(startDateTime, endDateTime, true);
    }

    @Test
    public void constructorPastDateTimeAllowed_pastStartDateTimeAfterEndDateTime_expectsException()
            throws PastDateTimeException, InvalidDurationException {
        expectInvalidDurationExceptionExceptionThrown();
        ZonedDateTime startDateTime = TestDateTimeHelper.getDaysAfterCurrentDateTime(3);
        ZonedDateTime endDateTime = TestDateTimeHelper.getMinutesAfterCurrentDateTime(2);
        new StartEndDateTime(startDateTime, endDateTime, true);
    }

    @Test
    public void constructorPastDateTimeAllowed_pastEndDateTimeBeforeStartDateTime_expectsException()
            throws PastDateTimeException, InvalidDurationException {
        expectInvalidDurationExceptionExceptionThrown();
        ZonedDateTime startDateTime = TestDateTimeHelper.getDaysAfterCurrentDateTime(3);
        ZonedDateTime endDateTime = TestDateTimeHelper.getOneNanoBeforeCurrentDateTime();
        new StartEndDateTime(startDateTime, endDateTime, true);
    }

    // notice this is essentially equal to the below. Different date-time is used however
    // constructorPastDateTimeAllowed_pastStartDateTimeEqualEndDateTime_expectsException()
    @Test
    public void constructorPastDateTimeAllowed_pastEndDateTimeEqualStartDateTime_expectsException()
            throws PastDateTimeException, InvalidDurationException {
        expectInvalidDurationExceptionExceptionThrown();
        ZonedDateTime endDateTime = TestDateTimeHelper.getDaysBeforeCurrentDateTime(5);
        ZonedDateTime startDateTime = endDateTime;
        new StartEndDateTime(startDateTime, endDateTime, true);
    }

    @Test
    public void constructorPastDateTimeAllowed_pastEndDateTimeAfterStartDateTime_success()
            throws PastDateTimeException, InvalidDurationException {
        ZonedDateTime startDateTime = TestDateTimeHelper.getDaysBeforeCurrentDateTime(3);
        ZonedDateTime endDateTime = TestDateTimeHelper.getDaysBeforeCurrentDateTime(2);
        StartEndDateTime startEndDateTime = new StartEndDateTime(startDateTime, endDateTime, true);
        assertNotNull(startEndDateTime);
    }

    /*
     * Future date times with invalid duration EP: [future start date-time before end date-time]
     * and past date times not allowed             [future start date-time equal end date-time]
     *                                             [future start date-time after end date-time]
     *                                             [future end date-time before start date-time]
     *                                             [future end date-time equal start date-time]
     *                                             [future end date-time after start date-time]
     */
    @Test
    public void constructorPastDateTimeNotAllowed_futureStartDateTimeBeforeEndDateTime_success()
            throws PastDateTimeException, InvalidDurationException {
        ZonedDateTime startDateTime = TestDateTimeHelper.getDaysAfterCurrentDateTime(4);
        ZonedDateTime endDateTime = TestDateTimeHelper.getDaysAfterCurrentDateTime(6);
        StartEndDateTime startEndDateTime = new StartEndDateTime(startDateTime, endDateTime);
        assertNotNull(startEndDateTime);
    }

    @Test
    public void constructorPastDateTimeNotAllowed_futureStartDateTimeEqualEndDateTime_expectsException()
            throws PastDateTimeException, InvalidDurationException {
        expectInvalidDurationExceptionExceptionThrown();
        ZonedDateTime endDateTime = TestDateTimeHelper.getDaysAfterCurrentDateTime(7);
        ZonedDateTime startDateTime = endDateTime;
        new StartEndDateTime(startDateTime, endDateTime);
    }

    @Test
    public void constructorPastDateTimeNotAllowed_futureStartDateTimeAfterEndDateTime_expectsException()
            throws PastDateTimeException, InvalidDurationException {
        expectInvalidDurationExceptionExceptionThrown();
        ZonedDateTime endDateTime = TestDateTimeHelper.getMinutesAfterCurrentDateTime(2);
        ZonedDateTime startDateTime = endDateTime.plusSeconds(7);
        new StartEndDateTime(startDateTime, endDateTime);
    }

    // effectively equals to
    // constructorPastDateTimeNotAllowed_futureStartDateTimeAfterEndDateTime_expectsException()
    @Test
    public void constructorPastDateTimeNotAllowed_futureEndDateTimeBeforeStartDateTime_expectsException()
            throws PastDateTimeException, InvalidDurationException {
        expectInvalidDurationExceptionExceptionThrown();
        ZonedDateTime startDateTime = TestDateTimeHelper.getDaysAfterCurrentDateTime(9);
        ZonedDateTime endDateTime = startDateTime.minusHours(3);
        new StartEndDateTime(startDateTime, endDateTime);
    }

    // effectively equals to
    // constructorPastDateTimeNotAllowed_futureStartDateTimeEqualEndDateTime_expectsException()
    @Test
    public void constructorPastDateTimeNotAllowed_futureEndDateTimeEqualStartDateTime_expectsException()
            throws PastDateTimeException, InvalidDurationException {
        expectInvalidDurationExceptionExceptionThrown();
        ZonedDateTime startDateTime = TestDateTimeHelper.getMinutesAfterCurrentDateTime(3);
        ZonedDateTime endDateTime = startDateTime;
        new StartEndDateTime(startDateTime, endDateTime);
    }
    // effectively equals to
    // constructorPastDateTimeNotAllowed_futureStartDateTimeBeforeEndDateTime_success()
    @Test
    public void constructorPastDateTimeNotAllowed_futureEndDateTimeAfterStartDateTime_success()
            throws PastDateTimeException, InvalidDurationException {
        ZonedDateTime startDateTime = TestDateTimeHelper.getDaysAfterCurrentDateTime(9);
        ZonedDateTime endDateTime = startDateTime.plusSeconds(3);
        StartEndDateTime startEndDateTime = new StartEndDateTime(startDateTime, endDateTime);
        assertNotNull(startEndDateTime);
    }

    /*
     * Future date times with invalid duration EP and past date-times allowed not tested
     * Future date times with valid duration EP and past date-times allowed not tested
     */

    private void expectPastStartDateTimeExceptionThrown() {
        exception.expect(PastDateTimeException.class);
        exception.expectMessage(StartEndDateTime.MESSAGE_PAST_START_DATETIME_CONSTRAINTS);
    }

    private void expectPastEndDateTimeExceptionThrown() {
        exception.expect(PastDateTimeException.class);
        exception.expectMessage(StartEndDateTime.MESSAGE_PAST_END_DATETIME_CONSTRAINTS);
    }

    private void expectInvalidDurationExceptionExceptionThrown() {
        exception.expect(InvalidDurationException.class);
        exception.expectMessage(StartEndDateTime.MESSAGE_INVALID_DURATION_CONSTRAINTS);
    }

}
```
###### /java/onlythree/imanager/model/task/TaskTest.java
``` java
public class TaskTest {
    @Rule
    public ExpectedException exception = ExpectedException.none();

    @Test
    public void constructor_withRequiredFields_success() throws IllegalValueException {
        assertNotNull(new Task(new Name("Random"), Optional.empty(), Optional.empty(), new UniqueTagList()));

        assertNotNull(
                new Task(new Name("&#421"), Optional.empty(), Optional.empty(), new UniqueTagList("tag1")));

        assertNotNull(new Task(new Name("1234"), Optional.empty(), Optional.empty(),
                new UniqueTagList("tag1", "tag2")));
    }

    @Test
    public void constructor_withDeadline_success() throws PastDateTimeException, IllegalValueException {
        assertNotNull(new Task(new Name("Test"), Optional.of(new Deadline(ZonedDateTime.now().plusDays(6))),
                        Optional.empty(), new UniqueTagList()));

        assertNotNull(new Task(new Name("Test"), Optional.of(new Deadline(ZonedDateTime.now().plusSeconds(25))),
                        Optional.empty(), new UniqueTagList()));
    }

    @Test
    public void constructor_withStartEndDateTime_success()
            throws PastDateTimeException, InvalidDurationException, IllegalValueException {

        assertNotNull(new Task(new Name("why what lol"), Optional.empty(), Optional.of(
                new StartEndDateTime(ZonedDateTime.now().plusMinutes(5), ZonedDateTime.now().plusHours(2))),
                new UniqueTagList()));

        assertNotNull(new Task(new Name("idkkk"), Optional.empty(), Optional.of(
                new StartEndDateTime(ZonedDateTime.now().plusDays(7), ZonedDateTime.now().plusYears(2))),
                new UniqueTagList()));
    }

    @Test
    public void constructor_withDeadlineAndStartEndDateTime_expectsException()
            throws PastDateTimeException, InvalidDurationException, IllegalValueException {

        exception.expect(IllegalValueException.class);
        exception.expectMessage(Task.MESSAGE_TASK_CONSTRAINTS);

        final Deadline deadline = new Deadline(ZonedDateTime.now().plusMinutes(7));
        final StartEndDateTime startEndDateTime = new StartEndDateTime(ZonedDateTime.now().plusDays(7),
                ZonedDateTime.now().plusYears(2));
        assertNotNull(new Task(new Name("Rumble roll!"), Optional.of(deadline), Optional.of(startEndDateTime),
                new UniqueTagList()));
    }
}
```
###### /java/onlythree/imanager/testutil/TaskBuilder.java
``` java
/**
 * A Task Builder class that allow us to construct a Task by chaining calls for convenience in testing.
 */
```
###### /java/onlythree/imanager/testutil/TaskBuilder.java
``` java
    public TaskBuilder withDeadline(Deadline deadline) {
        task.setDeadline(deadline);
        return this;
    }

    public TaskBuilder withStartEndDateTime(StartEndDateTime startEndDateTime) {
        task.setStartEndDateTime(startEndDateTime);
        return this;
    }

```
###### /java/onlythree/imanager/testutil/TaskBuilder.java
``` java
    public TaskBuilder withComplete(boolean isComplete) {
        task.setComplete(isComplete);
        return this;
    }

```
###### /java/onlythree/imanager/testutil/TestDateTimeHelper.java
``` java
/**
 * A utility class for testing and manipulating date-times
 *
 */
public class TestDateTimeHelper {
    public static ZonedDateTime getOneNanoBeforeCurrentDateTime() {
        return ZonedDateTime.now().minusNanos(1);
    }

    public static ZonedDateTime getMinutesAfterCurrentDateTime(int minutes) {
        return ZonedDateTime.now().plusMinutes(minutes);
    }

    public static ZonedDateTime getDaysBeforeCurrentDateTime(int days) {
        return ZonedDateTime.now().minusDays(days);
    }

    public static ZonedDateTime getDaysAfterCurrentDateTime(int days) {
        return ZonedDateTime.now().plusDays(days);
    }

    public static void assertEqualsIgnoresSecondsAndBelow(ZonedDateTime expected, ZonedDateTime actual) {
        assertEqualsIgnoresUnitBelow(expected, actual, ChronoUnit.MINUTES);
    }

    public static void assertEqualsTaskIgnoreDeadlineSeconds(Task expectedTask, Task actualTask) {
        assertEquals(expectedTask.getName(), actualTask.getName());
        assertEqualsIgnoresSecondsAndBelow(expectedTask.getDeadline().get().getDateTime(),
                actualTask.getDeadline().get().getDateTime());
        assertEquals(expectedTask.getStartEndDateTime(), actualTask.getStartEndDateTime());
        assertEquals(expectedTask.getTags(), actualTask.getTags());
        assertEquals(expectedTask.isComplete(), actualTask.isComplete());
    }

    public static void assertEqualsTaskIgnoreStartEndDateTimeSeconds(Task expectedTask, Task actualTask) {
        assertEquals(expectedTask.getName(), actualTask.getName());
        assertEquals(expectedTask.getDeadline(), actualTask.getDeadline());
        assertEqualsIgnoresSecondsAndBelow(expectedTask.getStartEndDateTime().get().getStartDateTime(),
                actualTask.getStartEndDateTime().get().getStartDateTime());
        assertEqualsIgnoresSecondsAndBelow(expectedTask.getStartEndDateTime().get().getEndDateTime(),
                actualTask.getStartEndDateTime().get().getEndDateTime());
        assertEquals(expectedTask.getTags(), actualTask.getTags());
        assertEquals(expectedTask.isComplete(), actualTask.isComplete());
    }

    /**
     * Asserts that two zoned date-times are equal ignoring the unit below the truncationUnit.
     */
    public static void assertEqualsIgnoresUnitBelow(ZonedDateTime expected, ZonedDateTime actual,
            ChronoUnit truncationUnit) {
        ZonedDateTime expectedTruncated = expected.truncatedTo(truncationUnit);
        ZonedDateTime actualTruncated = actual.truncatedTo(truncationUnit);
        assertIsEqual(expectedTruncated, actualTruncated);
    }

    /**
     * Asserts that two zoned date-times are not equal ignoring the unit below the truncationUnit.
     */
    public static void assertNotEqualsIgnoresUnitBelow(ZonedDateTime expected, ZonedDateTime actual,
            ChronoUnit truncationUnit) {
        ZonedDateTime expectedTruncated = expected.truncatedTo(truncationUnit);
        ZonedDateTime actualTruncated = actual.truncatedTo(truncationUnit);
        assertIsNotEqual(expectedTruncated, actualTruncated);
    }

    /**
     * Assert that the instant of the ZonedDateTimes are equal instead of comparing component by component.
     * @see ChronoZonedDateTime#isEqual(ChronoZonedDateTime)
     */
    public static void assertIsEqual(ZonedDateTime expected, ZonedDateTime actual) {
        assertEquals(expected.toInstant(), actual.toInstant());
    }

    /**
     * Assert that the instant of the ZonedDateTimes are not equal instead of comparing component by component.
     * @see ChronoZonedDateTime#isEqual(ChronoZonedDateTime)
     */
    public static  void assertIsNotEqual(ZonedDateTime expected, ZonedDateTime actual) {
        assertNotEquals(expected.toInstant(), actual.toInstant());
    }

}
```
###### /java/onlythree/imanager/testutil/TestTask.java
``` java
    public TestTask() {
        // Initialize TestTask with empty deadlines, startEndDateTime and tags because they are optional.
        // this will allow us to conveniently create TestTasks through TaskBuilder without being forced
        // to specify the optional fields
        deadline = Optional.empty();
        startEndDateTime = Optional.empty();
        tags = new UniqueTagList();
        complete = false;
    }

    /**
     * Creates a copy of {@code taskToCopy} by shallow copying only the data.
     * Shallow copying reduces the overhead of copying the data.
     */
    public TestTask(TestTask taskToCopy) {
        name = taskToCopy.getName();
        deadline = taskToCopy.getDeadline();
        startEndDateTime = taskToCopy.getStartEndDateTime();
        tags = taskToCopy.getTags();
        complete = taskToCopy.isComplete();
    }

```
###### /java/onlythree/imanager/testutil/TestTask.java
``` java
    @Override
    public Optional<Deadline> getDeadline() {
        return deadline;
    }

    @Override
    public Optional<StartEndDateTime> getStartEndDateTime() {
        return startEndDateTime;
    }

```
###### /java/onlythree/imanager/testutil/TestTask.java
``` java
    public void setDeadline(Deadline dateTime) {
        this.deadline = Optional.of(dateTime);
    }

    public void setStartEndDateTime(StartEndDateTime startEndDateTime) {
        this.startEndDateTime = Optional.of(startEndDateTime);
    }

```
###### /java/onlythree/imanager/testutil/TestTask.java
``` java
    public String getAddCommand() {
        StringBuilder sb = new StringBuilder();
        sb.append("add " + getName().value + " ");

        if (getDeadline().isPresent()) {
            sb.append(" by ");
            sb.append(getDeadline().get().getDateTime().format(DateTimeFormats.TEST_FORMAT));
        }

        if (getStartEndDateTime().isPresent()) {
            StartEndDateTime startEndDateTime = getStartEndDateTime().get();
            sb.append(" from ");
            sb.append(startEndDateTime.getStartDateTime().format(DateTimeFormats.TEST_FORMAT));
            sb.append(" to ");
            sb.append(startEndDateTime.getEndDateTime().format(DateTimeFormats.TEST_FORMAT));
        }

        getTags().asObservableList().stream().forEach(s -> sb.append("t/" + s.tagName + " "));
        return sb.toString();
    }
}
```
###### /java/onlythree/imanager/testutil/TestUtil.java
``` java
    private static Task[] getSampleTaskData() {
        try {
            // TODO maybe they should not be empty optionals
            return new Task[]{
                new Task(new Name("Allocate Work"), Optional.empty(), Optional.empty(), new UniqueTagList()),
                new Task(new Name("Buy Groceries"), Optional.empty(), Optional.empty(), new UniqueTagList()),
                new Task(new Name("Count doomsday"), Optional.empty(), Optional.empty(), new UniqueTagList()),
                new Task(new Name("Die tomorrow"), Optional.empty(), Optional.empty(), new UniqueTagList()),
                new Task(new Name("Elicit crap"), Optional.empty(), Optional.empty(), new UniqueTagList()),
                new Task(new Name("Fool around"), Optional.empty(), Optional.empty(), new UniqueTagList()),
                new Task(new Name("Goof around"), Optional.empty(), Optional.empty(), new UniqueTagList()),
                new Task(new Name("Help someone"), Optional.empty(), Optional.empty(), new UniqueTagList()),
                new Task(new Name("Improve tasks"), Optional.empty(), Optional.empty(), new UniqueTagList())
            };
            //CHECKSTYLE.ON: LineLength
        } catch (IllegalValueException e) {
            throw new AssertionError("The sample tasks should meet all the constraints");
        }
    }


    private static Tag[] getSampleTagData() {
        try {
            return new Tag[]{
                new Tag("meeting"),
                new Tag("project")
            };
        } catch (IllegalValueException e) {
            throw new AssertionError("The sample tag should meet the constraints");
        }
    }

```
###### /java/onlythree/imanager/testutil/TypicalTestTasks.java
``` java
    // TODO naming of tasks as names does not seem to be a good idea, and not descriptive enough
    // for example helpMe and iAmCode are to be manually added in test cases but it is not clear
    // conversely the name shows what the task contains, so it can be helpful
    public TestTask amuseFriend, bet, count, dog, elephant, flipTable, goondu, helpMe, iAmCode;

    public TypicalTestTasks() {
        // Starting Test Date Time is set to one day after today so that dates in the past is not
        // generated to prevent a PastDateTimeException from occuring. Furthermore the precision
        // is truncated to seconds as Natty does not parse milliseconds
        ZonedDateTime startTestDateTime = ZonedDateTime.now().truncatedTo(ChronoUnit.SECONDS).plusDays(1);
        try {
            // floating task with a tag
            amuseFriend = new TaskBuilder().withName("Amuse friend").withTags("friends").build();
            // Notice how flipping the order of tags and test cases can fail, see TestUtil::compareCardAndTask
            // using list compare instead of set compare
            // floating task with two tags
            bet = new TaskBuilder().withName("Bet dog race").withTags("luck", "money").build();
            // floating task with no tags
            count = new TaskBuilder().withName("Count chickens before they hatch").build();
            // task with deadlines
            dog = new TaskBuilder().withName("Dog naming")
                    .withDeadline(new Deadline(startTestDateTime.plusDays(3))).build();
            // task with start and end dates
            elephant = new TaskBuilder().withName("Elephant riding")
                    .withStartEndDateTime(new StartEndDateTime(startTestDateTime.plusHours(2),
                                                               startTestDateTime.plusHours(3)))
                    .build();
            // some other random floating tasks
            flipTable = new TaskBuilder().withName("Flip table").build();
            goondu = new TaskBuilder().withName("Goondu goon").build();

            // Manually added
            // TODO maybe to use non-floating tasks here
            helpMe = new TaskBuilder().withName("Help me").build();
            iAmCode = new TaskBuilder().withName("I am code").build();
        } catch (PastDateTimeException e) {
            throw new AssertionError("The typical test tasks should not be built with date-times in the past");
        } catch (InvalidDurationException e) {
            throw new AssertionError("The typical test tasks should not be built with an invalid duration period");
        } catch (IllegalValueException e) {
            throw new AssertionError("The typical test tasks should already meet all the constraints required");
        }
    }

    public static void loadTaskListWithSampleData(TaskList taskList) {
        for (TestTask task : new TypicalTestTasks().getTypicalTasks()) {
            try {
                taskList.addTask(new Task(task));
            } catch (IllegalValueException e) {
                throw new AssertionError("Copying a valid task should always result in a valid task.");
            }
        }
    }

    public TestTask[] getTypicalTasks() {
        return new TestTask[]{amuseFriend, bet, count, dog, elephant, flipTable, goondu};
    }

```
