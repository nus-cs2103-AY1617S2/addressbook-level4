# A0142418L
###### \java\guitests\AddCommandTest.java
``` java
    private void assertAddSuccess(TestTask taskToAdd, TestTask... currentList) {
        commandBox.runCommand(taskToAdd.getAddCommand());

        // confirm the new card contains the right data
        if (taskToAdd.isEventTask()) {
            EventTaskCardHandle addedCard = eventTaskListPanel.navigateToEventTask(taskToAdd.getTaskName().toString());
            assertMatching(taskToAdd, addedCard);
        } else {
            if (taskToAdd.isDeadlineTask()) {
                DeadlineTaskCardHandle addedCard = deadlineTaskListPanel
                        .navigateToDeadlineTask(taskToAdd.getTaskName().toString());
                assertMatching(taskToAdd, addedCard);
            } else {
                if (taskToAdd.isFloatingTask()) {
                    FloatingTaskCardHandle addedCard = floatingTaskListPanel
                            .navigateToFloatingTask(taskToAdd.getTaskName().toString());
                    assertMatching(taskToAdd, addedCard);
                }
            }
        }

        // confirm the list now contains all previous tasks plus the new
        // task
        TestTask[] expectedList = TestUtil.addTasksToList(currentList, taskToAdd).getKey();
        assertTrue(eventTaskListPanel.isListMatching(expectedList));
        assertTrue(deadlineTaskListPanel.isListMatching(expectedList));
        assertTrue(floatingTaskListPanel.isListMatching(expectedList));
    }

```
###### \java\guitests\ChangeSaveLocationCommandTest.java
``` java
    @Test
    public void changeSaveLocationInvalidCommand() {
        commandBox.runCommand("SAVEdata");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    @Test
    public void changeSaveLocationInvalidSaveLocation() {
        commandBox.runCommand("SAVE hello");
        assertResultMessage(INVALID_SAVE_LOCATION + "\n" + ChangeSaveLocationCommand.MESSAGE_USAGE);
    }

    @Test
    public void changeSaveLocationInvalidCommandFormat() {
        commandBox.runCommand("SAVE");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ChangeSaveLocationCommand.MESSAGE_USAGE));
    }

}
```
###### \java\guitests\DeleteCommandTest.java
``` java
    /**
     * Runs the delete command to delete the task at specified index and
     * confirms the result is correct.
     *
     * @param targetIndexOneIndexed
     *            e.g. index 1 to delete the first task in the list,
     * @param currentList
     *            A copy of the current list of tasks (before deletion).
     */
    private void assertDeleteSuccess(int targetIndexOneIndexed, final TestTask[] currentList) {
        TestTask taskToDelete = currentList[targetIndexOneIndexed - 1]; // -1 as
                                                                        // array
                                                                        // uses
                                                                        // zero
                                                                        // indexing
        TestTask[] expectedRemainder = TestUtil.removeTaskFromList(currentList, targetIndexOneIndexed);

        commandBox.runCommand("DELETE " + targetIndexOneIndexed);

        // confirm the list now contains all previous tasks except the deleted
        // task
        assertTrue(eventTaskListPanel.isListMatching(expectedRemainder));
        assertTrue(deadlineTaskListPanel.isListMatching(expectedRemainder));
        assertTrue(floatingTaskListPanel.isListMatching(expectedRemainder));

        // confirm the result message is correct
        assertResultMessage(String.format(MESSAGE_DELETE_TASK_SUCCESS, taskToDelete));
    }

}
```
###### \java\guitests\guihandles\DeadlineTaskCardHandle.java
``` java
/**
 * Provides a handle to a task card in the task list panel.
 */
public class DeadlineTaskCardHandle extends GuiHandle {
    private static final String TASKNAME_FIELD_ID = "#taskname";
    private static final String DUEDATETIME_FIELD_ID = "#dueDateTime";
    private static final String COMPLETED_FIELD_ID = "#completed";
    private static final String CATEGORIES_FIELD_ID = "#categories";

    private Node node;

    public DeadlineTaskCardHandle(GuiRobot guiRobot, Stage primaryStage, Node node) {
        super(guiRobot, primaryStage, null);
        this.node = node;
    }

    protected String getTextFromLabel(String fieldId) {
        return getTextFromLabel(fieldId, node);
    }

    public String getTaskName() {
        return getTextFromLabel(TASKNAME_FIELD_ID);
    }

    public String getEndDate() {
        String startDate = getTextFromLabel(DUEDATETIME_FIELD_ID);
        startDate = startDate.substring(10, startDate.length() - 5);
        return startDate;
    }

    public String getEndTime() {
        String endTime = getTextFromLabel(DUEDATETIME_FIELD_ID);
        endTime = endTime.substring(endTime.length() - 4);
        return endTime;
    }

    public String getIsMarkedAsCompleted() {
        return getTextFromLabel(COMPLETED_FIELD_ID);
    }

    public List<String> getCategories() {
        return getCategories(getCategoriesContainer());
    }

    private List<String> getCategories(Region categoriesContainer) {
        return categoriesContainer.getChildrenUnmodifiable().stream().map(node -> ((Labeled) node).getText())
                .collect(Collectors.toList());
    }

    private List<String> getCategories(UniqueCategoryList categories) {
        return categories.asObservableList().stream().map(category -> category.categoryName)
                .collect(Collectors.toList());
    }

    private Region getCategoriesContainer() {
        return guiRobot.from(node).lookup(CATEGORIES_FIELD_ID).query();
    }

    public boolean isSameTask(ReadOnlyTask task) {
        return task != null || this == task && getTaskName().equals(task.getTaskName())
                && getEndDate().equals(task.getEndDate()) && getEndTime().equals(task.getEndTime())
                && getIsMarkedAsCompleted().equals(task.getIsMarkedAsComplete())
                && getCategories().equals(getCategories(task.getCategories()));
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof DeadlineTaskCardHandle) {
            DeadlineTaskCardHandle handle = (DeadlineTaskCardHandle) obj;
            return getTaskName().equals(handle.getTaskName()) && getEndDate().equals(handle.getEndDate())
                    && getEndTime().equals(handle.getEndTime())
                    && getIsMarkedAsCompleted().equals(handle.getIsMarkedAsCompleted())
                    && getCategories().equals(handle.getCategories());
        }
        return super.equals(obj);
    }

    @Override
    public String toString() {
        return getTaskName() + " " + getEndDate() + " " + getEndTime();
    }
}
```
###### \java\guitests\guihandles\DeadlineTaskListPanelHandle.java
``` java
/**
 * Provides a handle for the panel containing the task list.
 */
public class DeadlineTaskListPanelHandle extends GuiHandle {

    public static final int NOT_FOUND = -1;
    public static final String CARD_PANE_ID = "#cardPane";

    private static final String DEADLINE_TASK_LIST_VIEW_ID = "#deadlineTaskListView";

    public DeadlineTaskListPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    public List<Pair<ReadOnlyTask, Integer>> getSelectedTasks() {
        ListView<Pair<ReadOnlyTask, Integer>> taskList = getDeadlineListView();
        return taskList.getSelectionModel().getSelectedItems();
    }

    public ListView<Pair<ReadOnlyTask, Integer>> getDeadlineListView() {
        ListView<Pair<ReadOnlyTask, Integer>> deadlineListView = getNode(DEADLINE_TASK_LIST_VIEW_ID);
        return deadlineListView;
    }

    /**
     * Returns true if the list is showing the task details correctly and in
     * correct order.
     *
     * @param tasks
     *            A list of tasks in the correct order.
     */
    public boolean isListMatching(ReadOnlyTask... tasks) {
        return this.isListMatching(0, tasks);
    }

    /**
     * Returns true if the list is showing the task details correctly and in
     * correct order.
     *
     * @param startPosition
     *            The starting position of the sub list.
     * @param persons
     *            A list of task in the correct order.
     */
    public boolean isListMatching(int startPosition, ReadOnlyTask... tasks) throws IllegalArgumentException {
        List<ReadOnlyTask> deadlineTasks = new ArrayList<>(Arrays.asList(tasks));
        for (int index = 0; index < deadlineTasks.size(); index++) {
            if (!deadlineTasks.get(index).isDeadlineTask()) {
                deadlineTasks.remove(index);
                index--;
            }
        }
        if (deadlineTasks.size() + startPosition != getDeadlineListView().getItems().size()) {
            throw new IllegalArgumentException(
                    "List size mismatched\n" + "Expected " + (getDeadlineListView().getItems().size() - 1) + " tasks");
        }
        ReadOnlyTask[] taskArray = deadlineTasks.toArray(new ReadOnlyTask[deadlineTasks.size()]);
        assertTrue(this.containsInOrder(startPosition, taskArray));
        for (int i = 0; i < deadlineTasks.size(); i++) {
            final int scrollTo = i + startPosition;
            guiRobot.interact(() -> getDeadlineListView().scrollTo(scrollTo));
            guiRobot.sleep(200);
            if (!TestUtil.compareCardAndTask(getDeadlineTaskCardHandle(startPosition + i), deadlineTasks.get(i))) {
                return false;
            }
        }
        return true;
    }

    /**
     * Clicks on the ListView.
     */
    public void clickOnListView() {
        Point2D point = TestUtil.getScreenMidPoint(getDeadlineListView());
        guiRobot.clickOn(point.getX(), point.getY());
    }

    /**
     * Returns true if the {@code tasks} appear as the sub list (in that order)
     * at position {@code startPosition}.
     */
    public boolean containsInOrder(int startPosition, ReadOnlyTask... tasks) {
        List<Pair<ReadOnlyTask, Integer>> tasksInList = getDeadlineListView().getItems();

        // Return false if the list in panel is too short to contain the given
        // list
        if (startPosition + tasks.length > tasksInList.size()) {
            return false;
        }

        // Return false if any of the persons doesn't match
        for (int i = 0; i < tasks.length; i++) {
            if (!tasksInList.get(startPosition + i).getKey().getTaskName().fullTaskName
                    .equals(tasks[i].getTaskName().fullTaskName)) {
                return false;
            }
        }

        return true;
    }

    public DeadlineTaskCardHandle navigateToDeadlineTask(String taskname) {
        guiRobot.sleep(500); // Allow a bit of time for the list to be updated
        final Optional<Pair<ReadOnlyTask, Integer>> task = getDeadlineListView().getItems().stream()
                .filter(p -> p.getKey().getTaskName().toString().equals(taskname)).findAny();
        if (!task.isPresent()) {
            throw new IllegalStateException("Task name not found: " + taskname);
        }

        return navigateToDeadlineTask(task.get().getKey());
    }

    /**
     * Navigates the listview to display and select the task.
     */
    public DeadlineTaskCardHandle navigateToDeadlineTask(ReadOnlyTask task) {
        int index = getDeadlineTaskIndex(task);

        guiRobot.interact(() -> {
            getDeadlineListView().scrollTo(index);
            guiRobot.sleep(150);
            getDeadlineListView().getSelectionModel().select(index);
        });
        guiRobot.sleep(100);
        return getDeadlineTaskCardHandle(task);
    }

    /**
     * Returns the position of the person given, {@code NOT_FOUND} if not found
     * in the list.
     */
    public int getDeadlineTaskIndex(ReadOnlyTask targetTask) {
        List<Pair<ReadOnlyTask, Integer>> tasksInList = getDeadlineListView().getItems();
        for (int i = 0; i < tasksInList.size(); i++) {
            if (tasksInList.get(i).getKey().getTaskName().equals(targetTask.getTaskName())) {
                return i;
            }
        }
        return NOT_FOUND;
    }

    /**
     * Gets a person from the list by index
     */
    public ReadOnlyTask getDeadlineTask(int index) {
        return getDeadlineListView().getItems().get(index).getKey();
    }

    public DeadlineTaskCardHandle getDeadlineTaskCardHandle(int index) {
        return getDeadlineTaskCardHandle(new Task(getDeadlineListView().getItems().get(index).getKey()));
    }

    public DeadlineTaskCardHandle getDeadlineTaskCardHandle(ReadOnlyTask task) {
        Set<Node> nodes = getAllCardNodes();
        Optional<Node> taskCardNode = nodes.stream()
                .filter(n -> new DeadlineTaskCardHandle(guiRobot, primaryStage, n).isSameTask(task)).findFirst();
        if (taskCardNode.isPresent()) {
            return new DeadlineTaskCardHandle(guiRobot, primaryStage, taskCardNode.get());
        } else {
            return null;
        }
    }

    protected Set<Node> getAllCardNodes() {
        return guiRobot.lookup(CARD_PANE_ID).queryAll();
    }

    public int getNumberOfTask() {
        return getDeadlineListView().getItems().size();
    }
}
```
###### \java\guitests\guihandles\EventTaskCardHandle.java
``` java
/**
 * Provides a handle to a task card in the task list panel.
 */
public class EventTaskCardHandle extends GuiHandle {
    private static final String TASKNAME_FIELD_ID = "#taskname";
    private static final String STARTDATETIME_FIELD_ID = "#startDateTime";
    private static final String ENDDATETIME_FIELD_ID = "#endDateTime";
    private static final String COMPLETED_FIELD_ID = "#markedCompleted";
    private static final String CATEGORIES_FIELD_ID = "#categories";

    private Node node;

    public EventTaskCardHandle(GuiRobot guiRobot, Stage primaryStage, Node node) {
        super(guiRobot, primaryStage, null);
        this.node = node;
    }

    protected String getTextFromLabel(String fieldId) {
        return getTextFromLabel(fieldId, node);
    }

    public String getTaskName() {
        return getTextFromLabel(TASKNAME_FIELD_ID);
    }

    public String getStartDate() {
        String startDate = getTextFromLabel(STARTDATETIME_FIELD_ID);
        startDate = startDate.substring(12 , startDate.length() - 19);
        return startDate;
    }

    public String getStartTime() {
        String startTime = getTextFromLabel(STARTDATETIME_FIELD_ID);
        startTime = startTime.substring(startTime.length() - 4);
        return startTime;
    }

    public String getEndDate() {
        String endDate = getTextFromLabel(ENDDATETIME_FIELD_ID);
        endDate = endDate.substring(12 , endDate.length() - 19);
        return endDate;
    }

    public String getEndTime() {
        String endTime = getTextFromLabel(ENDDATETIME_FIELD_ID);
        endTime = endTime.substring(endTime.length() - 4);
        return endTime;
    }

    public String getIsMarkedAsCompleted() {
        return getTextFromLabel(COMPLETED_FIELD_ID);
    }

    public List<String> getCategories() {
        return getCategories(getCategoriesContainer());
    }

    private List<String> getCategories(Region categoriesContainer) {
        return categoriesContainer.getChildrenUnmodifiable().stream().map(node -> ((Labeled) node).getText())
                .collect(Collectors.toList());
    }

    private List<String> getCategories(UniqueCategoryList categories) {
        return categories.asObservableList().stream().map(category -> category.categoryName)
                .collect(Collectors.toList());
    }

    private Region getCategoriesContainer() {
        return guiRobot.from(node).lookup(CATEGORIES_FIELD_ID).query();
    }

    public boolean isSameTask(ReadOnlyTask task) {
        return task != null || this == task && getTaskName().equals(task.getTaskName())
                && getStartDate().equals(task.getStartDate()) && getStartTime().equals(task.getStartTime())
                && getEndDate().equals(task.getEndDate()) && getEndTime().equals(task.getEndTime())
                && getIsMarkedAsCompleted().equals(task.getIsMarkedAsComplete())
                && getCategories().equals(getCategories(task.getCategories()));
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof EventTaskCardHandle) {
            EventTaskCardHandle handle = (EventTaskCardHandle) obj;
            return getTaskName().equals(handle.getTaskName()) && getStartDate().equals(handle.getStartDate())
                    && getStartTime().equals(handle.getStartTime()) && getEndDate().equals(handle.getEndDate())
                    && getEndTime().equals(handle.getEndTime())
                    && getIsMarkedAsCompleted().equals(handle.getIsMarkedAsCompleted())
                    && getCategories().equals(handle.getCategories());
        }
        return super.equals(obj);
    }

    @Override
    public String toString() {
        return getTaskName() + " " + getStartDate() + " " + getStartTime() + " " + getEndDate() + " " + getEndTime();
    }
}
```
###### \java\guitests\guihandles\EventTaskListPanelHandle.java
``` java
/**
 * Provides a handle for the panel containing the task list.
 */
public class EventTaskListPanelHandle extends GuiHandle {

    public static final int NOT_FOUND = -1;
    public static final String CARD_PANE_ID = "#cardPane";

    private static final String EVENT_TASK_LIST_VIEW_ID = "#eventTaskListView";

    public EventTaskListPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    public List<ReadOnlyTask> getSelectedTasks() {
        ListView<ReadOnlyTask> eventTaskList = getEventListView();
        return eventTaskList.getSelectionModel().getSelectedItems();
    }

    public ListView<ReadOnlyTask> getEventListView() {
        ListView<ReadOnlyTask> eventTaskListView = getNode(EVENT_TASK_LIST_VIEW_ID);
        return eventTaskListView;
    }

    /**
     * Returns true if the list is showing the task details correctly and in
     * correct order.
     *
     * @param tasks
     *            A list of tasks in the correct order.
     */
    public boolean isListMatching(ReadOnlyTask... tasks) {
        return this.isListMatching(0, tasks);
    }

    /**
     * Returns true if the list is showing the task details correctly and in
     * correct order.
     *
     * @param startPosition
     *            The starting position of the sub list.
     * @param persons
     *            A list of task in the correct order.
     */
    public boolean isListMatching(int startPosition, ReadOnlyTask... tasks) throws IllegalArgumentException {
        List<ReadOnlyTask> eventTasks = new ArrayList<>(Arrays.asList(tasks));
        for (int index = 0; index < eventTasks.size(); index++) {
            if (!eventTasks.get(index).isEventTask()) {
                eventTasks.remove(index);
                index--;
            }
        }
        if (eventTasks.size() + startPosition != getEventListView().getItems().size()) {
            throw new IllegalArgumentException(
                    "List size mismatched\n" + "Expected " + (getEventListView().getItems().size() - 1) + " tasks");
        }
        ReadOnlyTask[] taskArray = eventTasks.toArray(new ReadOnlyTask[eventTasks.size()]);
        assertTrue(this.containsInOrder(startPosition, taskArray));
        for (int i = 0; i < eventTasks.size(); i++) {
            final int scrollTo = i + startPosition;
            guiRobot.interact(() -> getEventListView().scrollTo(scrollTo));
            guiRobot.sleep(200);
            if (!TestUtil.compareCardAndTask(getEventTaskCardHandle(startPosition + i), eventTasks.get(i))) {
                return false;
            }
        }
        return true;
    }

    /**
     * Clicks on the ListView.
     */
    public void clickOnListView() {
        Point2D point = TestUtil.getScreenMidPoint(getEventListView());
        guiRobot.clickOn(point.getX(), point.getY());
    }

    /**
     * Returns true if the {@code tasks} appear as the sub list (in that order)
     * at position {@code startPosition}.
     */
    public boolean containsInOrder(int startPosition, ReadOnlyTask... tasks) {
        List<ReadOnlyTask> tasksInList = getEventListView().getItems();

        // Return false if the list in panel is too short to contain the given
        // list
        if (startPosition + tasks.length > tasksInList.size()) {
            return false;
        }

        // Return false if any of the persons doesn't match
        for (int i = 0; i < tasks.length; i++) {
            if (!tasksInList.get(startPosition + i).getTaskName().fullTaskName
                    .equals(tasks[i].getTaskName().fullTaskName)) {
                return false;
            }
        }

        return true;
    }

    public EventTaskCardHandle navigateToEventTask(String taskname) {
        guiRobot.sleep(500); // Allow a bit of time for the list to be updated
        final Optional<ReadOnlyTask> task = getEventListView().getItems().stream()
                .filter(p -> p.getTaskName().toString().equals(taskname)).findAny();
        if (!task.isPresent()) {
            throw new IllegalStateException("Task name not found: " + taskname);
        }

        return navigateToEventTask(task.get());
    }

    /**
     * Navigates the listview to display and select the task.
     */
    public EventTaskCardHandle navigateToEventTask(ReadOnlyTask task) {
        int index = getEventTaskIndex(task);

        guiRobot.interact(() -> {
            getEventListView().scrollTo(index);
            guiRobot.sleep(150);
            getEventListView().getSelectionModel().select(index);
        });
        guiRobot.sleep(100);
        return getEventTaskCardHandle(task);
    }

    /**
     * Returns the position of the person given, {@code NOT_FOUND} if not found
     * in the list.
     */
    public int getEventTaskIndex(ReadOnlyTask targetTask) {
        List<ReadOnlyTask> tasksInList = getEventListView().getItems();
        for (int i = 0; i < tasksInList.size(); i++) {
            if (tasksInList.get(i).getTaskName().equals(targetTask.getTaskName())) {
                return i;
            }
        }
        return NOT_FOUND;
    }

    /**
     * Gets a person from the list by index
     */
    public ReadOnlyTask getEventTask(int index) {
        return getEventListView().getItems().get(index);
    }

    public EventTaskCardHandle getEventTaskCardHandle(int index) {
        return getEventTaskCardHandle(new Task(getEventListView().getItems().get(index)));
    }

    public EventTaskCardHandle getEventTaskCardHandle(ReadOnlyTask task) {
        Set<Node> nodes = getAllCardNodes();
        Optional<Node> taskCardNode = nodes.stream()
                .filter(n -> new EventTaskCardHandle(guiRobot, primaryStage, n).isSameTask(task)).findFirst();
        if (taskCardNode.isPresent()) {
            return new EventTaskCardHandle(guiRobot, primaryStage, taskCardNode.get());
        } else {
            return null;
        }
    }

    protected Set<Node> getAllCardNodes() {
        return guiRobot.lookup(CARD_PANE_ID).queryAll();
    }

    public int getNumberOfTask() {
        return getEventListView().getItems().size();
    }
}
```
###### \java\guitests\guihandles\FloatingTaskCardHandle.java
``` java
/**
 * Provides a handle to a task card in the task list panel.
 */
public class FloatingTaskCardHandle extends GuiHandle {
    private static final String TASKNAME_FIELD_ID = "#taskname";
    private static final String COMPLETED_FIELD_ID = "#completed";
    private static final String CATEGORIES_FIELD_ID = "#categories";

    private Node node;

    public FloatingTaskCardHandle(GuiRobot guiRobot, Stage primaryStage, Node node) {
        super(guiRobot, primaryStage, null);
        this.node = node;
    }

    protected String getTextFromLabel(String fieldId) {
        return getTextFromLabel(fieldId, node);
    }

    public String getTaskName() {
        return getTextFromLabel(TASKNAME_FIELD_ID);
    }

    public String getIsMarkedAsCompleted() {
        return getTextFromLabel(COMPLETED_FIELD_ID);
    }

    public List<String> getCategories() {
        return getCategories(getCategoriesContainer());
    }

    private List<String> getCategories(Region categoriesContainer) {
        return categoriesContainer.getChildrenUnmodifiable().stream().map(node -> ((Labeled) node).getText())
                .collect(Collectors.toList());
    }

    private List<String> getCategories(UniqueCategoryList categories) {
        return categories.asObservableList().stream().map(category -> category.categoryName)
                .collect(Collectors.toList());
    }

    private Region getCategoriesContainer() {
        return guiRobot.from(node).lookup(CATEGORIES_FIELD_ID).query();
    }

    public boolean isSameTask(ReadOnlyTask task) {
        return task != null || this == task && getTaskName().equals(task.getTaskName())
                && getIsMarkedAsCompleted().equals(task.getIsMarkedAsComplete())
                && getCategories().equals(getCategories(task.getCategories()));
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof FloatingTaskCardHandle) {
            FloatingTaskCardHandle handle = (FloatingTaskCardHandle) obj;
            return getTaskName().equals(handle.getTaskName())
                    && getIsMarkedAsCompleted().equals(handle.getIsMarkedAsCompleted())
                    && getCategories().equals(handle.getCategories());
        }
        return super.equals(obj);
    }

    @Override
    public String toString() {
        return getTaskName();
    }
}
```
###### \java\guitests\guihandles\FloatingTaskListPanelHandle.java
``` java
/**
 * Provides a handle for the panel containing the task list.
 */
public class FloatingTaskListPanelHandle extends GuiHandle {

    public static final int NOT_FOUND = -1;
    public static final String CARD_PANE_ID = "#cardPane";

    private static final String FLOATING_TASK_LIST_VIEW_ID = "#floatingTaskListView";

    public FloatingTaskListPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    public List<Pair<ReadOnlyTask, Integer>> getSelectedTasks() {
        ListView<Pair<ReadOnlyTask, Integer>> taskList = getFloatingListView();
        return taskList.getSelectionModel().getSelectedItems();
    }

    public ListView<Pair<ReadOnlyTask, Integer>> getFloatingListView() {
        ListView<Pair<ReadOnlyTask, Integer>> floatingListView = getNode(FLOATING_TASK_LIST_VIEW_ID);
        return floatingListView;
    }

    /**
     * Returns true if the list is showing the task details correctly and in
     * correct order.
     *
     * @param tasks
     *            A list of tasks in the correct order.
     */
    public boolean isListMatching(ReadOnlyTask... tasks) {
        return this.isListMatching(0, tasks);
    }

    /**
     * Returns true if the list is showing the task details correctly and in
     * correct order.
     *
     * @param startPosition
     *            The starting position of the sub list.
     * @param persons
     *            A list of task in the correct order.
     */
    public boolean isListMatching(int startPosition, ReadOnlyTask... tasks) throws IllegalArgumentException {
        List<ReadOnlyTask> floatingTasks = new ArrayList<>(Arrays.asList(tasks));
        for (int index = 0; index < floatingTasks.size(); index++) {
            if (!floatingTasks.get(index).isFloatingTask()) {
                floatingTasks.remove(index);
                index--;
            }
        }
        ReadOnlyTask[] taskArray = floatingTasks.toArray(new ReadOnlyTask[floatingTasks.size()]);
        if (taskArray.length + startPosition != getFloatingListView().getItems().size()) {
            throw new IllegalArgumentException(
                    "List size mismatched\n" + "Expected " + (getFloatingListView().getItems().size() - 1) + " tasks");
        }
        assertTrue(this.containsInOrder(startPosition, taskArray));
        for (int i = 0; i < taskArray.length; i++) {
            final int scrollTo = i + startPosition;
            guiRobot.interact(() -> getFloatingListView().scrollTo(scrollTo));
            guiRobot.sleep(200);
            if (!TestUtil.compareCardAndTask(getFloatingTaskCardHandle(startPosition + i), taskArray[i])) {
                return false;
            }
        }
        return true;
    }

    /**
     * Clicks on the ListView.
     */
    public void clickOnListView() {
        Point2D point = TestUtil.getScreenMidPoint(getFloatingListView());
        guiRobot.clickOn(point.getX(), point.getY());
    }

    /**
     * Returns true if the {@code tasks} appear as the sub list (in that order)
     * at position {@code startPosition}.
     */
    public boolean containsInOrder(int startPosition, ReadOnlyTask... tasks) {
        List<Pair<ReadOnlyTask, Integer>> tasksInList = getFloatingListView().getItems();

        // Return false if the list in panel is too short to contain the given
        // list
        if (startPosition + tasks.length > tasksInList.size()) {
            return false;
        }

        // Return false if any of the persons doesn't match
        for (int i = 0; i < tasks.length; i++) {
            if (!tasksInList.get(startPosition + i).getKey().getTaskName().fullTaskName
                    .equals(tasks[i].getTaskName().fullTaskName)) {
                return false;
            }
        }

        return true;
    }

    public FloatingTaskCardHandle navigateToFloatingTask(String taskname) {
        guiRobot.sleep(500); // Allow a bit of time for the list to be updated
        final Optional<Pair<ReadOnlyTask, Integer>> task = getFloatingListView().getItems().stream()
                .filter(p -> p.getKey().getTaskName().toString().equals(taskname)).findAny();
        if (!task.isPresent()) {
            throw new IllegalStateException("Task name not found: " + taskname);
        }

        return navigateToFloatingTask(task.get().getKey());
    }

    /**
     * Navigates the listview to display and select the task.
     */
    public FloatingTaskCardHandle navigateToFloatingTask(ReadOnlyTask task) {
        int index = getFloatingTaskIndex(task);

        guiRobot.interact(() -> {
            getFloatingListView().scrollTo(index);
            guiRobot.sleep(150);
            getFloatingListView().getSelectionModel().select(index);
        });
        guiRobot.sleep(100);
        return getFloatingTaskCardHandle(task);
    }

    /**
     * Returns the position of the person given, {@code NOT_FOUND} if not found
     * in the list.
     */
    public int getFloatingTaskIndex(ReadOnlyTask targetTask) {
        List<Pair<ReadOnlyTask, Integer>> tasksInList = getFloatingListView().getItems();
        for (int i = 0; i < tasksInList.size(); i++) {
            if (tasksInList.get(i).getKey().getTaskName().equals(targetTask.getTaskName())) {
                return i;
            }
        }
        return NOT_FOUND;
    }

    /**
     * Gets a person from the list by index
     */
    public ReadOnlyTask getFloatingTask(int index) {
        return getFloatingListView().getItems().get(index).getKey();
    }

    public FloatingTaskCardHandle getFloatingTaskCardHandle(int index) {
        return getFloatingTaskCardHandle(new Task(getFloatingListView().getItems().get(index).getKey()));
    }

    public FloatingTaskCardHandle getFloatingTaskCardHandle(ReadOnlyTask task) {
        Set<Node> nodes = getAllCardNodes();
        Optional<Node> taskCardNode = nodes.stream()
                .filter(n -> new FloatingTaskCardHandle(guiRobot, primaryStage, n).isSameTask(task)).findFirst();
        if (taskCardNode.isPresent()) {
            return new FloatingTaskCardHandle(guiRobot, primaryStage, taskCardNode.get());
        } else {
            return null;
        }
    }

    protected Set<Node> getAllCardNodes() {
        return guiRobot.lookup(CARD_PANE_ID).queryAll();
    }

    public int getNumberOfTask() {
        return getFloatingListView().getItems().size();
    }
}
```
###### \java\guitests\RedoCommandTest.java
``` java
    @Test
    public void redoDeleteSuccess() {
        TestTask[] currentList = td.getTypicalTasks();
        int targetIndex = 1;
        TestTask[] expectedRemainder = TestUtil.removeTaskFromList(currentList, targetIndex);
        commandBox.runCommand("DELETE " + targetIndex);
        commandBox.runCommand("UNDO");
        commandBox.runCommand("REDO");
        assertRedoSuccess(expectedRemainder);
    }

    @Test
    public void redoAddSuccess() {
        TestTask[] currentList = td.getTypicalTasks();
        TestTask taskToAdd = td.sampleEvent;
        currentList = TestUtil.addTasksToList(currentList, taskToAdd).getKey();
        commandBox.runCommand(taskToAdd.getAddCommand());
        commandBox.runCommand("UNDO");
        commandBox.runCommand("REDO");
        assertRedoSuccess(currentList);
    }

    @Test
    public void redoClearSuccess() {
        commandBox.runCommand("CLEAR");
        commandBox.runCommand("UNDO");
        commandBox.runCommand("REDO");
        assertListSize(0);
    }

    @Test
    public void redoUpdateSuccess() throws Exception  {
        TestTask[] currentList = td.getTypicalTasks();
        String detailsToUpdate = "take a snack break ON 03/03/19 1500 TO 1600 CATEGORY";
        int taskManagerIndex = 1;
        TestTask updatedTask = new TaskBuilder().withTaskName("take a snack break").withStartDate("03/03/19")
                .withStartTime("1500").withEndDate("03/03/19").withEndTime("1600").build();
        currentList = TestUtil.removeTaskFromList(currentList, taskManagerIndex);
        Pair<TestTask[], Integer> expectedList = TestUtil.addTasksToList(currentList, updatedTask);

        currentList = expectedList.getKey();

        commandBox.runCommand("UPDATE " + taskManagerIndex + " " + detailsToUpdate);
        commandBox.runCommand("UNDO");
        commandBox.runCommand("REDO");
        assertRedoSuccess(currentList);
    }

    @Test
    public void redoInvalidCommand() {
        commandBox.runCommand("REDOwrong");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    @Test
    public void redoNothingToRedo() {
        commandBox.runCommand("REDO");
        assertResultMessage("Nothing to redo.");
    }

    @Test
    public void redoOverwritted() {
        commandBox.runCommand("CLEAR");
        commandBox.runCommand("UNDO");
        TestTask taskToAdd = td.sampleEvent;
        commandBox.runCommand(taskToAdd.getAddCommand());
        commandBox.runCommand("REDO");
        assertResultMessage("Nothing to redo.");
    }

    /**
     * Validate the redo command, confirming if the result is correct.
     *
     * @param currentList
     *            A copy of the current list of tasks (before undo).
     */
    private void assertRedoSuccess(TestTask[] expectedList) {

        // confirm the list now contains all tasks after redo
        assertTrue(eventTaskListPanel.isListMatching(expectedList));
        assertTrue(deadlineTaskListPanel.isListMatching(expectedList));
        assertTrue(floatingTaskListPanel.isListMatching(expectedList));

        // confirm the result message is correct
        assertResultMessage(RedoCommand.MESSAGE_SUCCESS);
    }

}
```
###### \java\guitests\SelectCommandTest.java
``` java
    private void assertTaskSelected(int index) {
        if (eventTaskListPanel.getNumberOfTask() > index) {
            assertEquals(eventTaskListPanel.getSelectedTasks().size(), 1);
            assertNoDeadlineTaskSelected();
            assertNoFloatingTaskSelected();
            ReadOnlyTask selectedTask = eventTaskListPanel.getSelectedTasks().get(0);
            assertEquals(eventTaskListPanel.getEventTask(index - 1), selectedTask);
        } else {
            if ((eventTaskListPanel.getNumberOfTask() + deadlineTaskListPanel.getNumberOfTask()) > index) {
                assertEquals(deadlineTaskListPanel.getSelectedTasks().size(), 1);
                assertNoEventTaskSelected();
                assertNoFloatingTaskSelected();
                ReadOnlyTask selectedTask = deadlineTaskListPanel.getSelectedTasks().get(0).getKey();
                assertEquals(deadlineTaskListPanel.getDeadlineTask(index - eventTaskListPanel.getNumberOfTask()
                        - 1), selectedTask);

            } else {
                assertEquals(floatingTaskListPanel.getSelectedTasks().size(), 1);
                assertNoDeadlineTaskSelected();
                assertNoEventTaskSelected();
                ReadOnlyTask selectedTask = floatingTaskListPanel.getSelectedTasks().get(0).getKey();
                assertEquals(floatingTaskListPanel.getFloatingTask(
                        index - eventTaskListPanel.getNumberOfTask() - deadlineTaskListPanel.getNumberOfTask()
                        - 1), selectedTask);
            }
        }
    }

```
###### \java\guitests\SelectCommandTest.java
``` java
    private void assertNoTaskSelected() {
        assertNoEventTaskSelected();
        assertNoDeadlineTaskSelected();
        assertNoFloatingTaskSelected();
    }

    private void assertNoEventTaskSelected() {
        assertEquals(eventTaskListPanel.getSelectedTasks().size(), 0);
    }

    private void assertNoDeadlineTaskSelected() {
        assertEquals(deadlineTaskListPanel.getSelectedTasks().size(), 0);
    }

    private void assertNoFloatingTaskSelected() {
        assertEquals(floatingTaskListPanel.getSelectedTasks().size(), 0);
    }

}
```
###### \java\guitests\UndoCommandTest.java
``` java
    @Test
    public void undoDeleteSuccess() {
        TestTask[] currentList = td.getTypicalTasks();
        int targetIndex = 1;
        commandBox.runCommand("DELETE " + targetIndex);
        commandBox.runCommand("UNDO");
        assertUndoSuccess(currentList);
    }

    @Test
    public void undoAddSuccess() {
        TestTask[] currentList = td.getTypicalTasks();
        TestTask taskToAdd = td.sampleEvent;
        commandBox.runCommand(taskToAdd.getAddCommand());
        commandBox.runCommand("UNDO");
        assertUndoSuccess(currentList);
    }

    @Test
    public void undoClearSuccess() {
        TestTask[] currentList = td.getTypicalTasks();
        commandBox.runCommand("CLEAR");
        commandBox.runCommand("UNDO");
        assertUndoSuccess(currentList);
    }

    @Test
    public void undoUpdateSuccess() {
        TestTask[] currentList = td.getTypicalTasks();
        String detailsToUpdate = "take a snack break ON 03/03/19 1500 TO 1600 CATEGORY";
        int taskManagerIndex = 1;

        commandBox.runCommand("UPDATE " + taskManagerIndex + " " + detailsToUpdate);
        commandBox.runCommand("UNDO");
        assertUndoSuccess(currentList);
    }

    @Test
    public void undoInvalidCommand() {
        commandBox.runCommand("UNDOwrong");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    @Test
    public void undoNothingToUndo() {
        commandBox.runCommand("UNDO");
        assertResultMessage("Nothing to undo.");
    }



    /**
     * Validate the undo command, confirming if the result is correct.
     *
     * @param currentList
     *            A copy of the current list of tasks (before undo).
     */
    private void assertUndoSuccess(TestTask[] expectedList) {

        // confirm the list now contains all tasks after undo
        assertTrue(eventTaskListPanel.isListMatching(expectedList));
        assertTrue(deadlineTaskListPanel.isListMatching(expectedList));
        assertTrue(floatingTaskListPanel.isListMatching(expectedList));

        // confirm the result message is correct
        assertResultMessage(UndoCommand.MESSAGE_SUCCESS);
    }

}
```
###### \java\guitests\UpdateCommandTest.java
``` java
    @Test
    public void update_noFieldsSpecified_success() throws Exception {
        String detailsToUpdate = "";
        int taskManagerIndex = 1;

        TestTask taskToUpdate = expectedTasksList[taskManagerIndex - 1];
        TestTask updatedTask = new TaskBuilder(taskToUpdate).withStartDate("EMPTY_FIELD").withStartTime("EMPTY_FIELD")
                .withEndDate("EMPTY_FIELD").withEndTime("EMPTY_FIELD").build();

        assertUpdateSuccess(taskManagerIndex, taskManagerIndex, detailsToUpdate, updatedTask);
    }

    @Test
    public void update_timeOnly_success() throws Exception {
        String detailsToUpdate = "FROM 0010 TO 0020";
        int taskManagerIndex = 1;

        TestTask taskToUpdate = expectedTasksList[taskManagerIndex - 1];
        TestTask updatedTask = new TaskBuilder(taskToUpdate).withStartTime("0010").withEndTime("0020").build();

        assertUpdateSuccess(taskManagerIndex, taskManagerIndex, detailsToUpdate, updatedTask);
    }

    @Test
    public void update_correctOnDateWrongTimeFailure() throws Exception {
        commandBox.runCommand("UPDATE 1 ON 01/01/14 1171 TO 1172");
        assertResultMessage("Invalid input for time\nTime must be between 0000 and 2359");
    }

    @Test
    public void update_correctOnDateTimeNoEndTimeSucess() throws Exception {
        String detailsToUpdate = "ON 01/01/14 2350";
        int taskManagerIndex = 1;

        TestTask taskToUpdate = expectedTasksList[taskManagerIndex - 1];
        TestTask updatedTask = new TaskBuilder(taskToUpdate).withStartDate("01/01/14").withStartTime("2350")
                .withEndDate("02/01/14").withEndTime("0050").build();

        assertUpdateSuccess(taskManagerIndex, taskManagerIndex, detailsToUpdate, updatedTask);
    }

    @Test
    public void update_correctOnDateWrongToInputFailure() throws Exception {
        commandBox.runCommand("UPDATE 1 ON 01/01/14 1100 TO 02/01/14 1110");
        assertResultMessage(
                "Incorrect input after TO prefix.\n" + "Example of Allowed Format: ADD task ON thursday 1200 TO 1400\n"
                        + "Type HELP for user guide with detailed explanations of all commands");
    }

    @Test
    public void update_changeTimeOnlyForEventsSuccess() throws Exception {
        String detailsToUpdate = "FROM 1100 TO 1110";
        int taskManagerIndex = 1;

        TestTask taskToUpdate = expectedTasksList[taskManagerIndex - 1];
        TestTask updatedTask = new TaskBuilder(taskToUpdate).withStartDate("03/03/17").withStartTime("1100")
                .withEndDate("03/03/17").withEndTime("1110").build();

        assertUpdateSuccess(taskManagerIndex, taskManagerIndex, detailsToUpdate, updatedTask);
    }

    @Test
    public void update_changeStartTimeOnlyForEventsSuccess() throws Exception {
        String detailsToUpdate = "FROM 0900";
        int taskManagerIndex = 1;

        TestTask taskToUpdate = expectedTasksList[taskManagerIndex - 1];
        TestTask updatedTask = new TaskBuilder(taskToUpdate).withStartDate("03/03/17").withStartTime("0900")
                .withEndDate("03/03/17").withEndTime("1100").build();

        assertUpdateSuccess(taskManagerIndex, taskManagerIndex, detailsToUpdate, updatedTask);
    }

    @Test
    public void update_changeEndTimeOnlyForEventsSuccess() throws Exception {
        String detailsToUpdate = "TO 1200";
        int taskManagerIndex = 1;

        TestTask taskToUpdate = expectedTasksList[taskManagerIndex - 1];
        TestTask updatedTask = new TaskBuilder(taskToUpdate).withStartDate("03/03/17").withStartTime("1000")
                .withEndDate("03/03/17").withEndTime("1200").build();

        assertUpdateSuccess(taskManagerIndex, taskManagerIndex, detailsToUpdate, updatedTask);
    }

    @Test
    public void update_changeTimeOnlyForNotEventFailure() throws Exception {
        commandBox.runCommand("UPDATE 7 FROM 1100 TO 1110");
        assertResultMessage(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
    }

```
###### \java\guitests\UpdateCommandTest.java
``` java
    /**
     * Checks whether the updated task has the correct updated details.
     *
     * @param filteredTaskListIndex
     *            index of task to update in filtered list
     * @param taskManagerIndex
     *            index of task to update in the task manager. Must refer to the
     *            same task as {@code filteredTaskListIndex}
     * @param detailsToUpdate
     *            details to update the task with as input to the update command
     * @param updatedTask
     *            the expected task after updating the task's details
     */
    private void assertUpdateSuccess(int filteredTaskListIndex, int taskManagerIndex, String detailsToUpdate,
            TestTask updatedTask) {
        commandBox.runCommand("UPDATE " + filteredTaskListIndex + " " + detailsToUpdate);

        if (updatedTask.isEventTask()) {
            EventTaskCardHandle updatedCard = eventTaskListPanel
                    .navigateToEventTask(updatedTask.getTaskName().toString());
            assertMatching(updatedTask, updatedCard);
        } else {
            if (updatedTask.isDeadlineTask()) {
                DeadlineTaskCardHandle updatedCard = deadlineTaskListPanel
                        .navigateToDeadlineTask(updatedTask.getTaskName().toString());
                assertMatching(updatedTask, updatedCard);
            } else {
                if (updatedTask.isFloatingTask()) {
                    FloatingTaskCardHandle updatedCard = floatingTaskListPanel
                            .navigateToFloatingTask(updatedTask.getTaskName().toString());
                    assertMatching(updatedTask, updatedCard);
                }
            }
        }

        // confirm the list now contains all previous tasks plus the task with
        // updated details
        expectedTasksList = TestUtil.removeTaskFromList(expectedTasksList, taskManagerIndex);
        Pair<TestTask[], Integer> expectedList = TestUtil.addTasksToList(expectedTasksList, updatedTask);

        expectedTasksList = expectedList.getKey();
        int updateIndex = expectedList.getValue();

        assertTrue(eventTaskListPanel.isListMatching(expectedTasksList));
        assertTrue(deadlineTaskListPanel.isListMatching(expectedTasksList));
        assertTrue(floatingTaskListPanel.isListMatching(expectedTasksList));
        assertResultMessage(String.format(UpdateCommand.MESSAGE_UPDATE_TASK_SUCCESS, updatedTask) + "\n"
                + "Task updated to index: " + Integer.toString(updateIndex + 1));
    }

```
###### \java\seedu\taskmanager\testutil\TestTask.java
``` java
    /**
     * Checks the fields populated within the task
     *
     * @return true if task is a Event Task
     */
    @Override
    public boolean isEventTask() {
        return (!startDate.value.equals(EMPTY_FIELD) && !endDate.value.equals(EMPTY_FIELD));
    }

    /**
     * Checks the fields populated within the task
     *
     * @return true if task is a Deadline Task
     */
    @Override
    public boolean isDeadlineTask() {
        return (startDate.value.equals(EMPTY_FIELD) && !endDate.value.equals(EMPTY_FIELD));
    }

    /**
     * Checks the fields populated within the task
     *
     * @return true if task is a Floating Task
     */
    @Override
    public boolean isFloatingTask() {
        return (startDate.value.equals(EMPTY_FIELD) && endDate.value.equals(EMPTY_FIELD));
    }

    @Override
    public boolean isCompletedTask() {
        return completed;
    }

    @Override
    public boolean isWithinStartEndDuration(ReadOnlyTask t) {
        if (this.getStartDate().equals(t.getStartDate()) && this.getEndDate().equals(t.getEndDate())) {
            if ((DateTimeUtil.isDateWithin(this.getStartDate().value, t.getStartDate().value,
                    t.getEndDate().value) == 2)) {
                if ((this.getStartTime().laterThanOrEqual(t.getEndTime()))
                        || (t.getStartTime().laterThanOrEqual(this.getEndTime()))) {
                    return false;
                }
                return true;
            } else {
                return true;
            }
        } else if ((this.getEndDate().value).equals(t.getStartDate().value)) {
            if (t.getStartTime().laterThanOrEqual(this.getEndTime())) {
                return false;
            } else {
                return true;
            }
        } else if ((this.getStartDate().value).equals(t.getEndDate().value)) {
            if (this.getStartTime().laterThanOrEqual(t.getEndTime())) {
                return false;
            } else {
                return true;
            }
        } else if ((DateTimeUtil.isDateWithin(this.getStartDate().value, t.getStartDate().value,
                t.getEndDate().value) == 1)
                || (DateTimeUtil.isDateWithin(this.getEndDate().value, t.getStartDate().value,
                        t.getEndDate().value) == 1)
                || (DateTimeUtil.isDateWithin(t.getStartDate().value, this.getStartDate().value,
                        this.getEndDate().value) == 1)
                || (DateTimeUtil.isDateWithin(t.getEndDate().value, this.getStartDate().value,
                        this.getEndDate().value) == 1)) {
            return true;
        } else if ((DateTimeUtil.isDateWithin(this.getStartDate().value, t.getStartDate().value,
                t.getEndDate().value) == 2) && t.getEndTime().laterThanOrEqual(this.getStartTime())) {
            return true;
        } else if ((DateTimeUtil.isDateWithin(this.getEndDate().value, t.getStartDate().value,
                t.getEndDate().value) == 2) && this.getEndTime().laterThanOrEqual(t.getStartTime())) {
            return true;
        }
        return false;
    }
}
```
