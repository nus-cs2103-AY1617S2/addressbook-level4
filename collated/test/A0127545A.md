# A0127545A
###### /java/guitests/AddTaskCommandTest.java
``` java
package guitests;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;

import org.junit.Before;
import org.junit.Test;

import seedu.toluist.commons.util.DateTimeUtil;
import seedu.toluist.model.Tag;
import seedu.toluist.model.Task;
import seedu.toluist.model.Task.TaskPriority;

/**
 * Gui tests for add task command
 */
public class AddTaskCommandTest extends ToLuistGuiTest {

    private static final IllegalArgumentException ILLEGAL_ARGUMENT_EXCEPTION_1 =
            new IllegalArgumentException("Description must not be empty.");
    private static final IllegalArgumentException ILLEGAL_ARGUMENT_EXCEPTION_2 =
            new IllegalArgumentException("Start date must be before end date.");
    private static final IllegalArgumentException ILLEGAL_ARGUMENT_EXCEPTION_3 =
            new IllegalArgumentException("Priority level must be either 'low' or 'high'.");
    private static final IllegalArgumentException ILLEGAL_ARGUMENT_EXCEPTION_4 =
            new IllegalArgumentException("Recurring frequency must be either 'daily',"
                    + "'weekly', 'monthly' or 'yearly'.");
    private static final String ADD = "add ";
    private static final String FROM = " from/";
    private static final String TO = " to/";
    private static final String BY = " by/";
    private static final String TAGS = " tags/";
    private static final String PRIORITY = " priority/";
    private static final String REPEAT = " repeat/";
    private static final String REPEAT_UNTIL = " repeatuntil/";
    private Tag tag1 = new Tag("tag1");
    private Tag tag2 = new Tag("tag2");
    private Tag tag3 = new Tag("tag3");

    @Before
    public void setUp() {
        String switchToDefaulTab = "switch i";
        commandBox.runCommand(switchToDefaulTab);
    }


    @Test
    public void addFloatingTask() {
        // add one task
        String taskDescription = "do homework for Melvin";
        String command = ADD + taskDescription;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription);
        assertTrue(isTaskShown(task));

        // add another task, with tags
        String taskDescription2 = "drink Koi after school";
        String command2 = ADD + taskDescription2 + TAGS + "tag1 tag2 tag3" + PRIORITY + "high";
        commandBox.runCommand(command2);
        Task task2 = new Task(taskDescription2, null, null);
        task2.setTaskPriority(TaskPriority.HIGH);
        task2.replaceTags(new ArrayList<>(Arrays.asList(tag1, tag2, tag3)));
        assertTrue(areTasksShown(task, task2));
    }

    @Test
    public void addTaskWithDeadline() {
        // add task with deadline
        String taskDescription1 = "get v0.2 ready";
        LocalDateTime endDate1 = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        String command1 = ADD + taskDescription1 + BY + endDate1;
        commandBox.runCommand(command1);
        Task task1 = new Task(taskDescription1, endDate1);
        assertTrue(isTaskShown(task1));

        // add task without description with deadline
        String taskDescription2 = "";
        LocalDateTime endDate2 = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        String command2 = ADD + taskDescription2 + BY + endDate2;
        Task task2 = null;
        try {
            commandBox.runCommand(command2);
            task2 = new Task(taskDescription2, endDate2);
            fail("Should throw an IllegalArgumentException here since description is empty.");
        } catch (IllegalArgumentException illegalArgumentException) {
            assertTrue(illegalArgumentException.getMessage().equals(ILLEGAL_ARGUMENT_EXCEPTION_1.getMessage()));
        }
        assertTrue(isTaskShown(task1));
        assertFalse(isTaskShown(task2));

        // add another task with deadline and tags
        String taskDescription3 = "get v0.3 ready";
        LocalDateTime endDate3 = DateTimeUtil.parseDateString("22 Mar 2017, 12pm");
        String command3 = ADD + taskDescription3 + BY + endDate3 + PRIORITY + "low" + TAGS + "tag1 tag2";
        commandBox.runCommand(command3);
        Task task3 = new Task(taskDescription3, null, endDate3);
        task3.replaceTags(new ArrayList<>(Arrays.asList(tag1, tag2)));
        assertTrue(areTasksShown(task1, task3));
        assertFalse(isTaskShown(task2));
    }

    @Test
    public void addEvent() {
        // add event
        String taskDescription1 = "attend CS2103T tutorial";
        LocalDateTime startDate1 = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        LocalDateTime endDate1 = DateTimeUtil.parseDateString("15 Mar 2017, 1pm");
        String command1 = ADD + taskDescription1 + FROM + startDate1 + TO + endDate1;
        commandBox.runCommand(command1);
        Task task1 = new Task(taskDescription1, startDate1, endDate1);
        assertTrue(isTaskShown(task1));

        // add event with start date after end date
        String taskDescription2 = "attend CS2103T tutorial";
        LocalDateTime startDate2 = DateTimeUtil.parseDateString("15 Mar 2017, 1pm");
        LocalDateTime endDate2 = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        String command2 = ADD + taskDescription2 + FROM + startDate2 + TO + endDate2;
        Task task2 = null;
        try {
            commandBox.runCommand(command2);
            task2 = new Task(taskDescription2, startDate2, endDate2);
            fail("Should throw an IllegalArgumentException here since start date is after end date.");
        } catch (IllegalArgumentException illegalArgumentException) {
            assertTrue(illegalArgumentException.getMessage().equals(ILLEGAL_ARGUMENT_EXCEPTION_2.getMessage()));
        }
        assertTrue(isTaskShown(task1));
        assertFalse(isTaskShown(task2));

        // add event without description
        String taskDescription3 = "";
        LocalDateTime startDate3 = DateTimeUtil.parseDateString("15 Mar 2017, 1pm");
        LocalDateTime endDate3 = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        String command3 = ADD + taskDescription3 + FROM + startDate3 + TO + endDate3;
        Task task3 = null;
        try {
            commandBox.runCommand(command3);
            task3 = new Task(taskDescription3, startDate3, endDate3);
            fail("Should throw an IllegalArgumentException here since description is empty.");
        } catch (IllegalArgumentException illegalArgumentException) {
            assertTrue(illegalArgumentException.getMessage().equals(ILLEGAL_ARGUMENT_EXCEPTION_1.getMessage()));
        }
        assertTrue(isTaskShown(task1));
        assertFalse(isTaskShown(task2));
        assertFalse(isTaskShown(task3));

        // add another event with tags
        String taskDescription4 = "attend CS2101 tutorial";
        LocalDateTime startDate4 = DateTimeUtil.parseDateString("16 Mar 2017, 10am");
        LocalDateTime endDate4 = DateTimeUtil.parseDateString("16 Mar 2017, 12pm");
        String command4 = ADD + taskDescription4 + TAGS + "tag3" +
                 FROM + startDate4 + TO + endDate4 + PRIORITY + "high";
        commandBox.runCommand(command4);
        Task task4 = new Task(taskDescription4, startDate4, endDate4);
        task4.setTaskPriority(TaskPriority.HIGH);
        task4.replaceTags(new ArrayList<>(Arrays.asList(tag3)));
        assertTrue(areTasksShown(task1, task4));
        assertFalse(isTaskShown(task2));
        assertFalse(isTaskShown(task3));
    }

    @Test
    public void addDuplicatedTask() {
        String command = ADD + "task";
        commandBox.runCommand(command);
        assertResultMessage("Added task at index 3:\n" +
                "- Task type: \"TASK\"\n" +
                "- Description: \"task\"\n" +
                "- Priority: \"LOW\"");

        command = ADD + "task";
        commandBox.runCommand(command);
        assertResultMessage("Task provided already exist in the list.");
    }

    @Test
    public void addMultipleTypeTask_shouldNotBeCreated() {
        String taskDescription = "attend CS2103T tutorial";
        LocalDateTime startDate = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        LocalDateTime endDate1 = DateTimeUtil.parseDateString("15 Mar 2017, 1pm");
        LocalDateTime endDate2 = DateTimeUtil.parseDateString("15 Mar 2017, 5pm");
        String command1 = ADD + taskDescription + FROM + startDate + TO + endDate1 + BY + endDate2;
        commandBox.runCommand(command1);
        Task task1 = new Task(taskDescription, startDate, endDate1);
        Task task2 = new Task(taskDescription, startDate, endDate2);
        Task task3 = new Task(taskDescription, endDate2);
        Task task4 = new Task(taskDescription);
        assertFalse(isTaskShown(task1));
        assertFalse(isTaskShown(task2));
        assertFalse(isTaskShown(task3));
        assertFalse(isTaskShown(task4));
    }

    @Test
    public void addTaskWithInvalidPriorityLevel_shouldNotBeCreated() {
        String taskDescription = "attend CS2103T tutorial";
        String priorityString = "high low";
        String command = ADD + taskDescription + PRIORITY + priorityString;
        Task task1 = null;
        Task task2 = null;
        try {
            commandBox.runCommand(command);
            task1 = new Task(taskDescription);
            task2 = new Task(taskDescription);
            task2.setTaskPriority(priorityString);
            fail("Should not reach here since priority is both high and low at the same time.");
        } catch (IllegalArgumentException illegalArgumentException) {
            assertTrue(illegalArgumentException.getMessage().equals(ILLEGAL_ARGUMENT_EXCEPTION_3.getMessage()));
        }
        assertFalse(isTaskShown(task1));
        assertFalse(isTaskShown(task2));

        priorityString = "";
        command = ADD + taskDescription + PRIORITY + priorityString;
        try {
            commandBox.runCommand(command);
            task1 = new Task(taskDescription);
            task2 = new Task(taskDescription);
            task2.setTaskPriority(priorityString);
            fail("Should not reach here since priority is blank.");
        } catch (IllegalArgumentException illegalArgumentException) {
            assertTrue(illegalArgumentException.getMessage().equals(ILLEGAL_ARGUMENT_EXCEPTION_3.getMessage()));
        }
        assertFalse(isTaskShown(task1));
        assertFalse(isTaskShown(task2));
    }

    @Test
    public void addRecurringFloatingTask() {
        String taskDescription = "shower";
        String recurFrequencyString = "daily";
        String command = ADD + taskDescription + REPEAT + recurFrequencyString;
        commandBox.runCommand(command);
        Task task1 = new Task(taskDescription);
        task1.setRecurring(recurFrequencyString);
        assertTrue(isTaskShown(task1));

        LocalDateTime recurUntilEndDate = DateTimeUtil.parseDateString("11 April 2017, 2pm");
        command = ADD + taskDescription + REPEAT + recurFrequencyString + REPEAT_UNTIL + recurUntilEndDate;
        commandBox.runCommand(command);
        Task task2 = new Task(taskDescription);
        task2.setRecurring(recurUntilEndDate, recurFrequencyString);
        assertTrue(areTasksShown(task1, task2));
    }

    @Test
    public void addRecurringTaskWithDeadline() {
        String taskDescription = "shower";
        String recurFrequencyString = "daily";
        LocalDateTime endDate = DateTimeUtil.parseDateString("9pm");
        String command = ADD + taskDescription + BY + endDate + REPEAT + recurFrequencyString;
        commandBox.runCommand(command);
        Task task1 = new Task(taskDescription, endDate);
        task1.setRecurring(recurFrequencyString);
        assertTrue(isTaskShown(task1));

        taskDescription = "do CS2103T project";
        recurFrequencyString = "weekly";
        endDate = DateTimeUtil.parseDateString("28 April 2017, 11pm");
        LocalDateTime recurUntilEndDate = DateTimeUtil.parseDateString("11 April 2017, 2pm");
        command = ADD + taskDescription + BY + endDate + REPEAT + recurFrequencyString
                + REPEAT_UNTIL + recurUntilEndDate;
        commandBox.runCommand(command);
        Task task2 = new Task(taskDescription, endDate);
        task2.setRecurring(recurUntilEndDate, recurFrequencyString);
        assertTrue(areTasksShown(task1, task2));
    }

    @Test
    public void addRecurringEvent() {
        String taskDescription = "shower";
        String recurFrequencyString = "daily";
        LocalDateTime from = DateTimeUtil.parseDateString("9pm");
        LocalDateTime to = DateTimeUtil.parseDateString("10pm");
        String command = ADD + taskDescription + FROM + from + TO + to + REPEAT + recurFrequencyString;
        commandBox.runCommand(command);
        Task task1 = new Task(taskDescription, from, to);
        task1.setRecurring(recurFrequencyString);
        assertTrue(isTaskShown(task1));

        taskDescription = "do CS2103T project";
        recurFrequencyString = "weekly";
        from = DateTimeUtil.parseDateString("28 April 2017, 9pm");
        to = DateTimeUtil.parseDateString("28 April 2017, 11pm");
        LocalDateTime recurUntilEndDate = DateTimeUtil.parseDateString("11 April 2017, 2pm");
        command = ADD + taskDescription + FROM + from + TO + to + REPEAT + recurFrequencyString
                + REPEAT_UNTIL + recurUntilEndDate;
        commandBox.runCommand(command);
        Task task2 = new Task(taskDescription, from, to);
        task2.setRecurring(recurUntilEndDate, recurFrequencyString);
        assertTrue(areTasksShown(task1, task2));
    }

    @Test
    public void addRecurringTaskWithWrongParams_shouldThrowException() {
        // Recurring event with empty repeat
        String taskDescription = "shower";
        LocalDateTime from = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        LocalDateTime to = DateTimeUtil.parseDateString("15 Mar 2017, 1pm");
        String recurFrequencyString = "";
        String command = ADD + taskDescription + REPEAT + recurFrequencyString
                + FROM + from + TO + to;
        Task task = null;
        try {
            commandBox.runCommand(command);
            task = new Task(taskDescription, from, to);
            task.setRecurring(recurFrequencyString);
            fail("Should not reach here since recurring task must have a repeat frequency.");
        } catch (IllegalArgumentException illegalArgumentException) {
            assertTrue(illegalArgumentException.getMessage().equals(ILLEGAL_ARGUMENT_EXCEPTION_4.getMessage()));
        }
        assertTrue(isTaskShown(task));

        // Recurring event with two repeats
        recurFrequencyString = "weekly yearly";
        command = ADD + taskDescription + REPEAT + recurFrequencyString
                + FROM + from + TO + to;
        Task task2 = null;
        try {
            commandBox.runCommand(command);
            task2 = new Task(taskDescription, from, to);
            task2.setRecurring(recurFrequencyString);
            fail("Should not reach here since recurring task must have only one repeat frequency.");
        } catch (IllegalArgumentException illegalArgumentException) {
            assertTrue(illegalArgumentException.getMessage().equals(ILLEGAL_ARGUMENT_EXCEPTION_4.getMessage()));
        }
        assertTrue(isTaskShown(task2));
    }

    @Test
    public void addEventWithMultipleParameters_testResultMessage() {
        String command = ADD + "get a life";
        commandBox.runCommand(command);
        assertResultMessage("Added task at index 3:\n" +
                "- Task type: \"TASK\"\n" +
                "- Description: \"get a life\"\n" +
                "- Priority: \"LOW\"");

        LocalDateTime from = DateTimeUtil.parseDateString("5 May 2017, 9pm");
        LocalDateTime to = DateTimeUtil.parseDateString("5 May 2017, 10pm");
        LocalDateTime recurUntil = DateTimeUtil.parseDateString("5 May 2019, 10pm");
        command = ADD + "write code" + FROM + from + TO + to + PRIORITY + "high" + TAGS + "hello world"
                + REPEAT + "weekly" + REPEAT_UNTIL + recurUntil;
        commandBox.runCommand(command);
        assertResultMessage("Added task at index 1:\n" +
                "- Task type: \"EVENT\"\n" +
                "- Description: \"write code\"\n" +
                "- Start date: \"Fri, 05 May 2017 09:00 PM\"\n" +
                "- End date: \"Fri, 05 May 2017 10:00 PM\"\n" +
                "- Priority: \"HIGH\"\n" +
                "- Repeat: \"WEEKLY\"\n" +
                "- Repeat until: \"Sun, 05 May 2019 10:00 PM\"\n" +
                "- Tags: \"hello world\"");
    }

    @Test
    public void addTaskAfterSwitching() {
        String clearCommand = "clear";
        commandBox.runCommand(clearCommand);
        String switchCommand = "switch t";
        commandBox.runCommand(switchCommand);
        String taskDescription = "get a life";
        String addCommand = ADD + taskDescription;
        Task task = new Task(taskDescription);
        commandBox.runCommand(addCommand);

        assertEquals(tabBar.getHighlightedTabText(), "TODAY (0/1)");
        assertFalse(isTaskShown(task));
    }
}
```
###### /java/guitests/DeleteTaskCommandTest.java
``` java
package guitests;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.junit.Before;
import org.junit.Test;

import seedu.toluist.commons.util.DateTimeUtil;
import seedu.toluist.model.Task;
import seedu.toluist.model.TodoList;
import seedu.toluist.testutil.TypicalTestTodoLists;
import seedu.toluist.ui.UiStore;

/**
 * Gui tests for delete task command
 */
public class DeleteTaskCommandTest extends ToLuistGuiTest {
    @Before
    public void setUp() {
        String switchToDefaulTab = "switch i";
        commandBox.runCommand(switchToDefaulTab);
    }

    @Test
    public void deleteTask() {
        Task task = new TypicalTestTodoLists().getTypicalTasks()[0];
        String command = "delete 1";
        commandBox.runCommand(command);
        assertFalse(isTaskShown(task));
    }

    @Test
    public void deleteMultipleTasksIndividually() {
        // Start with empty list
        commandBox.runCommand("delete 2");
        commandBox.runCommand("delete 1");

        // add one task
        String taskDescription = "do homework for Melvin";
        String command = "add " + taskDescription;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription);

        // add task with deadline
        String taskDescription2 = "get v0.2 ready";
        LocalDateTime endDate2 = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        String command2 = "add " + taskDescription2 + " by/" + endDate2;
        commandBox.runCommand(command2);
        Task task2 = new Task(taskDescription2, endDate2);

        // add event
        String taskDescription3 = "attend CS2103T tutorial";
        LocalDateTime startDate3 = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        LocalDateTime endDate3 = DateTimeUtil.parseDateString("15 Mar 2017, 1pm");
        String command3 = "add " + taskDescription3 + " from/" + startDate3 + " to/" + endDate3;
        commandBox.runCommand(command3);
        Task task3 = new Task(taskDescription3, startDate3, endDate3);

        assertTrue(areTasksShown(task, task2, task3));

        commandBox.runCommand("delete 3");
        assertFalse(isTaskShown(task));
        assertTrue(areTasksShown(task2, task3));

        commandBox.runCommand("delete 1");
        assertFalse(isTaskShown(task));
        assertFalse(isTaskShown(task2));
        assertTrue(isTaskShown(task3));

        commandBox.runCommand("delete 1");
        assertFalse(isTaskShown(task));
        assertFalse(isTaskShown(task2));
        assertFalse(isTaskShown(task3));
    }

    @Test
    public void testInvalidIndexInput() {
        String command = "delete 0";
        commandBox.runCommand(command);
        assertResultMessage("No valid index found.");

        command = "delete potato";
        commandBox.runCommand(command);
        assertResultMessage("No valid index found.");
    }

    public void deleteMultipleTasksTogether(String deleteCommand, int listSize, int... taskIndexesLeft) {
        // Start with empty list
        commandBox.runCommand("delete 2");
        commandBox.runCommand("delete 1");

        for (int i = 1; i <= listSize; i++) {
            String command = "add task " + i;
            commandBox.runCommand(command);
        }

        // Use shallow copy of task list so it doesn't mutate upon calling delete command
        List<Task> allTasks = (List<Task>) UiStore.getInstance().getShownTasks().clone();

        commandBox.runCommand(deleteCommand);

        Set<Integer> setOfTaskIndexLeft = new HashSet<Integer>();
        for (int taskIndex: taskIndexesLeft) {
            setOfTaskIndexLeft.add(taskIndex);
        }

        for (int i = 1; i <= listSize; i++) {
            // If task index exist in the set, that particular task should be shown in the UI.
            if (setOfTaskIndexLeft.contains(i)) {
                assertTrue(isTaskShown(allTasks.get(i - 1)));
            } else {
                assertFalse(isTaskShown(allTasks.get(i - 1)));
            }
        }
    }

    @Test
    public void deleteMultipleTasksTogether1() {
        String command = "delete  - 2, 4 -  5, 7    9- ";
        deleteMultipleTasksTogether(command, 10, 3, 6, 8);
    }

    @Test
    public void findThenDeleteTasksThenList() {
        String findCommand = "find lewis";
        commandBox.runCommand(findCommand);

        String deleteCommand = "delete -";
        commandBox.runCommand(deleteCommand);

        String listCommand = "list";
        commandBox.runCommand(listCommand);

        TodoList todoList = new TypicalTestTodoLists().getTypicalTodoList();
        assertTrue(isTaskShown(todoList.getTasks().get(1)));
        assertFalse(isTaskShown(todoList.getTasks().get(0)));
    }


    @Test
    public void switchThenDeleteTasksThenSwitchBack() {
        String addCommand = "add tomorrow by/Tomorrow 1:12pm";
        commandBox.runCommand(addCommand);

        String switchCommand = "switch 3";
        commandBox.runCommand(switchCommand);

        String deleteCommand = "delete 1";
        commandBox.runCommand(deleteCommand);

        String switchAgainCommand = "switch 1";
        commandBox.runCommand(switchAgainCommand);

        TodoList todoList = new TypicalTestTodoLists().getTypicalTodoList();
        assertTrue(areTasksShown(todoList.getTasks().get(0), todoList.getTasks().get(1)));
    }

    @Test
    public void deleteMultipleRecurringTaskMultipleTimes() {
        // add recurring floating task, will recur until end date is due.
        String taskDescription = "do homework for Melvin";
        String recurFrequencyString = "daily";
        LocalDateTime recurUntilEndDate = DateTimeUtil.parseDateString("15 May 2018, 12pm");
        String command = "add " + taskDescription + " repeat/" + recurFrequencyString
                       + " repeatuntil/" + recurUntilEndDate;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription);
        task.setRecurring(recurUntilEndDate, recurFrequencyString);
        assertTrue(isTaskShown(task));

        // add task with deadline, can recur once and then get deleted
        String taskDescription2 = "get v0.4 ready";
        String recurFrequencyString2 = "monthly";
        LocalDateTime endDate2 = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        LocalDateTime recurUntilEndDate2 = DateTimeUtil.parseDateString("30 Apr 2017, 12pm");
        String command2 = "add " + taskDescription2 + " by/" + endDate2 + " repeat/" + recurFrequencyString2
                + " repeatuntil/" + recurUntilEndDate2;
        commandBox.runCommand(command2);
        Task task2 = new Task(taskDescription2, endDate2);
        task2.setRecurring(recurUntilEndDate2, recurFrequencyString2);
        assertTrue(isTaskShown(task2));

        // add event, can recur 0 times and then get deleted
        String taskDescription3 = "attend CS2103T tutorial";
        String recurFrequencyString3 = "weekly";
        LocalDateTime startDate3 = DateTimeUtil.parseDateString("24 Mar 2017, 12pm");
        LocalDateTime endDate3 = DateTimeUtil.parseDateString("24 Mar 2017, 1pm");
        LocalDateTime recurUntilEndDate3 = DateTimeUtil.parseDateString("28 Mar 2017, 1pm");
        String command3 = "add " + taskDescription3 + " from/" + startDate3 + " to/" + endDate3
                        + " repeat/" + recurFrequencyString3 + " repeatuntil/" + recurUntilEndDate3;
        commandBox.runCommand(command3);
        Task task3 = new Task(taskDescription3, startDate3, endDate3);
        task3.setRecurring(recurUntilEndDate3, recurFrequencyString3);
        assertTrue(isTaskShown(task3));

        String deleteAllCommand = "delete -";
        commandBox.runCommand(deleteAllCommand);
        assertTrue(isTaskShown(task));
        assertFalse(isTaskShown(task2));
        assertFalse(isTaskShown(task3));
        task2.updateToNextRecurringTask();
        task3.updateToNextRecurringTask();
        assertTrue(isTaskShown(task2));
        assertFalse(isTaskShown(task3)); // recurring task reached end date, so it got deleted

        commandBox.runCommand(deleteAllCommand);
        assertTrue(isTaskShown(task));
        assertFalse(isTaskShown(task2));
        assertFalse(isTaskShown(task3));
        task2.updateToNextRecurringTask();
        task3.updateToNextRecurringTask();
        assertFalse(isTaskShown(task2)); // recurring task reached end date, so it got deleted for real
        assertFalse(isTaskShown(task3));
    }
}
```
###### /java/guitests/MarkCommandTest.java
``` java
    @Test
    public void markMultipleRecurringTaskAsCompletedMultipleTimes() {
        // add recurring floating task, will recur until end date is due.
        String taskDescription = "do homework for Melvin";
        String recurFrequencyString = "daily";
        LocalDateTime recurUntilEndDate = DateTimeUtil.parseDateString("15 May 2018, 12pm");
        String command = "add " + taskDescription + " repeat/" + recurFrequencyString
                       + " repeatuntil/" + recurUntilEndDate;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription);
        task.setRecurring(recurUntilEndDate, recurFrequencyString);
        assertTrue(isTaskShown(task));

        // add task with deadline, can recur once and then get deleted
        String taskDescription2 = "get v0.4 ready";
        String recurFrequencyString2 = "monthly";
        LocalDateTime endDate2 = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        LocalDateTime recurUntilEndDate2 = DateTimeUtil.parseDateString("30 Apr 2017, 12pm");
        String command2 = "add " + taskDescription2 + " by/" + endDate2 + " repeat/" + recurFrequencyString2
                + " repeatuntil/" + recurUntilEndDate2;
        commandBox.runCommand(command2);
        Task task2 = new Task(taskDescription2, endDate2);
        task2.setRecurring(recurUntilEndDate2, recurFrequencyString2);
        assertTrue(isTaskShown(task2));

        // add event, can recur 0 times and then get deleted
        String taskDescription3 = "attend CS2103T tutorial";
        String recurFrequencyString3 = "weekly";
        LocalDateTime startDate3 = DateTimeUtil.parseDateString("24 Mar 2017, 12pm");
        LocalDateTime endDate3 = DateTimeUtil.parseDateString("24 Mar 2017, 1pm");
        LocalDateTime recurUntilEndDate3 = DateTimeUtil.parseDateString("28 Mar 2017, 1pm");
        String command3 = "add " + taskDescription3 + " from/" + startDate3 + " to/" + endDate3
                        + " repeat/" + recurFrequencyString3 + " repeatuntil/" + recurUntilEndDate3;
        commandBox.runCommand(command3);
        Task task3 = new Task(taskDescription3, startDate3, endDate3);
        task3.setRecurring(recurUntilEndDate3, recurFrequencyString3);
        assertTrue(isTaskShown(task3));

        String deleteAllCommand = "mark complete -";
        commandBox.runCommand(deleteAllCommand);
        assertTrue(isTaskShown(task));
        assertFalse(isTaskShown(task2));
        assertFalse(isTaskShown(task3));
        task2.updateToNextRecurringTask();
        task3.updateToNextRecurringTask();
        assertTrue(isTaskShown(task2));
        assertFalse(isTaskShown(task3)); // recurring task reached end date, so it got deleted

        commandBox.runCommand(deleteAllCommand);
        assertTrue(isTaskShown(task));
        assertFalse(isTaskShown(task2));
        assertFalse(isTaskShown(task3));
        task2.updateToNextRecurringTask();
        task3.updateToNextRecurringTask();
        assertFalse(isTaskShown(task2)); // recurring task reached end date, so it got deleted for real
        assertFalse(isTaskShown(task3));
    }

    @Test
    public void markRecurringEventAsCompleted_endingThirtyFirstOfTheMonth() {
        // add event
        String taskDescription = "attend CS2103T tutorial";
        String recurFrequencyString = "monthly";
        LocalDateTime startDate = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        LocalDateTime endDate = DateTimeUtil.parseDateString("31 Mar 2017, 1pm");
        String command = "add " + taskDescription + " from/" + startDate + " to/" + endDate
                        + " repeat/" + recurFrequencyString;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription, startDate, endDate);
        task.setRecurring(recurFrequencyString);
        assertTrue(isTaskShown(task));

        command = "mark complete -";
        commandBox.runCommand(command);
        assertFalse(isTaskShown(task));
        LocalDateTime newStartDate = startDate.plusDays(61);
        LocalDateTime newEndDate = endDate.plusDays(61);
        Task task2 = new Task(taskDescription, newStartDate, newEndDate);
        task2.setRecurring(recurFrequencyString);
        assertTrue(isTaskShown(task2));
    }
}
```
###### /java/guitests/UpdateTaskCommandTest.java
``` java
package guitests;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;

import org.junit.Before;
import org.junit.Test;

import seedu.toluist.commons.util.DateTimeUtil;
import seedu.toluist.model.Tag;
import seedu.toluist.model.Task;
import seedu.toluist.model.Task.TaskPriority;
import seedu.toluist.testutil.TypicalTestTodoLists;

/**
 * Gui tests for update task command
 */
public class UpdateTaskCommandTest extends ToLuistGuiTest {
    private static final String ADD = "add ";
    private static final String UPDATE = "update ";
    private static final String FROM = " from/";
    private static final String TO = " to/";
    private static final String BY = " by/";
    private static final String FLOATING = " floating/";
    private static final String TAGS = " tags/";
    private static final String PRIORITY = " priority/";
    private static final String REPEAT = " repeat/";
    private static final String REPEAT_UNTIL = " repeatuntil/";
    private static final String STOP_REPEATING = " stoprepeating/";

    private static Tag tag1 = new Tag("tag1");
    private static Tag tag2 = new Tag("tag2");
    private static Tag tag3 = new Tag("tag3");

    @Before
    public void setUp() {
        String switchToDefaultTab = "switch i";
        commandBox.runCommand(switchToDefaultTab);
    }

    @Test
    public void testInvalidIndexInput() {
        String command = UPDATE + " 0 " + "description";
        commandBox.runCommand(command);
        assertResultMessage("No valid index found.");

        command = UPDATE + " 3 " + "description";
        commandBox.runCommand(command);
        assertResultMessage("No valid index found.");

        command = UPDATE + " potato " + "description";
        commandBox.runCommand(command);
        assertResultMessage("No valid index found.");
    }

    @Test
    public void updateFloatingTask() {
        // update description
        Task task = new TypicalTestTodoLists().getTypicalTasks()[0];
        String newDescription = "do homework for Melvin";
        String command = UPDATE + " 1 " + newDescription;
        task.setDescription(newDescription);
        commandBox.runCommand(command);
        assertFalse(isTaskShown(new TypicalTestTodoLists().getTypicalTasks()[0]));
        assertTrue(isTaskShown(task));

        // update tags
        command = UPDATE + "2" + TAGS + "tag2";
        commandBox.runCommand(command);
        Task task2 = new Task(newDescription);
        task2.replaceTags(new ArrayList<>(Arrays.asList(tag2)));
        assertFalse(isTaskShown(task));
        assertTrue(isTaskShown(task2));

        // update tags with new tags
        command = UPDATE + "2" + TAGS + "tag1 tag3" + PRIORITY + "high";
        commandBox.runCommand(command);
        Task task3 = new Task(newDescription);
        task3.setTaskPriority(TaskPriority.HIGH);
        task3.replaceTags(new ArrayList<>(Arrays.asList(tag1, tag3)));
        assertFalse(isTaskShown(task));
        assertFalse(isTaskShown(task2));
        assertTrue(isTaskShown(task3));
    }

    @Test
    public void updateTaskWithDeadline() {
        int eventIndex = 1;

        // add task with deadline
        String taskDescription = "get v0.2 ready";
        LocalDateTime endDate = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        String command = ADD + taskDescription + BY + endDate;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription, endDate);
        assertTrue(isTaskShown(task));

        // update task deadline
        LocalDateTime newEndDate = DateTimeUtil.parseDateString("22 Mar 2017, 11am");
        command = UPDATE + eventIndex + BY + newEndDate;
        commandBox.runCommand(command);
        Task task2 = new Task(taskDescription, newEndDate);
        assertFalse(isTaskShown(task));
        assertTrue(isTaskShown(task2));

        // update task description
        String newTaskDescription = "complete v0.2";
        command = UPDATE + eventIndex + " " + newTaskDescription + PRIORITY + "high";
        commandBox.runCommand(command);
        Task task3 = new Task(newTaskDescription, newEndDate);
        task3.setTaskPriority(TaskPriority.HIGH);
        assertFalse(isTaskShown(task));
        assertFalse(isTaskShown(task2));
        assertTrue(isTaskShown(task3));

        // update all parameters for task with deadline and tags
        String newerTaskDescription = "get v0.2 ready";
        LocalDateTime newerEndDate = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        command = UPDATE + eventIndex + " " + newerTaskDescription + BY + newerEndDate +
                PRIORITY + "low" + TAGS + "tag1 tag3";
        commandBox.runCommand(command);
        Task task4 = new Task(newerTaskDescription, null, newerEndDate);
        task4.replaceTags(new ArrayList<>(Arrays.asList(tag1, tag3)));
        assertFalse(isTaskShown(task));
        assertFalse(isTaskShown(task2));
        assertFalse(isTaskShown(task3));
        assertTrue(isTaskShown(task4));
    }

    @Test
    public void updateEvents() {
        int eventIndex = 1;

        // add event
        String taskDescription = "attend CS2103T tutorial";
        LocalDateTime startDate = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        LocalDateTime endDate = DateTimeUtil.parseDateString("15 Mar 2017, 1pm");
        String command = ADD + taskDescription + FROM + startDate + TO + endDate;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription, startDate, endDate);
        assertTrue(isTaskShown(task));

        // update event start date and end date
        LocalDateTime newStartDate = DateTimeUtil.parseDateString("22 Mar 2017, 12pm");
        LocalDateTime newEndDate = DateTimeUtil.parseDateString("22 Mar 2017, 1pm");
        command = UPDATE + eventIndex + FROM + newStartDate + TO + newEndDate + PRIORITY + "high";
        commandBox.runCommand(command);
        Task task2 = new Task(taskDescription, newStartDate, newEndDate);
        task2.setTaskPriority(TaskPriority.HIGH);
        assertFalse(isTaskShown(task));
        assertTrue(isTaskShown(task2));

        // update event description
        String newTaskDescription = "participate in CS2103 tutorial";
        command = UPDATE + eventIndex + " " + newTaskDescription;
        commandBox.runCommand(command);
        Task task3 = new Task(newTaskDescription, newStartDate, newEndDate);
        task3.setTaskPriority(TaskPriority.HIGH);
        assertFalse(isTaskShown(task));
        assertFalse(isTaskShown(task2));
        assertTrue(isTaskShown(task3));

        // update all parameters for event (and test tags, startdate and enddate not in order)
        String newerTaskDescription = "attend CS2103T tutorial";
        LocalDateTime newerStartDate = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        LocalDateTime newerEndDate = DateTimeUtil.parseDateString("15 Mar 2017, 1pm");
        command = UPDATE + eventIndex + " " + newerTaskDescription +
                  PRIORITY + "low" + TO + newerEndDate + TAGS + "tag1" + FROM + newerStartDate;
        commandBox.runCommand(command);
        Task task4 = new Task(newerTaskDescription, newerStartDate, newerEndDate);
        task4.replaceTags(new ArrayList<>(Arrays.asList(tag1)));
        assertFalse(isTaskShown(task));
        assertFalse(isTaskShown(task2));
        assertFalse(isTaskShown(task3));
        assertTrue(isTaskShown(task4));
    }

    @Test
    public void updateTaskToADuplicatedTask_shouldNotBeUpdated() {
        String taskDescription = "yet another task";
        String command = ADD + taskDescription;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription);

        taskDescription = "task";
        command = ADD + taskDescription;
        commandBox.runCommand(command);
        Task task2 = new Task(taskDescription);
        assertTrue(areTasksShown(task, task2));

        command = UPDATE + " 3 " + taskDescription;
        commandBox.runCommand(command);
        assertTrue(areTasksShown(task, task2));
        assertResultMessage("Task provided already exist in the list.");

        command = UPDATE + " 4 " + taskDescription;
        commandBox.runCommand(command);
        assertTrue(areTasksShown(task, task2));
        assertResultMessage("Task provided already exist in the list.");
    }

    @Test
    public void updateMultipleTypeTask_shouldNotBeUpdated() {
        int eventIndex = 1;

        String taskDescription = "attend CS2103T tutorial";
        LocalDateTime startDate = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        LocalDateTime endDate = DateTimeUtil.parseDateString("15 Mar 2017, 1pm");
        LocalDateTime endDate2 = DateTimeUtil.parseDateString("15 Mar 2017, 5pm");
        String command = ADD + taskDescription + FROM + startDate + TO + endDate;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription, startDate, endDate);
        assertTrue(isTaskShown(task));

        // Update to both event, and floating task
        command = UPDATE + eventIndex + FLOATING + FROM + startDate + TO + endDate;
        commandBox.runCommand(command);
        assertTrue(isTaskShown(task));

        // Update to both event, and task with deadline
        command = UPDATE + eventIndex + FROM + startDate + TO + endDate + BY + endDate2;
        commandBox.runCommand(command);
        assertTrue(isTaskShown(task));

        // Update to both floating task, and task with deadline
        command = UPDATE + eventIndex + FLOATING + BY + endDate2;
        commandBox.runCommand(command);
        assertTrue(isTaskShown(task));

        // Update to all floating task, task with deadline, event
        command = UPDATE + eventIndex + BY + endDate2 + FROM + startDate + TO + endDate + FLOATING;
        commandBox.runCommand(command);
        assertTrue(isTaskShown(task));
    }

    @Test
    public void updateFloatingTaskToEvent() {
        int eventIndex = 1;

        String taskDescription = "attend CS2103T tutorial";
        LocalDateTime startDate = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        LocalDateTime endDate = DateTimeUtil.parseDateString("15 Mar 2017, 1pm");
        String command = ADD + taskDescription;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription);
        assertTrue(isTaskShown(task));

        // Event
        command = UPDATE + eventIndex + FROM + startDate + TO + endDate;
        commandBox.runCommand(command);
        Task task2 = new Task(taskDescription, startDate, endDate);
        assertFalse(isTaskShown(task));
        assertTrue(isTaskShown(task2));
    }

    @Test
    public void updateFloatingTaskToTaskWithDeadline() {
        int eventIndex = 1;

        String taskDescription = "attend CS2103T tutorial";
        LocalDateTime endDate2 = DateTimeUtil.parseDateString("15 Mar 2017, 5pm");
        String command = ADD + taskDescription;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription);
        assertTrue(isTaskShown(task));

        // Task with deadline
        command = UPDATE + eventIndex + BY + endDate2;
        commandBox.runCommand(command);
        Task task2 = new Task(taskDescription, endDate2);
        assertFalse(isTaskShown(task));
        assertTrue(isTaskShown(task2));
    }

    @Test
    public void updateTaskWithDeadlineToFloatingTask() {
        int eventIndex = 1;

        String taskDescription = "attend CS2103T tutorial";
        LocalDateTime endDate2 = DateTimeUtil.parseDateString("15 Mar 2017, 5pm");
        String command = ADD + taskDescription + BY + endDate2;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription, endDate2);
        assertTrue(isTaskShown(task));

        // Floating task
        command = UPDATE + eventIndex + FLOATING;
        commandBox.runCommand(command);
        Task task2 = new Task(taskDescription);
        assertFalse(isTaskShown(task));
        assertTrue(isTaskShown(task2));
    }

    @Test
    public void updateTaskWithDeadlineToEvent() {
        int eventIndex = 1;

        String taskDescription = "attend CS2103T tutorial";
        LocalDateTime startDate = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        LocalDateTime endDate = DateTimeUtil.parseDateString("15 Mar 2017, 1pm");
        LocalDateTime endDate2 = DateTimeUtil.parseDateString("15 Mar 2017, 5pm");
        String command = ADD + taskDescription + BY + endDate2;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription, endDate2);
        assertTrue(isTaskShown(task));

        // Task with deadline to event
        command = UPDATE + eventIndex + FROM + startDate + TO + endDate;
        commandBox.runCommand(command);
        Task task2 = new Task(taskDescription, startDate, endDate);
        assertFalse(isTaskShown(task));
        assertTrue(isTaskShown(task2));
    }

    @Test
    public void updateEventToFloatingTask() {
        int eventIndex = 1;

        String taskDescription = "attend CS2103T tutorial";
        LocalDateTime startDate = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        LocalDateTime endDate = DateTimeUtil.parseDateString("15 Mar 2017, 1pm");
        String command = ADD + taskDescription + FROM + startDate + TO + endDate;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription, startDate, endDate);
        assertTrue(isTaskShown(task));

        // Event to floating task
        command = UPDATE + eventIndex + FLOATING;
        commandBox.runCommand(command);
        Task task2 = new Task(taskDescription);
        assertFalse(isTaskShown(task));
        assertTrue(isTaskShown(task2));
    }

    @Test
    public void updateEventToTaskWithDeadline() {
        int eventIndex = 1;

        String taskDescription = "attend CS2103T tutorial";
        LocalDateTime startDate = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        LocalDateTime endDate = DateTimeUtil.parseDateString("15 Mar 2017, 1pm");
        LocalDateTime endDate2 = DateTimeUtil.parseDateString("15 Mar 2017, 5pm");
        String command = ADD + taskDescription + FROM + startDate + TO + endDate;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription, startDate, endDate);
        assertTrue(isTaskShown(task));

        // Event to task with deadline
        command = UPDATE + eventIndex + BY + endDate2;
        commandBox.runCommand(command);
        Task task2 = new Task(taskDescription, endDate2);
        assertFalse(isTaskShown(task));
        assertTrue(isTaskShown(task2));
    }

    @Test
    public void updateTaskAfterMarkingComplete() {
        String markCompleteCommand = "mark 1";
        commandBox.runCommand(markCompleteCommand);

        // update description
        Task task = new TypicalTestTodoLists().getTypicalTasks()[1];
        String newDescription = "do homework for Melvin";
        String updateCommand = UPDATE + " 1 " + newDescription;
        task.setDescription(newDescription);
        commandBox.runCommand(updateCommand);
        assertFalse(isTaskShown(new TypicalTestTodoLists().getTypicalTasks()[1]));
        assertTrue(isTaskShown(task));
    }

    @Test
    public void updateTaskWithInvalidPriorityLevel_shouldNotBeUpdated() {
        int eventIndex = 1;

        String taskDescription = "attend CS2103T tutorial";
        String command = ADD + taskDescription;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription);
        assertTrue(isTaskShown(task));

        command = UPDATE + eventIndex + PRIORITY + "high low";
        commandBox.runCommand(command);
        assertTrue(isTaskShown(task));

        command = UPDATE + eventIndex + PRIORITY;
        commandBox.runCommand(command);
        assertTrue(isTaskShown(task));
    }

    @Test
    public void updateRecurringEventToRecurringFloatingTask() {
        int eventIndex = 1;

        String taskDescription = "attend CS2103T tutorial";
        String recurFrequencyString = "weekly";
        LocalDateTime from = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        LocalDateTime to = DateTimeUtil.parseDateString("15 Mar 2017, 1pm");
        String command = ADD + taskDescription + FROM + from + TO + to + REPEAT + recurFrequencyString;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription, from, to);
        task.setRecurring(recurFrequencyString);
        assertTrue(isTaskShown(task));

        command = UPDATE + eventIndex + FLOATING;
        commandBox.runCommand(command);
        Task task2 = new Task(taskDescription);
        task2.setRecurring(recurFrequencyString);
        assertFalse(isTaskShown(task));
        assertTrue(isTaskShown(task2));
    }

    @Test
    public void updateNonRecurringFloatingTaskToRecurringEvent() {
        int eventIndex = 1;

        String taskDescription = "attend CS2103T tutorial";
        String command = ADD + taskDescription;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription);
        assertTrue(isTaskShown(task));

        LocalDateTime from = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        LocalDateTime to = DateTimeUtil.parseDateString("15 Mar 2017, 1pm");
        String recurFrequencyString = "weekly";
        command = UPDATE + eventIndex + FROM + from + TO + to + REPEAT + recurFrequencyString;
        commandBox.runCommand(command);
        Task task2 = new Task(taskDescription, from, to);
        task2.setRecurring(recurFrequencyString);
        assertFalse(isTaskShown(task));
        assertTrue(isTaskShown(task2));
    }

    @Test
    public void updateNonRecurringEventToRecurringEvent() {
        int eventIndex = 1;

        String taskDescription = "attend CS2103T tutorial";
        LocalDateTime from = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        LocalDateTime to = DateTimeUtil.parseDateString("15 Mar 2017, 1pm");
        String command = ADD + taskDescription + FROM + from + TO + to;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription, from, to);
        assertTrue(isTaskShown(task));

        String recurFrequencyString = "monthly";
        LocalDateTime recurEndDate = DateTimeUtil.parseDateString("15 Mar 2018, 1pm");
        command = UPDATE + eventIndex + REPEAT + recurFrequencyString + REPEAT_UNTIL + recurEndDate;
        commandBox.runCommand(command);
        Task task2 = new Task(taskDescription, from, to);
        task2.setRecurring(recurEndDate, recurFrequencyString);
        assertFalse(isTaskShown(task));
        assertTrue(isTaskShown(task2));
    }

    @Test
    public void updateNonRecurringEventToRecurringTaskWithDeadline() {
        int eventIndex = 1;

        String taskDescription = "attend CS2103T tutorial";
        LocalDateTime from = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        LocalDateTime to = DateTimeUtil.parseDateString("15 Mar 2017, 1pm");
        String command = ADD + taskDescription + FROM + from + TO + to;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription, from, to);
        assertTrue(isTaskShown(task));

        String recurFrequencyString = "yearly";
        LocalDateTime recurEndDate = DateTimeUtil.parseDateString("15 Mar 2020, 1pm");
        command = UPDATE + eventIndex + BY + to
                + REPEAT + recurFrequencyString + REPEAT_UNTIL + recurEndDate;
        commandBox.runCommand(command);
        Task task2 = new Task(taskDescription, to);
        task2.setRecurring(recurEndDate, recurFrequencyString);
        assertFalse(isTaskShown(task));
        assertTrue(isTaskShown(task2));
    }

    @Test
    public void updateRecurringTaskWithDeadlineToNonRecurringTaskWithDeadline() {
        int eventIndex = 1;

        String taskDescription = "attend CS2103T tutorial";
        String recurFrequencyString = "daily";
        LocalDateTime to = DateTimeUtil.parseDateString("15 Mar 2017, 1pm");
        String command = ADD + taskDescription + BY + to + REPEAT + recurFrequencyString;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription, to);
        task.setRecurring(recurFrequencyString);
        assertTrue(isTaskShown(task));

        command = UPDATE + eventIndex + STOP_REPEATING;
        commandBox.runCommand(command);
        Task task2 = new Task(taskDescription, to);
        assertFalse(isTaskShown(task));
        assertTrue(isTaskShown(task2));
    }

    @Test
    public void updateRecurringEventToNonRecurringTaskWithDeadline() {
        int eventIndex = 1;

        String taskDescription = "attend CS2103T tutorial";
        String recurFrequencyString = "weekly";
        LocalDateTime from = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        LocalDateTime to = DateTimeUtil.parseDateString("15 Mar 2017, 1pm");
        String command = ADD + taskDescription + FROM + from + TO + to + REPEAT + recurFrequencyString;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription, from, to);
        task.setRecurring(recurFrequencyString);
        assertTrue(isTaskShown(task));

        command = UPDATE + eventIndex + BY + to + STOP_REPEATING;
        commandBox.runCommand(command);
        Task task2 = new Task(taskDescription, to);
        assertFalse(isTaskShown(task));
        assertTrue(isTaskShown(task2));
    }

    @Test
    public void updateRecurringEventToNonRecurringFloatingTask() {
        int eventIndex = 1;

        String taskDescription = "attend CS2103T tutorial";
        String recurFrequencyString = "weekly";
        LocalDateTime from = DateTimeUtil.parseDateString("15 Mar 2017, 12pm");
        LocalDateTime to = DateTimeUtil.parseDateString("15 Mar 2017, 1pm");
        String command = ADD + taskDescription + FROM + from + TO + to + REPEAT + recurFrequencyString;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription, from, to);
        task.setRecurring(recurFrequencyString);
        assertTrue(isTaskShown(task));

        command = UPDATE + eventIndex + FLOATING + STOP_REPEATING;
        commandBox.runCommand(command);
        Task task2 = new Task(taskDescription);
        assertFalse(isTaskShown(task));
        assertTrue(isTaskShown(task2));
    }

    @Test
    public void updateRecurringTask_invalidParams_shouldNotUpdate() {
        int eventIndex = 1;

        String taskDescription = "shower";
        String recurFrequencyString = "daily";
        String command = ADD + taskDescription + REPEAT + recurFrequencyString;
        commandBox.runCommand(command);
        Task task = new Task(taskDescription);
        task.setRecurring(recurFrequencyString);
        assertTrue(isTaskShown(task));

        command = UPDATE + eventIndex + STOP_REPEATING + REPEAT + recurFrequencyString;
        commandBox.runCommand(command);
        assertTrue(isTaskShown(task));
        assertResultMessage("Input contains both recurring and stop recurring arguments at the same time.");

        LocalDateTime recurEndDate = DateTimeUtil.parseDateString("15 Mar 2020, 1pm");
        command = UPDATE + eventIndex + STOP_REPEATING + REPEAT_UNTIL + recurEndDate;
        commandBox.runCommand(command);
        assertTrue(isTaskShown(task));
        assertResultMessage("Input contains both recurring and stop recurring arguments at the same time.");
    }

    @Test
    public void updateTaskWithMultipleParameters_testResultMessage() {
        int index = 1;

        LocalDateTime from = DateTimeUtil.parseDateString("5 May 2017, 9pm");
        LocalDateTime to = DateTimeUtil.parseDateString("5 May 2017, 10pm");
        LocalDateTime recurUntil = DateTimeUtil.parseDateString("5 May 2019, 10pm");
        String command = UPDATE + index + " write code" + FROM + from + TO + to + PRIORITY + "high"
                + TAGS + "hello world" + REPEAT + "weekly" + REPEAT_UNTIL + recurUntil;
        commandBox.runCommand(command);
        assertResultMessage("Updated task at index 1:\n" +
            "- Task type: \"TASK\" to \"EVENT\"\n" +
            "- Description: \"clean the house while Lewis is gone\" to \"write code\"\n" +
            "- Start date: \"\" to \"Fri, 05 May 2017 09:00 PM\"\n" +
            "- End date: \"\" to \"Fri, 05 May 2017 10:00 PM\"\n" +
            "- Priority: \"LOW\" to \"HIGH\"\n" +
            "- Repeat: \"\" to \"WEEKLY\"\n" +
            "- Repeat until: \"\" to \"Sun, 05 May 2019 10:00 PM\"\n" +
            "- Tags: \"lewis work\" to \"hello world\"");

        command = UPDATE + index + FLOATING + TAGS + STOP_REPEATING;
        commandBox.runCommand(command);
        assertResultMessage("Updated task at index 1:\n" +
                "- Task type: \"EVENT\" to \"TASK\"\n" +
                "- Start date: \"Fri, 05 May 2017 09:00 PM\" to \"\"\n" +
                "- End date: \"Fri, 05 May 2017 10:00 PM\" to \"\"\n" +
                "- Repeat: \"WEEKLY\" to \"\"\n" +
                "- Repeat until: \"Sun, 05 May 2019 10:00 PM\" to \"\"");
    }


    @Test
    public void updateTaskAfterSwitching() {
        String clearCommand = "clear";
        commandBox.runCommand(clearCommand);
        String switchCommand = "switch t";
        commandBox.runCommand(switchCommand);
        String addCommand = ADD + "sth sth" + BY + "today";
        commandBox.runCommand(addCommand);
        int index = 1;
        String taskDescription = "get a life";
        String updateCommand = UPDATE + index + " " + taskDescription;
        commandBox.runCommand(updateCommand);

        assertEquals(tabBar.getHighlightedTabText(), "TODAY (1/1)");
    }
}
```
###### /java/seedu/toluist/commons/util/DateTimeUtilTest.java
``` java
    @Test
    public void isSameLocalDateTime() {
        String stringDate;
        LocalDateTime localDateTime1;
        LocalDateTime localDateTime2;

        // convert a fully specified date time to local date time
        stringDate = "31 Mar 2017, 5:24pm";
        localDateTime1 = DateTimeUtil.parseDateString(stringDate);
        localDateTime2 = LocalDateTime.of(2017, Month.MARCH, 31, 17, 24);
        assertTrue(datesApproximatelyEqual(localDateTime1, localDateTime2));

        stringDate = "31 Mar 2017, 5am";
        localDateTime1 = DateTimeUtil.parseDateString(stringDate);
        localDateTime2 = LocalDateTime.of(2017, Month.MARCH, 31, 5, 0);
        assertTrue(datesApproximatelyEqual(localDateTime1, localDateTime1));

        // convert a fully specified date to local date time
        stringDate = "31 Mar 2017";
        localDateTime1 = DateTimeUtil.parseDateString(stringDate);
        localDateTime2 = LocalDateTime.of(2017, Month.MARCH, 31,
                LocalDateTime.now().getHour(), LocalDateTime.now().getMinute());
        assertTrue(datesApproximatelyEqual(localDateTime1, localDateTime2));

        // convert an unclear date time to local date time
        stringDate = "now";
        localDateTime1 = DateTimeUtil.parseDateString(stringDate);
        localDateTime2 = LocalDateTime.now();
        assertTrue(datesApproximatelyEqual(localDateTime1, localDateTime2));

        stringDate = "3 hours from now";
        localDateTime1 = DateTimeUtil.parseDateString(stringDate);
        localDateTime2 = LocalDateTime.now();
        localDateTime2 = localDateTime2.plus(3, ChronoUnit.HOURS);
        assertTrue(datesApproximatelyEqual(localDateTime1, localDateTime2));

        stringDate = "tomorrow";
        localDateTime1 = DateTimeUtil.parseDateString(stringDate);
        localDateTime2 = LocalDateTime.now();
        localDateTime2 = localDateTime2.plus(1, ChronoUnit.DAYS);
        assertTrue(datesApproximatelyEqual(localDateTime1, localDateTime2));

        stringDate = "next week";
        localDateTime1 = DateTimeUtil.parseDateString(stringDate);
        localDateTime2 = LocalDateTime.now();
        localDateTime2 = localDateTime2.plus(1, ChronoUnit.WEEKS);
        assertTrue(datesApproximatelyEqual(localDateTime1, localDateTime2));

        stringDate = "next month";
        localDateTime1 = DateTimeUtil.parseDateString(stringDate);
        localDateTime2 = LocalDateTime.now();
        localDateTime2 = localDateTime2.plus(1, ChronoUnit.MONTHS);
        assertTrue(datesApproximatelyEqual(localDateTime1, localDateTime2));

        stringDate = "next year";
        localDateTime1 = DateTimeUtil.parseDateString(stringDate);
        localDateTime2 = LocalDateTime.now();
        localDateTime2 = localDateTime2.plus(1, ChronoUnit.YEARS);
        assertTrue(datesApproximatelyEqual(localDateTime1, localDateTime2));
    }

    @Test
    public void dateTimeIsNull() {
        String stringDate;
        LocalDateTime localDateTime;

        localDateTime = DateTimeUtil.parseDateString(null);
        assertTrue(localDateTime == null);

        stringDate = "buy banana";
        localDateTime = DateTimeUtil.parseDateString(stringDate);
        assertTrue(localDateTime == null);
    }

```
###### /java/seedu/toluist/commons/util/DateTimeUtilTest.java
``` java
    private boolean datesApproximatelyEqual(LocalDateTime localDateTime1, LocalDateTime localDateTime2) {
        // Dates are approximately equal so long as they are accurate up to the minute.
        return localDateTime1.getYear() == localDateTime2.getYear()
                && localDateTime1.getMonth() == localDateTime2.getMonth()
                && localDateTime1.getDayOfMonth() == localDateTime2.getDayOfMonth()
                && localDateTime1.getHour() == localDateTime2.getHour()
                && localDateTime1.getMinute() == localDateTime2.getMinute();
    }
}
```
###### /java/seedu/toluist/controller/commons/IndexParserTest.java
``` java
package seedu.toluist.controller.commons;

import static org.junit.Assert.assertTrue;

import java.util.Arrays;
import java.util.List;

import org.junit.Test;

public class IndexParserTest {
    //---------------- Tests for splitIndexes --------------------------------------

    @Test
    public void splitIndexes_obtainSingleIndex() {
        List<Integer> actual = IndexParser.splitStringToIndexes(" 3  ", 8);
        List<Integer> expected = Arrays.asList(3);
        assertTrue(actual.equals(expected));
    }

    @Test
    public void splitIndexes_obtainIndexesToEndIndex() {
        List<Integer> actual = IndexParser.splitStringToIndexes(" - 3", 8);
        List<Integer> expected = Arrays.asList(1, 2, 3);
        assertTrue(actual.equals(expected));
    }

    @Test
    public void splitIndexes_obtainIndexesFromStartIndex() {
        List<Integer> actual = IndexParser.splitStringToIndexes(" 3 -", 8);
        List<Integer> expected = Arrays.asList(3, 4, 5, 6, 7, 8);
        assertTrue(actual.equals(expected));
    }

    @Test
    public void splitIndexes_obtainIndexesFromStartIndexToEndIndex() {
        List<Integer> actual = IndexParser.splitStringToIndexes("3-5", 8);
        List<Integer> expected = Arrays.asList(3, 4, 5);
        assertTrue(actual.equals(expected));
    }

    @Test
    public void splitIndexes_obtainIndexesFromPoorlyFormattedStringIndexes() {
        List<Integer> actual = IndexParser.splitStringToIndexes("1-2  ,    3-   4   5  -6   , 7   -      8", 8);
        List<Integer> expected = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8);
        assertTrue(actual.equals(expected));
    }

    @Test
    public void splitIndexes_obtainIndexesFromAssortedIndexes() {
        List<Integer> actual = IndexParser.splitStringToIndexes("1 3,  7", 8);
        List<Integer> expected = Arrays.asList(1, 3, 7);
        assertTrue(actual.equals(expected));
    }

    @Test
    public void splitIndexes_obtainIndexesFromAssortedUnorderedIndexes1() {
        List<Integer> actual = IndexParser.splitStringToIndexes("3, 2, 8, 5-7", 8);
        List<Integer> expected = Arrays.asList(2, 3, 5, 6, 7, 8);
        assertTrue(actual.equals(expected));
    }

    @Test
    public void splitIndexes_obtainIndexesFromAssortedUnorderedIndexes2() {
        List<Integer> actual = IndexParser.splitStringToIndexes("7, - 3", 8);
        List<Integer> expected = Arrays.asList(1, 2, 3, 7);
        assertTrue(actual.equals(expected));
    }

    @Test
    public void splitIndexes_obtainIndexesComplexStringIndexes() {
        List<Integer> actual = IndexParser.splitStringToIndexes("- 3, 5, 7 - 12", 8);
        List<Integer> expected = Arrays.asList(1, 2, 3, 5, 7, 8);
        assertTrue(actual.equals(expected));
    }

    @Test
    public void splitIndexes_withInvalidIndex1() {
        List<Integer> actual = IndexParser.splitStringToIndexes("banana", 8);
        List<Integer> expected = Arrays.asList();
        assertTrue(actual.equals(expected));
    }

    @Test
    public void splitIndexes_withInvalidIndex2() {
        List<Integer> actual = IndexParser.splitStringToIndexes("-3 banana 5", 8);
        List<Integer> expected = Arrays.asList(1, 2, 3);
        assertTrue(actual.equals(expected));
    }

    @Test
    public void splitIndexes_withInvalidIndex3() {
        List<Integer> actual = IndexParser.splitStringToIndexes("-3 5 banana", 8);
        List<Integer> expected = Arrays.asList(1, 2, 3, 5);
        assertTrue(actual.equals(expected));
    }

    @Test
    public void splitIndexes_withInvalidIndex4() {
        List<Integer> actual = IndexParser.splitStringToIndexes("-3, banana, 5", 8);
        List<Integer> expected = Arrays.asList(1, 2, 3, 5);
        assertTrue(actual.equals(expected));
    }

    @Test
    public void splitIndexes_withInvalidIndex5() {
        List<Integer> actual = IndexParser.splitStringToIndexes("-3, 5, banana", 8);
        List<Integer> expected = Arrays.asList(1, 2, 3, 5);
        assertTrue(actual.equals(expected));
    }
}
```
###### /java/seedu/toluist/controller/commons/KeywordTokenizerTest.java
``` java
package seedu.toluist.controller.commons;

import static org.junit.Assert.assertTrue;

import java.util.HashMap;

import org.junit.Test;

public class KeywordTokenizerTest {
    //---------------- Tests for tokenize --------------------------------------

    @Test
    public void tokenize_allNullValues() {
        HashMap<String, String> actual = KeywordTokenizer.tokenize(null, null, (String[]) null);
        HashMap<String, String> expected = new HashMap<String, String>();
        assertTrue(actual.equals(expected));
    }

    @Test
    public void tokenize_onlyDescriptionGiven() {
        HashMap<String, String> actual = KeywordTokenizer.tokenize("Description", null, (String[]) null);
        HashMap<String, String> expected = new HashMap<String, String>();
        assertTrue(actual.equals(expected));
    }

    @Test
    public void tokenize_onlyDefaultKeywordGiven() {
        HashMap<String, String> actual = KeywordTokenizer.tokenize(null, "default", (String[]) null);
        HashMap<String, String> expected = new HashMap<String, String>();
        assertTrue(actual.equals(expected));
    }

    @Test
    public void tokenize_onlyOneNonDefaultKeywordGiven() {
        String[] keywords = {"non-default"};
        HashMap<String, String> actual = KeywordTokenizer.tokenize(null, null, keywords);
        HashMap<String, String> expected = new HashMap<String, String>();
        assertTrue(actual.equals(expected));
    }

    @Test
    public void tokenize_descriptionAndDefaultKeywordGiven() {
        HashMap<String, String> actual = KeywordTokenizer.tokenize("description", "default");
        HashMap<String, String> expected = new HashMap<String, String>();
        expected.put("default", "description");
        assertTrue(actual.equals(expected));
    }

    @Test
    public void tokenize_descriptionAndNonMatchingNonDefaultKeywordsGiven() {
        HashMap<String, String> actual = KeywordTokenizer.tokenize("description", null, "non-default");
        HashMap<String, String> expected = new HashMap<String, String>();
        assertTrue(actual.equals(expected));
    }

    @Test
    public void tokenize_descriptionAndMatchingNonDefaultKeywordsGiven() {
        HashMap<String, String> actual = KeywordTokenizer.tokenize("non default description", null, "non default");
        HashMap<String, String> expected = new HashMap<String, String>();
        expected.put("non default", "description");
        assertTrue(actual.equals(expected));
    }

    @Test
    public void tokenize_updateTaskCommandCaseSensitive() {
        String description = "update v0.3 to/next wednesday tags/ohno tag manysubtasks from/today floating/";
        HashMap<String, String> actual = KeywordTokenizer.tokenize(description, "description", "from/",
                                                                                               "to/",
                                                                                               "by/",
                                                                                               "floating/",
                                                                                               "tags/");
        HashMap<String, String> expected = new HashMap<String, String>();
        expected.put("description", "update v0.3");
        expected.put("from/", "today");
        expected.put("to/", "next wednesday");
        expected.put("tags/", "ohno tag manysubtasks");
        expected.put("floating/", "");
        assertTrue(actual.equals(expected));
    }

    @Test
    public void tokenize_updateTaskCommandCaseInsensitive() {
        String description = "update v0.3 to/next wednesday tAgS/ohno tag manysubtasks frOM/today floating/";
        HashMap<String, String> actual = KeywordTokenizer.tokenize(description, "description", "from/",
                                                                                               "to/",
                                                                                               "by/",
                                                                                               "floating/",
                                                                                               "tags/");
        HashMap<String, String> expected = new HashMap<String, String>();
        expected.put("description", "update v0.3");
        expected.put("from/", "today");
        expected.put("to/", "next wednesday");
        expected.put("tags/", "ohno tag manysubtasks");
        expected.put("floating/", "");
        assertTrue(actual.equals(expected));
    }
}
```
###### /java/seedu/toluist/controller/commons/TagParserTest.java
``` java
package seedu.toluist.controller.commons;

import static org.junit.Assert.assertTrue;

import java.util.Arrays;
import java.util.Set;
import java.util.TreeSet;

import org.junit.Test;

import seedu.toluist.model.Tag;

public class TagParserTest {
    //---------------- Tests for parseTags --------------------------------------

    @Test
    public void parseTags_emptyTag() {
        Set<Tag> actual = TagParser.parseTags("   ");
        Set<Tag> expected = new TreeSet<>(Arrays.asList());
        assertTrue(actual.equals(expected));
    }

    @Test
    public void parseTags_singleTag() {
        Set<Tag> actual = TagParser.parseTags("  yoohoo   ");
        Set<Tag> expected = new TreeSet<>(Arrays.asList(new Tag("yoohoo")));
        assertTrue(actual.equals(expected));
    }

    @Test
    public void parseTags_multipleTags() {
        Set<Tag> actual = TagParser.parseTags("  yoohoo lololol   wheeeeeee     ");
        Set<Tag> expected = new TreeSet<>(Arrays.asList(new Tag("yoohoo"), new Tag("lololol"),
                new Tag("wheeeeeee")));
        assertTrue(actual.equals(expected));
    }
}
```
###### /java/seedu/toluist/model/TodoListTest.java
``` java
package seedu.toluist.model;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.when;

import java.util.Arrays;
import java.util.List;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnit;
import org.mockito.junit.MockitoRule;

import seedu.toluist.commons.exceptions.DataStorageException;
import seedu.toluist.storage.TodoListStorage;
import seedu.toluist.testutil.TestUtil;
import seedu.toluist.testutil.TypicalTestTodoLists;

/**
 * Tests for TodoList model
 */
public class TodoListTest {
```
###### /java/seedu/toluist/model/TodoListTest.java
``` java
    @Test
    public void testEquals() {
        TodoList todoList2 = new TodoList();
        todoList2.add(task1);
        todoList2.add(task2);
        todoList2.add(task3);
        todoList2.add(task4);
        assertTrue(todoList1.equals(todoList1));
        assertTrue(todoList1.equals(todoList2));
    }

    @Test
    public void testNotEquals() {
        TodoList todoList2 = new TodoList();
        todoList2.add(task1);
        todoList2.add(task2);
        todoList2.add(task3);
        TodoList todoList3 = new TodoList();
        todoList2.add(task1);
        todoList2.add(task3);
        todoList2.add(task2);
        assertFalse(todoList1.equals(todoList2));
        assertFalse(todoList2.equals(todoList3));
    }

    @Test
    public void testGetAllTasks() {
        List<Task> actual = todoList1.getTasks();
        List<Task> expected = Arrays.asList(task1, task2, task3, task4);
        assertTrue(actual.equals(expected));
    }

    @Test
    public void testAddDuplicatedTask() {
        todoList1.add(task1);
        List<Task> actual = todoList1.getTasks();
        List<Task> expected = Arrays.asList(task1, task2, task3, task4);
        assertTrue(actual.equals(expected));
    }

    @Test
    public void testAddNewTask() {
        todoList1.add(task5);
        List<Task> actual = todoList1.getTasks();
        List<Task> expected = Arrays.asList(task1, task2, task3, task4, task5);
        assertTrue(actual.equals(expected));
    }

    @Test
    public void testRemoveExistingTask() {
        todoList1.remove(task2);
        List<Task> actual = todoList1.getTasks();
        List<Task> expected = Arrays.asList(task1, task3, task4);
        assertTrue(actual.equals(expected));
    }

    @Test
    public void testRemoveNonExistingTask() {
        todoList1.remove(task5);
        List<Task> actual = todoList1.getTasks();
        List<Task> expected = Arrays.asList(task1, task2, task3, task4);
        assertTrue(actual.equals(expected));
    }
}
```
