# A0148038A
###### /java/guitests/AddCommandTest.java
``` java
/*
 * GUI test for AddCommand
 */
public class AddCommandTest extends WhatsLeftGuiTest {

    @Test
    public void addEvent() {
        //add one event
        TestEvent[] currentEventList = te.getTypicalEvents();
        TestEvent eventToAdd = te.consultation;
        currentEventList = TestUtil.addEventsToList(currentEventList, eventToAdd);
        assertAddEventSuccess(eventToAdd, currentEventList);

        //add another event
        eventToAdd = te.workshop;
        currentEventList = TestUtil.addEventsToList(currentEventList, eventToAdd);
        assertAddEventSuccess(eventToAdd, currentEventList);

        //add duplicate event
        commandBox.runCommand(eventToAdd.getAddCommand());
        assertResultMessage(AddCommand.MESSAGE_DUPLICATE_ACTIVITY);
        assertTrue(eventListPanel.isListMatching(TestUtil.getFilteredTestEvents(currentEventList)));

        //add a clashed event
        eventToAdd = te.clashedWorkshop;
        currentEventList = TestUtil.addEventsToList(currentEventList, eventToAdd);
        assertAddEventSuccess(eventToAdd, currentEventList);
        assertResultMessage("New event added but with possible clash! : " + eventToAdd.getAsText());

        //add an event with invalid end date time
        commandBox.runCommand("add CS2102 Demostration st/0800 sd/060717 et/0900 ed/050717");
        assertResultMessage(AddCommand.MESSAGE_ILLEGAL_EVENT_END_DATETIME);

        //add to empty list
        commandBox.runCommand("clear ev");
        currentEventList = TestUtil.removeEventsFromList(currentEventList, currentEventList);
        eventToAdd = te.presentation;
        currentEventList = TestUtil.addEventsToList(currentEventList, eventToAdd);
        assertAddEventSuccess(eventToAdd, currentEventList);

        //case insensitive command
        eventToAdd = te.consultation;
        commandBox.runCommand("aDD MA2101 Consultation st/1000 sd/270817 et/1100 l/S17");
        currentEventList = TestUtil.addEventsToList(currentEventList, eventToAdd);
        assertTrue(eventListPanel.isListMatching(TestUtil.getFilteredTestEvents(currentEventList)));

        //invalid command
        commandBox.runCommand("adds invalid event");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);

    }

    @Test
    public void addTask() {
        //add one task
        TestTask[] currentTaskList = tt.getTypicalTasks();
        TestTask taskToAdd = tt.homework;
        currentTaskList = TestUtil.addTasksToList(currentTaskList, taskToAdd);
        assertAddTaskSuccess(taskToAdd, currentTaskList);

        //add another task
        taskToAdd = tt.cycling;
        currentTaskList = TestUtil.addTasksToList(currentTaskList, taskToAdd);
        assertAddTaskSuccess(taskToAdd, currentTaskList);

        //add duplicate task
        commandBox.runCommand(taskToAdd.getAddCommand());
        assertResultMessage(AddCommand.MESSAGE_DUPLICATE_ACTIVITY);
        assertTrue(taskListPanel.isListMatching(TestUtil.getFilteredTestTasks(currentTaskList)));

        //add to empty list
        commandBox.runCommand("clear ts");
        currentTaskList = TestUtil.removeTasksFromList(currentTaskList, currentTaskList);
        currentTaskList = TestUtil.addTasksToList(currentTaskList, taskToAdd);
        assertAddTaskSuccess(taskToAdd, currentTaskList);

        //case insensitive command
        taskToAdd = tt.homework;
        commandBox.runCommand("aDD MA2101 HW p/high bt/1100 bd/270617 l/S17 ta/homework");
        currentTaskList = TestUtil.addTasksToList(currentTaskList, taskToAdd);
        assertTrue(taskListPanel.isListMatching(TestUtil.getFilteredTestTasks(currentTaskList)));

        //invalid command
        commandBox.runCommand("adds invalid task");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    private void assertAddEventSuccess(TestEvent eventToAdd, TestEvent... currentList) {
        commandBox.runCommand(eventToAdd.getAddCommand());

        //confirm the new card contains the right data
        EventCardHandle addedCard = eventListPanel.navigateToEvent(eventToAdd.getAsText());
        assertMatchingEvent(eventToAdd, addedCard);

        //confirm the list now contains all previous events plus the new event
        TestEvent[] filteredEventList = TestUtil.getFilteredTestEvents(currentList);
        assertTrue(eventListPanel.isListMatching(filteredEventList));
    }

    private void assertAddTaskSuccess(TestTask taskToAdd, TestTask... currentList) {
        commandBox.runCommand(taskToAdd.getAddCommand());

        //confirm the new card contains the right data
        TaskCardHandle addedCard = taskListPanel.navigateToTask(taskToAdd.getAsText());
        assertMatchingTask(taskToAdd, addedCard);

        //confirm the list now contains all previous events plus the new task
        TestTask[] filteredTaskList = TestUtil.getFilteredTestTasks(currentList);
        assertTrue(taskListPanel.isListMatching(filteredTaskList));
    }

}
```
###### /java/guitests/ClearCommandTest.java
``` java
/*
 * GUI test for ClearCommand
 */
public class ClearCommandTest extends WhatsLeftGuiTest {

    @Test
    public void clearEvent() {
        //verify a non-empty event list can be cleared
        TestEvent[] currentEventList = te.getTypicalEvents();
        TestEvent[] filteredEventList = TestUtil.getFilteredTestEvents(currentEventList);
        assertTrue(eventListPanel.isListMatching(filteredEventList));
        assertClearEventCommandSuccess();

        //verify other commands can work after a clear event command
        currentEventList = TestUtil.removeEventsFromList(currentEventList, currentEventList);
        TestEvent eventToAdd = te.workshop;
        currentEventList = TestUtil.addEventsToList(currentEventList, eventToAdd);
        filteredEventList = TestUtil.getFilteredTestEvents(currentEventList);
        commandBox.runCommand(eventToAdd.getAddCommand());
        assertTrue(eventListPanel.isListMatching(filteredEventList));
        commandBox.runCommand("delete ev 1");
        assertEventListSize(0);

        //invalid command
        commandBox.runCommand("clear deadline");
        assertResultMessage("Invalid command format! \n" + ClearCommand.MESSAGE_USAGE);

        //verify clear command works when the list is empty
        assertClearEventCommandSuccess();
    }

    @Test
    public void clearTask() {
        //verify a non-empty task list can be cleared
        TestTask[] currentTaskList = tt.getTypicalTasks();
        TestTask[] filteredTaskList = TestUtil.getFilteredTestTasks(currentTaskList);
        assertTrue(taskListPanel.isListMatching(filteredTaskList));
        assertClearTaskCommandSuccess();

        //verify other commands can work after a clear task command
        currentTaskList = TestUtil.removeTasksFromList(currentTaskList, currentTaskList);
        TestTask taskToAdd = tt.homework;
        currentTaskList = TestUtil.addTasksToList(currentTaskList, taskToAdd);
        filteredTaskList = TestUtil.getFilteredTestTasks(currentTaskList);
        commandBox.runCommand(taskToAdd.getAddCommand());
        assertTrue(taskListPanel.isListMatching(filteredTaskList));
        commandBox.runCommand("delete ts 1");
        assertTaskListSize(0);

        //verify clear command works when the list is empty
        assertClearTaskCommandSuccess();
    }

    @Test
    public void clearAll() {
        //verify a non-empty WhatsLeft can be cleared
        TestEvent[] currentEventList = te.getTypicalEvents();
        TestEvent[] filteredEventList = TestUtil.getFilteredTestEvents(currentEventList);
        TestTask[] currentTaskList = tt.getTypicalTasks();
        TestTask[] filteredTaskList = TestUtil.getFilteredTestTasks(currentTaskList);
        assertTrue(eventListPanel.isListMatching(filteredEventList));
        assertTrue(taskListPanel.isListMatching(filteredTaskList));
        assertClearAllCommandSuccess();

        //verify other commands can work after a clear command
        //verify add and delete event works after a clear command
        currentEventList = TestUtil.removeEventsFromList(currentEventList, currentEventList);
        TestEvent eventToAdd = te.workshop;
        currentEventList = TestUtil.addEventsToList(currentEventList, eventToAdd);
        filteredEventList = TestUtil.getFilteredTestEvents(currentEventList);
        commandBox.runCommand(eventToAdd.getAddCommand());
        assertTrue(eventListPanel.isListMatching(filteredEventList));
        commandBox.runCommand("delete ev 1");
        assertEventListSize(0);

        //verify add and delete task works after a clear command
        currentTaskList = TestUtil.removeTasksFromList(currentTaskList, currentTaskList);
        TestTask taskToAdd = tt.homework;
        currentTaskList = TestUtil.addTasksToList(currentTaskList, taskToAdd);
        filteredTaskList = TestUtil.getFilteredTestTasks(currentTaskList);
        commandBox.runCommand(taskToAdd.getAddCommand());
        assertTrue(taskListPanel.isListMatching(filteredTaskList));
        commandBox.runCommand("delete ts 1");
        assertTaskListSize(0);

        //invalid command
        commandBox.runCommand("clear all");
        assertResultMessage("Invalid command format! \n" + ClearCommand.MESSAGE_USAGE);

        //verify clear command works when the list is empty
        assertClearAllCommandSuccess();
    }

    private void assertClearEventCommandSuccess() {
        commandBox.runCommand("clear ev");
        assertEventListSize(0);
        assertResultMessage("Event list in WhatsLeft has been cleared!");
    }

    private void assertClearTaskCommandSuccess() {
        commandBox.runCommand("clear ts");
        assertTaskListSize(0);
        assertResultMessage("Task list in WhatsLeft has been cleared!");
    }

    private void assertClearAllCommandSuccess() {
        commandBox.runCommand("clear");
        assertEventListSize(0);
        assertTaskListSize(0);
        assertResultMessage("WhatsLeft has been cleared!");
    }
}
```
###### /java/guitests/DeleteCommandTest.java
``` java
/*
 * GUI test for DeleteCommand
 */
public class DeleteCommandTest extends WhatsLeftGuiTest {

    @Test
    public void deleteEvent() {

        //delete the first in the event list
        TestEvent[] currentEventList =  TestUtil.getFilteredTestEvents(te.getTypicalEvents());
        TestEvent[] filteredEventList = TestUtil.getFilteredTestEvents(currentEventList);
        int targetIndex = 1;
        assertDeleteEventSuccess(targetIndex, filteredEventList);

        //delete the last in the event list
        filteredEventList = TestUtil.removeEventFromList(filteredEventList, targetIndex);
        targetIndex = filteredEventList.length;
        assertDeleteEventSuccess(targetIndex, filteredEventList);

        //delete from the middle of the event list
        filteredEventList = TestUtil.removeEventFromList(filteredEventList, targetIndex);
        targetIndex = filteredEventList.length / 2;
        assertDeleteEventSuccess(targetIndex, filteredEventList);

        //invalid index
        commandBox.runCommand("delete ev " + filteredEventList.length + 1);
        assertResultMessage("The Event index provided is invalid");

    }

    @Test
    public void deleteTask() {

        //delete the first in the task list
        TestTask[] currentTaskList =  TestUtil.getFilteredTestTasks(tt.getTypicalTasks());
        TestTask[] filteredTaskList = TestUtil.getFilteredTestTasks(currentTaskList);
        int targetIndex = 1;
        assertDeleteTaskSuccess(targetIndex, filteredTaskList);

        //delete the last in the task list
        filteredTaskList = TestUtil.removeTaskFromList(filteredTaskList, targetIndex);
        targetIndex = filteredTaskList.length;
        assertDeleteTaskSuccess(targetIndex, filteredTaskList);

        //delete from the middle of the task list
        filteredTaskList = TestUtil.removeTaskFromList(filteredTaskList, targetIndex);
        targetIndex = filteredTaskList.length / 2;
        assertDeleteTaskSuccess(targetIndex, filteredTaskList);

        //invalid index
        commandBox.runCommand("delete ts " + filteredTaskList.length + 1);
        assertResultMessage("The Task index provided is invalid");

    }

    /**
     * Runs the delete event command to delete the event at specified index and confirms the result is correct.
     * @param targetIndexOneIndexed e.g. index 1 to delete the first event in the event list,
     * @param currentList A copy of the current list of events (before deletion).
     */
    private void assertDeleteEventSuccess(int targetIndexOneIndexed, final TestEvent[] filteredEventList) {
        TestEvent eventToDelete = filteredEventList[targetIndexOneIndexed - 1]; // -1 as array uses zero indexing
        TestEvent[] expectedEventList = TestUtil.removeEventFromList(filteredEventList, targetIndexOneIndexed);
        TestEvent[] expectedFilteredEventList = TestUtil.getFilteredTestEvents(expectedEventList);

        commandBox.runCommand("delete ev " + targetIndexOneIndexed);

        //confirm the list now contains all previous events except the deleted event
        assertTrue(eventListPanel.isListMatching(expectedFilteredEventList));

        //confirm the result message is correct
        assertResultMessage(String.format(MESSAGE_DELETE_EVENT_SUCCESS, eventToDelete));
    }

    /**
     * Runs the delete event command to delete the task at specified index and confirms the result is correct.
     * @param targetIndexOneIndexed e.g. index 1 to delete the first task in the task list,
     * @param currentList A copy of the current list of tasks (before deletion).
     */
    private void assertDeleteTaskSuccess(int targetIndexOneIndexed, final TestTask[] filteredTaskList) {
        TestTask taskToDelete = filteredTaskList[targetIndexOneIndexed - 1]; // -1 as array uses zero indexing
        TestTask[] expectedTaskList = TestUtil.removeTaskFromList(filteredTaskList, targetIndexOneIndexed);
        TestTask[] expectedFilteredTaskList = TestUtil.getFilteredTestTasks(expectedTaskList);

        commandBox.runCommand("delete ts " + targetIndexOneIndexed);

        //confirm the list now contains all previous events except the deleted event
        assertTrue(taskListPanel.isListMatching(expectedFilteredTaskList));

        //confirm the result message is correct
        assertResultMessage(String.format(MESSAGE_DELETE_TASK_SUCCESS, taskToDelete));
    }

}
```
###### /java/guitests/EditCommandTest.java
``` java
/*
* GUI test for EditCommand
*/
public class EditCommandTest extends WhatsLeftGuiTest {

    // The list of events in the event list panel is expected to match this list.
    // This list is updated with every successful call to assertEditSuccess().
    TestEvent[] filteredEventList = TestUtil.getFilteredTestEvents(te.getTypicalEvents());

    // The list of tasks in the task list panel is expected to match this list.
    // This list is updated with every successful call to assertEditSuccess().
    TestTask[] filteredTaskList = TestUtil.getFilteredTestTasks(tt.getTypicalTasks());

    @Test
    public void editEventWithAllFieldsSpecified() throws Exception {
        String detailsToEdit = "CS2102 Demostration st/0900 sd/220617 et/1000 ed/220617 l/I Cube ta/demo";
        int filteredEventIndex = 1;
        int eventListPanelIndex = 1;
        TestEvent editedEvent = new EventBuilder().withDescription("CS2102 Demostration")
                 .withStartTime("0900").withStartDate("220617").withEndTime("1000").withEndDate("220617")
                .withLocation("I Cube").withTags("demo").build();

        assertEditEventSuccess(eventListPanelIndex, filteredEventIndex, detailsToEdit, editedEvent);
    }

    @Test
    public void editEventWithoutAllFieldsSpecified() throws Exception {
        String detailsToEdit = "l/NUS";

        //edit the last event in the event list
        int filteredEventIndex = filteredEventList.length;
        int eventListPanelIndex = filteredEventIndex;
        TestEvent eventToEdit = filteredEventList[filteredEventIndex - 1];
        TestEvent editedEvent = new EventBuilder(eventToEdit).withLocation("NUS").build();

        assertEditEventSuccess(eventListPanelIndex, filteredEventIndex, detailsToEdit, editedEvent);
    }

    @Test
    public void editEventClearTags() throws Exception {
        String detailsToEdit = "ta/";

        //edit the middle event in the event list
        int filteredEventIndex = filteredEventList.length / 2;
        int eventListPanelIndex = filteredEventIndex;
        TestEvent eventToEdit = filteredEventList[filteredEventIndex - 1];
        TestEvent editedEvent = new EventBuilder(eventToEdit).withTags().build();

        assertEditEventSuccess(eventListPanelIndex, filteredEventIndex, detailsToEdit, editedEvent);
    }

    @Test
    public void editEventWithInvalidEndDateTime() {
        //edit an event with invalid end date time
        commandBox.runCommand("edit ev 1 sd/060717 ed/050717");
        assertResultMessage(EditCommand.MESSAGE_ILLEGAL_EVENT_END_DATETIME);
    }

    @Test
    public void editEventToClash() {
        filteredEventList = TestUtil.addEventsToList(filteredEventList, te.workshop);
        commandBox.runCommand(te.workshop.getAddCommand());
        filteredEventList = TestUtil.getFilteredTestEvents(filteredEventList);
        commandBox.runCommand("edit ev 1 Latex Workshop st/0730 sd/280617 et/0930 ed/280617 l/YIH ta/");
        int filteredEventListIndex = 1;
        TestEvent editedEvent = te.clashedWorkshop;

        // confirm the new card contains the right data
        EventCardHandle editedCard = eventListPanel.navigateToEvent(editedEvent.getAsText());
        assertMatchingEvent(editedEvent, editedCard);

        // confirm the list now contains all previous events plus the event with updated details
        filteredEventList[filteredEventListIndex - 1] = editedEvent;
        filteredEventList = TestUtil.getFilteredTestEvents(filteredEventList);
        assertTrue(eventListPanel.isListMatching(filteredEventList));
        assertResultMessage(String.format(EditCommand.MESSAGE_EDIT_SUCCESS_CLASH, editedEvent));
    }

    @Test
    public void editEventAfterFind() throws Exception {
        commandBox.runCommand("find CS2103");

        String detailsToEdit = "l/Changi Airport";
        int filteredEventIndex = 2;
        int eventListPanelIndex = 1;
        TestEvent eventToEdit = filteredEventList[filteredEventIndex - 1];
        TestEvent editedEvent = new EventBuilder(eventToEdit).withLocation("Changi Airport").build();

        assertEditEventSuccess(eventListPanelIndex, filteredEventIndex, detailsToEdit, editedEvent);
    }

    @Test
    public void editWithoutTypeSpecified() {
        commandBox.runCommand("edit 1 l/NTU");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
    }

    @Test
    public void editWithInvalidIndex() {
        // invalid task index
        int invalidIndex = filteredEventList.length + 1;
        commandBox.runCommand("edit ev " + invalidIndex + " st/1200");
        assertResultMessage(Messages.MESSAGE_INVALID_EVENT_DISPLAYED_INDEX);

        // invalid task index
        invalidIndex = filteredTaskList.length + 1;
        commandBox.runCommand("edit ts " + invalidIndex + " bt/2230");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
    }

    @Test
    public void editWithNoFieldSpecified() {
        commandBox.runCommand("edit ev 1");
        assertResultMessage(EditCommand.MESSAGE_NOT_EDITED);

        commandBox.runCommand("edit ts 1 ");
        assertResultMessage(EditCommand.MESSAGE_NOT_EDITED);
    }

    @Test
    public void editEventWithInvalidValues() {
        commandBox.runCommand("edit ev 1 st/3000");
        assertResultMessage(StartTime.MESSAGE_STARTTIME_CONSTRAINTS);

        commandBox.runCommand("edit ev 1 ta/*");
        assertResultMessage(Tag.MESSAGE_TAG_CONSTRAINTS);
    }

    @Test
    public void editDuplicateEvent() {
        commandBox.runCommand("edit ev 1 CS2103 Tutorial st/0900 sd/280717 et/1000 ed/280717 l/COM1-B103 ta/demo");
        assertResultMessage(EditCommand.MESSAGE_DUPLICATE_EVENT);
    }

    @Test
    public void editTaskWithAllFieldsSpecified() throws Exception {
        String detailsToEdit = "CS2102 Project Report p/high bt/2200 bd/210617 l/IVLE ta/PDF";
        int filteredTaskIndex = 1;
        int taskListPanelIndex = filteredTaskIndex;
        TestTask editedTask = new TaskBuilder().withDescription("CS2102 Project Report")
                 .withPriority("high").withByTime("2200").withByDate("210617")
                 .withLocation("IVLE").withTags("PDF").build();

        assertEditTaskSuccess(taskListPanelIndex, filteredTaskIndex, detailsToEdit, editedTask);
    }

    @Test
    public void editTaskWithoutAllFieldsSpecified() throws Exception {
        String detailsToEdit = "bt/2330";

        //edit the last task in the task list
        int filteredTaskIndex = filteredTaskList.length;
        int taskListPanelIndex = filteredTaskIndex;
        TestTask taskToEdit = filteredTaskList[filteredTaskIndex - 1];
        TestTask editedTask = new TaskBuilder(taskToEdit).withByTime("2330").build();

        assertEditTaskSuccess(taskListPanelIndex, filteredTaskIndex, detailsToEdit, editedTask);
    }

    @Test
    public void editTaskWithInvalidValues() {
        commandBox.runCommand("edit ts 1 p/important");
        assertResultMessage(Priority.MESSAGE_PRIORITY_CONSTRAINTS);

        commandBox.runCommand("edit ts 1 bd/320917");
        assertResultMessage(ByDate.MESSAGE_BYDATE_CONSTRAINTS);
    }

    @Test
    public void editDuplicateTask() {
        //check command word case insensitive
        commandBox.runCommand("edit ts 1 LSM Project Report p/high bt/2300 bd/010517 l/IVLE ta/softcopy");
        assertResultMessage(EditCommand.MESSAGE_DUPLICATE_TASK);
    }

    /**
     * Checks whether the edited event has the correct updated details.
     *
     * @param panelListIndex index of task to edit in the current list shown in the event panel
     * @param filteredEventListIndex index of event to edit in filtered event list
     * @param detailsToEdit details to edit the event with as input to the edit command
     * @param editedEvent the expected event after editing the event's details
     */
    private void assertEditEventSuccess(int eventListPanelIndex, int filteredEventListIndex,
            String detailsToEdit, TestEvent editedEvent) {
        commandBox.runCommand("edit ev " + eventListPanelIndex + " " + detailsToEdit);

        // confirm the new card contains the right data
        EventCardHandle editedCard = eventListPanel.navigateToEvent(editedEvent.getAsText());
        assertMatchingEvent(editedEvent, editedCard);

        // confirm the list now contains all previous events plus the event with updated details
        filteredEventList[filteredEventListIndex - 1] = editedEvent;
        filteredEventList = TestUtil.getFilteredTestEvents(filteredEventList);
        assertTrue(eventListPanel.isListMatching(filteredEventList));
        assertResultMessage(String.format(EditCommand.MESSAGE_EDIT_EVENT_SUCCESS, editedEvent));
    }

    /**
     * Checks whether the edited task has the correct updated details.
     *
     * @param panelListIndex index of task to edit in the current list shown in task list panel
     * @param filteredTaskListIndex index of task to edit in filtered task list
     * @param detailsToEdit details to edit the event with as input to the edit command
     * @param editedTask the expected event after editing the task's details
     */
    private void assertEditTaskSuccess(int taskListPanelIndex, int filteredTaskListIndex,
            String detailsToEdit, TestTask editedTask) {
        commandBox.runCommand("edit ts " + taskListPanelIndex + " " + detailsToEdit);

        // confirm the new card contains the right data
        TaskCardHandle editedCard = taskListPanel.navigateToTask(editedTask.getAsText());
        assertMatchingTask(editedTask, editedCard);

        // confirm the list now contains all previous events plus the event with updated details
        filteredTaskList[filteredTaskListIndex - 1] = editedTask;
        filteredTaskList = TestUtil.getFilteredTestTasks(filteredTaskList);
        assertTrue(taskListPanel.isListMatching(filteredTaskList));
        assertResultMessage(String.format(EditCommand.MESSAGE_EDIT_TASK_SUCCESS, editedTask));
    }
}
```
###### /java/guitests/FindCommandTest.java
``` java
/*
* GUI test for FindCommand
*/
public class FindCommandTest extends WhatsLeftGuiTest {

    @Test
    public void findNonEmptyList() {
        assertFindResult("find play", new TestEvent[]{}, new TestTask[]{}); // no results
        assertFindResult("find project", new TestEvent[]{te.discussion}, new TestTask[]{tt.report}); // multiple results

        //find after list
        commandBox.runCommand("list");
        commandBox.runCommand("delete ts 3");
        assertFindResult("find project", new TestEvent[]{te.discussion}, new TestTask[]{});

        //find after deleting one result
        commandBox.runCommand("delete ev 1");
        assertFindResult("find project", new TestEvent[]{}, new TestTask[]{});
    }

    @Test
    public void findEmptyList() {
        commandBox.runCommand("clear");
        assertFindResult("find tutorial", new TestEvent[]{}, new TestTask[]{}); // no results
    }

    @Test
    public void findInvalidCommandFail() {
        commandBox.runCommand("findwhatsleft");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    private void assertFindResult(String command, TestEvent[] expectedEventList, TestTask[] expectedTaskList) {
        commandBox.runCommand(command);
        assertEventListSize(expectedEventList.length);
        assertTaskListSize(expectedTaskList.length);
        int numberOfActivities = expectedEventList.length + expectedTaskList.length;
        assertResultMessage(numberOfActivities + " activities listed!");
        assertTrue(eventListPanel.isListMatching(expectedEventList));
        assertTrue(taskListPanel.isListMatching(expectedTaskList));
    }

}
```
###### /java/guitests/guihandles/EventCardHandle.java
``` java
/**
 * Provides a handle to an event card in the event list panel.
 */
public class EventCardHandle extends GuiHandle {
    private static final String DESCRIPTION_FIELD_ID = "#description";
    private static final String DURATION_FIELD_ID = "#duration";
    private static final String LOCATION_FIELD_ID = "#locations";
    private static final String TAGS_FIELD_ID = "#tags";

    private Node node;

    public EventCardHandle(GuiRobot guiRobot, Stage primaryStage, Node node) {
        super(guiRobot, primaryStage, null);
        this.node = node;
    }

    protected String getTextFromLabel(String fieldId) {
        return getTextFromLabel(fieldId, node);
    }

    public String getDescription() {
        return getTextFromLabel(DESCRIPTION_FIELD_ID);
    }

    public String getDuration() {
        return getTextFromLabel(DURATION_FIELD_ID);
    }

    public String getLocation() {
        return getTextFromLabel(LOCATION_FIELD_ID);
    }

    public List<String> getTags() {
        return getTags(getTagsContainer());
    }

    private List<String> getTags(Region tagsContainer) {
        return tagsContainer
                .getChildrenUnmodifiable()
                .stream()
                .map(node -> ((Labeled) node).getText())
                .collect(Collectors.toList());
    }

    private List<String> getTags(UniqueTagList tags) {
        return tags
                .asObservableList()
                .stream()
                .map(tag -> tag.tagName)
                .collect(Collectors.toList());
    }

    private Region getTagsContainer() {
        return guiRobot.from(node).lookup(TAGS_FIELD_ID).query();
    }

    public boolean isSameEvent(ReadOnlyEvent event) {
        return getDescription().equals(event.getDescriptionToShow())
                && getDuration().equals(event.getDurationToShow())
                && getLocation().equals(event.getLocationToShow())
                && getTags().equals(event.getTagsToShow());
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof EventCardHandle) {
            EventCardHandle handle = (EventCardHandle) obj;
            return getDescription().equals(handle.getDescription())
                    && getDuration().equals(handle.getDuration())
                    && getLocation().equals(handle.getLocation())
                    && getTags().equals(handle.getTags());
        }
        return super.equals(obj);
    }

    @Override
    public String toString() {
        return getDescription() + " " + getDuration() + " " + getLocation() + " " + getTags();
    }
}
```
###### /java/guitests/guihandles/EventListPanelHandle.java
``` java
/**
 * Provides a handle for the panel containing the event list.
 */
public class EventListPanelHandle extends GuiHandle {

    public static final int NOT_FOUND = -1;
    public static final String CARD_PANE_ID = "#cardPane";

    private static final String EVENT_LIST_VIEW_ID = "#eventListView";

    public EventListPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    public List<ReadOnlyEvent> getSelectedEvents() {
        ListView<ReadOnlyEvent> eventList = getListView();
        return eventList.getSelectionModel().getSelectedItems();
    }

    public ListView<ReadOnlyEvent> getListView() {
        return getNode(EVENT_LIST_VIEW_ID);
    }

    /**
     * Returns true if the list is showing the event details correctly and in correct order.
     * @param events A list of event in the correct order.
     */
    public boolean isListMatching(ReadOnlyEvent... events) {
        return this.isListMatching(0, events);
    }

    /**
     * Returns true if the list is showing the event details correctly and in correct order.
     * @param startPosition The starting position of the sub list.
     * @param events A list of events in the correct order.
     */
    public boolean isListMatching(int startPosition, ReadOnlyEvent... events) throws IllegalArgumentException {
        if (events.length + startPosition != getListView().getItems().size()) {
            throw new IllegalArgumentException("List size mismatched\n" +
                    "Expected " + (getListView().getItems().size() - 1) + " events.\n"
                    + "Actually " + events.length + " events.");
        }
        assertTrue(this.containsInOrder(startPosition, events));
        for (int i = 0; i < events.length; i++) {
            final int scrollTo = i + startPosition;
            guiRobot.interact(() -> getListView().scrollTo(scrollTo));
            guiRobot.sleep(500);
            if (!TestUtil.compareCardAndEvent(getEventCardHandle(startPosition + i), events[i])) {
                return false;
            }
        }
        return true;
    }

    /**
     * Clicks on the ListView.
     */
    public void clickOnListView() {
        Point2D point = TestUtil.getScreenMidPoint(getListView());
        guiRobot.clickOn(point.getX(), point.getY());
    }

```
###### /java/guitests/guihandles/EventListPanelHandle.java
``` java
    /**
     * Returns true if the {@code activities} appear as the sub list (in that order) at position {@code startPosition}.
     */
    public boolean containsInOrder(int startPosition, ReadOnlyEvent... events) {
        List<ReadOnlyEvent> eventsInList = getListView().getItems();

        // Return false if the list in panel is too short to contain the given list
        if (startPosition + events.length > eventsInList.size()) {
            return false;
        }

        // Return false if any of the events doesn't match
        for (int i = 0; i < events.length; i++) {
            if (!eventsInList.get(startPosition + i).getAsText().equals(
                    events[i].getAsText())) {
                return false;
            }
        }

        return true;
    }

    public EventCardHandle navigateToEvent(String text) {
        guiRobot.sleep(500); //Allow a bit of time for the list to be updated
        final Optional<ReadOnlyEvent> event = getListView().getItems().stream()
                                                    .filter(p -> p.getAsText().equals(text))
                                                    .findAny();
        if (!event.isPresent()) {
            throw new IllegalStateException("Name not found: " + text);
        }

        return navigateToEvent(event.get());
    }

    /**
     * Navigates the listview to display and select the event.
     */
    public EventCardHandle navigateToEvent(ReadOnlyEvent event) {
        int index = getEventIndex(event);

        guiRobot.interact(() -> {
            getListView().scrollTo(index);
            guiRobot.sleep(150);
            getListView().getSelectionModel().select(index);
        });
        guiRobot.sleep(100);
        return getEventCardHandle(event);
    }


    /**
     * Returns the position of the event given, {@code NOT_FOUND} if not found in the list.
     */
    public int getEventIndex(ReadOnlyEvent targetEvent) {
        List<ReadOnlyEvent> eventsInList = getListView().getItems();
        for (int i = 0; i < eventsInList.size(); i++) {
            if (eventsInList.get(i).getDescription().equals(targetEvent.getDescription())) {
                return i;
            }
        }
        return NOT_FOUND;
    }

    /**
     * Gets an event from the list by index
     */
    public ReadOnlyEvent getEvent(int index) {
        return getListView().getItems().get(index);
    }

    public EventCardHandle getEventCardHandle(int index) {
        return getEventCardHandle(new Event(getListView().getItems().get(index)));
    }

    public EventCardHandle getEventCardHandle(ReadOnlyEvent event) {
        Set<Node> nodes = getAllCardNodes();
        Optional<Node> eventCardNode = nodes.stream()
                .filter(n -> new EventCardHandle(guiRobot, primaryStage, n).isSameEvent(event))
                .findFirst();
        if (eventCardNode.isPresent()) {
            return new EventCardHandle(guiRobot, primaryStage, eventCardNode.get());
        } else {
            return null;
        }
    }

    protected Set<Node> getAllCardNodes() {
        return guiRobot.lookup(CARD_PANE_ID).queryAll();
    }

    public int getNumberOfEvent() {
        return getListView().getItems().size();
    }
}
```
###### /java/guitests/guihandles/TaskCardHandle.java
``` java
/**
 * Provides a handle to a task card in the task list panel.
 */
public class TaskCardHandle extends GuiHandle {
    private static final String DESCRIPTION_FIELD_ID = "#description";
    private static final String PRIORITY_FIELD_ID = "#priority";
    private static final String DEADLINE_FIELD_ID = "#byTimeDate";
    private static final String LOCATION_FIELD_ID = "#locations";
    private static final String TAGS_FIELD_ID = "#tags";

    private Node node;

    public TaskCardHandle(GuiRobot guiRobot, Stage primaryStage, Node node) {
        super(guiRobot, primaryStage, null);
        this.node = node;
    }

    protected String getTextFromLabel(String fieldId) {
        return getTextFromLabel(fieldId, node);
    }

    public String getDescription() {
        return getTextFromLabel(DESCRIPTION_FIELD_ID);
    }

    public String getPriority() {
        return getTextFromLabel(PRIORITY_FIELD_ID);
    }

    public String getByTimeDate() {
        return getTextFromLabel(DEADLINE_FIELD_ID);
    }

    public String getLocation() {
        return getTextFromLabel(LOCATION_FIELD_ID);
    }

    public List<String> getTags() {
        return getTags(getTagsContainer());
    }

    private List<String> getTags(Region tagsContainer) {
        return tagsContainer
                .getChildrenUnmodifiable()
                .stream()
                .map(node -> ((Labeled) node).getText())
                .collect(Collectors.toList());
    }

    private List<String> getTags(UniqueTagList tags) {
        return tags
                .asObservableList()
                .stream()
                .map(tag -> tag.tagName)
                .collect(Collectors.toList());
    }

    private Region getTagsContainer() {
        return guiRobot.from(node).lookup(TAGS_FIELD_ID).query();
    }

    public boolean isSameTask(ReadOnlyTask task) {
        return getDescription().equals(task.getDescriptionToShow())
                && getPriority().equals(task.getPriorityToShow())
                && getByTimeDate().equals(task.getByTimeDateToShow())
                && getLocation().equals(task.getLocationToShow())
                && getTags().equals(task.getTagsToShow());
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof TaskCardHandle) {
            TaskCardHandle handle = (TaskCardHandle) obj;
            return getDescription().equals(handle.getDescription())
                    && getPriority().equals(handle.getPriority())
                    && getByTimeDate().equals(handle.getByTimeDate())
                    && getLocation().equals(handle.getLocation())
                    && getTags().equals(handle.getTags());
        }
        return super.equals(obj);
    }

    @Override
    public String toString() {
        return getDescription() + " " + getPriority() + " " + getByTimeDate() + " " + getLocation() + " " + getTags();
    }
}
```
###### /java/guitests/guihandles/TaskListPanelHandle.java
``` java
/**
 * Provides a handle for the panel containing the task list.
 */
public class TaskListPanelHandle extends GuiHandle {

    public static final int NOT_FOUND = -1;
    public static final String CARD_PANE_ID = "#cardPane";

    private static final String EVENT_LIST_VIEW_ID = "#taskListView";

    public TaskListPanelHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    public List<ReadOnlyTask> getSelectedTasks() {
        ListView<ReadOnlyTask> taskList = getListView();
        return taskList.getSelectionModel().getSelectedItems();
    }

    public ListView<ReadOnlyTask> getListView() {
        return getNode(EVENT_LIST_VIEW_ID);
    }

    /**
     * Returns true if the list is showing the task details correctly and in correct order.
     * @param tasks A list of task in the correct order.
     */
    public boolean isListMatching(ReadOnlyTask... tasks) {
        return this.isListMatching(0, tasks);
    }

    /**
     * Returns true if the list is showing the task details correctly and in correct order.
     * @param startPosition The starting position of the sub list.
     * @param tasks A list of tasks in the correct order.
     */
    public boolean isListMatching(int startPosition, ReadOnlyTask... tasks) throws IllegalArgumentException {
        if (tasks.length + startPosition != getListView().getItems().size()) {
            throw new IllegalArgumentException("List size mismatched\n" +
                    "Expected " + (getListView().getItems().size()) + " tasks.\n"
                    + "Actually " + tasks.length + " tasks.");
        }
        assertTrue(this.containsInOrder(startPosition, tasks));
        for (int i = 0; i < tasks.length; i++) {
            final int scrollTo = i + startPosition;
            guiRobot.interact(() -> getListView().scrollTo(scrollTo));
            guiRobot.sleep(200);
            if (!TestUtil.compareCardAndTask(getTaskCardHandle(startPosition + i), tasks[i])) {
                return false;
            }
        }
        return true;
    }

    /**
     * Clicks on the ListView.
     */
    public void clickOnListView() {
        Point2D point = TestUtil.getScreenMidPoint(getListView());
        guiRobot.clickOn(point.getX(), point.getY());
    }

    /**
     * Returns true if the {@code activities} appear as the sub list (in that order) at position {@code startPosition}.
     */
    public boolean containsInOrder(int startPosition, ReadOnlyTask... tasks) {
        List<ReadOnlyTask> tasksInList = getListView().getItems();

        // Return false if the list in panel is too short to contain the given list
        if (startPosition + tasks.length > tasksInList.size()) {
            return false;
        }

        // Return false if any of the activities doesn't match
        for (int i = 0; i < tasks.length; i++) {
            if (!tasksInList.get(startPosition + i).getAsText().equals(
                    tasks[i].getAsText())) {
                return false;
            }
        }

        return true;
    }

    public TaskCardHandle navigateToTask(String text) {
        guiRobot.sleep(500); //Allow a bit of time for the list to be updated
        final Optional<ReadOnlyTask> task = getListView().getItems().stream()
                                                    .filter(p -> p.getAsText().equals(text))
                                                    .findAny();
        if (!task.isPresent()) {
            throw new IllegalStateException("Name not found: " + text);
        }

        return navigateToTask(task.get());
    }

    /**
     * Navigates the listview to display and select the task.
     */
    public TaskCardHandle navigateToTask(ReadOnlyTask task) {
        int index = getTaskIndex(task);

        guiRobot.interact(() -> {
            getListView().scrollTo(index);
            guiRobot.sleep(150);
            getListView().getSelectionModel().select(index);
        });
        guiRobot.sleep(100);
        return getTaskCardHandle(task);
    }


    /**
     * Returns the position of the task given, {@code NOT_FOUND} if not found in the list.
     */
    public int getTaskIndex(ReadOnlyTask targetTask) {
        List<ReadOnlyTask> tasksInList = getListView().getItems();
        for (int i = 0; i < tasksInList.size(); i++) {
            if (tasksInList.get(i).getDescription().equals(targetTask.getDescription())) {
                return i;
            }
        }
        return NOT_FOUND;
    }

    /**
     * Gets an task from the list by index
     */
    public ReadOnlyTask getTask(int index) {
        return getListView().getItems().get(index);
    }

    public TaskCardHandle getTaskCardHandle(int index) {
        return getTaskCardHandle(new Task(getListView().getItems().get(index)));
    }

    public TaskCardHandle getTaskCardHandle(ReadOnlyTask task) {
        Set<Node> nodes = getAllCardNodes();
        Optional<Node> taskCardNode = nodes.stream()
                .filter(n -> new TaskCardHandle(guiRobot, primaryStage, n).isSameTask(task))
                .findFirst();
        if (taskCardNode.isPresent()) {
            return new TaskCardHandle(guiRobot, primaryStage, taskCardNode.get());
        } else {
            return null;
        }
    }

    protected Set<Node> getAllCardNodes() {
        return guiRobot.lookup(CARD_PANE_ID).queryAll();
    }

    public int getNumberOfTask() {
        return getListView().getItems().size();
    }
}
```
###### /java/guitests/HelpCommandTest.java
``` java
/*
* GUI test for HelpCommand
*/
public class HelpCommandTest extends WhatsLeftGuiTest {

    @Test
    public void helpWithoutCommandWord() {
        commandBox.runCommand("help");
        assertTrue(mainMenu.openHelpWindowUsingAccelerator().isWindowOpen());
        mainMenu.openHelpWindowUsingAccelerator().closeWindow();
    }

    @Test
    public void helpAdd() {
        commandBox.runCommand("help add");
        assertResultMessage(AddCommand.MESSAGE_USAGE);
    }

    @Test
    public void helpEdit() {
        commandBox.runCommand("help edit");
        assertResultMessage(EditCommand.MESSAGE_USAGE);
    }

    @Test
    public void helpSelect() {
        commandBox.runCommand("help select");
        assertResultMessage(SelectCommand.MESSAGE_USAGE);
    }

    @Test
    public void helpDelete() {
        commandBox.runCommand("help delete");
        assertResultMessage(DeleteCommand.MESSAGE_USAGE);
    }

    @Test
    public void helpClear() {
        commandBox.runCommand("help clear");
        assertResultMessage(ClearCommand.MESSAGE_USAGE);
    }

    @Test
    public void helpShow() {
        commandBox.runCommand("help show");
        assertResultMessage(ShowCommand.MESSAGE_USAGE);
    }

    @Test
    public void helpFind() {
        commandBox.runCommand("help find");
        assertResultMessage(FindCommand.MESSAGE_USAGE);
    }

    @Test
    public void helpFinish() {
        commandBox.runCommand("help finish");
        assertResultMessage(FinishCommand.MESSAGE_USAGE);
    }

    @Test
    public void helpRedo() {
        commandBox.runCommand("help redo");
        assertResultMessage(RedoCommand.MESSAGE_USAGE);
    }

    @Test
    public void helpSave() {
        commandBox.runCommand("help save");
        assertResultMessage(SaveCommand.MESSAGE_USAGE);
    }

    @Test
    public void helpRead() {
        commandBox.runCommand("help read");
        assertResultMessage(ReadCommand.MESSAGE_USAGE);
    }

    @Test
    public void helpNext() {
        commandBox.runCommand("help next");
        assertResultMessage(CalendarViewCommand.MESSAGE_USAGE);
    }

    @Test
    public void helpList() {
        commandBox.runCommand("help list");
        assertResultMessage(ListCommand.MESSAGE_USAGE);
    }

    @Test
    public void helpExit() {
        commandBox.runCommand("help exit");
        assertResultMessage(ExitCommand.MESSAGE_USAGE);
    }

    @Test
    public void helpUndo() {
        commandBox.runCommand("help undo");
        assertResultMessage(UndoCommand.MESSAGE_USAGE);
    }

    @Test
    public void helpRefresh() {
        commandBox.runCommand("help refresh");
        assertResultMessage(CalendarRefreshCommand.MESSAGE_USAGE);
    }

    @Test
    public void helpRecur() {
        commandBox.runCommand("help recur");
        assertResultMessage(RecurCommand.MESSAGE_USAGE);
    }

}
```
###### /java/guitests/ListCommandTest.java
``` java
/*
* GUI test for ListCommand
*/
public class ListCommandTest extends WhatsLeftGuiTest {

    TestEvent[] currentEventList =  TestUtil.getFilteredTestEvents(te.getTypicalEvents());
    TestEvent[] filteredEventList = TestUtil.getFilteredTestEvents(currentEventList);
    TestTask[] currentTaskList =  TestUtil.getFilteredTestTasks(tt.getTypicalTasks());
    TestTask[] filteredTaskList = TestUtil.getFilteredTestTasks(currentTaskList);

    @Test
    public void listNonEmptyList() {
        assertListSuccess(filteredEventList, filteredTaskList);
    }

    @Test
    public void listEmptyEventList() {
        //list an empty event list
        commandBox.runCommand("clear ev");
        assertListSuccess(new TestEvent[]{}, filteredTaskList);
    }

    @Test
    public void listEmptyTaskList() {
        //list an empty task list
        commandBox.runCommand("clear ts");
        assertListSuccess(filteredEventList, new TestTask[]{});
    }

    public void listEmptyWhatsLeft() {
        commandBox.runCommand("clear");
        assertListSuccess(new TestEvent[]{}, new TestTask[]{});
    }

    @Test
    public void listAfterAfterFind() {
        commandBox.runCommand("find tutorial");
        assertListSuccess(filteredEventList, filteredTaskList);
    }

    private void assertListSuccess(TestEvent[] filteredEventList, TestTask[] filteredTaskList) {
        commandBox.runCommand("list");
        assertTrue(eventListPanel.isListMatching(filteredEventList));
        assertTrue(taskListPanel.isListMatching(filteredTaskList));
    }

}
```
###### /java/guitests/SelectCommandTest.java
``` java
/*
* GUI test for SelectCommand
*/
public class SelectCommandTest extends WhatsLeftGuiTest {

    @Test
    public void selectEventNonEmptyList() {

        TestEvent[] currentEventList =  TestUtil.getFilteredTestEvents(te.getTypicalEvents());
        TestEvent[] filteredEventList = TestUtil.getFilteredTestEvents(currentEventList);

        int eventCount = filteredEventList.length;

        assertEventSelectionInvalid(eventCount + 1); // invalid index
        assertNoEventSelected();

        assertEventSelectionSuccess(1); // first event in the list
        assertEventSelectionSuccess(eventCount); // last event in the list
        int middleIndex = eventCount / 2;
        assertEventSelectionSuccess(middleIndex); // an event in the middle of the list

        assertEventSelectionInvalid(eventCount + 1); // invalid index
        assertEventSelected(middleIndex); // assert previous selection remains

    }

    @Test
    public void selectEventEmptyList() {
        commandBox.runCommand("clear ev");
        assertEventListSize(0);
        assertEventSelectionInvalid(1); //invalid index
    }

    @Test
    public void selectTaskNonEmptyList() {

        TestTask[] currentTaskList =  TestUtil.getFilteredTestTasks(tt.getTypicalTasks());
        TestTask[] filteredTaskList = TestUtil.getFilteredTestTasks(currentTaskList);

        int taskCount = filteredTaskList.length;

        assertTaskSelectionInvalid(taskCount + 1); // invalid index
        assertNoTaskSelected();

        assertTaskSelectionSuccess(1); // first event in the list
        assertTaskSelectionSuccess(taskCount); // last event in the list
        int middleIndex = taskCount / 2;
        assertTaskSelectionSuccess(middleIndex); // an event in the middle of the list

        assertTaskSelectionInvalid(taskCount + 1); // invalid index
        assertTaskSelected(middleIndex); // assert previous selection remains

    }

    @Test
    public void selectTaskEmptyList() {
        commandBox.runCommand("clear ts");
        assertTaskListSize(0);
        assertTaskSelectionInvalid(1); //invalid index
    }

    @Test
    public void selectFirstAfterList() {
        commandBox.runCommand("list");
        assertEventSelectionSuccess(1);
        assertTaskSelectionSuccess(1);
    }

    private void assertEventSelectionInvalid(int index) {
        commandBox.runCommand("select ev " + index);
        assertResultMessage("The Event index provided is invalid");
    }

    private void assertEventSelectionSuccess(int index) {
        commandBox.runCommand("select ev " + index);
        ReadOnlyEvent eventToSelect = eventListPanel.getEvent(index - 1);
        assertResultMessage("Selected Event: " + eventToSelect);
        assertEventSelected(index);
    }

    private void assertEventSelected(int index) {
        assertEquals(eventListPanel.getSelectedEvents().size(), 1);
        ReadOnlyEvent selectedEvent = eventListPanel.getSelectedEvents().get(0);
        assertEquals(eventListPanel.getEvent(index - 1), selectedEvent);
    }

    private void assertNoEventSelected() {
        assertEquals(eventListPanel.getSelectedEvents().size(), 0);
    }

    private void assertTaskSelectionInvalid(int index) {
        commandBox.runCommand("select ts " + index);
        assertResultMessage("The Task index provided is invalid");
    }

    private void assertTaskSelectionSuccess(int index) {
        commandBox.runCommand("select ts " + index);
        ReadOnlyTask taskToSelect = taskListPanel.getTask(index - 1);
        assertResultMessage("Selected Task: " + taskToSelect);
        assertTaskSelected(index);
    }

    private void assertTaskSelected(int index) {
        assertEquals(taskListPanel.getSelectedTasks().size(), 1);
        ReadOnlyTask selectedTask = taskListPanel.getSelectedTasks().get(0);
        assertEquals(taskListPanel.getTask(index - 1), selectedTask);
    }

    private void assertNoTaskSelected() {
        assertEquals(taskListPanel.getSelectedTasks().size(), 0);
    }

}
```
###### /java/seedu/whatsleft/model/activity/LocationTest.java
``` java

public class LocationTest {

    @Test
    public void isValidLocation() {
        // invalid location
        assertFalse(Location.isValidLocation(" ")); // spaces only
        assertFalse(Location.isValidLocation("")); //empty

        // valid location
        assertTrue(Location.isValidLocation("NUS"));
        assertTrue(Location.isValidLocation("-")); // one character
        assertTrue(Location.isValidLocation("Central Library, NUS, Singapore")); // long location
    }
}
```
###### /java/seedu/whatsleft/testutil/TestEvent.java
``` java
    @Override
    public String getDescriptionToShow() {
        return getDescription().toString();
    }

    @Override
    public String getDurationToShow() {
        return getStartTime().toString() + " " + getStartDate().toString()
               +  " ~ " + getEndTime().toString() + " " + getEndDate().toString();
    }

    @Override
    public String getLocationToShow() {
        if (getLocation().toString() != null) {
            return "@" + getLocation().toString();
        } else {
            return null;
        }
    }

    @Override
    public List<String> getTagsToShow() {
        return tags
                .asObservableList()
                .stream()
                .map(tag -> tag.tagName)
                .collect(Collectors.toList());
    }
}
```
###### /java/seedu/whatsleft/testutil/TestTask.java
``` java
/**
 * A mutable Task object. For testing only.
 */
public class TestTask implements ReadOnlyTask {

    private Description description;
    private Priority priority;
    private ByTime byTime;
    private ByDate byDate;
    private Location location;
    private UniqueTagList tags;
    private boolean status;

    public TestTask() {
        tags = new UniqueTagList();
        status = false;
    }

    /**
     * Creates a copy of {@code taskToCopy}.
     */
    public TestTask(TestTask taskToCopy) {
        this.description = taskToCopy.getDescription();
        this.priority = taskToCopy.getPriority();
        this.byTime = taskToCopy.getByTime();
        this.byDate = taskToCopy.getByDate();
        this.location = taskToCopy.getLocation();
        this.tags = taskToCopy.getTags();
        this.status = taskToCopy.getStatus();
    }

    public void setDescription(Description description) {
        this.description = description;
    }

    public void setPriority(Priority priority) {
        this.priority = priority;
    }

    public void setByTime(ByTime byTime) {
        this.byTime = byTime;
    }

    public void setByDate(ByDate byDate) {
        this.byDate = byDate;
    }

    public void setLocation(Location location) {
        this.location = location;
    }

    public void setTags(UniqueTagList tags) {
        this.tags = tags;
    }

    public void setStatus(boolean status) {
        this.status = status;
    }

    @Override
    public Description getDescription() {
        return description;
    }

    @Override
    public Priority getPriority() {
        return priority;
    }

    @Override
    public ByTime getByTime() {
        return byTime;
    }

    @Override
    public ByDate getByDate() {
        return byDate;
    }

    @Override
    public Location getLocation() {
        return location;
    }

    @Override
    public UniqueTagList getTags() {
        return tags;
    }

    @Override
    public boolean getStatus() {
        return status;
    }

    @Override
    public boolean hasDeadline() {
        return (this.getByDate() != null || this.getByTime() != null);
    }

    @Override
    public String toString() {
        return getAsText();
    }

    public String getAddCommand() {
        StringBuilder sb = new StringBuilder();
        sb.append("add " + this.getDescription().description + " ");
        sb.append("p/" + this.getPriority().toString() + " ");
        sb.append("bt/" + this.getByTime().getValue().format(DateTimeFormatter.ofPattern("HHmm")));
        sb.append("bd/" + this.getByDate().getValue().format(DateTimeFormatter.ofPattern("ddMMyy")));
        sb.append("l/" + this.getLocation().value + " ");
        this.getTags().asObservableList().stream().forEach(s -> sb.append("ta/" + s.tagName + " "));
        return sb.toString();
    }

```
###### /java/seedu/whatsleft/testutil/TestTask.java
``` java
    @Override
    public String getDescriptionToShow() {
        return getDescription().toString();
    }

    @Override
    public String getPriorityToShow() {
        return "Priority: " + getPriority().toString().toUpperCase();
    }

    @Override
    public String getByTimeDateToShow() {
        if (hasDeadline()) {
            return "BY " + this.byTime.toString() + " " + this.byDate.toString();
        } else {
            return null;
        }
    }

    @Override
    public String getLocationToShow() {
        if (getLocation().toString() != null) {
            return "@" + getLocation().toString();
        } else {
            return null;
        }

    }

    @Override
    public List<String> getTagsToShow() {
        return tags
                .asObservableList()
                .stream()
                .map(tag -> tag.tagName)
                .collect(Collectors.toList());
    }
}
```
###### /java/seedu/whatsleft/testutil/TestUtil.java
``` java
    /**
     * Filters all future test events from an array of test events, then sort
     * the test events in filtered array in time order.
     *
     * @param events
     * @return TestEvent filteredTestEvents
     */
    public static TestEvent[] getFilteredTestEvents(TestEvent[] events) {
        ArrayList<TestEvent> eventList = new ArrayList<TestEvent>(Arrays.asList(events));
        eventList.removeIf(e -> e.isOver());
        eventList.sort(ReadOnlyEvent.getComparator());
        TestEvent[] filteredTestEvents = eventList.toArray(new TestEvent[eventList.size()]);
        return filteredTestEvents;
    }

    /**
     * Filters all past test events from an array of test events, then sort
     * the test events in filtered array in time order.
     *
     * @param events
     * @return TestEvent filteredTestEvents
     */
    public static TestEvent[] getPastTestEvents(TestEvent[] events) {
        ArrayList<TestEvent> eventList = new ArrayList<TestEvent>(Arrays.asList(events));
        eventList.removeIf(e -> !e.isOver());
        eventList.sort(ReadOnlyEvent.getComparator());
        TestEvent[] filteredTestEvents = eventList.toArray(new TestEvent[eventList.size()]);
        return filteredTestEvents;
    }

```
###### /java/seedu/whatsleft/testutil/TestUtil.java
``` java
    /**
     * Filters all future test tasks from an array of test tasks, then sort the
     * test events in filtered array in time order.
     *
     * @param events
     * @return TestEvent filteredTestEvents
     */
    public static TestTask[] getFilteredTestTasks(TestTask[] tasks) {
        ArrayList<TestTask> taskList = new ArrayList<TestTask>(Arrays.asList(tasks));
        taskList.removeIf(t -> t.getStatus());
        taskList.sort(ReadOnlyTask.getComparator());
        TestTask[] filteredTestTasks = taskList.toArray(new TestTask[taskList.size()]);
        return filteredTestTasks;
    }

    public static void main(String... s) {
        createDataFileWithSampleData(TestApp.SAVE_LOCATION_FOR_TESTING);
    }

    public static XmlSerializableWhatsLeft generateSampleStorageWhatsLeft() {
        return new XmlSerializableWhatsLeft(new WhatsLeft());
    }

    /**
     * Tweaks the {@code keyCodeCombination} to resolve the
     * {@code KeyCode.SHORTCUT} to their respective platform-specific keycodes
     */
    public static KeyCode[] scrub(KeyCodeCombination keyCodeCombination) {
        List<KeyCode> keys = new ArrayList<>();
        if (keyCodeCombination.getAlt() == KeyCombination.ModifierValue.DOWN) {
            keys.add(KeyCode.ALT);
        }
        if (keyCodeCombination.getShift() == KeyCombination.ModifierValue.DOWN) {
            keys.add(KeyCode.SHIFT);
        }
        if (keyCodeCombination.getMeta() == KeyCombination.ModifierValue.DOWN) {
            keys.add(KeyCode.META);
        }
        if (keyCodeCombination.getControl() == KeyCombination.ModifierValue.DOWN) {
            keys.add(KeyCode.CONTROL);
        }
        keys.add(keyCodeCombination.getCode());
        return keys.toArray(new KeyCode[] {});
    }

    public static boolean isHeadlessEnvironment() {
        String headlessProperty = System.getProperty("testfx.headless");
        return headlessProperty != null && headlessProperty.equals("true");
    }

    public static void captureScreenShot(String fileName) {
        File file = GuiTest.captureScreenshot();
        try {
            Files.copy(file, new File(fileName + ".png"));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static String descOnFail(Object... comparedObjects) {
        return "Comparison failed \n"
                + Arrays.asList(comparedObjects).stream().map(Object::toString).collect(Collectors.joining("\n"));
    }

    public static void setFinalStatic(Field field, Object newValue)
            throws NoSuchFieldException, IllegalAccessException {
        field.setAccessible(true);
        // remove final modifier from field
        Field modifiersField = Field.class.getDeclaredField("modifiers");
        modifiersField.setAccessible(true);
        // ~Modifier.FINAL is used to remove the final modifier from field so
        // that its value is no longer
        // final and can be changed
        modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);
        field.set(null, newValue);
    }

    public static void initRuntime() throws TimeoutException {
        FxToolkit.registerPrimaryStage();
        FxToolkit.hideStage();
    }

    public static void tearDownRuntime() throws Exception {
        FxToolkit.cleanupStages();
    }

    /**
     * Gets private method of a class Invoke the method using
     * method.invoke(objectInstance, params...)
     *
     * Caveat: only find method declared in the current Class, not inherited
     * from supertypes
     */
    public static Method getPrivateMethod(Class<?> objectClass, String methodName) throws NoSuchMethodException {
        Method method = objectClass.getDeclaredMethod(methodName);
        method.setAccessible(true);
        return method;
    }

    public static void renameFile(File file, String newFileName) {
        try {
            Files.copy(file, new File(newFileName));
        } catch (IOException e1) {
            e1.printStackTrace();
        }
    }

    /**
     * Gets mid point of a node relative to the screen.
     *
     * @param node
     * @return
     */
    public static Point2D getScreenMidPoint(Node node) {
        double x = getScreenPos(node).getMinX() + node.getLayoutBounds().getWidth() / 2;
        double y = getScreenPos(node).getMinY() + node.getLayoutBounds().getHeight() / 2;
        return new Point2D(x, y);
    }

    /**
     * Gets mid point of a node relative to its scene.
     *
     * @param node
     * @return
     */
    public static Point2D getSceneMidPoint(Node node) {
        double x = getScenePos(node).getMinX() + node.getLayoutBounds().getWidth() / 2;
        double y = getScenePos(node).getMinY() + node.getLayoutBounds().getHeight() / 2;
        return new Point2D(x, y);
    }

    /**
     * Gets the bound of the node relative to the parent scene.
     *
     * @param node
     * @return
     */
    public static Bounds getScenePos(Node node) {
        return node.localToScene(node.getBoundsInLocal());
    }

    public static Bounds getScreenPos(Node node) {
        return node.localToScreen(node.getBoundsInLocal());
    }

    public static double getSceneMaxX(Scene scene) {
        return scene.getX() + scene.getWidth();
    }

    public static double getSceneMaxY(Scene scene) {
        return scene.getX() + scene.getHeight();
    }

    public static Object getLastElement(List<?> list) {
        return list.get(list.size() - 1);
    }

    /**
     * Removes a subset from the list of events.
     *
     * @param events
     *            The list of events
     * @param eventsToRemove
     *            The subset of events.
     * @return The modified events after removal of the subset from events.
     */
    public static TestEvent[] removeEventsFromList(final TestEvent[] events, TestEvent... eventsToRemove) {
        List<TestEvent> listOfEvents = asList(events);
        listOfEvents.removeAll(asList(eventsToRemove));
        return listOfEvents.toArray(new TestEvent[listOfEvents.size()]);
    }

    /**
     * Removes a subset from the list of tasks.
     *
     * @param tasks
     *            The list of tasks
     * @param tasks
     *            The subset of tasks.
     * @return The modified tasks after removal of the subset from tasks.
     */
    public static TestTask[] removeTasksFromList(final TestTask[] tasks, TestTask... tasksToRemove) {
        List<TestTask> listOfTasks = asList(tasks);
        listOfTasks.removeAll(asList(tasksToRemove));
        return listOfTasks.toArray(new TestTask[listOfTasks.size()]);
    }

    /**
     * Returns a copy of the list with the event at specified index removed.
     *
     * @param list
     *            original list to copy from
     * @param targetIndexInOneIndexedFormat
     *            e.g. index 1 if the first element is to be removed
     */
    public static TestEvent[] removeEventFromList(final TestEvent[] list, int targetIndexInOneIndexedFormat) {
        return removeEventsFromList(list, list[targetIndexInOneIndexedFormat - 1]);
    }

    /**
     * Returns a copy of the list with the task at specified index removed.
     *
     * @param list
     *            original list to copy from
     * @param targetIndexInOneIndexedFormat
     *            e.g. index 1 if the first element is to be removed
     */
    public static TestTask[] removeTaskFromList(final TestTask[] list, int targetIndexInOneIndexedFormat) {
        return removeTasksFromList(list, list[targetIndexInOneIndexedFormat - 1]);
    }

```
###### /java/seedu/whatsleft/testutil/TypicalTestEvents.java
``` java
/**
 * TypicalTestEvents for GUI test
 */
public class TypicalTestEvents {

    public TestEvent tutorial, lecture, meeting, talk, exam, presentation, discussion,
            consultation, workshop, clashedWorkshop;

    public TypicalTestEvents() {
        try {
            tutorial = new EventBuilder().withDescription("CS2103 Tutorial")
                    .withStartTime("0900")
                    .withStartDate("280717")
                    .withEndTime("1000")
                    .withEndDate("280717")
                    .withLocation("COM1-B103")
                    .withTags("demo").build();
            lecture = new EventBuilder().withDescription("CS2010 Lecture")
                    .withStartTime("1000")
                    .withStartDate("030717")
                    .withEndTime("1200")
                    .withEndDate("030717")
                    .withLocation("LT19")
                    .withTags("webcasted").build();
            meeting = new EventBuilder().withDescription("CCA Meeting")
                    .withStartTime("1900")
                    .withStartDate("200717")
                    .withEndTime("2200")
                    .withEndDate("200717")
                    .withLocation("FoS")
                    .withTags("meeting").build();
            talk = new EventBuilder().withDescription("Enrichment Talk")
                    .withStartTime("1800")
                    .withStartDate("150717")
                    .withEndTime("2000")
                    .withEndDate("150717")
                    .withLocation("LT28")
                    .withTags("talk").build();
            exam = new EventBuilder().withDescription("CS2107 Exam")
                    .withStartTime("0900")
                    .withStartDate("250317")
                    .withEndTime("1030")
                    .withEndDate("250317")
                    .withLocation("MPSH1A")
                    .withTags("calculator").build();
            presentation = new EventBuilder().withDescription("GEH Presentation")
                    .withStartTime("1200")
                    .withStartDate("250517")
                    .withEndTime("1400")
                    .withEndDate("250517")
                    .withLocation("FASS")
                    .withTags("formal").build();
            discussion = new EventBuilder().withDescription("CS2103 Project Discussion")
                    .withStartTime("1500")
                    .withStartDate("260517")
                    .withEndTime("1900")
                    .withEndDate("260517")
                    .withLocation("Central Library, NUS")
                    .withTags("project").build();

            // Manually added
            consultation = new EventBuilder().withDescription("MA2101 Consultation")
                    .withStartTime("1000")
                    .withStartDate("270817")
                    .withEndTime("1100")
                    .withEndDate("270817")
                    .withLocation("S17")
                    .withTags().build();
            workshop = new EventBuilder().withDescription("PS Workshop")
                    .withStartTime("0900")
                    .withStartDate("280617")
                    .withEndTime("1000")
                    .withEndDate("280617")
                    .withLocation("UHALL")
                    .withTags("registration").build();

            // Clashed event
            clashedWorkshop = new EventBuilder().withDescription("Latex Workshop")
                    .withStartTime("0730")
                    .withStartDate("280617")
                    .withEndTime("0930")
                    .withEndDate("280617")
                    .withLocation("YIH")
                    .withTags().build();
        } catch (IllegalValueException e) {
            e.printStackTrace();
            assert false : "not possible";
        }
    }

    public static void loadWhatsLeftWithSampleData(WhatsLeft wl) {
        for (TestEvent event : new TypicalTestEvents().getTypicalEvents()) {
            try {
                wl.addEvent(new Event(event));
            } catch (DuplicateEventException e) {
                assert false : "not possible";
            }
        }
    }

    public TestEvent[] getTypicalEvents() {
        return new TestEvent[]{tutorial, lecture, meeting, talk, exam, presentation, discussion};
    }

    public WhatsLeft getTypicalWhatsLeft() {
        WhatsLeft wl = new WhatsLeft();
        loadWhatsLeftWithSampleData(wl);
        return wl;
    }
}
```
###### /java/seedu/whatsleft/testutil/TypicalTestTasks.java
``` java
/**
 * TypicalTestTasks for GUI test
 */
public class TypicalTestTasks {

    public TestTask report, cleaning, laundry, printing, shopping, reading, cooking, homework, cycling;

    public TypicalTestTasks() {
        try {
            report = new TaskBuilder().withDescription("LSM Project Report")
                    .withPriority("high")
                    .withByTime("2300")
                    .withByDate("010517")
                    .withLocation("IVLE")
                    .withTags("softcopy").build();
            cleaning = new TaskBuilder().withDescription("Clean room")
                    .withPriority("medium")
                    .withByTime("1200")
                    .withByDate("070218")
                    .withLocation("home")
                    .withTags("housekeeping").build();
            laundry = new TaskBuilder().withDescription("Laundry")
                    .withPriority("medium")
                    .withByTime("2200")
                    .withByDate("200417")
                    .withLocation("home")
                    .withTags("housekeeping").build();
            printing = new TaskBuilder().withDescription("Print Notes")
                    .withPriority("high")
                    .withByTime("1000")
                    .withByDate("120417")
                    .withLocation("YIH")
                    .withTags("study").build();
            shopping = new TaskBuilder().withDescription("Shopping")
                    .withPriority("low")
                    .withByTime("1800")
                    .withByDate("040517")
                    .withLocation("VivoCity")
                    .withTags("shopping").build();
            reading = new TaskBuilder().withDescription("Reading Books")
                    .withPriority("high")
                    .withByTime("1700")
                    .withByDate("220518")
                    .withLocation("CLB")
                    .withTags("study").build();
            cooking = new TaskBuilder().withDescription("Cook Dinner")
                    .withPriority("high")
                    .withByTime("1730")
                    .withByDate("210517")
                    .withLocation("kitchen")
                    .withTags("food").build();

            // Manually added
            homework = new TaskBuilder().withDescription("MA2101 HW")
                    .withPriority("high")
                    .withByTime("1100")
                    .withByDate("270617")
                    .withLocation("S17")
                    .withTags("homework").build();
            cycling = new TaskBuilder().withDescription("Night Cycling")
                    .withPriority("low")
                    .withByTime("1000")
                    .withByDate("280417")
                    .withLocation("Sentosa")
                    .withTags("sport").build();
        } catch (IllegalValueException e) {
            e.printStackTrace();
            assert false : "not possible";
        }
    }

    public static void loadWhatsLeftWithSampleData(WhatsLeft wl) {
        for (TestTask task : new TypicalTestTasks().getTypicalTasks()) {
            try {
                wl.addTask(new Task(task));
            } catch (DuplicateTaskException e) {
                assert false : "not possible";
            }
        }
    }

    public TestTask[] getTypicalTasks() {
        return new TestTask[]{report, cleaning, laundry, printing, shopping, reading, cooking};
    }

    public WhatsLeft getTypicalWhatsLeft() {
        WhatsLeft ab = new WhatsLeft();
        loadWhatsLeftWithSampleData(ab);
        return ab;
    }
}
```
