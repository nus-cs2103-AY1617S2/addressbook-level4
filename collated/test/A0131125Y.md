# A0131125Y
###### /java/guitests/AliasCommandTest.java
``` java
package guitests;

import org.junit.Before;
import org.junit.Test;

import seedu.toluist.commons.core.Config;
import seedu.toluist.controller.AliasController;
import seedu.toluist.controller.ViewAliasController;
import seedu.toluist.model.Task;

/**
 * Gui tests for alias command
 */
public class AliasCommandTest extends ToLuistGuiTest {
    @Before
    public void setUp() {
        Config.getInstance().getAliasTable().clearAliases();
    }

    @Test
    public void alias_singleWord() {
        String aliasCommand = "alias d add";
        commandBox.runCommand(aliasCommand);

        String taskDescription = "read lecture slides from Uncle Soo";
        String addCommand = "d " + taskDescription;
        Task task = new Task(taskDescription);
        runCommandThenCheckForTasks(addCommand, new Task[] { task }, new Task[0]);
    }

    @Test
    public void alias_phraseWithMultipleWords() {
        String aliasCommand = "alias d add a task";
        commandBox.runCommand(aliasCommand);

        String addCommand = "d ";
        Task task = new Task("a task");
        runCommandThenCheckForTasks(addCommand, new Task[] { task }, new Task[0]);
    }

    @Test
    public void alias_ReservedWord() {
        String aliasCommand = "alias alias alias";
        runCommandThenCheckForResultMessage(aliasCommand,
                String.format(AliasController.MESSAGE_RESULT_RESERVED_WORD, "alias"));

        String viewAliasCommand = "viewalias";
        runCommandThenCheckForResultMessage(viewAliasCommand, ViewAliasController.MESSAGE_RESULT_NO_ALIAS);
    }

    @Test
    public void updateAlias() {
        String aliasCommandForDelete = "alias d delete";
        commandBox.runCommand(aliasCommandForDelete);

        String aliasCommandForAdd = "alias d add";
        commandBox.runCommand(aliasCommandForAdd);

        String taskDescription = "watch webcast at home";
        String addCommand = "d " + taskDescription;
        Task task = new Task(taskDescription);
        runCommandThenCheckForTasks(addCommand, new Task[] { task }, new Task[0]);
    }
}
```
###### /java/guitests/CommandAutoCompleteTest.java
``` java
package guitests;

import static junit.framework.TestCase.assertEquals;

import java.util.Arrays;
import java.util.List;

import org.junit.Test;

import javafx.scene.input.KeyCode;

/**
 * Gui tests for command autocomplete
 */
public class CommandAutoCompleteTest extends ToLuistGuiTest {

    @Test
    public void autoComplete_sameThingTwiceFromMultipleOptions() {
        commandBox.focus();
        mainGui.press(KeyCode.S);
        List<String> expected1 = Arrays.asList(new String[] { "save", "sort", "switch" });
        assertEquals(expected1, commandAutoCompleteView.getSuggestions());

        mainGui.press(KeyCode.TAB);
        mainGui.press(KeyCode.ENTER);
        assertEquals("save", commandBox.getCommandInput());

        for (int i = 0; i < 3; i++) {
            mainGui.press(KeyCode.BACK_SPACE);
        }
        mainGui.press(KeyCode.TAB);
        mainGui.press(KeyCode.ENTER);
        assertEquals("save", commandBox.getCommandInput());
    }
}
```
###### /java/guitests/ExitCommandTest.java
``` java
package guitests;

import org.junit.Test;

/**
 * Gui tests for exit command
 */
public class ExitCommandTest extends ToLuistGuiTest {
    @Test
    public void exit() {
        String command = "exit";
        commandBox.runCommand(command);
        // Just making sure that this passed and no exceptions happened
    }
}
```
###### /java/guitests/FindCommandTest.java
``` java
package guitests;

import org.junit.Test;

import seedu.toluist.model.Task;
import seedu.toluist.testutil.TypicalTestTodoLists;

/**
 * Gui tests for find command
 */
public class FindCommandTest extends ToLuistGuiTest {

    @Test
    public void findByName() {
        Task[] sampleTasks = (new TypicalTestTodoLists()).getTypicalTasks();

        // Find without argument
        String commandNoArguments = "find";
        runCommandThenCheckForTasks(commandNoArguments, sampleTasks, new Task[0]);

        // Find with only spaces
        String commandOnlySpaces = "find  ";
        runCommandThenCheckForTasks(commandOnlySpaces, sampleTasks, new Task[0]);

        // Find by complete word
        String commandCompleteWord = "find clean  ";
        runCommandThenCheckForTasks(commandCompleteWord, new Task[] { sampleTasks[0] },
                new Task[] { sampleTasks[1] });

        // Find by partial word
        String commandPartialWord = "find  clea";
        runCommandThenCheckForTasks(commandPartialWord, new Task[] { sampleTasks[0] },
                new Task[] { sampleTasks[1] });

        // Find with explicit parameter
        String commandExplicitByName = "find  clean /name";
        runCommandThenCheckForTasks(commandExplicitByName, new Task[] { sampleTasks[0] },
                new Task[] { sampleTasks[1] });

        // Check that find is case-insensitive
        String commandCaseInsensitive = "find CLEAn";
        runCommandThenCheckForTasks(commandCaseInsensitive, new Task[] { sampleTasks[0] },
                new Task[] { sampleTasks[1] });

        // Find with multiple words
        String commandMultipleWords = "find clean assign";
        runCommandThenCheckForTasks(commandMultipleWords, sampleTasks, new Task[0]);
    }

    @Test
    public void findByTag() {
        Task[] sampleTasks = (new TypicalTestTodoLists()).getTypicalTasks();

        // Find with only spaces
        String commandOnlySpaces = "find  /tag";
        runCommandThenCheckForTasks(commandOnlySpaces, sampleTasks, new Task[0]);

        // Find by complete word
        String commandCompleteWord = "find lewis  /tag";
        runCommandThenCheckForTasks(commandCompleteWord, new Task[] { sampleTasks[0] },
                new Task[] { sampleTasks[1] });

        // Find by partial word
        String commandPartialWord = "find  lew /tag";
        runCommandThenCheckForTasks(commandPartialWord, new Task[] { sampleTasks[0] },
                new Task[] { sampleTasks[1] });


        // Check that find is case-insensitive
        String commandCaseInsensitive = "find WORK /tag";
        runCommandThenCheckForTasks(commandCaseInsensitive, sampleTasks, new Task[0]);

        // Find with multiple words
        String commandMultipleWords = "find lewis  louis /tag";
        runCommandThenCheckForTasks(commandMultipleWords, sampleTasks, new Task[0]);
    }
}
```
###### /java/guitests/guihandles/CommandAutoCompleteViewHandle.java
``` java
package guitests.guihandles;

import java.util.List;
import java.util.stream.Collectors;

import guitests.GuiRobot;
import javafx.scene.control.Label;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import seedu.toluist.TestApp;

/**
 * A handle to the Command autocomplet view in the GUI.
 */
public class CommandAutoCompleteViewHandle extends GuiHandle {
    private static final String COMMAND_AUTO_COMPLETE_VIEW_ID = "#suggestedCommandList";

    public CommandAutoCompleteViewHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    public List<String> getSuggestions() {
        VBox root = getNode(COMMAND_AUTO_COMPLETE_VIEW_ID);
        return root.getChildren().stream()
                .map(label -> ((Label) label).getText()).collect(Collectors.toList());
    }
}
```
###### /java/guitests/guihandles/MainGuiHandle.java
``` java
package guitests.guihandles;

import guitests.GuiRobot;
import javafx.stage.Stage;
import seedu.toluist.TestApp;

/**
 * Provides a handle for the main GUI.
 */
public class MainGuiHandle extends GuiHandle {
    public MainGuiHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    public TaskListHandle getTaskList() {
        return new TaskListHandle(guiRobot, primaryStage);
    }

    public ResultDisplayHandle getResultDisplay() {
        return new ResultDisplayHandle(guiRobot, primaryStage);
    }

    public CommandBoxHandle getCommandBox() {
        return new CommandBoxHandle(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    public TabBarViewHandle getTabBar() {
        return new TabBarViewHandle(guiRobot, primaryStage);
    }

    public CommandAutoCompleteViewHandle getCommandAutoCompleteView() {
        return new CommandAutoCompleteViewHandle(guiRobot, primaryStage);
    }

    public HelpHandle getHelpView() {
        return new HelpHandle(guiRobot, primaryStage);
    }
}
```
###### /java/guitests/guihandles/TabBarViewHandle.java
``` java
package guitests.guihandles;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import guitests.GuiRobot;
import javafx.scene.control.Label;
import javafx.scene.layout.FlowPane;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;
import seedu.toluist.TestApp;
import seedu.toluist.commons.util.StringUtil;

/**
 * Provide a handle for TabBarView
 */
public class TabBarViewHandle extends GuiHandle {
    private static final String TAB_BAR_VIEW_ID = "#tabContainer";

    public TabBarViewHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    /**
     * Returns the string shown in the highlighted tab in the tab bar
     */
    public String getHighlightedTabText() {
        FlowPane root = getNode(TAB_BAR_VIEW_ID);
        return root.getChildren().stream()
                   .filter(hBox -> hBox.getStyleClass().contains("selected"))
                   .map(hBox -> Arrays.asList(((HBox) hBox).getChildren().toArray()))
                   .flatMap(List::stream)
                   .map(label -> ((Label) label).getText())
                   .collect(Collectors.joining(StringUtil.EMPTY_STRING));
    }
}
```
###### /java/guitests/guihandles/TaskListHandle.java
``` java
package guitests.guihandles;

import guitests.GuiRobot;

import javafx.scene.control.ListView;
import javafx.stage.Stage;
import seedu.toluist.TestApp;
import seedu.toluist.model.Task;

/**
 * Provides a handle for the TaskList.
 */
public class TaskListHandle extends GuiHandle {
    public static final String TASK_LIST_VIEW_ID = "#taskListView";

    public TaskListHandle(GuiRobot guiRobot, Stage primaryStage) {
        super(guiRobot, primaryStage, TestApp.APP_TITLE);
    }

    public ListView<Task> getTaskList() {
        return (ListView<Task>) getNode(TASK_LIST_VIEW_ID);
    }
}
```
###### /java/guitests/LoadCommandTest.java
``` java
package guitests;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.io.File;

import org.junit.Test;

import seedu.toluist.TestApp;
import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.core.Messages;
import seedu.toluist.commons.util.FileUtil;
import seedu.toluist.model.TodoList;
import seedu.toluist.testutil.TestUtil;
import seedu.toluist.testutil.TypicalTestTodoLists;

/**
 * Gui tests for getInstance command
 */
public class LoadCommandTest extends ToLuistGuiTest {
    @Test
    public void load_fileNotExists() {
        String newPath = TestUtil.getFilePathInSandboxFolder("load_test.json");
        FileUtil.removeFile(new File(newPath));
        String command = "load " + newPath;
        runCommandThenCheckForResultMessage(command,
                String.format(Messages.MESSAGE_SET_STORAGE_FAILURE, newPath));

        // Check that storage path is not changed
        assertEquals(Config.getInstance().getTodoListFilePath(), TestApp.SAVE_LOCATION_FOR_TESTING);
    }

    @Test
    public void load_fileExists() {
        String newPath = "./src/test/data/StorageTest/TypicalData.json";
        String command = "load " + newPath;
        runCommandThenCheckForResultMessage(command,
                String.format(Messages.MESSAGE_SET_STORAGE_SUCCESS, newPath));

        // Check that storage path is changed
        assertEquals(Config.getInstance().getTodoListFilePath(), newPath);

        // Check that todo list loaded is the same as previous todo list
        TodoList todoListAtLoadedLocation = TodoList.getInstance();
        assertTrue(TestUtil.compareTasksOfTodoLists(todoListAtLoadedLocation,
                new TypicalTestTodoLists().getTypicalTodoList()));
    }

    @Test
    public void load_sameLocation() {
        String newPath = TestApp.SAVE_LOCATION_FOR_TESTING;
        String command = "load " + newPath;
        runCommandThenCheckForResultMessage(command,
                String.format(Messages.MESSAGE_STORAGE_SAME_LOCATION, newPath));
    }

    @Test
    public void load_noStoragePath() {
        String command = "load ";
        runCommandThenCheckForResultMessage(command, Messages.MESSAGE_NO_STORAGE_PATH);
    }

    @Test
    public void load_invalidStoragePath() {
        String newPath = "sfas?////sffsf.json";
        String command = "load " + newPath;
        runCommandThenCheckForResultMessage(command,
                String.format(Messages.MESSAGE_SET_STORAGE_FAILURE, newPath));
    }

    @Test
    public void load_invalidData() {
        String newPath = "./src/test/data/StorageTest/NotJsonFormatData.json";
        String command = "load " + newPath;
        runCommandThenCheckForResultMessage(command,
                String.format(Messages.MESSAGE_SET_STORAGE_FAILURE, newPath));

        assertEquals(Config.getInstance().getTodoListFilePath(), TestApp.SAVE_LOCATION_FOR_TESTING);
    }
}
```
###### /java/guitests/MarkCommandTest.java
``` java
package guitests;

import static junit.framework.TestCase.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.time.LocalDateTime;
import java.util.Objects;

import org.junit.Before;
import org.junit.Test;

import seedu.toluist.commons.core.Messages;
import seedu.toluist.commons.util.DateTimeUtil;
import seedu.toluist.model.Task;
import seedu.toluist.model.TodoList;
import seedu.toluist.testutil.TypicalTestTodoLists;

/**
 * Gui tests for mark command
 */
public class MarkCommandTest extends ToLuistGuiTest {
    @Before
    public void setUp() {
        for (Task task : TodoList.getInstance().getTasks()) {
            task.setCompleted(false);
        }
        String switchViewtoAll = "switch a";
        commandBox.runCommand(switchViewtoAll);
    }

    @Test
    public void mark_invalidIndex() {
        String command = "mark";
        runCommandThenCheckForResultMessage(command, Messages.MESSAGE_INVALID_TASK_INDEX);
    }

    @Test
    public void markComplete_singleTask() {
        Task task1 = new TypicalTestTodoLists().getTypicalTasks()[0];
        String command1 = "mark complete 1";
        runCommandWithCallback(command1, () -> assertTaskComplete(true, task1));

        Task task2 = new TypicalTestTodoLists().getTypicalTasks()[1];
        String command2 = "mark 2 complete";
        runCommandWithCallback(command2, () -> assertTaskComplete(true, task2));
    }

    @Test
    public void markComplete_multipleTasks() {
        String command = "mark 1-2";
        commandBox.runCommand(command);
        assertTaskComplete(true, new TypicalTestTodoLists().getTypicalTasks());
    }

    @Test
    public void markIncomplete_singleTask() {
        Task task = new TypicalTestTodoLists().getTypicalTasks()[0];
        String markCompleteCommand = "mark complete 1";
        runCommandWithCallback(markCompleteCommand, () -> assertTaskComplete(true, task));

        String markIncompleteCommand = "mark incomplete 1";
        runCommandWithCallback(markIncompleteCommand, () -> assertTaskComplete(false, task));
    }

    @Test
    public void markIncomplete_multipleTasks() {
        String markCompleteCommand = "mark complete 1 - ";
        runCommandWithCallback(markCompleteCommand,
            () -> assertTaskComplete(true, new TypicalTestTodoLists().getTypicalTasks()));

        String markIncompleteCommand = "mark incomplete  - 2";
        runCommandWithCallback(markIncompleteCommand,
            () -> assertTaskComplete(false, new TypicalTestTodoLists().getTypicalTasks()));
    }

    /**
     * Check that all the tasks are completed or incomplete
     * @param isCompleted whether the tasks should be check for being completed or incomplete
     * @param tasks varargs of tasks
     */
    private void assertTaskComplete(boolean isCompleted, Task... tasks) {
        for (Task task : tasks) {
            Task taskOnUi = getTasksShown().stream()
                    .filter(shownTask -> isEqualAsideFromCompleteDateTime(task, shownTask))
                    .findFirst()
                    .get();
            assertEquals(taskOnUi.isCompleted(), isCompleted);
        }
    }

    /**
     * Check if two tasks have equal properties, not counting completionDateTime
     */
    private boolean isEqualAsideFromCompleteDateTime(Task task1, Task task2) {
        return task1.getDescription().equals(task2.getDescription())
                && task1.getTaskPriority().equals(task2.getTaskPriority())
                && task1.getAllTags().equals(task2.getAllTags())
                && Objects.equals(task1.getStartDateTime(), task2.getStartDateTime())
                && Objects.equals(task1.getEndDateTime(), task2.getEndDateTime());
    }

```
###### /java/guitests/RedoCommandTest.java
``` java
package guitests;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.Arrays;

import org.junit.Before;
import org.junit.Test;

import javafx.scene.input.KeyCode;
import seedu.toluist.model.Task;
import seedu.toluist.model.TodoList;
import seedu.toluist.testutil.TypicalTestTodoLists;

/**
 * Gui tests for redo command
 */
public class RedoCommandTest extends ToLuistGuiTest {
    @Before
    public void setUp() {
        TodoList.getInstance().setTasks(Arrays.asList(new TypicalTestTodoLists().getTypicalTasks()));
        TodoList.getInstance().save();
    }

    @Test
    public void redoSingleCommand() {
        String taskDescription = "build a rocket";
        String addCommand = "add " + taskDescription;
        Task task = new Task(taskDescription);
        runCommandThenCheckForTasks(addCommand, new Task[] { task }, new Task[0]);

        String undoCommand = "undo";
        runCommandThenCheckForTasks(undoCommand, new Task[0], new Task[] { task });
        assertFalse(TodoList.getInstance().getTasks().contains(task));

        String redoCommand = "redo";
        runCommandThenCheckForTasks(redoCommand, new Task[] { task }, new Task[0]);
        assertTrue(TodoList.getInstance().getTasks().contains(task));
    }

    @Test
    public void redoMultipleCommand() {
        String taskDescription = "build a rocket";
        String addCommand = "add " + taskDescription;
        Task task = new Task(taskDescription);
        runCommandThenCheckForTasks(addCommand, new Task[] { task }, new Task[0]);

        String taskDescription2 = "ride a unicorn";
        String addCommand2 = "add " + taskDescription2;
        Task task2 = new Task(taskDescription2);
        runCommandThenCheckForTasks(addCommand2, new Task[] { task2 }, new Task[0]);

        String undoCommand = "undo 2";
        runCommandThenCheckForTasks(undoCommand, new Task[0], new Task[] { task, task2 });
        assertFalse(TodoList.getInstance().getTasks().contains(task));

        String redoCommand = "redo 2";
        runCommandThenCheckForTasks(redoCommand, new Task[] { task, task2 }, new Task[0]);
    }

    @Test
    public void redoAfterMutatingCommand() {
        String taskDescription1 = "build a rocket";
        String addCommand1 = "add " + taskDescription1;
        Task task1 = new Task(taskDescription1);
        runCommandThenCheckForTasks(addCommand1, new Task[] { task1 }, new Task[0]);

        String undoCommand = "undo";
        runCommandThenCheckForTasks(undoCommand, new Task[0], new Task[] { task1 });
        assertFalse(TodoList.getInstance().getTasks().contains(task1));

        String taskDescription2 = "build a castle";
        String addCommand2 = "add " + taskDescription2;
        Task task2 = new Task(taskDescription2);
        runCommandThenCheckForTasks(addCommand2, new Task[] { task2 }, new Task[0]);

        // This won't redo anything
        String redoCommand = "redo";
        runCommandThenCheckForTasks(redoCommand, new Task[0], new Task[] { task1 });
        assertFalse(TodoList.getInstance().getTasks().contains(task1));
    }

    @Test
    public void redoWithHotkey() {
        String taskDescription = "build a rocket";
        String addCommand = "add " + taskDescription;
        Task task = new Task(taskDescription);
        runCommandThenCheckForTasks(addCommand, new Task[] { task }, new Task[0]);

        String undoCommand = "undo";
        runCommandThenCheckForTasks(undoCommand, new Task[0], new Task[] { task });
        assertFalse(TodoList.getInstance().getTasks().contains(task));

        mainGui.press(KeyCode.CONTROL, KeyCode.Y);
        assertTrue(isTaskShown(task));
        assertTrue(TodoList.getInstance().getTasks().contains(task));
    }
}
```
###### /java/guitests/SaveCommandTest.java
``` java
package guitests;

import static junit.framework.TestCase.fail;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.io.File;
import java.io.IOException;

import org.junit.Test;

import seedu.toluist.TestApp;
import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.core.Messages;
import seedu.toluist.commons.util.FileUtil;
import seedu.toluist.controller.StoreController;
import seedu.toluist.model.TodoList;
import seedu.toluist.testutil.TestUtil;
import seedu.toluist.testutil.TypicalTestTodoLists;

/**
 * Gui tests for save command
 */
public class SaveCommandTest extends ToLuistGuiTest {
    @Test
    public void save_fileNotExists() {
        String newPath = TestUtil.getFilePathInSandboxFolder("save_test.json");
        FileUtil.removeFile(new File(newPath));
        String command = "save " + newPath;
        runCommandThenCheckForResultMessage(command,
                String.format(Messages.MESSAGE_SET_STORAGE_SUCCESS, newPath));

        // Check that storage path is changed
        assertEquals(Config.getInstance().getTodoListFilePath(), newPath);

        // Check that todo list loaded is the same as previous todo list
        TodoList todoListAtSavedLocation = TodoList.getInstance();
        assertTrue(TestUtil.compareTasksOfTodoLists(todoListAtSavedLocation,
                                                    new TypicalTestTodoLists().getTypicalTodoList()));
    }

    @Test
    public void save_fileExists() {
        String newPath = TestUtil.getFilePathInSandboxFolder("existing_file.json");
        try {
            FileUtil.createFile(new File(newPath));
            String command = "save " + newPath;
            runCommandThenCheckForResultMessage(command,
                    String.format(StoreController.MESSAGE_RESULT_WARNING_OVERWRITE, newPath)
                            + "\n" + String.format(Messages.MESSAGE_SET_STORAGE_SUCCESS, newPath));

            // Check that storage path is changed
            assertEquals(Config.getInstance().getTodoListFilePath(), newPath);

            // Check that todo list loaded is the same as previous todo list
            TodoList todoListAtSavedLocation = TodoList.getInstance();
            assertTrue(TestUtil.compareTasksOfTodoLists(todoListAtSavedLocation,
                    new TypicalTestTodoLists().getTypicalTodoList()));
        } catch (IOException e) {
            fail("Should not reach here");
        }
    }

    @Test
    public void save_sameLocation() {
        String newPath = TestApp.SAVE_LOCATION_FOR_TESTING;
        String command = "save " + newPath;
        runCommandThenCheckForResultMessage(command,
                String.format(Messages.MESSAGE_STORAGE_SAME_LOCATION, newPath));
    }

    @Test
    public void save_noStoragePath() {
        String command = "save ";
        runCommandThenCheckForResultMessage(command, Messages.MESSAGE_NO_STORAGE_PATH);
    }

    @Test
    public void save_invalidStoragePath() {
        String newPath = "///invalidLocation????/a";
        String command = "save " + newPath;
        runCommandThenCheckForResultMessage(command,
                String.format(Messages.MESSAGE_SET_STORAGE_FAILURE, newPath));
    }
}
```
###### /java/guitests/SwitchCommandTest.java
``` java
package guitests;

import static org.junit.Assert.assertFalse;

import java.time.LocalDateTime;
import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;

import guitests.guihandles.TaskListHandle;
import javafx.scene.input.KeyCode;
import seedu.toluist.controller.SwitchController;
import seedu.toluist.model.Task;
import seedu.toluist.model.TodoList;

/**
 * Gui tests for switch command
 */
public class SwitchCommandTest extends ToLuistGuiTest {
    private static final String TAB_INCOMPLETE = "INCOMPLETE";
    private static final String TAB_TODAY = "TODAY";
    private static final String TAB_NEXT_7_DAYS = "NEXT 7 DAYS";
    private static final String TAB_COMPLETED = "COMPLETED";
    private static final String TAB_ALL = "ALL";

    private Task floatingTask = new Task("floating task");
    private Task taskWithDeadline = new Task("last week task", LocalDateTime.now());
    private Task eventIn6Days = new Task("event", LocalDateTime.now().plusDays(1), LocalDateTime.now().plusDays(4));

    @Before
    public void setUp() {
        TodoList todoList = TodoList.getInstance();
        todoList.setTasks(new ArrayList<>());
        taskWithDeadline.setCompleted(true);
        todoList.add(floatingTask);
        todoList.add(taskWithDeadline);
        todoList.add(eventIn6Days);
        todoList.save();
        commandBox.runCommand("list");
        commandBox.runCommand("switch i");

        // Check that some default tasks are there
        assertTasksShown(true, floatingTask, eventIn6Days);
        assertFalse(isTaskShown(taskWithDeadline));
    }

    @Test
    public void switch_noTab() {
        String command = "switch ";
        runCommandThenCheckForResultMessage(command, SwitchController.MESSAGE_RESULT_NO_TAB);
    }

    @Test
    public void switch_toInvalidTab() {
        String tab = "fffs";
        String command = "switch " + tab;
        runCommandThenCheckForResultMessage(command,
                String.format(SwitchController.MESSAGE_RESULT_SWITCH_FAILURE, tab));
    }

    @Test
    public void switch_toValidTabUsingShortcutName() {
        String switchToToday = "switch t";
        commandBox.runCommand(switchToToday);
        assertSwitchResult(new Task[] { taskWithDeadline }, new Task[] { eventIn6Days, floatingTask },
                SwitchController.MESSAGE_RESULT_SWITCH_SUCCESS_ALL, TAB_TODAY, 1, 3);

        String switchToNext7Days = "switch n";
        commandBox.runCommand(switchToNext7Days);
        assertSwitchResult(new Task[] { eventIn6Days }, new Task[] { taskWithDeadline, floatingTask },
                SwitchController.MESSAGE_RESULT_SWITCH_SUCCESS_ALL, TAB_NEXT_7_DAYS, 1, 3);
    }

    @Test
    public void switch_toValidTabUsingShortcutNameCaseInsensitive() {
        String switchToToday = "switch T ";
        commandBox.runCommand(switchToToday);
        assertSwitchResult(new Task[] { taskWithDeadline }, new Task[] { eventIn6Days, floatingTask },
                SwitchController.MESSAGE_RESULT_SWITCH_SUCCESS_ALL, TAB_TODAY, 1, 3);
    }

    @Test
    public void switch_toValidTabUsingNumber() {
        String switchToToday = "switch 2";
        commandBox.runCommand(switchToToday);
        assertSwitchResult(new Task[] { taskWithDeadline }, new Task[] { eventIn6Days, floatingTask },
                SwitchController.MESSAGE_RESULT_SWITCH_SUCCESS_ALL, TAB_TODAY, 1, 3);

        String switchToNext7Days = "switch 3";
        commandBox.runCommand(switchToNext7Days);
        assertSwitchResult(new Task[] { eventIn6Days }, new Task[] { taskWithDeadline, floatingTask },
                SwitchController.MESSAGE_RESULT_SWITCH_SUCCESS_ALL, TAB_NEXT_7_DAYS, 1, 3);
    }

    @Test
    public void switch_toValidTabAfterFiltering() {
        String commandFilter = "filter task";
        commandBox.runCommand(commandFilter);

        String switchToToday = "switch tod";
        commandBox.runCommand(switchToToday);
        assertSwitchResult(new Task[] { taskWithDeadline }, new Task[] { eventIn6Days, floatingTask },
                SwitchController.MESSAGE_RESULT_SWITCH_SUCCESS_FILTERED, TAB_TODAY, 1, 2);

        String switchToNext7Days = "switch n";
        commandBox.runCommand(switchToNext7Days);
        assertSwitchResult(new Task[0], new Task[] { taskWithDeadline, eventIn6Days, floatingTask },
                SwitchController.MESSAGE_RESULT_SWITCH_SUCCESS_FILTERED, TAB_NEXT_7_DAYS, 0, 2);
    }

    @Test
    public void switch_toValidTabUsingHotkey() {
        mainGui.press(KeyCode.CONTROL, KeyCode.DIGIT2);
        assertSwitchResult(TAB_TODAY + " (1/3)", new Task[] { taskWithDeadline },
                new Task[] { eventIn6Days, floatingTask },
                SwitchController.MESSAGE_RESULT_SWITCH_SUCCESS_ALL, TAB_TODAY, 1, 3);

        mainGui.press(KeyCode.CONTROL, KeyCode.DIGIT3);
        assertSwitchResult(TAB_NEXT_7_DAYS + " (1/3)", new Task[] { eventIn6Days },
                new Task[] { taskWithDeadline, floatingTask },
                SwitchController.MESSAGE_RESULT_SWITCH_SUCCESS_ALL, TAB_NEXT_7_DAYS, 1, 3);

        mainGui.press(KeyCode.CONTROL, KeyCode.DIGIT4);
        assertSwitchResult(TAB_COMPLETED + " (1/3)", new Task[] { taskWithDeadline },
                new Task[] { eventIn6Days, floatingTask },
                SwitchController.MESSAGE_RESULT_SWITCH_SUCCESS_ALL, TAB_COMPLETED, 1, 3);

        mainGui.focusOnView(TaskListHandle.TASK_LIST_VIEW_ID);
        mainGui.press(KeyCode.CONTROL, KeyCode.DIGIT5);
        assertSwitchResult(TAB_ALL + " (3/3)",
                new Task[] { taskWithDeadline, eventIn6Days, floatingTask }, new Task[0],
                SwitchController.MESSAGE_RESULT_SWITCH_SUCCESS_ALL, TAB_ALL, 3, 3);

        mainGui.press(KeyCode.CONTROL, KeyCode.DIGIT1);
        assertSwitchResult(TAB_INCOMPLETE + " (2/3)",
                new Task[] { floatingTask, eventIn6Days }, new Task[] { taskWithDeadline },
                SwitchController.MESSAGE_RESULT_SWITCH_SUCCESS_ALL, TAB_INCOMPLETE, 2, 3);

        runCommandThenCheckForResultMessage("history", "list\nswitch i\n2 commands displayed.");
    }

    /**
     * Helper method to check the result of switching
     * @param tasksToBeShown tasks that should be shown
     * @param tasksNotToBeShown tasks that should not be shown
     * @param resultMessageTemplate template for result message
     * @param templateParams params for the template, if any
     */
    private void assertSwitchResult(Task[] tasksToBeShown, Task[] tasksNotToBeShown,
                                    String resultMessageTemplate, Object... templateParams) {
        assertTasksShown(true, tasksToBeShown);
        assertTasksShown(false, tasksNotToBeShown);
        assertResultMessage(String.format(resultMessageTemplate, templateParams));
    }

    /**
     * Helper method to check the result of switching
     * @param highlightedTab expected label of the highlighed tab
     * @param tasksToBeShown tasks that should be shown
     * @param tasksNotToBeShown tasks that should not be shown
     * @param resultMessageTemplate template for result message
     * @param templateParams params for the template, if any
     */
    private void assertSwitchResult(String highlightedTab, Task[] tasksToBeShown, Task[] tasksNotToBeShown,
                                    String resultMessageTemplate, Object... templateParams) {
        assertSwitchResult(tasksToBeShown, tasksNotToBeShown, resultMessageTemplate, templateParams);
        assertTabShown(highlightedTab);
    }
}
```
###### /java/guitests/ToLuistGuiTest.java
``` java
package guitests;

import static junit.framework.TestCase.fail;
import static org.junit.Assert.assertEquals;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import org.junit.After;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Rule;

import org.junit.rules.TestName;
import org.testfx.api.FxToolkit;

import guitests.guihandles.CommandAutoCompleteViewHandle;
import guitests.guihandles.CommandBoxHandle;
import guitests.guihandles.HelpHandle;
import guitests.guihandles.MainGuiHandle;
import guitests.guihandles.ResultDisplayHandle;
import guitests.guihandles.TabBarViewHandle;
import guitests.guihandles.TaskListHandle;


import javafx.application.Platform;
import javafx.collections.ObservableList;
import javafx.stage.Stage;
import seedu.toluist.TestApp;
import seedu.toluist.commons.core.EventsCenter;
import seedu.toluist.commons.events.BaseEvent;
import seedu.toluist.model.Task;
import seedu.toluist.model.TodoList;
import seedu.toluist.testutil.TestUtil;
import seedu.toluist.testutil.TypicalTestTodoLists;

/**
 * Gui Test class
 */
public abstract class ToLuistGuiTest {

    // The TestName Rule makes the current test name available inside test methods.
    @Rule
    public TestName name = new TestName();

    TestApp testApp;

    // Handles to GUI elements present at the start up are created in advance for easy access from child classes.
    protected MainGuiHandle mainGui;
    protected ResultDisplayHandle resultDisplay;
    protected CommandBoxHandle commandBox;
    protected TaskListHandle taskList;
    protected TabBarViewHandle tabBar;
    protected CommandAutoCompleteViewHandle commandAutoCompleteView;
    protected HelpHandle helpView;

    private Stage stage;

    @BeforeClass
    public static void setupSpec() {
        try {
            FxToolkit.registerPrimaryStage();
            FxToolkit.hideStage();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }
    }

    @Before
    public void setup() throws Exception {
        FxToolkit.setupStage((stage) -> {
            mainGui = new MainGuiHandle(new GuiRobot(), stage);
            resultDisplay = mainGui.getResultDisplay();
            commandBox = mainGui.getCommandBox();
            taskList = mainGui.getTaskList();
            tabBar = mainGui.getTabBar();
            commandAutoCompleteView = mainGui.getCommandAutoCompleteView();
            helpView = mainGui.getHelpView();
            this.stage = stage;
        });
        EventsCenter.clearSubscribers();
        TestUtil.cleanSandboxFolder();
        testApp = (TestApp) FxToolkit.setupApplication(() -> new TestApp(this::getInitialData,
                                                                        getConfigFileLocation(),
                                                                        getDataFileLocation()));
        // Sleep for 1 second to allow initial data to be loaded
        TimeUnit.SECONDS.sleep(1);
        FxToolkit.showStage();
        while (!stage.isShowing());
        mainGui.focusOnMainApp();
    }

    /**
     * Override this in child classes to set the initial local data.
     * Return null to use the data in the file specified in {@link #getDataFileLocation()}
     */
    protected TodoList getInitialData() {
        TodoList todoList = new TypicalTestTodoLists().getTypicalTodoList();
        return todoList;
    }

    /**
     * Override this in child classes to set the config file location.
     */
    protected String getConfigFileLocation() {
        return TestApp.CONFIG_LOCATION_FOR_TESTING;
    }

    /**
     * Override this in child classes to set the data file location.
     */
    protected String getDataFileLocation() {
        return TestApp.SAVE_LOCATION_FOR_TESTING;
    }

    @After
    public void cleanup() throws TimeoutException {
        FxToolkit.cleanupStages();
    }

    public void raise(BaseEvent e) {
        //JUnit doesn't run its test cases on the UI thread. Platform.runLater is used to post event on the UI thread.
        Platform.runLater(() -> EventsCenter.getInstance().post(e));
    }

    /**
     * Run a command then use callback to check for result
     * @param command command string
     * @param callback a callback, can be lambda
     */
    protected void runCommandWithCallback(String command, Runnable callback) {
        commandBox.runCommand(command);
        callback.run();
    }

    /**
     * Run a command then check if the tasks are shown and not shown. Also check for expect result message
     * @param command command string
     * @param resultMessage expected result message
     * @param tasksShown all the tasks that should be shown
     * @param tasksNotShown all the tasks that should not be shown
     */
    protected void runCommandThenCheckForTasks(String command, String resultMessage,
                                               Task[] tasksShown, Task[] tasksNotShown) {
        runCommandThenCheckForTasks(command, tasksShown, tasksNotShown);
        assertResultMessage(resultMessage);
    }

    /**
     * Run a command then check if the tasks are shown and not shown
     * @param command command string
     * @param tasksShown all the tasks that should be shown
     * @param tasksNotShown all the tasks that should not be shown
     */
    protected void runCommandThenCheckForTasks(String command, Task[] tasksShown, Task[] tasksNotShown) {
        commandBox.runCommand(command);
        assertTasksShown(true, tasksShown);
        assertTasksShown(false, tasksNotShown);
    }

    /**
     * Run a command then check if the result message matches the expected one
     * @param command a command
     * @param resultMessage expected result message
     */
    protected void runCommandThenCheckForResultMessage(String command, String resultMessage) {
        commandBox.runCommand(command);
        assertResultMessage(resultMessage);
    }

    /**
     * Asserts the message shown in the Result Display area is same as the given string.
     */
    protected void assertResultMessage(String expected) {
        assertEquals(resultDisplay.getText(), expected);
    }

    /**
     * Asserts the label of the highlighted tab is same as the given string.
     */
    protected void assertTabShown(String expected) {
        assertEquals(tabBar.getHighlightedTabText(), expected);
    }

    /**
     * Check if tasks are shown in the TaskList. Returns true only if all tasks are shown.
     */
    protected void assertTasksShown(boolean isShown, Task... tasks) {
        for (Task task : tasks) {
            if (isTaskShown(task) != isShown) {
                fail("task should be shown/not shown");
            }
        }
    }

    /**
     * Returns the lists of tasks shown on UI
     */
    protected ObservableList<Task> getTasksShown() {
        return taskList.getTaskList().getItems();
    }

    /**
     * Check if a task is shown in the TaskList
     */
    protected boolean isTaskShown(Task task) {
        boolean taskIsPresent = getTasksShown().stream()
                .filter(t -> t.equals(task))
                .findFirst()
                .isPresent();
        return taskIsPresent;
    }
}
```
###### /java/guitests/UnaliasCommandTest.java
``` java
package guitests;

import org.junit.Before;
import org.junit.Test;

import seedu.toluist.commons.core.Config;
import seedu.toluist.controller.UnaliasController;
import seedu.toluist.model.Task;

/**
 * Gui tests for unalias command
 */
public class UnaliasCommandTest extends ToLuistGuiTest {
    @Before
    public void setUp() {
        Config.getInstance().getAliasTable().clearAliases();
    }

    @Test
    public void unalias_nonExistingAlias() {
        String unaliasCommand = "unalias d";
        runCommandThenCheckForResultMessage(unaliasCommand,
                String.format(UnaliasController.MESSAGE_RESULT_NOT_ALIAS, "d"));
    }

    @Test
    public void unalias_existingAlias() {
        Config.getInstance().getAliasTable().setAlias("d", "add");

        String unaliasCommand = "unalias d";
        commandBox.runCommand(unaliasCommand);

        String taskDescription = "read lecture slides from Prof Henry";
        String addCommand = "d " + taskDescription;
        Task task = new Task(taskDescription);
        runCommandThenCheckForTasks(addCommand, new Task[0], new Task[] { task });
    }
}
```
###### /java/guitests/UndoCommandTest.java
``` java
package guitests;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

import javafx.scene.input.KeyCode;
import seedu.toluist.model.Task;
import seedu.toluist.model.TodoList;
import seedu.toluist.testutil.TypicalTestTodoLists;

/**
 * Gui tests for undo command
 */
public class UndoCommandTest extends ToLuistGuiTest {
    @Test
    public void undoSingleCommand() {
        String taskDescription = "build a rocket";
        String addCommand = "add " + taskDescription;
        Task task = new Task(taskDescription);
        commandBox.runCommand(addCommand);
        assertTrue(isTaskShown(task));

        String undoCommand = "undo";
        commandBox.runCommand(undoCommand);
        assertFalse(isTaskShown(task));

        assertFalse(TodoList.getInstance().getTasks().contains(task));
    }

    @Test
    public void undoMultipleCommand() {
        String taskDescription = "build a rocket";
        String addCommand = "add " + taskDescription;
        Task task = new Task(taskDescription);
        commandBox.runCommand(addCommand);
        assertTrue(isTaskShown(task));

        String taskDescription2 = "ride a unicorn";
        String addCommand2 = "add " + taskDescription2;
        Task task2 = new Task(taskDescription2);
        commandBox.runCommand(addCommand2);
        assertTrue(isTaskShown(task2));

        String undoCommand = "undo 2";
        commandBox.runCommand(undoCommand);
        assertFalse(isTaskShown(task));
        assertFalse(isTaskShown(task2));

        assertFalse(TodoList.getInstance().getTasks().contains(task));
        assertFalse(TodoList.getInstance().getTasks().contains(task2));
    }

    @Test
    public void undoWithHotkey() {
        String command = "delete -";
        commandBox.runCommand(command);
        for (Task task : new TypicalTestTodoLists().getTypicalTasks()) {
            assertFalse(isTaskShown(task));
        }

        mainGui.press(KeyCode.CONTROL, KeyCode.Z);
        assertTasksShown(true, new TypicalTestTodoLists().getTypicalTasks());
    }
}
```
###### /java/guitests/UnknownCommandTest.java
``` java
package guitests;

import org.junit.Test;

import seedu.toluist.commons.core.Messages;

/**
 * GuiTest for unknown command
 */
public class UnknownCommandTest extends ToLuistGuiTest {
    @Test
    public void unknownCommand() {
        commandBox.runCommand("alias unknown");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }
}
```
###### /java/guitests/ViewAliasCommandTest.java
``` java
package guitests;

import org.junit.Before;
import org.junit.Test;

import seedu.toluist.commons.core.Config;
import seedu.toluist.controller.ViewAliasController;

/**
 * Gui tests for viewalias command
 */
public class ViewAliasCommandTest extends ToLuistGuiTest {
    @Before
    public void setUp() {
        Config.getInstance().getAliasTable().clearAliases();
    }

    @Test
    public void viewAlias_noAliases() {
        checkResultOfViewAlias(ViewAliasController.MESSAGE_RESULT_NO_ALIAS);
    }

    @Test
    public void viewAlias_oneAlias() {
        String aliasCommand = "alias d add";
        commandBox.runCommand(aliasCommand);

        String expected = "d:add";
        checkResultOfViewAlias(expected);
    }

    @Test
    public void viewAlias_multipleAliases() {
        String aliasCommandForAdd = "alias d add";
        commandBox.runCommand(aliasCommandForAdd);

        String aliasCommandForDelete = "alias del delete";
        commandBox.runCommand(aliasCommandForDelete);

        String aliasCommandForGibberish = "alias g gibberish";
        commandBox.runCommand(aliasCommandForGibberish);


        String expected = "d:add\ndel:delete\ng:gibberish";
        checkResultOfViewAlias(expected);
    }

    /**
     * Check output of viewalias command
     * @param expected expected result message
     */
    private void checkResultOfViewAlias(String expected) {
        runCommandThenCheckForResultMessage("viewalias", expected);
    }
}
```
###### /java/seedu/toluist/commons/core/ConfigTest.java
``` java
package seedu.toluist.commons.core;

import static junit.framework.TestCase.assertFalse;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertTrue;

import java.io.File;
import java.util.logging.Level;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.TemporaryFolder;

import seedu.toluist.commons.util.FileUtil;
import seedu.toluist.model.AliasTable;
import seedu.toluist.testutil.TestUtil;

public class ConfigTest {
    private static final String TEST_CONFIG_FILE_PATH = FileUtil.getPath("./src/test/data/ConfigTest/");

    @Rule
    public TemporaryFolder folder = new TemporaryFolder();

    @Before
    public void resetConfig() throws NoSuchFieldException, IllegalAccessException {
        TestUtil.resetSingleton(Config.class);
    }

    @Test
    public void defaultConfig_correctProperties() {
        Config config = new Config();
        assertSimilarToDefaultConfig(config);
    }

    @Test
    public void load_nonExistentFile_returnsDefaultConfig() {
        Config config = loadTestConfig(folder.getRoot().getPath());
        assertSimilarToDefaultConfig(config);
    }

    @Test
    public void load_emptyConfig_returnsDefaultConfig() {
        Config config = loadTestConfig("EmptyConfig.json");
        assertSimilarToDefaultConfig(config);
    }

    @Test
    public void load_notJsonFormat_returnsDefaultConfig() {
        Config config = loadTestConfig("NotJsonFormatConfig.json");
        assertSimilarToDefaultConfig(config);
    }

    @Test
    public void load_differentValues_useDifferentValues() {
        Config config = loadTestConfig("TypicalConfig.json");
        assertEquals(config, getTypicalConfig());
    }

    @Test
    public void save_fileThatCannotBeSaved_fail() {
        String path = folder.getRoot().getPath();
        Config.setConfigFilePath(path);
        assertFalse(getTypicalConfig().save());
    }

    @Test
    public void save_missingFile_createNewFile() {
        String missingFilePath = TestUtil.getFilePathInSandboxFolder("testConfig.json");
        File missingFile = new File(missingFilePath);

        // Remove this file if it exists
        FileUtil.removeFile(missingFile);
        assertFalse(FileUtil.isFileExists(missingFile));

        Config.setConfigFilePath(missingFilePath);
        assertTrue(getTypicalConfig().save());
        assertTrue(FileUtil.isFileExists(missingFile));
        assertEquals(getTypicalConfig(), Config.getInstance());
    }

    @Test
    public void save_existingFile_overWriteFile() {
        String filePath = TestUtil.getFilePathInSandboxFolder("testConfig.json");
        Config.setConfigFilePath(filePath);

        // Save a config first
        Config defaultConfig = new Config();
        defaultConfig.save();

        // Then save another config
        getTypicalConfig().save();

        // Check that data was overwritten
        assertNotEquals(defaultConfig, Config.getInstance());
        assertEquals(getTypicalConfig(), Config.getInstance());
    }

    private Config loadTestConfig(String testConfigFilePath) {
        Config.setConfigFilePath(TEST_CONFIG_FILE_PATH + "/" + testConfigFilePath);
        return Config.getInstance();
    }

    /**
     * Returns a typical config
     */
    private Config getTypicalConfig() {
        Config config = new Config();
        config.setTodoListFilePath("data/b.json");
        config.getAliasTable().setAlias("a", "add");
        config.setGuiSettings(new GuiSettings(600.0, 600.0, 400, 60));
        return config;
    }

    /**
     * Assert that the config's properties are the default properties
     */
    private void assertSimilarToDefaultConfig(Config config) {
        assertEquals(config.getAppTitle(), Config.APP_NAME);
        assertEquals(config.getAliasTable(), new AliasTable());
        assertEquals(config.getLogLevel(), Level.INFO);
        assertEquals(config.getTodoListFilePath(), Config.DEFAULT_TODO_LIST_FILE_PATH);
        assertEquals(config.getGuiSettings(), new GuiSettings());
    }
}
```
###### /java/seedu/toluist/commons/core/SwitchConfigTest.java
``` java
package seedu.toluist.commons.core;

import static org.junit.Assert.assertEquals;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Optional;

import org.junit.Test;

import seedu.toluist.model.TaskSwitchPredicate;

/**
 * Tests for SwitchConfig
 */
public class SwitchConfigTest {
    @Test
    public void testDefaultSwitchConfig() {
        SwitchConfig switchConfig = SwitchConfig.getDefaultSwitchConfig();

        ArrayList<TaskSwitchPredicate> expectedPredicates = new ArrayList<>(Arrays.asList(
            TaskSwitchPredicate.SWITCH_PREDICATE_INCOMPLETE,
            TaskSwitchPredicate.SWITCH_PREDICATE_TODAY,
            TaskSwitchPredicate.SWITCH_PREDICATE_NEXT_7_DAYS,
            TaskSwitchPredicate.COMPLETED_SWITCH_PREDICATE,
            TaskSwitchPredicate.SWITCH_PREDICATE_ALL
        ));
        assertEquals(expectedPredicates, switchConfig.getAllPredicates());

        assertEquals(switchConfig.getPredicate("1"),
                Optional.of(TaskSwitchPredicate.SWITCH_PREDICATE_INCOMPLETE));
        assertEquals(switchConfig.getPredicate("2"),
                Optional.of(TaskSwitchPredicate.SWITCH_PREDICATE_TODAY));
        assertEquals(switchConfig.getPredicate("3"),
                Optional.of(TaskSwitchPredicate.SWITCH_PREDICATE_NEXT_7_DAYS));
        assertEquals(switchConfig.getPredicate("4"),
                Optional.of(TaskSwitchPredicate.COMPLETED_SWITCH_PREDICATE));
        assertEquals(switchConfig.getPredicate("5"),
                Optional.of(TaskSwitchPredicate.SWITCH_PREDICATE_ALL));

        assertEquals(switchConfig.getPredicate("i"),
                Optional.of(TaskSwitchPredicate.SWITCH_PREDICATE_INCOMPLETE));
        assertEquals(switchConfig.getPredicate("T"),
                Optional.of(TaskSwitchPredicate.SWITCH_PREDICATE_TODAY));
        assertEquals(switchConfig.getPredicate("N"),
                Optional.of(TaskSwitchPredicate.SWITCH_PREDICATE_NEXT_7_DAYS));
        assertEquals(switchConfig.getPredicate("C"),
                Optional.of(TaskSwitchPredicate.COMPLETED_SWITCH_PREDICATE));
        assertEquals(switchConfig.getPredicate("a"),
                Optional.of(TaskSwitchPredicate.SWITCH_PREDICATE_ALL));

        assertEquals(switchConfig.getPredicate("al"),
                Optional.of(TaskSwitchPredicate.SWITCH_PREDICATE_ALL));

        assertEquals(switchConfig.getPredicate("gibberish"), Optional.empty());
    }
}
```
###### /java/seedu/toluist/commons/util/CollectionUtilTest.java
``` java
    @Test
    public void isAnyPresent() throws Exception {
        // no arguments
        assertFalse(CollectionUtil.isAnyPresent());

        // any non-presentt argument list
        assertFalse(CollectionUtil.isAnyPresent(Optional.empty(), Optional.empty()));
        assertFalse(CollectionUtil.isAnyPresent(Optional.empty()));

        // argument lists with just one present at the beginning
        assertTrue(CollectionUtil.isAnyPresent(Optional.of(1)));
        assertTrue(CollectionUtil.isAnyPresent(Optional.of(false), Optional.empty(), Optional.empty()));

        // argument lists with present optional in the middle
        assertTrue(CollectionUtil.isAnyPresent(Optional.empty(), Optional.of(StringUtil.EMPTY_STRING),
                Optional.empty()));

        // argument lists with one present as the last argument
        assertTrue(CollectionUtil.isAnyPresent(Optional.empty(), Optional.empty(), Optional.of(true)));
    }

```
###### /java/seedu/toluist/commons/util/CollectionUtilTest.java
``` java
    @Test
    public void elementsAreSimilar() {
        // empty collections
        assertTrue(CollectionUtil.elementsAreSimilar(new HashSet<>(), new HashSet<>()));

        // collections have the same elements in same order
        assertTrue(CollectionUtil.elementsAreSimilar(Arrays.asList(true, false), Arrays.asList(true, false)));

        // collections have the same elements in different order
        assertTrue(CollectionUtil.elementsAreSimilar(Arrays.asList(1, 2), Arrays.asList(2, 1)));

        // one collection has more different element
        assertFalse(CollectionUtil.elementsAreSimilar(Arrays.asList(1, 2, 3), Arrays.asList(2, 1)));
        assertFalse(CollectionUtil.elementsAreSimilar(Arrays.asList("a", "b"), Arrays.asList("a", "b", "c")));

        // one collection has more similar element
        assertFalse(CollectionUtil.elementsAreSimilar(Arrays.asList(1, 2, 1), Arrays.asList(2, 1)));
        assertFalse(CollectionUtil.elementsAreSimilar(Arrays.asList("a", "b"), Arrays.asList("a", "b", "a")));
    }

    @Test
    public void getStringRepresentation() {
        // empty collections
        assertEquals(CollectionUtil.getStringRepresentation(StringUtil.EMPTY_STRING, new HashSet<>()), "");

        // collections with items
        assertEquals(CollectionUtil.getStringRepresentation(", ", Arrays.asList(1, 2)), "1, 2");
        assertEquals(CollectionUtil.getStringRepresentation("-", Arrays.asList("a", "b")), "a-b");
    }

```
###### /java/seedu/toluist/commons/util/DateTimeFormatterUtilTest.java
``` java
package seedu.toluist.commons.util;

import static junit.framework.TestCase.assertEquals;

import java.time.LocalDateTime;

import org.junit.Test;

import seedu.toluist.model.Task.RecurringFrequency;

/**
 * Tests for DateTimeFormatter
 */
public class DateTimeFormatterUtilTest {
    @Test
    public void formatDate() {
        // Test format normal date
        LocalDateTime aDateTime = LocalDateTime.of(2009, 12, 1, 12, 22);
        String expectedADateTime = "Tue, 01 Dec 2009";
        assertEquals(expectedADateTime, DateTimeFormatterUtil.formatDate(aDateTime));

        // Test format today
        LocalDateTime today = LocalDateTime.now();
        String expectedToday = DateTimeFormatterUtil.TODAY;
        assertEquals(expectedToday, DateTimeFormatterUtil.formatDate(today));

        // Test format yesterday
        LocalDateTime yesterday = LocalDateTime.now().minusDays(1);
        String expectedYesterday = DateTimeFormatterUtil.YESTERDAY;
        assertEquals(expectedYesterday, DateTimeFormatterUtil.formatDate(yesterday));

        // Test format today
        LocalDateTime tomorrow = LocalDateTime.now().plusDays(1);
        String expectedTomorrow = DateTimeFormatterUtil.TOMORROW;
        assertEquals(expectedTomorrow, DateTimeFormatterUtil.formatDate(tomorrow));
    }

    @Test
    public void formatTime() {
        // Test format time AM
        LocalDateTime dateTimeAM = LocalDateTime.of(1 , 1 , 1 , 1, 2);
        String expectedAM = "01:02 AM";
        assertEquals(expectedAM, DateTimeFormatterUtil.formatTime(dateTimeAM));

        // Test format time PM
        LocalDateTime dateTimePM = LocalDateTime.of(1 , 1 , 1 , 23, 2);
        String expectedPM = "11:02 PM";
        assertEquals(expectedPM, DateTimeFormatterUtil.formatTime(dateTimePM));
    }

    @Test
    public void formatTaskDeadline() {
        LocalDateTime deadline = LocalDateTime.of(2008, 12, 1, 12, 22);
        String expectedDeadline = "by Mon, 01 Dec 2008, 12:22 PM";
        assertEquals(expectedDeadline, DateTimeFormatterUtil.formatTaskDeadline(deadline));
    }

    @Test
    public void formatEventRange() {
        // Different days for from and to
        LocalDateTime fromDifferentDay = LocalDateTime.of(2008, 12, 1, 12, 22);
        LocalDateTime toDifferentDay = LocalDateTime.of(2009, 12, 1, 13, 22);
        String expectedDifferentDayFromTo = "Mon, 01 Dec 2008, 12:22 PM to Tue, 01 Dec 2009, 01:22 PM";
        assertEquals(expectedDifferentDayFromTo,
                DateTimeFormatterUtil.formatEventRange(fromDifferentDay, toDifferentDay));

        // Same day for from and to
        LocalDateTime fromSameDay = LocalDateTime.of(2009, 12, 1, 13, 22);
        LocalDateTime toSameDay = LocalDateTime.of(2009, 12, 1, 17, 22);
        String expectedSameDayFromTo = "Tue, 01 Dec 2009, 01:22 PM to 05:22 PM";
        assertEquals(expectedSameDayFromTo,
                DateTimeFormatterUtil.formatEventRange(fromSameDay, toSameDay));
    }

    @Test
    public void formatRecurringTaskDeadline() {
        LocalDateTime deadline = LocalDateTime.of(2008, 12, 1, 12, 22);
        LocalDateTime recurringUntilEndDate = LocalDateTime.of(2009, 12, 1, 17, 22);

        RecurringFrequency daily = RecurringFrequency.DAILY;
        String expectedResult = "Every 12:22 PM of the day";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringTaskDeadline(deadline, null, daily));
        expectedResult = "Every 12:22 PM of the day until Tue, 01 Dec 2009";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringTaskDeadline(deadline, recurringUntilEndDate, daily));

        RecurringFrequency weekly = RecurringFrequency.WEEKLY;
        expectedResult = "Every Monday of the week";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringTaskDeadline(deadline, null, weekly));
        expectedResult = "Every Monday of the week until Tue, 01 Dec 2009";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringTaskDeadline(deadline, recurringUntilEndDate, weekly));

        RecurringFrequency monthly = RecurringFrequency.MONTHLY;
        expectedResult = "Every 1st of the month";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringTaskDeadline(deadline, null, monthly));
        expectedResult = "Every 1st of the month until Tue, 01 Dec 2009";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringTaskDeadline(deadline, recurringUntilEndDate, monthly));

        RecurringFrequency yearly = RecurringFrequency.YEARLY;
        expectedResult = "Every 1st December of the year";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringTaskDeadline(deadline, null, yearly));
        expectedResult = "Every 1st December of the year until Tue, 01 Dec 2009";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringTaskDeadline(deadline, recurringUntilEndDate, yearly));
    }

    @Test
    public void formatRecurringEvent() {
        LocalDateTime from;
        LocalDateTime to;
        LocalDateTime recurringUntilEndDate = LocalDateTime.of(2009, 12, 1, 17, 22);

        // same time
        from = LocalDateTime.of(2008, 12, 1, 12, 22);
        to = LocalDateTime.of(2008, 12, 2, 12, 22);
        RecurringFrequency daily = RecurringFrequency.DAILY;
        String expectedResult = "Every 12:22 PM of the day";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringEvent(from, to, null, daily));
        expectedResult = "Every 12:22 PM of the day until Tue, 01 Dec 2009";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringEvent(from, to, recurringUntilEndDate, daily));

        // same day of week
        from = LocalDateTime.of(2008, 12, 1, 12, 22);
        to = LocalDateTime.of(2008, 12, 1, 18, 22);
        RecurringFrequency weekly = RecurringFrequency.WEEKLY;
        expectedResult = "Every Monday of the week";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringEvent(from, to, null, weekly));
        expectedResult = "Every Monday of the week until Tue, 01 Dec 2009";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringEvent(from, to, recurringUntilEndDate, weekly));

        // same day of month
        from = LocalDateTime.of(2008, 12, 1, 12, 22);
        to = LocalDateTime.of(2008, 12, 1, 18, 22);
        RecurringFrequency monthly = RecurringFrequency.MONTHLY;
        expectedResult = "Every 1st of the month";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringEvent(from, to, null, monthly));
        expectedResult = "Every 1st of the month until Tue, 01 Dec 2009";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringEvent(from, to, recurringUntilEndDate, monthly));

        // same date of year
        from = LocalDateTime.of(2008, 12, 1, 12, 22);
        to = LocalDateTime.of(2008, 12, 1, 18, 22);
        RecurringFrequency yearly = RecurringFrequency.YEARLY;
        expectedResult = "Every 1st December of the year";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringEvent(from, to, null, yearly));
        expectedResult = "Every 1st December of the year until Tue, 01 Dec 2009";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringEvent(from, to, recurringUntilEndDate, yearly));

        // same time
        from = LocalDateTime.of(2008, 12, 1, 12, 22);
        to = LocalDateTime.of(2008, 12, 1, 17, 22);
        expectedResult = "Every 12:22 PM to 05:22 PM of the day";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringEvent(from, to, null, daily));
        expectedResult = "Every 12:22 PM to 05:22 PM of the day until Tue, 01 Dec 2009";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringEvent(from, to, recurringUntilEndDate, daily));

        // different day of week
        from = LocalDateTime.of(2008, 12, 1, 12, 22);
        to = LocalDateTime.of(2008, 12, 5, 18, 22);
        expectedResult = "Every Monday to Friday of the week";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringEvent(from, to, null, weekly));
        expectedResult = "Every Monday to Friday of the week until Tue, 01 Dec 2009";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringEvent(from, to, recurringUntilEndDate, weekly));

        // different day of month
        from = LocalDateTime.of(2008, 12, 1, 12, 22);
        to = LocalDateTime.of(2009, 12, 30, 18, 22);
        expectedResult = "Every 1st to 30th of the month";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringEvent(from, to, null, monthly));
        expectedResult = "Every 1st to 30th of the month until Tue, 01 Dec 2009";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringEvent(from, to, recurringUntilEndDate, monthly));

        // different date of year
        from = LocalDateTime.of(2008, 12, 1, 12, 22);
        to = LocalDateTime.of(2009, 3, 1, 18, 22);
        expectedResult = "Every 1st December to 1st March of the year";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringEvent(from, to, null, yearly));
        expectedResult = "Every 1st December to 1st March of the year until Tue, 01 Dec 2009";
        assertEquals(expectedResult,
                DateTimeFormatterUtil.formatRecurringEvent(from, to, recurringUntilEndDate, yearly));

    }

    @Test
    public void getDayNumberSuffix() {
        int[] days = {1, 2, 3, 4, 10, 11, 12, 13, 14, 20, 21, 22, 23, 24, 30, 31};
        String[] suffixes = {"st", "nd", "rd", "th", "th",
                             "th", "th", "th", "th", "th",
                             "st", "nd", "rd", "th", "th",
                             "st"};
        for (int i = 0; i < 16; i++) {
            assertEquals(suffixes[i], DateTimeFormatterUtil.getDayNumberSuffix(days[i]));
        }
    }
}
```
###### /java/seedu/toluist/commons/util/DateTimeUtilTest.java
``` java
package seedu.toluist.commons.util;

import static junit.framework.TestCase.assertFalse;
import static org.junit.Assert.assertTrue;

import java.time.LocalDateTime;
import java.time.Month;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.temporal.ChronoUnit;

import org.junit.Test;

/**
 * Tests for DateTimeUtil
 */
public class DateTimeUtilTest {

```
###### /java/seedu/toluist/commons/util/DateTimeUtilTest.java
``` java
    @Test
    public void isToday_startOfToday_isTrue() {
        ZonedDateTime datetime = ZonedDateTime.now().toLocalDate().atStartOfDay(ZoneId.systemDefault());
        LocalDateTime startOfToday =  LocalDateTime.ofInstant(datetime.toInstant(), ZoneId.systemDefault());
        assertTrue(DateTimeUtil.isToday(startOfToday));
    }

    @Test
    public void isToday_endOfToday_isTrue() {
        ZonedDateTime datetime = ZonedDateTime.now().toLocalDate().plusDays(1)
                .atStartOfDay(ZoneId.systemDefault()).minusSeconds(1);
        LocalDateTime endOfToday =  LocalDateTime.ofInstant(datetime.toInstant(), ZoneId.systemDefault());
        assertTrue(DateTimeUtil.isToday(endOfToday));
    }

    @Test
    public void isToday_startOfTomorrow_isFalse() {
        ZonedDateTime datetime = ZonedDateTime.now().toLocalDate().plusDays(1)
                .atStartOfDay(ZoneId.systemDefault());
        LocalDateTime startOfTomorrow =  LocalDateTime.ofInstant(datetime.toInstant(), ZoneId.systemDefault());
        assertFalse(DateTimeUtil.isToday(startOfTomorrow));
    }

    @Test
    public void isToday_endOfYesterday_isFalse() {
        ZonedDateTime datetime = ZonedDateTime.now().toLocalDate().atStartOfDay(ZoneId.systemDefault()).minusSeconds(1);
        LocalDateTime endOfYesterday =  LocalDateTime.ofInstant(datetime.toInstant(), ZoneId.systemDefault());
        assertFalse(DateTimeUtil.isToday(endOfYesterday));
    }

    @Test
    public void isYesterday_startOfYesterday_isTrue() {
        ZonedDateTime datetime = ZonedDateTime.now().toLocalDate().atStartOfDay(ZoneId.systemDefault()).minusDays(1);
        LocalDateTime startOfYesterday =  LocalDateTime.ofInstant(datetime.toInstant(), ZoneId.systemDefault());
        assertTrue(DateTimeUtil.isYesterday(startOfYesterday));
    }

    @Test
    public void isYesterday_endOfYesterday_isTrue() {
        ZonedDateTime datetime = ZonedDateTime.now().toLocalDate().atStartOfDay(ZoneId.systemDefault()).minusSeconds(1);
        LocalDateTime endOfYesterday =  LocalDateTime.ofInstant(datetime.toInstant(), ZoneId.systemDefault());
        assertTrue(DateTimeUtil.isYesterday(endOfYesterday));
    }

    @Test
    public void isYesterday_startOfToday_isFalse() {
        ZonedDateTime datetime = ZonedDateTime.now().toLocalDate().atStartOfDay(ZoneId.systemDefault());
        LocalDateTime startOfToday =  LocalDateTime.ofInstant(datetime.toInstant(), ZoneId.systemDefault());
        assertFalse(DateTimeUtil.isYesterday(startOfToday));
    }

    @Test
    public void isYesterday_endOfTheDayBeforeYesterday_isFalse() {
        ZonedDateTime datetime = ZonedDateTime.now().toLocalDate().minusDays(1)
                .atStartOfDay(ZoneId.systemDefault()).minusSeconds(1);
        LocalDateTime endOfTheDayBeforeYesterday =  LocalDateTime.ofInstant(datetime.toInstant(),
                ZoneId.systemDefault());
        assertFalse(DateTimeUtil.isYesterday(endOfTheDayBeforeYesterday));
    }

    @Test
    public void isTomorrow_startOfTomorrow_isTrue() {
        ZonedDateTime datetime = ZonedDateTime.now().toLocalDate().atStartOfDay(ZoneId.systemDefault()).plusDays(1);
        LocalDateTime startOfTomorrow =  LocalDateTime.ofInstant(datetime.toInstant(), ZoneId.systemDefault());
        assertTrue(DateTimeUtil.isTomorrow(startOfTomorrow));
    }

    @Test
    public void isTomorrow_endOfTomorrow_isTrue() {
        ZonedDateTime datetime = ZonedDateTime.now().toLocalDate().plusDays(2)
                .atStartOfDay(ZoneId.systemDefault()).minusSeconds(1);
        LocalDateTime endOfTomorrow =  LocalDateTime.ofInstant(datetime.toInstant(), ZoneId.systemDefault());
        assertTrue(DateTimeUtil.isTomorrow(endOfTomorrow));
    }

    @Test
    public void isTomorrow_startOfTheDayAfterTomorrow_isFalse() {
        ZonedDateTime datetime = ZonedDateTime.now().toLocalDate().atStartOfDay(ZoneId.systemDefault()).plusDays(2);
        LocalDateTime startOfTheDayAfterTomorrow =  LocalDateTime.ofInstant(datetime.toInstant(),
                ZoneId.systemDefault());
        assertFalse(DateTimeUtil.isTomorrow(startOfTheDayAfterTomorrow));
    }

    @Test
    public void isTomorrow_endOfToday_isFalse() {
        ZonedDateTime datetime = ZonedDateTime.now().toLocalDate().plusDays(1)
                .atStartOfDay(ZoneId.systemDefault()).minusSeconds(1);
        LocalDateTime endOfToday =  LocalDateTime.ofInstant(datetime.toInstant(),
                ZoneId.systemDefault());
        assertFalse(DateTimeUtil.isTomorrow(endOfToday));
    }

    @Test
    public void isBeforeOrEqual_twoNulls_isTrue() {
        assertTrue(DateTimeUtil.isBeforeOrEqual(null, null));
    }

    @Test
    public void isBeforeOrEqual_nullAndNonNull_isFalse() {
        assertFalse(DateTimeUtil.isBeforeOrEqual(null, LocalDateTime.now()));
    }

    @Test
    public void isBeforeOrEqual_nonNullAndNull_isTrue() {
        assertTrue(DateTimeUtil.isBeforeOrEqual(LocalDateTime.now(), null));
    }

    @Test
    public void isBeforeOrEqual_leftAfterRight_isFalse() {
        assertFalse(DateTimeUtil.isBeforeOrEqual(LocalDateTime.MAX, LocalDateTime.MIN));
    }

    @Test
    public void isBeforeOrEqual_leftEqualsRight_isTrue() {
        assertTrue(DateTimeUtil.isBeforeOrEqual(LocalDateTime.MIN, LocalDateTime.MIN));
    }

    @Test
    public void isBeforeOrEqual_leftBeforeRight_isTrue() {
        assertTrue(DateTimeUtil.isBeforeOrEqual(LocalDateTime.MIN, LocalDateTime.MAX));
    }

```
###### /java/seedu/toluist/commons/util/FileUtilTest.java
``` java
package seedu.toluist.commons.util;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.io.File;
import java.io.IOException;

import org.junit.Before;
import org.junit.Test;

import seedu.toluist.testutil.TestUtil;

/**
 * Tests for FileUtil
 */
public class FileUtilTest {
    @Before
    public void clearSandboxFolder() {
        TestUtil.cleanSandboxFolder();
    }

    @Test
    public void createIfMissing() throws IOException {
        File file = new File(TestUtil.getFilePathInSandboxFolder("missing"));
        FileUtil.createIfMissing(file);
        assertTrue(file.exists());
    }

    @Test
    public void createParentDirOfFile() throws IOException {
        File file = new File(TestUtil.getFilePathInSandboxFolder("missingFolder/missing"));
        FileUtil.createParentDirsOfFile(file);
        assertTrue(file.getParentFile().exists());
    }

    @Test
    public void createFile_noMissingParentDir() throws IOException {
        File file = new File(TestUtil.getFilePathInSandboxFolder("file"));
        FileUtil.createFile(file);
        assertTrue(file.exists());
    }

    @Test
    public void createFile_missingParentDirs() throws IOException {
        File file = new File(TestUtil.getFilePathInSandboxFolder("file/file/file"));
        FileUtil.createFile(file);
        assertTrue(file.exists());
        assertTrue(file.getParentFile().exists());
        assertTrue(file.getParentFile().getParentFile().exists());
    }

    @Test
    public void writeFile() throws IOException {
        File file = new File(TestUtil.getFilePathInSandboxFolder("file/file/file"));
        String expected = "some content";
        FileUtil.writeToFile(file, expected);

        // Check that any missing parent dirs are created
        assertTrue(file.exists());
        assertTrue(file.getParentFile().exists());
        assertTrue(file.getParentFile().getParentFile().exists());

        // Check that the content of the file when read is the same
        assertEquals(FileUtil.readFromFile(file), expected);
    }
}
```
###### /java/seedu/toluist/controller/AddTaskControllerTest.java
``` java
package seedu.toluist.controller;

import java.util.ArrayList;
import java.util.HashMap;

import org.junit.Test;

import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.model.Task;
import seedu.toluist.testutil.TypicalTestTodoLists;

/**
 * Tests for AddTaskController
 */
public class AddTaskControllerTest extends ControllerTest {

    protected Controller controllerUnderTest() {
        return new AddTaskController();
    }

    @Test
    public void addFloatingTask() throws InvalidCommandException {
        String taskDescription = "learn how to catch a pokemon";
        Task floatingTask = new Task(taskDescription);
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put("description", taskDescription);
        controller.execute(tokens);

        ArrayList<Task> tasksThatShouldExist = new ArrayList<>();
        for (Task task : (new TypicalTestTodoLists()).getTypicalTasks()) {
            tasksThatShouldExist.add(task);
        }
        tasksThatShouldExist.add(floatingTask);
        assertTasksExist(tasksThatShouldExist.toArray(new Task[3]));
    }
}
```
###### /java/seedu/toluist/controller/AliasControllerTest.java
``` java
package seedu.toluist.controller;

import static junit.framework.TestCase.assertFalse;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;


import java.util.Arrays;
import java.util.HashMap;

import org.junit.Test;

/**
 * Tests for AliasController
 */
public class AliasControllerTest extends ControllerTest {
    protected Controller controllerUnderTest() {
        return new AliasController();
    }

    @Test
    public void getCommandWord() {
        assertEquals(Arrays.asList(AliasController.COMMAND_WORD),
                Arrays.asList(new AliasController().getCommandWords()));
    }

    @Test
    public void matchesCommand() {
        assertTrue(controller.matchesCommand("alias a add"));
        assertTrue(controller.matchesCommand("alias d1 delete 1"));
        assertFalse(controller.matchesCommand("alias a"));
        assertFalse(controller.matchesCommand("alias"));
    }

    @Test
    public void tokenize() {
        HashMap<String, String> tokensForAliasingOneWord = new HashMap<>();
        tokensForAliasingOneWord.put(AliasController.PARAMETER_ALIAS, "a");
        tokensForAliasingOneWord.put(AliasController.PARAMETER_COMMAND, "add");
        assertEquals(tokensForAliasingOneWord, controller.tokenize("alias a add"));

        HashMap<String, String> tokensForAliasingMultipleWords = new HashMap<>();
        tokensForAliasingMultipleWords.put(AliasController.PARAMETER_ALIAS, "u1");
        tokensForAliasingMultipleWords.put(AliasController.PARAMETER_COMMAND, "update 1");
        assertEquals(tokensForAliasingMultipleWords, controller.tokenize("alias u1   update 1"));
    }
}
```
###### /java/seedu/toluist/controller/ControllerTest.java
``` java
package seedu.toluist.controller;

import static junit.framework.TestCase.fail;
import static org.mockito.Mockito.when;

import org.junit.Before;
import org.junit.Rule;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnit;
import org.mockito.junit.MockitoRule;

import seedu.toluist.commons.exceptions.DataStorageException;
import seedu.toluist.model.Task;
import seedu.toluist.model.TodoList;
import seedu.toluist.storage.TodoListStorage;
import seedu.toluist.testutil.TestUtil;
import seedu.toluist.testutil.TypicalTestTodoLists;

/**
 * Base class for Controller tests. All Controller tests should extend this class
 */
public abstract class ControllerTest {
    @Rule
    public MockitoRule rule = MockitoJUnit.rule();

    @Mock
    protected TodoListStorage storage;
    protected Controller controller;
    protected TodoList todoList;

    /**
     * Returns an instance of the controller to be teste
     * @return the controller instance to be tested
     */
    protected abstract Controller controllerUnderTest();

    @Before
    public void setUp() throws DataStorageException, NoSuchFieldException, IllegalAccessException {
        when(storage.load()).thenReturn(new TypicalTestTodoLists().getTypicalTodoList());
        TestUtil.resetSingleton(TodoList.class);
        todoList = TodoList.getInstance();
        todoList.setStorage(storage);
        todoList.load();
        controller = controllerUnderTest();
    }

    /**
     * Asserts that each task exists in memory
     * @param tasks varargs of tasks
     */
    protected void assertTasksExist(Task... tasks) {
        for (Task task : tasks) {
            if (!todoList.getTasks().contains(task)) {
                fail("Task should exist");
            }
        }
    }

    /**
     * Asserts that each task does not exist in memory
     * @param tasks varargs of tasks
     */
    protected void assertTasksNotExist(Task... tasks) {
        for (Task task : tasks) {
            if (TodoList.getInstance().getTasks().contains(task)) {
                fail("Task should not exist");
            }
        }
    }
}
```
###### /java/seedu/toluist/controller/ExitControllerTest.java
``` java
package seedu.toluist.controller;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.util.Arrays;
import java.util.HashMap;

import org.junit.Test;

/**
 * Tests for ExitController
 */
public class ExitControllerTest extends ControllerTest {
    protected Controller controllerUnderTest() {
        return new ExitController();
    }

    @Test
    public void getCommandWord() {
        assertEquals(Arrays.asList(ExitController.COMMAND_WORD_EXIT, ExitController.COMMAND_WORD_QUIT),
                    Arrays.asList(new ExitController().getCommandWords()));
    }

    @Test
    public void matchesCommand() {
        assertTrue(controller.matchesCommand("exit "));
        assertTrue(controller.matchesCommand("exit"));
        assertTrue(controller.matchesCommand("quit"));
        assertTrue(controller.matchesCommand(" quit"));
    }

    @Test
    public void tokenize() {
        assertEquals(new HashMap<>(), controller.tokenize("exit"));
        assertEquals(new HashMap<>(), controller.tokenize("quit "));
    }
}
```
###### /java/seedu/toluist/controller/LoadControllerTest.java
``` java
package seedu.toluist.controller;

import static junit.framework.TestCase.assertFalse;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.util.Arrays;
import java.util.HashMap;

import org.junit.Test;

/**
 * Tests for LoadController
 */
public class LoadControllerTest extends ControllerTest {
    protected Controller controllerUnderTest() {
        return new LoadController();
    }

    @Test
    public void getCommandWord() {
        assertEquals(Arrays.asList(LoadController.COMMAND_WORD),
                Arrays.asList(new LoadController().getCommandWords()));
    }

    @Test
    public void matchesCommand() {
        // With no storage provided
        assertTrue(controller.matchesCommand("load  "));
        assertTrue(controller.matchesCommand("load"));

        // with valid storage provided
        assertTrue(controller.matchesCommand("load aFile.json"));

        // with invalid storage provided
        assertTrue(controller.matchesCommand("load sfas?////sffsf.json"));

        // with more than 1 parameters
        assertFalse(controller.matchesCommand("load a b c"));
    }

    @Test
    public void tokenize() {
        HashMap<String, String> tokensNoArgument = new HashMap<>();
        tokensNoArgument.put(StoreController.PARAMETER_STORE_DIRECTORY, null);
        assertEquals(tokensNoArgument, controller.tokenize("load"));

        HashMap<String, String> tokensOneArgument = new HashMap<>();
        tokensOneArgument.put(StoreController.PARAMETER_STORE_DIRECTORY, "abc");
        assertEquals(tokensOneArgument, controller.tokenize("load abc"));
    }
}
```
###### /java/seedu/toluist/controller/StoreControllerTest.java
``` java
package seedu.toluist.controller;

import static junit.framework.TestCase.assertFalse;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.util.Arrays;
import java.util.HashMap;

import org.junit.Test;

/**
 * Tests for StoreController
 */
public class StoreControllerTest extends ControllerTest {
    protected Controller controllerUnderTest() {
        return new StoreController();
    }

    @Test
    public void getCommandWord() {
        assertEquals(Arrays.asList(StoreController.COMMAND_WORD),
                Arrays.asList(new StoreController().getCommandWords()));
    }

    @Test
    public void matchesCommand() {
        // With no storage provided
        assertTrue(controller.matchesCommand("save  "));
        assertTrue(controller.matchesCommand("save"));

        // with valid storage provided
        assertTrue(controller.matchesCommand("save aFile.json"));

        // with invalid storage provided
        assertTrue(controller.matchesCommand("save sfas?////sffsf.json"));

        // with more than 1 parameters
        assertFalse(controller.matchesCommand("save a b c"));
    }

    @Test
    public void tokenize() {
        HashMap<String, String> tokensNoArgument = new HashMap<>();
        tokensNoArgument.put(StoreController.PARAMETER_STORE_DIRECTORY, null);
        assertEquals(tokensNoArgument, controller.tokenize("save"));

        HashMap<String, String> tokensOneArgument = new HashMap<>();
        tokensOneArgument.put(StoreController.PARAMETER_STORE_DIRECTORY, "abc");
        assertEquals(tokensOneArgument, controller.tokenize("save abc"));
    }
}
```
###### /java/seedu/toluist/controller/SwitchControllerTest.java
``` java
package seedu.toluist.controller;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.util.Arrays;
import java.util.HashMap;

import org.junit.Test;

/**
 * Tests for SwitchController
 */
public class SwitchControllerTest extends ControllerTest {
    protected Controller controllerUnderTest() {
        return new SwitchController();
    }

    @Test
    public void getCommandWord() {
        assertEquals(Arrays.asList(SwitchController.COMMAND_WORD),
                Arrays.asList(new SwitchController().getCommandWords()));
    }

    @Test
    public void matchesCommand() {
        // With no tab provided
        assertTrue(controller.matchesCommand("switch  "));
        assertTrue(controller.matchesCommand("switch"));

        // with valid tab provided
        assertTrue(controller.matchesCommand("switch c"));

        // with invalid tab provided
        assertTrue(controller.matchesCommand("switch ccc   "));
    }

    @Test
    public void tokenize() {
        HashMap<String, String> tokensNoArgument = new HashMap<>();
        tokensNoArgument.put(SwitchController.PARAMETER_TAB, null);
        assertEquals(tokensNoArgument, controller.tokenize("switch  "));

        HashMap<String, String> tokensOneArgument = new HashMap<>();
        tokensOneArgument.put(SwitchController.PARAMETER_TAB, "abc");
        assertEquals(tokensOneArgument, controller.tokenize("switch abc"));
    }
}
```
###### /java/seedu/toluist/model/AliasTableTest.java
``` java
package seedu.toluist.model;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.junit.Before;
import org.junit.Test;

/**
 * Tests for AliasTable
 */
public class AliasTableTest {
    private final AliasTable aliasTable = new AliasTable();
    private final AliasTable aliasTableWithReservedWords = new AliasTable();
    private final String resersedWordA = "add";
    private final String resersedWordB = "update";


    @Before
    public void setUp() {
        Set<String> reservedWords = new HashSet<>();
        reservedWords.add(resersedWordA);
        reservedWords.add(resersedWordB);
        aliasTableWithReservedWords.setReservedKeywords(reservedWords);
    }

    @Test
    public void equalsMethod() {
        // Tables with no aliases are equal
        AliasTable aliasTable1 = new AliasTable();
        AliasTable aliasTable2 = new AliasTable();
        assertEquals(aliasTable1, aliasTable2);

        // Table is not equal to null
        assertNotEquals(aliasTable1, null);

        // Tables with equals alias mapping are equal
        aliasTable1.setAlias("a", "add");
        aliasTable2.setAlias("a", "add");
        assertEquals(aliasTable1, aliasTable2);

        // Tables with same reserved keywords are equal
        aliasTable1.setReservedKeywords(new HashSet<String>(Arrays.asList(new String[] { "add" })));
        aliasTable2.setReservedKeywords(new HashSet<String>(Arrays.asList(new String[] { "add" })));
        assertEquals(aliasTable1, aliasTable2);
    }

    @Test
    public void isReservedWord_reservedWord_isTrue() {
        assert(aliasTableWithReservedWords.isReservedWord(resersedWordA));
    }

    @Test
    public void isReservedWord_nonReservedWord_isFalse() {
        String nonReservedWord = "delete";
        assert(!aliasTableWithReservedWords.isReservedWord(nonReservedWord));
    }

    @Test
    public void addAlias_validAlias_isSuccessful() {
        String alias = "add";
        String command = "test";
        aliasTable.setAlias(alias, command);
        assert(aliasTable.isAlias(alias));
    }

    @Test
    public void addAlias_nonValidAlias_fail() {
        String command = "test";
        aliasTableWithReservedWords.setAlias(resersedWordA, command);
        assert(!aliasTable.isAlias(resersedWordA));
    }

    @Test
    public void removeAlias_existingAlias_replacesData() {
        String alias = "add";
        String command = "test";
        aliasTable.setAlias(alias, command);
        aliasTable.removeAlias(alias);
        assert(!aliasTable.isAlias(alias));
    }

    @Test
    public void removeAlias_nonExistentAlias_notReplacesData() {
        String alias = "add";
        String command = "test";
        String nonAlias = "add1";
        aliasTable.setAlias(alias, command);
        aliasTable.removeAlias(nonAlias);
        assert(aliasTable.isAlias(alias));
    }

    @Test
    public void getAliasMapping_emptyMapping_isCorrect() {
        assertEquals(aliasTable.getAliasMapping(), new HashMap<String, String>());
    }

    @Test
    public void getAliasMapping_OneAlias_isCorrect() {
        String alias = "add";
        String command = "test";
        aliasTable.setAlias(alias, command);

        Map<String, String> otherMapping = new HashMap<>();
        otherMapping.put(alias, command);

        assertEquals(aliasTable.getAliasMapping(), otherMapping);
    }

    @Test
    public void getAliasMapping_ManyAliases_isCorrect() {
        String alias1 = "add";
        String command1 = "test";
        String alias2 = "remove";
        String command2 = "test2";
        String alias3 = "update";
        String command3 = "yes";

        aliasTable.setAlias(alias1, command1);
        aliasTable.setAlias(alias2, command2);
        aliasTable.setAlias(alias3, command3);

        Map<String, String> otherMapping = new HashMap<>();
        otherMapping.put(alias1, command1);
        otherMapping.put(alias2, command2);
        otherMapping.put(alias3, command3);

        assertEquals(aliasTable.getAliasMapping(), otherMapping);
    }

    @Test
    public void dealias_commandInputWithAlias_replaceAlias() {
        String input = "d a task";
        String alias = "d";
        String command = "add that";
        String output = "add that a task";

        aliasTable.setAlias(alias, command);
        assertEquals(aliasTable.dealias(input), output);
    }

    @Test
    public void dealias_commandInputWithoutAlias_returnsCommandInput() {
        String input1 = "d a task";
        assertEquals(aliasTable.dealias(input1), input1);

        aliasTable.setAlias("a", "add");
        String input2 = "add task";
        // Won't match partial word
        assertEquals(aliasTable.dealias(input2), input2);
    }
}
```
###### /java/seedu/toluist/model/TaskSwitchPredicateTest.java
``` java
package seedu.toluist.model;

import static org.junit.Assert.assertEquals;

import java.time.LocalDateTime;

import org.junit.Test;

/**
 * Tests for TaskSwitchPredicate
 */
public class TaskSwitchPredicateTest {
    @Test
    public void todaySwitchPredicate() {
        assertTaskWithDeadlineSatisfiesPredicate(LocalDateTime.now(), TaskSwitchPredicate.SWITCH_PREDICATE_TODAY, true);
        assertTaskWithDeadlineSatisfiesPredicate(LocalDateTime.now().minusDays(1), TaskSwitchPredicate
                        .SWITCH_PREDICATE_TODAY,
                false);
        assertTaskWithDeadlineSatisfiesPredicate(LocalDateTime.now().plusDays(1), TaskSwitchPredicate
                        .SWITCH_PREDICATE_TODAY,
                false);
    }

    @Test
    public void next7DaysSwitchPredicate() {
        assertTaskWithDeadlineSatisfiesPredicate(LocalDateTime.now(),
                TaskSwitchPredicate.SWITCH_PREDICATE_NEXT_7_DAYS, false);
        assertTaskWithDeadlineSatisfiesPredicate(LocalDateTime.now().plusDays(7),
                TaskSwitchPredicate.SWITCH_PREDICATE_NEXT_7_DAYS, true);
        assertTaskWithDeadlineSatisfiesPredicate(LocalDateTime.now().plusDays(1),
                TaskSwitchPredicate.SWITCH_PREDICATE_NEXT_7_DAYS, true);
        assertTaskWithDeadlineSatisfiesPredicate(LocalDateTime.now().plusDays(8),
                TaskSwitchPredicate.SWITCH_PREDICATE_NEXT_7_DAYS, false);
    }


    /**
     * Helper method to check that a predicate works correctly
     * @param deadline a deadline to check
     * @param predicate a TaskSwitchPredicate instance
     * @param isSatisfied should the predicate be satisfied
     */
    private void assertTaskWithDeadlineSatisfiesPredicate(LocalDateTime deadline, TaskSwitchPredicate predicate,
                                                          boolean isSatisfied) {
        Task task = new Task("task", deadline);
        assertEquals(predicate.getPredicate().test(task), isSatisfied);
    }
}
```
###### /java/seedu/toluist/model/TaskTest.java
``` java
package seedu.toluist.model;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

import org.junit.Before;
import org.junit.Test;

import seedu.toluist.commons.util.DateTimeUtil;

/**
 * Tests for Task model
 */
public class TaskTest {
    private Task testTask;
    private final String taskDescription = "a description";

    private final Tag tag1 = new Tag("nature");
    private final Tag tag2 = new Tag("nature");
    private final Tag tag3 = new Tag("wolf");
    private final Tag tag4 = new Tag("cat");


    @Before
    public void setUp() {
        testTask = new Task(taskDescription);
        testTask.addTag(tag1);
    }

    @Test
    public void testConstruct_testTask() {
        Task task = new Task(taskDescription);
        assertEquals(task.getDescription(), taskDescription);
        assertNull(task.getStartDateTime());
        assertNull(task.getEndDateTime());
        assertNull(task.getCompletionDateTime());
        assertEquals(task.getTaskPriority(), Task.TaskPriority.LOW);
        assertTrue(task.getAllTags().isEmpty());
        assertTrue(task.isFloatingTask());
    }

    @Test
    public void testConstruct_taskWithDeadline() {
        LocalDateTime dateTime = LocalDateTime.now();
        Task task = new Task(taskDescription, dateTime);
        assertEquals(task.getDescription(), taskDescription);
        assertNull(task.getStartDateTime());
        assertEquals(task.getEndDateTime(), dateTime);
        assertNull(task.getCompletionDateTime());
        assertEquals(task.getTaskPriority(), Task.TaskPriority.LOW);
        assertTrue(task.getAllTags().isEmpty());
        assertTrue(task.isTaskWithDeadline());
    }

    @Test
    public void testConstruct_event() {
        LocalDateTime from = LocalDateTime.now().minusDays(1);
        LocalDateTime to = LocalDateTime.now();
        Task event = new Task(taskDescription, from, to);
        assertEquals(event.getDescription(), taskDescription);
        assertEquals(event.getStartDateTime(), from);
        assertEquals(event.getEndDateTime(), to);
        assertNull(event.getCompletionDateTime());
        assertEquals(event.getTaskPriority(), Task.TaskPriority.LOW);
        assertTrue(event.getAllTags().isEmpty());
        assertTrue(event.isEvent());
    }

    @Test
    public void setDeadline() {
        LocalDateTime now = LocalDateTime.now();
        testTask.setDeadLine(now);
        assertEquals(testTask.getEndDateTime(), now);
        // task is now a task with deadline
        assertTrue(testTask.isTaskWithDeadline());
    }

    @Test
    public void setFromTo() {
        LocalDateTime from = LocalDateTime.now().minusDays(1);
        LocalDateTime to = LocalDateTime.now();
        testTask.setFromTo(from, to);
        assertEquals(testTask.getStartDateTime(), from);
        assertEquals(testTask.getEndDateTime(), to);
        // task is now an event
        assertTrue(testTask.isEvent());
    }

    @Test
    public void setComplete() {
        LocalDateTime now = LocalDateTime.now();
        // Set completed
        testTask.setCompleted(true);
        assertNotNull(testTask.getCompletionDateTime());
        assertTrue(testTask.isCompleted());
        assertTrue(DateTimeUtil.isBeforeOrEqual(now, testTask.getCompletionDateTime()));

        // Set incomplete
        testTask.setCompleted(false);
        assertNull(testTask.getCompletionDateTime());
        assertFalse(testTask.isCompleted());
    }

    @Test
    public void isOverdue() {
        // incomplete task with end date passed is overdue
        testTask.setDeadLine(LocalDateTime.now().minusDays(1));
        assertTrue(testTask.isOverdue());

        // incomplete task with end date in future is not overdue
        testTask.setDeadLine(LocalDateTime.MAX);
        assertFalse(testTask.isOverdue());

        // complete task with end date passed is not overdue
        testTask.setDeadLine(LocalDateTime.MIN);
        testTask.setCompleted(true);
        assertTrue(testTask.isCompleted());
        assertFalse(testTask.isOverdue());
    }

    @Test
    public void addTag_newTag_tagIsAdded() {
        testTask.addTag(tag3);
        assertSimilarTags(testTask, tag1, tag3);
    }

    @Test
    public void addTag_existingTag_tagIsNotAddedTwice() {
        testTask.addTag(tag1);
        assertSimilarTags(testTask, tag1);
    }

    @Test
    public void addTag_tagWithSameTagName_tagIsNotAddedTwice() {
        testTask.addTag(tag2);
        assertSimilarTags(testTask, tag1);
    }

    @Test
    public void removeTag_existingTag_tagIsRemoved() {
        testTask.removeTag(tag1);
        assertSimilarTags(testTask);
    }

    @Test
    public void removeTag_tagWithSameTagName_tagIsRemoved() {
        testTask.removeTag(tag2);
        assertSimilarTags(testTask);
    }

    @Test
    public void removeTag_nonExistingTag_noEffect() {
        testTask.removeTag(tag3);
        assertSimilarTags(testTask, tag1);
    }

    @Test
    public void replaceTag_emptyTagList_replaceTags() {
        testTask.replaceTags(new ArrayList<>());
        assertSimilarTags(testTask);
    }

    @Test
    public void replaceTag_listWithSingleTag_replaceTags() {
        ArrayList<Tag> tagsList = new ArrayList<>();
        tagsList.add(tag3);

        testTask.replaceTags(tagsList);
        assertSimilarTags(testTask, tag3);
    }

    @Test
    public void replaceTag_listWithMultipleTags_replaceTags() {
        ArrayList<Tag> tagsList = new ArrayList<>();
        tagsList.add(tag3);
        tagsList.add(tag4);

        testTask.replaceTags(tagsList);
        assertSimilarTags(testTask, tag3, tag4);
    }

    @Test
    public void replaceTag_listWithEqualTags_keepUniqueTags() {
        ArrayList<Tag> tagsList = new ArrayList<>();
        tagsList.add(tag1);
        tagsList.add(tag2);
        tagsList.add(tag4);

        testTask.replaceTags(tagsList);
        assertSimilarTags(testTask, tag1, tag4);
    }

    @Test
    public void compareTo_differentPriority() {
        Task.sortBy("default");
        Task testTask = new Task("floating");
        Task highPriorityTask = new Task("high priority");
        Task event = new Task("event", LocalDateTime.now().minusDays(1), LocalDateTime.now().plusDays(1));
        highPriorityTask.setTaskPriority(Task.TaskPriority.HIGH);

        assertEquals(highPriorityTask.compareTo(event), -1);
        assertEquals(highPriorityTask.compareTo(testTask), -1);
    }

    @Test
    public void compareTo_samePriorityDifferentEndDateTime() {
        Task.sortBy("default");
        Task testTask = new Task("floating");
        Task taskWithDeadline = new Task("task with deadline", LocalDateTime.now());
        Task event = new Task("event", LocalDateTime.now().minusDays(1), LocalDateTime.now().plusDays(1));
        assertEquals(taskWithDeadline.compareTo(event), -1);
        assertEquals(event.compareTo(testTask), -1);
    }

    @Test
    public void compareTo_sameEndDateTimeSamePriorityDifferentStartDateTime() {
        Task.sortBy("default");
        LocalDateTime to = LocalDateTime.now();
        LocalDateTime from  = to.minusDays(1);
        Task event1 = new Task("event 1", from, to);
        Task event2 = new Task("event 2", from.minusDays(1), to);
        assertEquals(event2.compareTo(event1), -1);
    }

    @Test
    public void compareTo_sameEndDateTimeSameStartDateTimeSamePriorityDifferentDescription() {
        Task.sortBy("default");
        LocalDateTime to = LocalDateTime.now();
        LocalDateTime from  = to.minusDays(1);
        Task event1 = new Task("event 1", from, to);
        Task event2 = new Task("event 2", from, to);
        assertEquals(event1.compareTo(event2), -1);

        Task taskWithDeadline1 = new Task("task 1", to);
        Task taskWithDeadline2 = new Task("task 2", to);
        assertEquals(taskWithDeadline1.compareTo(taskWithDeadline2), -1);

        Task testTask1 = new Task("floating 1");
        Task testTask2 = new Task("floating 2");
        assertEquals(testTask1.compareTo(testTask2), -1);
    }

    @Test
    public void compareTo_nonOverdueOverdue() {
        Task.sortBy("default");
        Task task1 = new Task("yesterday", LocalDateTime.now().minusDays(1));
        task1.setCompleted(true);
        Task task2 = new Task("today", LocalDateTime.now());

        assertEquals(task2.compareTo(task1), -1);
    }

    @Test
    public void isWithinInterval_nullFromNullTo() {
        Task floatingTask = new Task("floating");
        Task taskWithDeadline = new Task("task with deadline", LocalDateTime.MIN);
        Task event = new Task("event", LocalDateTime.MIN, LocalDateTime.MAX);

        assertTrue(floatingTask.isWithinInterval(null, null));
        assertTrue(taskWithDeadline.isWithinInterval(null, null));
        assertTrue(event.isWithinInterval(null, null));
    }

    @Test
    public void isWithinInterval_nonNullFromNullTo() {
        Task floatingTask = new Task("floating");
        Task taskWithDeadline = new Task("task with deadline", LocalDateTime.MIN);
        Task event = new Task("event", LocalDateTime.MIN, LocalDateTime.MAX);

        assertTrue(floatingTask.isWithinInterval(LocalDateTime.MIN, null));
        assertTrue(taskWithDeadline.isWithinInterval(LocalDateTime.MIN, null));
        assertTrue(event.isWithinInterval(LocalDateTime.MIN, null));
    }

    @Test
    public void isWithinInterval_nullFromNonNullTo() {
        Task floatingTask = new Task("floating");
        Task taskWithDeadline = new Task("task with deadline", LocalDateTime.MIN);
        Task event = new Task("event", LocalDateTime.MIN, LocalDateTime.MAX);

        assertTrue(floatingTask.isWithinInterval(null, LocalDateTime.MIN));
        assertTrue(taskWithDeadline.isWithinInterval(null, LocalDateTime.MIN));
        assertTrue(event.isWithinInterval(null, LocalDateTime.MIN));
    }

    @Test
    public void isWithinInterval_nonNullFromNonNullTo() {
        Task floatingTask = new Task("floating");
        Task taskWithDeadline1 = new Task("task with deadline", LocalDateTime.MAX);
        Task taskWithDeadline2 = new Task("task with deadline", LocalDateTime.MIN);
        Task event1 = new Task("event", LocalDateTime.MIN, LocalDateTime.MIN.plusDays(2));
        Task event2 = new Task("event", LocalDateTime.MAX.minusDays(2), LocalDateTime.MAX);

        assertFalse(floatingTask.isWithinInterval(LocalDateTime.MIN, LocalDateTime.MAX));
        assertFalse(taskWithDeadline1.isWithinInterval(LocalDateTime.MIN, LocalDateTime.MAX.minusDays(1)));
        assertTrue(taskWithDeadline2.isWithinInterval(LocalDateTime.MIN, LocalDateTime.MAX));
        assertTrue(event1.isWithinInterval(LocalDateTime.MIN.plusDays(1), LocalDateTime.MAX));
        assertTrue(event2.isWithinInterval(LocalDateTime.MIN, LocalDateTime.MAX.minusDays(1)));
    }

    /**
     * Check if the set of tags in the tasks and the tags passed in are identical
     */
    private void assertSimilarTags(Task task, Tag... tags) {
        Set<Tag> tagSet = new HashSet<>();
        for (Tag tag : tags) {
            tagSet.add(tag);
        }

        assertEquals(testTask.getAllTags(), tagSet);
    }

```
###### /java/seedu/toluist/model/TodoListTest.java
``` java
    @Rule
    public MockitoRule rule = MockitoJUnit.rule();

    @Mock
    private TodoListStorage storage;
    private TodoList todoList1;
    private TodoList todoListWithStorage;
    private TodoList sampleTodoList = new TypicalTestTodoLists().getTypicalTodoList();
    private final Task task1 = new Task("Task 1");
    private final Task task2 = new Task("Task 2");
    private final Task task3 = new Task("Task 3");
    private final Task task4 = new Task("Task 4");
    private final Task task5 = new Task("Task 5");

    @Before
    public void setUp() throws DataStorageException, NoSuchFieldException, IllegalAccessException {
        TestUtil.resetSingleton(TodoList.class);
        when(storage.load()).thenReturn(sampleTodoList);
        todoList1 = new TodoList();
        todoList1.add(task1);
        todoList1.add(task2);
        todoList1.add(task3);
        todoList1.add(task4);

        todoListWithStorage = new TodoList();
        todoListWithStorage.setStorage(storage);
        todoListWithStorage.load();
    }


    @Test
    public void todoList_withStorage_loadTasks() {
        assertEquals(todoListWithStorage.getTasks(), sampleTodoList.getTasks());
    }

    @Test
    public void multipleLoad_returnsSameTodoList() {
        assertEquals(TodoList.getInstance(), TodoList.getInstance());
    }

```
###### /java/seedu/toluist/storage/JsonStorageTest.java
``` java
package seedu.toluist.storage;

import static junit.framework.TestCase.fail;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.io.File;
import java.io.IOException;

import org.junit.Before;
import org.junit.Test;

import javafx.util.Pair;
import seedu.toluist.TestApp;
import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.exceptions.DataStorageException;
import seedu.toluist.commons.util.FileUtil;
import seedu.toluist.commons.util.JsonUtil;
import seedu.toluist.model.Task;
import seedu.toluist.model.TodoList;
import seedu.toluist.testutil.TestUtil;
import seedu.toluist.testutil.TypicalTestTodoLists;

/**
 * Tests for JsonStorage
 */
public class JsonStorageTest {
    private static final String TEST_STORAGE_FILE_PATH =
            FileUtil.getPath("./src/test/data/StorageTest/");
    private static final String EMPTY_JSON_DATA_FILE_PATH = TEST_STORAGE_FILE_PATH + "EmptyData.json";
    private static final String INVALID_JSON_DATA_FILE_PATH = TEST_STORAGE_FILE_PATH + "NotJsonFormatData.json";
    private static final String TYPICAL_JSON_DATA_FILE_PATH = TEST_STORAGE_FILE_PATH + "TypicalData.json";
    private static final String NON_EXISTING_FILE_PATH = TestUtil.getFilePathInSandboxFolder("non_existing.json");
    private static final String EXISTING_FILE_PATH = TestUtil.getFilePathInSandboxFolder("existing.json");
    private static final String INVALID_FILE_PATH = "////sfsfsf";
    private static final int ZILLION = 10000000;

    private JsonStorage storage;
    private TodoList emptyTodoList = new TodoList();
    private TodoList typicalTodoList = new TypicalTestTodoLists().getTypicalTodoList();
    private TodoList anotherTodoList;

    @Before
    public void setUp() {
        Config.getInstance().setTodoListFilePath(TestApp.SAVE_LOCATION_FOR_TESTING);
        storage = new JsonStorage();
        anotherTodoList = new TodoList();
        anotherTodoList.add(new Task("it's a task"));

        emptyTodoList.setStorage(storage);
        typicalTodoList.setStorage(storage);
        anotherTodoList.setStorage(storage);
    }

    @Test
    public void load_emptyData() {
        TodoList todoList = null;
        try {
            todoList = loadDataFromPath(EMPTY_JSON_DATA_FILE_PATH);
        } catch (DataStorageException e) {
            fail("Should not throw exception");
        }
        assertEquals(todoList, new TodoList());
    }

    @Test
    public void load_invalidJson() {
        try {
            loadDataFromPath(INVALID_JSON_DATA_FILE_PATH);
            fail("Should not reach here");
        } catch (DataStorageException e) {
            // good to go
        }
    }

    @Test
    public void load_typicalData() {
        TodoList todoList = null;
        try {
            todoList = loadDataFromPath(TYPICAL_JSON_DATA_FILE_PATH);
        } catch (DataStorageException e) {
            fail("Should not throw exception");
        }
        assertEquals(todoList, typicalTodoList);
    }

    @Test
    public void load_withPathEmptyData() throws DataStorageException {
        TodoList todoList = null;
        try {
            todoList = loadDataFromPath(EMPTY_JSON_DATA_FILE_PATH);
        } catch (DataStorageException e) {
            fail("Should not throw exception");
        }
        assertEquals(todoList, new TodoList());
        assertEquals(Config.getInstance().getTodoListFilePath(), EMPTY_JSON_DATA_FILE_PATH);
    }

    @Test
    public void load_withPathInvalidJson() {
        try {
            storage.load(INVALID_JSON_DATA_FILE_PATH);
            fail("Should not reach here");
        } catch (DataStorageException e) {
            // good to go
            assertEquals(Config.getInstance().getTodoListFilePath(), TestApp.SAVE_LOCATION_FOR_TESTING);
        }
    }

    @Test
    public void load_WithPathTypicalData() {
        TodoList todoList = null;
        try {
            todoList = loadDataFromPath(TYPICAL_JSON_DATA_FILE_PATH);
        } catch (DataStorageException e) {
            fail("Should not throw exception");
        }
        assertEquals(todoList, typicalTodoList);
        assertEquals(Config.getInstance().getTodoListFilePath(), TYPICAL_JSON_DATA_FILE_PATH);
    }

    @Test
    public void save_invalidPath() {
        assertFalse(saveDataToPath(new TodoList(), INVALID_FILE_PATH));
    }

    @Test
    public void save_nonExistingFile() throws DataStorageException, IOException {
        String path = NON_EXISTING_FILE_PATH;
        FileUtil.removeFile(new File(path));
        assertTrue(saveDataToPath(typicalTodoList, path));
        assertEquals(JsonUtil.toJsonString(typicalTodoList), FileUtil.readFromFile(new File(path)));
    }

    @Test
    public void save_overwriteFile() throws DataStorageException, IOException {
        String path = EXISTING_FILE_PATH;
        FileUtil.createFile(new File(path));
        assertTrue(saveDataToPath(typicalTodoList, path));
        assertEquals(JsonUtil.toJsonString(typicalTodoList), FileUtil.readFromFile(new File(path)));
    }

    @Test
    public void save_WithPathInvalidPath() {
        assertFalse(storage.save(new TodoList(), INVALID_FILE_PATH));
        assertEquals(Config.getInstance().getTodoListFilePath(), TestApp.SAVE_LOCATION_FOR_TESTING);
    }

    @Test
    public void save_WithPathNonExistingFile() throws DataStorageException, IOException {
        String path = NON_EXISTING_FILE_PATH;
        FileUtil.removeFile(new File(path));
        assertTrue(storage.save(typicalTodoList, path));
        assertEquals(JsonUtil.toJsonString(typicalTodoList), FileUtil.readFromFile(new File(path)));
        assertEquals(Config.getInstance().getTodoListFilePath(), path);
    }

    @Test
    public void save_WithPathOverwriteFile() throws DataStorageException, IOException {
        String path = EXISTING_FILE_PATH;
        FileUtil.createFile(new File(path));
        assertTrue(storage.save(typicalTodoList, path));
        assertEquals(JsonUtil.toJsonString(typicalTodoList), FileUtil.readFromFile(new File(path)));
        assertEquals(Config.getInstance().getTodoListFilePath(), path);
    }

    @Test
    public void move_toInvalidPath() throws DataStorageException, IOException {
        String oldPath = TestUtil.getFilePathInSandboxFolder("old.json");
        saveDataToPath(typicalTodoList, oldPath);
        assertEquals(JsonUtil.toJsonString(typicalTodoList), FileUtil.readFromFile(new File(oldPath)));

        String newPath = "///fff";
        assertFalse(storage.move(newPath));
        assertEquals(Config.getInstance().getTodoListFilePath(), oldPath);
        assertEquals(JsonUtil.toJsonString(typicalTodoList), FileUtil.readFromFile(new File(oldPath)));
    }

    @Test
    public void move_toValidPath() throws DataStorageException, IOException {
        String oldPath = TestUtil.getFilePathInSandboxFolder("old.json");
        saveDataToPath(typicalTodoList, oldPath);
        assertEquals(JsonUtil.toJsonString(typicalTodoList), FileUtil.readFromFile(new File(oldPath)));

        String newPath = TestUtil.getFilePathInSandboxFolder("new.json");
        assertTrue(storage.move(newPath));
        assertEquals(Config.getInstance().getTodoListFilePath(), newPath);
        assertEquals(JsonUtil.toJsonString(typicalTodoList), FileUtil.readFromFile(new File(newPath)));
        assertFalse(FileUtil.isFileExists(new File(oldPath)));
    }

    @Test
    public void undo_nothingToUndo() {
        saveDataToPath(new TodoList(), TestApp.SAVE_LOCATION_FOR_TESTING);
        assertValidUndoRedoData(storage.undo(1), new TodoList(), 0);
    }

    @Test
    public void undo_multipleOnce() {
        saveDataToPath(new TodoList(), TestApp.SAVE_LOCATION_FOR_TESTING);
        storage.save(typicalTodoList);
        storage.save(anotherTodoList);

        assertValidUndoRedoData(storage.undo(1), typicalTodoList, 1);
        assertValidUndoRedoData(storage.undo(1), new TodoList(), 1);
    }

    @Test
    public void undo_multipleTimesInOnce() {
        saveDataToPath(new TodoList(), TestApp.SAVE_LOCATION_FOR_TESTING);
        storage.save(typicalTodoList);
        storage.save(anotherTodoList);

        assertValidUndoRedoData(storage.undo(2), new TodoList(), 2);
    }

    @Test
    public void undo_zillionTimesInOnce() {
        saveDataToPath(new TodoList(), TestApp.SAVE_LOCATION_FOR_TESTING);
        storage.save(typicalTodoList);
        storage.save(anotherTodoList);

        assertValidUndoRedoData(storage.undo(ZILLION), new TodoList(), 2);
    }

    @Test
    public void undo_IdenticalDataSavedMultipleTimes() {
        saveDataToPath(new TodoList(), TestApp.SAVE_LOCATION_FOR_TESTING);
        storage.save(typicalTodoList);
        storage.save(typicalTodoList);

        assertValidUndoRedoData(storage.undo(ZILLION), new TodoList(), 1);
    }

    @Test
    public void redo_nothingToRedo() {
        saveDataToPath(new TodoList(), TestApp.SAVE_LOCATION_FOR_TESTING);
        assertValidUndoRedoData(storage.redo(1), new TodoList(), 0);
    }

    @Test
    public void redo_multipleOnce() {
        saveDataToPath(new TodoList(), TestApp.SAVE_LOCATION_FOR_TESTING);
        storage.save(typicalTodoList);
        storage.save(anotherTodoList);
        storage.undo(2);

        assertValidUndoRedoData(storage.redo(1), typicalTodoList, 1);
        assertValidUndoRedoData(storage.redo(1), anotherTodoList, 1);
    }

    @Test
    public void redo_multipleTimesInOnce() {
        saveDataToPath(new TodoList(), TestApp.SAVE_LOCATION_FOR_TESTING);
        storage.save(typicalTodoList);
        storage.save(anotherTodoList);
        storage.undo(2);

        assertValidUndoRedoData(storage.redo(2), anotherTodoList, 2);
    }

    @Test
    public void redo_zillionTimesInOnce() {
        saveDataToPath(new TodoList(), TestApp.SAVE_LOCATION_FOR_TESTING);
        storage.save(typicalTodoList);
        storage.save(anotherTodoList);
        storage.undo(2);

        assertValidUndoRedoData(storage.redo(ZILLION), anotherTodoList, 2);
    }

    @Test
    public void redo_afterSave() {
        saveDataToPath(new TodoList(), TestApp.SAVE_LOCATION_FOR_TESTING);
        storage.save(typicalTodoList);
        storage.undo(1);
        storage.save(anotherTodoList);

        assertValidUndoRedoData(storage.redo(1), anotherTodoList, 0);
    }

    /**
     * Helper method to set storage path in config and load data from config-defined path
     * @param path new todo list data path
     * @return Optional of todo list
     * @throws DataStorageException
     */
    private TodoList loadDataFromPath(String path) throws DataStorageException {
        Config.getInstance().setTodoListFilePath(path);
        return storage.load();
    }

    /**
     * Helper method to save data to a path
     * @param todoList todolist data
     * @param path new todo list data path
     * @return Optional of todo list
     */
    private boolean saveDataToPath(TodoList todoList, String path) {
        Config.getInstance().setTodoListFilePath(path);
        return storage.save(todoList);
    }

    /**
     * Helper method to verify if the undo/redo data is correct
     * @param data undo/redo data
     * @param expectedTodoList todolist expected
     * @param expectedUndoRedoTimes number of undo/redo times expected
     */
    private void assertValidUndoRedoData(Pair<TodoList, Integer> data, TodoList expectedTodoList, long
            expectedUndoRedoTimes) {
        assertEquals(data.getKey(), expectedTodoList);
        assertEquals(data.getKey().getStorage(), storage);
        assertEquals(data.getValue().longValue(), expectedUndoRedoTimes);
    }
}
```
###### /java/seedu/toluist/TestApp.java
``` java
package seedu.toluist;

import java.util.function.Supplier;

import seedu.toluist.model.TodoList;
import seedu.toluist.testutil.TestUtil;

/**
 * This class is meant to override some properties of MainApp so that it will be suited for
 * testing
 */
public class TestApp extends MainApp {
    public static final String APP_TITLE = "Test App";
    public static final String SAVE_LOCATION_FOR_TESTING = TestUtil.getFilePathInSandboxFolder("todolist.json");
    public static final String CONFIG_LOCATION_FOR_TESTING = TestUtil.getFilePathInSandboxFolder("preferences.json");
    protected Supplier<TodoList> initialDataSupplier = () -> null;
    protected String saveFileLocation = SAVE_LOCATION_FOR_TESTING;

    public TestApp(Supplier<TodoList> initialDataSupplier, String configLocation, String saveFileLocation) {
        super();

        this.initialDataSupplier = initialDataSupplier;
        this.saveFileLocation = saveFileLocation;
        // If some initial local data has been provided, write those to the file
        if (initialDataSupplier.get() != null) {
            TodoList todoList = initialDataSupplier.get();
            TestUtil.setTodoListTestData(todoList, configLocation, saveFileLocation);
        }
    }
}
```
###### /java/seedu/toluist/testutil/TestUtil.java
``` java
    /**
     * Clear all files in the sandbox folder
     * Creates the sandbox folder if it doesn't exist.
     */
    public static void cleanSandboxFolder() {
        FileUtil.removeFile(new File(SANDBOX_FOLDER));
        try {
            FileUtil.createDirs(new File(SANDBOX_FOLDER));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Do the necessary configuration so that todolist data can be used for testing
     * @param todoList todo list data
     * @parem configFilePath storage pah for config test data
     * @param todoListFilePath storage path for todo list test data
     */
    public static void setTodoListTestData(TodoList todoList, String configFilePath, String todoListFilePath) {
        Config.setConfigFilePath(configFilePath);
        Config config = Config.getInstance();
        config.setTodoListFilePath(todoListFilePath);
        config.save();
        TodoList.getInstance().setTasks(todoList.getTasks());
        todoList.save();
    }

    /**
     * Check that the tasks of the two todolists are the same. Order does not matter.
     * @param todoList1
     * @param todoList2
     * @return true / false
     */
    public static boolean compareTasksOfTodoLists(TodoList todoList1, TodoList todoList2) {
        return CollectionUtil.elementsAreSimilar(todoList1.getTasks(), todoList2.getTasks());
    }

    /**
     * Reset the instance for a singleton class
     * @param klass The singleton class to reset the instance
     * @throws SecurityException
     * @throws NoSuchFieldException
     * @throws IllegalArgumentException
     * @throws IllegalAccessException
     */
    public static void resetSingleton(Class klass) throws SecurityException, NoSuchFieldException,
            IllegalArgumentException, IllegalAccessException {
        Field instance = klass.getDeclaredField("instance");
        instance.setAccessible(true);
        instance.set(null, null);
    }

```
###### /java/seedu/toluist/testutil/TypicalTestTodoLists.java
``` java
package seedu.toluist.testutil;

import java.util.ArrayList;
import java.util.Arrays;

import seedu.toluist.model.Tag;
import seedu.toluist.model.Task;
import seedu.toluist.model.TodoList;

/**
 * Typical todo list test data
 */
public class TypicalTestTodoLists {
    public Task cleaning, studying;

    public TypicalTestTodoLists() {
        Tag lewisTag = new Tag("lewis");
        Tag workTag = new Tag("work");
        Tag louisTag = new Tag("louis");

        cleaning = new Task("clean the house while Lewis is gone");
        cleaning.replaceTags(new ArrayList<>(Arrays.asList(lewisTag, workTag)));
        studying = new Task("do assignments for Louis");
        studying.replaceTags(new ArrayList<>(Arrays.asList(louisTag, workTag)));
    }

    public static void loadTodoListWithSampleData(TodoList todoList) {
        for (Task task : new TypicalTestTodoLists().getTypicalTasks()) {
            todoList.add(task);
        }
    }

    public Task[] getTypicalTasks() {
        return new Task[] { cleaning, studying };
    }

    public TodoList getTypicalTodoList() {
        TodoList todoList = new TodoList();
        loadTodoListWithSampleData(todoList);
        return todoList;
    }
}
```
