# A0141102H
###### \java\guitests\AddCommandTest.java
``` java
    @Test
    public void add() {
        // add one floating task
        TestTask[] currentList = td.getTypicalTasks();
        TestTask taskToAdd = td.sampleEvent;
        assertAddSuccess(taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd).getKey();

        // add another task (deadline)
        taskToAdd = td.sampleDeadline;
        assertAddSuccess(taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd).getKey();

        // add duplicate task
        commandBox.runCommand(td.sampleDeadline.getAddCommand());
        assertResultMessage(AddCommand.MESSAGE_DUPLICATE_TASK);
        assertTrue(eventTaskListPanel.isListMatching(currentList));
        assertTrue(deadlineTaskListPanel.isListMatching(currentList));
        assertTrue(floatingTaskListPanel.isListMatching(currentList));

        // add to empty list
        commandBox.runCommand("CLEAR");
        assertAddSuccess(td.eatBreakfast);

        // invalid command
        commandBox.runCommand("ADDS Johnny");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

```
###### \java\guitests\ClearCommandTest.java
``` java
    @Test
    public void clear() {

        // verify a non-empty list can be cleared
        assertTrue(eventTaskListPanel.isListMatching(td.getTypicalTasks()));
        assertTrue(deadlineTaskListPanel.isListMatching(td.getTypicalTasks()));
        assertTrue(floatingTaskListPanel.isListMatching(td.getTypicalTasks()));
        assertClearCommandSuccess();

        // verify other commands can work after a clear command
        commandBox.runCommand(td.sampleEvent.getAddCommand());
        assertTrue(eventTaskListPanel.isListMatching(td.sampleEvent));
        commandBox.runCommand("DELETE 1");
        assertListSize(0);

        // verify clear command works when the list is empty
        assertClearCommandSuccess();
    }

    private void assertClearCommandSuccess() {
        commandBox.runCommand("CLEAR");
        assertListSize(0);
        assertResultMessage("Task Manager has been cleared!");
    }
}
```
###### \java\guitests\CommandBoxTest.java
``` java
    @Before
    public void setUp() {
        defaultStyleOfCommandBox = new ArrayList<>(commandBox.getStyleClass());
        assertFalse("CommandBox default style classes should not contain error style class.",
                    defaultStyleOfCommandBox.contains(CommandBox.ERROR_STYLE_CLASS));

        // build style class for error
        errorStyleOfCommandBox = new ArrayList<>(defaultStyleOfCommandBox);
        errorStyleOfCommandBox.add(CommandBox.ERROR_STYLE_CLASS);
    }

    @Test
    public void commandBox_commandSucceeds_textClearedAndStyleClassRemainsTheSame() {
        commandBox.runCommand(COMMAND_THAT_SUCCEEDS);

        assertEquals("", commandBox.getCommandInput());
        assertEquals(defaultStyleOfCommandBox, commandBox.getStyleClass());
    }

    @Test
    public void commandBox_commandFails_textStaysAndErrorStyleClassAdded() {
        commandBox.runCommand(COMMAND_THAT_FAILS);

        assertEquals(COMMAND_THAT_FAILS, commandBox.getCommandInput());
        assertEquals(errorStyleOfCommandBox, commandBox.getStyleClass());
    }

    @Test
    public void commandBox_commandSucceedsAfterFailedCommand_textClearedAndErrorStyleClassRemoved() {
        // add error style to simulate a failed command
        commandBox.getStyleClass().add(CommandBox.ERROR_STYLE_CLASS);

        commandBox.runCommand(COMMAND_THAT_SUCCEEDS);

        assertEquals("", commandBox.getCommandInput());
        assertEquals(defaultStyleOfCommandBox, commandBox.getStyleClass());
    }

}
```
###### \java\guitests\DeleteCommandTest.java
``` java
    @Test
    public void deleteByIndex() {

        // delete the first in the list
        TestTask[] currentList = td.getTypicalTasks();
        int targetIndex = 1;
        assertDeleteSuccess(targetIndex, currentList);

        // delete the last in the list
        currentList = TestUtil.removeTaskFromList(currentList, targetIndex);
        targetIndex = currentList.length;
        assertDeleteSuccess(targetIndex, currentList);

        // delete from the middle of the list
        currentList = TestUtil.removeTaskFromList(currentList, targetIndex);
        targetIndex = currentList.length / 2;
        assertDeleteSuccess(targetIndex, currentList);

        // invalid index
        commandBox.runCommand("DELETE " + currentList.length + 1);
        assertResultMessage("The task index provided is invalid");

    }

    @Test
    public void deleteByWord() {
        TestTask[] expectedList = td.getTypicalTasks();
        commandBox.runCommand("DELETE Eat breakfast with mom");
        expectedList = TestUtil.removeTaskFromList(expectedList, 1);
        assertTrue(eventTaskListPanel.isListMatching(expectedList));
        assertTrue(deadlineTaskListPanel.isListMatching(expectedList));
        assertTrue(floatingTaskListPanel.isListMatching(expectedList));

        // No task name exists
        commandBox.runCommand("DELETE aosfasoif");
        assertResultMessage(DeleteCommand.MESSAGE_INVALID_TASK_NAME);
    }

    @Test
    public void deleteByDate() {
        TestTask[] expectedList = td.getTypicalTasks();
        commandBox.runCommand("DELETE 04/04/17");
        expectedList = TestUtil.removeTaskFromList(expectedList, 4);
        assertTrue(eventTaskListPanel.isListMatching(expectedList));
        assertTrue(deadlineTaskListPanel.isListMatching(expectedList));
        assertTrue(floatingTaskListPanel.isListMatching(expectedList));

        // No task date exists
        commandBox.runCommand("DELETE 09/09/99");
        assertResultMessage(DeleteCommand.MESSAGE_INVALID_TASK_DATE);
    }

```
###### \java\guitests\ErrorDialogGuiTest.java
``` java
    @Test
    public void showErrorDialogs() throws InterruptedException {
        //Test DataSavingExceptionEvent dialog
        raise(new DataSavingExceptionEvent(new IOException("Stub")));
        AlertDialogHandle alertDialog = mainGui.getAlertDialog("File Op Error");
        assertTrue(alertDialog.isMatching("Could not save data", "Could not save data to file" + ":\n"
                                                                         + "java.io.IOException: Stub"));

    }

}
```
###### \java\guitests\ListCommandTest.java
``` java
    @Test
    public void listSpecificDateNonEmptyList() {
        assertListResult("LIST 01/03/17"); // no results
        assertListResult("LIST 03/03/17", td.eatBreakfast, td.doCS); // multiple
                                                                     // results
    }

    @Test
    public void listTodayDateNonEmptyList() {
        commandBox.runCommand("CLEAR");
        commandBox.runCommand("ADD testcase ON today");
        commandBox.runCommand("ADD testcase ON tmr");
        commandBox.runCommand("LIST today");
        assertListSize(1);
    }

    @Test
    public void listInvalidCommandFailure() {
        commandBox.runCommand("LIst");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);

        commandBox.runCommand("LIST nonsense");
        assertResultMessage(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
    }

    @Test
    public void listCommand() {
        commandBox.runCommand("LIST");
        assertListSize(td.getTypicalTasks().length);
        assertTrue(eventTaskListPanel.isListMatching(td.getTypicalTasks()));
        assertTrue(deadlineTaskListPanel.isListMatching(td.getTypicalTasks()));
        assertTrue(floatingTaskListPanel.isListMatching(td.getTypicalTasks()));
    }

    private void assertListResult(String command, TestTask... expectedHits) {
        commandBox.runCommand(command);
        assertListSize(expectedHits.length);
        String[] trimmedCommand = command.trim().split("\\s+");
        assertResultMessage("Listed all uncompleted tasks for [" + trimmedCommand[1] + "]");
        assertTrue(eventTaskListPanel.isListMatching(expectedHits));
        assertTrue(deadlineTaskListPanel.isListMatching(expectedHits));
        assertTrue(floatingTaskListPanel.isListMatching(expectedHits));
    }
}
```
###### \java\guitests\RecurringCommandTest.java
``` java
    @Test
    public void recurTaskFailure() {
        TestTask[] currentList = td.getTypicalTasks();
        int targetIndex = currentList.length;
        commandBox.runCommand("RECUR " + targetIndex + " 3 days");
        assertResultMessage(RecurringCommand.MESSAGE_RECURRING_FLOATING_TASK_FAILURE);

        commandBox.runCommand("RECUR 1000 4 days");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);

        commandBox.runCommand("RECUR");
        assertResultMessage(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, RecurringCommand.MESSAGE_USAGE));

        commandBox.runCommand("RECUR 4 DAYS 1000");
        assertResultMessage(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, RecurringCommand.MESSAGE_USAGE));
    }

    @Test
    public void recurEventTask() {
        // for days
        int targetIndex = 1;
        commandBox.runCommand("CLEAR");
        commandBox.runCommand(td.recurTestDay.getAddCommand());
        commandBox.runCommand("RECUR " + targetIndex + " 3 days");
        assertTrue(eventTaskListPanel.isListMatching(td.getTypicalRecurringEventTasksForDays()));

        // for weeks
        commandBox.runCommand("CLEAR");
        commandBox.runCommand(td.recurTestWeek.getAddCommand());
        commandBox.runCommand("RECUR " + targetIndex + " 3 weeks");
        assertTrue(eventTaskListPanel.isListMatching(td.getTypicalRecurringEventTasksForWeeks()));

        // duplicate task
        commandBox.runCommand("CLEAR");
        commandBox.runCommand(td.recurTestWeek.getAddCommand());
        commandBox.runCommand("RECUR " + targetIndex + " 3 days");
        commandBox.runCommand("RECUR 1 1 days");
        assertResultMessage(RecurringCommand.MESSAGE_DUPLICATE_TASK);
    }

    @Test
    public void recurDeadlineTask() {
        // for months
        int targetIndex = 1;
        commandBox.runCommand("CLEAR");
        commandBox.runCommand(td.recurTestMonth.getAddCommand());
        commandBox.runCommand("RECUR " + targetIndex + " 3 months");
        assertTrue(deadlineTaskListPanel.isListMatching(td.getTypicalRecurringDeadlineTasksForMonths()));

        // for years
        commandBox.runCommand("CLEAR");
        commandBox.runCommand(td.recurTestYear.getAddCommand());
        commandBox.runCommand("RECUR " + targetIndex + " 3 years");
        assertTrue(deadlineTaskListPanel.isListMatching(td.getTypicalRecurringDeadlineTasksForYears()));

        // duplicate task
        commandBox.runCommand("RECUR 1 1 years");
        assertResultMessage(RecurringCommand.MESSAGE_DUPLICATE_TASK);
    }
}
```
###### \java\guitests\SampleDataTest.java
``` java
    @Override
    protected TaskManager getInitialData() {
        // return null to force test app to load data from file only
        return null;
    }

    @Override
    protected String getDataFileLocation() {
        // return a non-existent file location to force test app to load sample
        // data
        return TestUtil.getFilePathInSandboxFolder("SomeFileThatDoesNotExist1234567890.xml");
    }

    @Test
    public void taskManager_dataFileDoesNotExist_loadSampleData() throws Exception {
        Task[] expectedList = SampleDataUtil.getSampleTasks();
        assertTrue(eventTaskListPanel.isListMatching(expectedList));
        assertTrue(deadlineTaskListPanel.isListMatching(expectedList));
        assertTrue(floatingTaskListPanel.isListMatching(expectedList));

    }
}
```
###### \java\guitests\SearchCommandTest.java
``` java
    @Test
    public void find_nonEmptyList() {
        assertFindResult("SEARCH food"); // no results
        assertFindResult("SEARCH with", td.eatBreakfast, td.eatDinner); // multiple
                                                                        // results

        // find after deleting one result
        commandBox.runCommand("DELETE 1");
        assertFindResult("SEARCH with", td.eatDinner);
    }

    @Test
    public void find_emptyList() {
        commandBox.runCommand("CLEAR");
        assertFindResult("SEARCH regret"); // no results
    }

    @Test
    public void find_invalidCommand_fail() {
        commandBox.runCommand("SEARCHregret");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    private void assertFindResult(String command, TestTask... expectedHits) {
        commandBox.runCommand(command);
        assertListSize(expectedHits.length);
        assertResultMessage(expectedHits.length + " tasks listed!");
        assertTrue(eventTaskListPanel.isListMatching(expectedHits));
        assertTrue(deadlineTaskListPanel.isListMatching(expectedHits));
        assertTrue(floatingTaskListPanel.isListMatching(expectedHits));

    }
}
```
###### \java\guitests\SelectCommandTest.java
``` java
    @Test
    public void selectTask_nonEmptyList() {

        assertSelectionInvalid(20); // invalid index
        assertNoTaskSelected();

        assertSelectionSuccess(1); // first task in the list
        int taskCount = td.getTypicalTasks().length;
        assertSelectionSuccess(taskCount); // last task in the list
        int middleIndex = taskCount / 2;
        assertSelectionSuccess(middleIndex); // a task in the middle of the list

        assertSelectionInvalid(taskCount + 1); // invalid index
        assertTaskSelected(middleIndex); // assert previous selection remains

        /*
         * Testing other invalid indexes such as -1 should be done when testing
         * the SelectCommand
         */
    }

    @Test
    public void selectTask_emptyList() {
        commandBox.runCommand("CLEAR");
        assertListSize(0);
        assertSelectionInvalid(1); // invalid index
    }

    private void assertSelectionInvalid(int index) {
        commandBox.runCommand("SELECT " + index);
        assertResultMessage("The task index provided is invalid");
    }

    private void assertSelectionSuccess(int index) {
        commandBox.runCommand("SELECT " + index);
        assertResultMessage("Selected Task: " + index);
        assertTaskSelected(index);
    }

```
###### \java\guitests\TaskManagerGuiTest.java
``` java
    /*
     * The TestName Rule makes the current test name available inside test
     * methods
     */
    @Rule
    public TestName name = new TestName();

    TestApp testApp;

    protected TypicalTestTasks td = new TypicalTestTasks();

    /*
     * Handles to GUI elements present at the start up are created in advance
     * for easy access from child classes.
     */
    protected MainGuiHandle mainGui;
    protected MainMenuHandle mainMenu;
    protected EventTaskListPanelHandle eventTaskListPanel;
    protected DeadlineTaskListPanelHandle deadlineTaskListPanel;
    protected FloatingTaskListPanelHandle floatingTaskListPanel;
    protected ResultDisplayHandle resultDisplay;
    protected CommandBoxHandle commandBox;
    private Stage stage;

    @BeforeClass
    public static void setupSpec() {
        try {
            FxToolkit.registerPrimaryStage();
            FxToolkit.hideStage();
        } catch (TimeoutException e) {
            e.printStackTrace();
        }
    }

    @Before
    public void setup() throws Exception {
        FxToolkit.setupStage((stage) -> {
            mainGui = new MainGuiHandle(new GuiRobot(), stage);
            mainMenu = mainGui.getMainMenu();
            eventTaskListPanel = mainGui.getEventTaskListPanel();
            deadlineTaskListPanel = mainGui.getDeadlineTaskListPanel();
            floatingTaskListPanel = mainGui.getFloatingTaskListPanel();
            resultDisplay = mainGui.getResultDisplay();
            commandBox = mainGui.getCommandBox();
            this.stage = stage;
        });
        EventsCenter.clearSubscribers();
        testApp = (TestApp) FxToolkit.setupApplication(() -> new TestApp(this::getInitialData, getDataFileLocation()));
        FxToolkit.showStage();
        while (!stage.isShowing())
            ;
        mainGui.focusOnMainApp();
    }

    /**
     * Override this in child classes to set the initial local data. Return null
     * to use the data in the file specified in {@link #getDataFileLocation()}
     */
    protected TaskManager getInitialData() {
        TaskManager tm = new TaskManager();
        TypicalTestTasks.loadTaskManagerWithSampleData(tm);
        return tm;
    }

    /**
     * Override this in child classes to set the data file location.
     */
    protected String getDataFileLocation() {
        return TestApp.SAVE_LOCATION_FOR_TESTING;
    }

    @After
    public void cleanup() throws TimeoutException {
        FxToolkit.cleanupStages();
    }

    /**
     * Asserts the task shown in the card is same as the given task
     */
    public void assertMatching(ReadOnlyTask task, EventTaskCardHandle card) {
        assertTrue(TestUtil.compareCardAndTask(card, task));
    }

    /**
     * Asserts the task shown in the card is same as the given task
     */
    public void assertMatching(ReadOnlyTask task, DeadlineTaskCardHandle card) {
        assertTrue(TestUtil.compareCardAndTask(card, task));
    }

    /**
     * Asserts the task shown in the card is same as the given task
     */
    public void assertMatching(ReadOnlyTask task, FloatingTaskCardHandle card) {
        assertTrue(TestUtil.compareCardAndTask(card, task));
    }

    /**
     * Asserts the size of the task list is equal to the given number.
     */
    protected void assertListSize(int size) {
        int numberOfTask = eventTaskListPanel.getNumberOfTask() + deadlineTaskListPanel.getNumberOfTask()
                + floatingTaskListPanel.getNumberOfTask();
        assertEquals(size, numberOfTask);
    }

    /**
     * Asserts the message shown in the Result Display area is same as the given
     * string.
     */
    protected void assertResultMessage(String expected) {
        assertEquals(expected, resultDisplay.getText());
    }

    public void raise(BaseEvent e) {
        // JUnit doesn't run its test cases on the UI thread. Platform.runLater
        // is used to post event on the UI thread.
        Platform.runLater(() -> EventsCenter.getInstance().post(e));
    }
}
```
###### \java\guitests\UpdateCommandTest.java
``` java
    @Test
    public void updateAllFieldsSpecified_success() throws Exception {
        String detailsToUpdate = "take a snack break ON 03/03/19 1500 TO 1600 CATEGORY";
        int taskManagerIndex = 1;

        updatedTask = new TaskBuilder().withTaskName("take a snack break").withStartDate("03/03/19")
                .withStartTime("1500").withEndDate("03/03/19").withEndTime("1600").build();

        assertUpdateSuccess(taskManagerIndex, taskManagerIndex, detailsToUpdate, updatedTask);
    }

    @Test
    public void update_notAllFieldsSpecified_success() throws Exception {
        String detailsToUpdate = "ON 31/03/17";
        int taskManagerIndex = 2;

        TestTask taskToUpdate = expectedTasksList[taskManagerIndex - 1];
        TestTask updatedTask = new TaskBuilder(taskToUpdate).withStartDate("31/03/17").withStartTime("0000")
                .withEndDate("31/03/17").withEndTime("2359").build();

        assertUpdateSuccess(taskManagerIndex, taskManagerIndex, detailsToUpdate, updatedTask);
    }

    @Test
    public void update_clearCategories_success() throws Exception {
        String detailsToUpdate = "CATEGORY";
        int taskManagerIndex = 2;
        TestTask taskToUpdate = expectedTasksList[taskManagerIndex - 1];
        TestTask updatedTask = new TaskBuilder(taskToUpdate).withCategories().build();

        assertUpdateSuccess(taskManagerIndex, taskManagerIndex, detailsToUpdate, updatedTask);
    }

    @Test
    public void update_searchThenUpdate_success() throws Exception {
        commandBox.runCommand("SEARCH lunch");

        String detailsToUpdate = "Lunch BY 04/03/17 1400";
        int filteredTaskListIndex = 1;
        int taskManagerIndex = 6;

        TestTask taskToUpdate = expectedTasksList[taskManagerIndex - 1];
        TestTask updatedTask = new TaskBuilder(taskToUpdate).withTaskName("Lunch").build();

        assertUpdateSuccess(filteredTaskListIndex, taskManagerIndex, detailsToUpdate, updatedTask);
    }

    @Test
    public void update_missingTaskIndex_failure() {
        commandBox.runCommand("UPDATE supper");
        assertResultMessage(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
    }

    @Test
    public void update_invalidTaskIndex_failure() {
        commandBox.runCommand("UPDATE 10 supper");
        assertResultMessage(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
    }

    @Test
    public void update_invalidValues_failure() {

        commandBox.runCommand("UPDATE 1 ON 030317");
        assertResultMessage(StartDate.MESSAGE_DATE_CONSTRAINTS);

        commandBox.runCommand("UPDATE 1 FROM thursday 1200hrs TO friday 1400");
        assertResultMessage(UpdateCommandParser.INVALID_TIME);

        commandBox.runCommand("UPDATE 1 FROM thursday 1200 TO friday 1300hrs");
        assertResultMessage(UpdateCommandParser.INVALID_TIME);

    }

    @Test
    public void update_duplicateTask_failure() {
        commandBox.runCommand("UPDATE 3 Eat lunch at techno BY 04/03/17 1400");
        assertResultMessage(UpdateCommand.MESSAGE_DUPLICATE_TASK);
    }

```
###### \java\seedu\taskmanager\commons\util\AppUtilTest.java
``` java
    @Rule
    public ExpectedException thrown = ExpectedException.none();


    @Test
    public void getImage_exitingImage() {
        assertNotNull(AppUtil.getImage("/images/task_manager.png"));
    }


    @Test
    public void getImage_nullGiven_assertionError() {
        thrown.expect(AssertionError.class);
        AppUtil.getImage(null);
    }


}
```
###### \java\seedu\taskmanager\commons\util\CollectionUtilTest.java
``` java
    @Rule
    public ExpectedException thrown = ExpectedException.none();

    @Test
    public void isAnyNullVarargs() {
        // no arguments
        assertFalse(CollectionUtil.isAnyNull());

        // any non-empty argument list
        assertFalse(CollectionUtil.isAnyNull(new Object(), new Object()));
        assertFalse(CollectionUtil.isAnyNull("test"));
        assertFalse(CollectionUtil.isAnyNull(""));

        // argument lists with just one null at the beginning
        assertTrue(CollectionUtil.isAnyNull((Object) null));
        assertTrue(CollectionUtil.isAnyNull(null, "", new Object()));
        assertTrue(CollectionUtil.isAnyNull(null, new Object(), new Object()));

        // argument lists with nulls in the middle
        assertTrue(CollectionUtil.isAnyNull(new Object(), null, null, "test"));
        assertTrue(CollectionUtil.isAnyNull("", null, new Object()));

        // argument lists with one null as the last argument
        assertTrue(CollectionUtil.isAnyNull("", new Object(), null));
        assertTrue(CollectionUtil.isAnyNull(new Object(), new Object(), null));

        // confirms nulls inside lists in the argument list are not considered
        List<Object> containingNull = Arrays.asList((Object) null);
        assertFalse(CollectionUtil.isAnyNull(containingNull, new Object()));
    }

    @Test
    public void isAnyNullVarargs_nullReference_throwsNullPointerException() {
        thrown.expect(NullPointerException.class);
        CollectionUtil.isAnyNull((Object[]) null);
    }

    @Test
    public void isAnyNullCollection() {
        // lists containing nulls in the front
        assertTrue(CollectionUtil.isAnyNull(Arrays.asList((Object) null)));
        assertTrue(CollectionUtil.isAnyNull(Arrays.asList(null, new Object(), "")));

        // lists containing nulls in the middle
        assertTrue(CollectionUtil.isAnyNull(Arrays.asList("spam", null, new Object())));
        assertTrue(CollectionUtil.isAnyNull(Arrays.asList("spam", null, "eggs", null, new Object())));

        // lists containing nulls at the end
        assertTrue(CollectionUtil.isAnyNull(Arrays.asList("spam", new Object(), null)));
        assertTrue(CollectionUtil.isAnyNull(Arrays.asList(new Object(), null)));

        // empty list
        assertFalse(CollectionUtil.isAnyNull(Collections.emptyList()));

        // list with all non-null elements
        assertFalse(CollectionUtil.isAnyNull(Arrays.asList(new Object(), "ham", new Integer(1))));
        assertFalse(CollectionUtil.isAnyNull(Arrays.asList(new Object())));

        // confirms nulls inside nested lists are not considered
        List<Object> containingNull = Arrays.asList((Object) null);
        assertFalse(CollectionUtil.isAnyNull(Arrays.asList(containingNull, new Object())));
    }

    @Test
    public void isAnyNullCollection_nullReference_throwsNullPointerException() {
        thrown.expect(NullPointerException.class);
        CollectionUtil.isAnyNull((Collection<Object>) null);
    }

    @Test
    public void elementsAreUnique() throws Exception {
        // empty list
        assertAreUnique();

        // only one object
        assertAreUnique((Object) null);
        assertAreUnique(1);
        assertAreUnique("");
        assertAreUnique("abc");

        // all objects unique
        assertAreUnique("abc", "ab", "a");
        assertAreUnique(1, 2);

        // some identical objects
        assertNotUnique("abc", "abc");
        assertNotUnique("abc", "", "abc", "ABC");
        assertNotUnique("", "abc", "a", "abc");
        assertNotUnique(1, new Integer(1));
        assertNotUnique(null, 1, new Integer(1));
        assertNotUnique(null, null);
        assertNotUnique(null, "a", "b", null);
    }

    private void assertAreUnique(Object... objects) {
        assertTrue(CollectionUtil.elementsAreUnique(Arrays.asList(objects)));
    }

    private void assertNotUnique(Object... objects) {
        assertFalse(CollectionUtil.elementsAreUnique(Arrays.asList(objects)));
    }
}
```
###### \java\seedu\taskmanager\commons\util\ConfigUtilTest.java
``` java
    @Rule
    public ExpectedException thrown = ExpectedException.none();

    @Rule
    public TemporaryFolder testFolder = new TemporaryFolder();

    @Test
    public void read_null_assertionFailure() throws DataConversionException {
        thrown.expect(AssertionError.class);
        read(null);
    }

    @Test
    public void read_missingFile_emptyResult() throws DataConversionException {
        assertFalse(read("NonExistentFile.json").isPresent());
    }

    @Test
    public void read_notJsonFormat_exceptionThrown() throws DataConversionException {

        thrown.expect(DataConversionException.class);
        read("NotJsonFormatConfig.json");

        /* IMPORTANT: Any code below an exception-throwing line (like the one above) will be ignored.
         * That means you should not have more than one exception test in one method
         */
    }

    @Test
    public void read_fileInOrder_successfullyRead() throws DataConversionException, Exception {

        Config expected = getTypicalConfig();

        Config actual = read("TypicalConfig.json").get();
        assertEquals(expected, actual);
    }

    @Test
    public void read_valuesMissingFromFile_defaultValuesUsed() throws DataConversionException {
        Config actual = read("EmptyConfig.json").get();
        assertEquals(new Config(), actual);
    }

    @Test
    public void read_extraValuesInFile_extraValuesIgnored() throws DataConversionException, Exception {
        Config expected = getTypicalConfig();
        Config actual = read("ExtraValuesConfig.json").get();

        assertEquals(expected, actual);
    }

    private Config getTypicalConfig() throws Exception {
        Config config = new Config();
        config.setAppTitle("Typical App Title");
        config.setLogLevel(Level.INFO);
        config.setUserPrefsFilePath("C:\\preferences.json");
        config.setTaskManagerFilePath("taskmanager.xml");
        config.setTaskManagerName("TypicalTaskManagerName");
        return config;
    }

    private Optional<Config> read(String configFileInTestDataFolder) throws DataConversionException {
        String configFilePath = addToTestDataPathIfNotNull(configFileInTestDataFolder);
        return ConfigUtil.readConfig(configFilePath);
    }

    @Test
    public void save_nullConfig_assertionFailure() throws IOException {
        thrown.expect(AssertionError.class);
        save(null, "SomeFile.json");
    }

    @Test
    public void save_nullFile_assertionFailure() throws IOException {
        thrown.expect(AssertionError.class);
        save(new Config(), null);
    }

    @Test
    public void saveConfig_allInOrder_success() throws DataConversionException, IOException, Exception {
        Config original = getTypicalConfig();

        String configFilePath = testFolder.getRoot() + File.separator + "TempConfig.json";

        //Try writing when the file doesn't exist
        ConfigUtil.saveConfig(original, configFilePath);
        Config readBack = ConfigUtil.readConfig(configFilePath).get();
        assertEquals(original, readBack);

        //Try saving when the file exists
        original.setAppTitle("Updated Title");
        original.setLogLevel(Level.FINE);
        ConfigUtil.saveConfig(original, configFilePath);
        readBack = ConfigUtil.readConfig(configFilePath).get();
        assertEquals(original, readBack);
    }

    private void save(Config config, String configFileInTestDataFolder) throws IOException {
        String configFilePath = addToTestDataPathIfNotNull(configFileInTestDataFolder);
        ConfigUtil.saveConfig(config, configFilePath);
    }

    private String addToTestDataPathIfNotNull(String configFileInTestDataFolder) {
        return configFileInTestDataFolder != null
                                  ? TEST_DATA_FOLDER + configFileInTestDataFolder
                                  : null;
    }


}
```
###### \java\seedu\taskmanager\logic\LogicManagerTest.java
``` java
    /**
     * See https://github.com/junit-team/junit4/wiki/rules#temporaryfolder-rule
     */
    @Rule
    public TemporaryFolder saveFolder = new TemporaryFolder();

    private Model model;
    private Logic logic;

    // These are for checking the correctness of the events raised
    private ReadOnlyTaskManager latestSavedTaskManager;
    private boolean helpShown;
    private int targetedJumpIndex;

    @Subscribe
    private void handleLocalModelChangedEvent(TaskManagerChangedEvent abce) {
        latestSavedTaskManager = new TaskManager(abce.data);
    }

    @Subscribe
    private void handleShowHelpRequestEvent(ShowHelpRequestEvent she) {
        helpShown = true;
    }

    @Subscribe
    private void handleJumpToListRequestEvent(JumpToListRequestEvent je) {
        targetedJumpIndex = je.targetIndex;
    }

    @Before
    public void setUp() {
        model = new ModelManager();
        String tempTaskManagerFile = saveFolder.getRoot().getPath() + "TempTaskManager.xml";
        String tempPreferencesFile = saveFolder.getRoot().getPath() + "TempPreferences.json";
        logic = new LogicManager(model, new StorageManager(tempTaskManagerFile, tempPreferencesFile));
        EventsCenter.getInstance().registerHandler(this);

        latestSavedTaskManager = new TaskManager(model.getTaskManager()); // last
                                                                          // saved
                                                                          // assumed
                                                                          // to
                                                                          // be
                                                                          // up
                                                                          // to
                                                                          // date
        helpShown = false;
        targetedJumpIndex = -1; // non yet
    }

    @After
    public void tearDown() {
        EventsCenter.clearSubscribers();
    }

    @Test
    public void execute_invalid() {
        String invalidCommand = "       ";
        assertCommandFailure(invalidCommand, String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
    }

    /**
     * Executes the command, confirms that a CommandException is not thrown and
     * that the result message is correct. Also confirms that both the 'task
     * manager' and the 'last shown list' are as specified.
     *
     * @see #assertCommandBehavior(boolean, String, String, ReadOnlyTaskManager,
     *      List)
     */
    private void assertCommandSuccess(String inputCommand, String expectedMessage,
            ReadOnlyTaskManager expectedTaskManager, List<? extends ReadOnlyTask> expectedShownList) {
        assertCommandBehavior(false, inputCommand, expectedMessage, expectedTaskManager, expectedShownList);
    }

    /**
     * Executes the command, confirms that a CommandException is thrown and that
     * the result message is correct. Both the 'task manager' and the 'last
     * shown list' are verified to be unchanged.
     *
     * @see #assertCommandBehavior(boolean, String, String, ReadOnlyTaskManager,
     *      List)
     */
    private void assertCommandFailure(String inputCommand, String expectedMessage) {
        TaskManager expectedTaskManager = new TaskManager(model.getTaskManager());
        List<ReadOnlyTask> expectedShownList = new ArrayList<>(model.getFilteredTaskList());
        assertCommandBehavior(true, inputCommand, expectedMessage, expectedTaskManager, expectedShownList);
    }

    /**
     * Executes the command, confirms that the result message is correct and
     * that a CommandException is thrown if expected and also confirms that the
     * following three parts of the LogicManager object's state are as
     * expected:<br>
     * - the internal task manager data are same as those in the
     * {@code expectedTaskManager} <br>
     * - the backing list shown by UI matches the {@code shownList} <br>
     * - {@code expectedTaskManager} was saved to the storage file. <br>
     */
    private void assertCommandBehavior(boolean isCommandExceptionExpected, String inputCommand, String expectedMessage,
            ReadOnlyTaskManager expectedTaskManager, List<? extends ReadOnlyTask> expectedShownList) {

        try {
            CommandResult result = logic.execute(inputCommand);
            assertFalse("CommandException expected but was not thrown.", isCommandExceptionExpected);
            assertEquals(expectedMessage, result.feedbackToUser);
        } catch (CommandException e) {
            assertTrue("CommandException not expected but was thrown.", isCommandExceptionExpected);
            assertEquals(expectedMessage, e.getMessage());
        }

        // Confirm the ui display elements should contain the right data
        assertEquals(expectedShownList, model.getFilteredTaskList());

        // Confirm the state of data (saved and in-memory) is as expected
        assertEquals(expectedTaskManager, model.getTaskManager());
        assertEquals(expectedTaskManager, latestSavedTaskManager);
    }

    @Test
    public void execute_unknownCommandWord() {
        String unknownCommand = "uicfhmowqewca";
        assertCommandFailure(unknownCommand, MESSAGE_UNKNOWN_COMMAND);
    }

    @Test
    public void execute_help() {
        assertCommandSuccess("HELP", HelpCommand.SHOWING_HELP_MESSAGE, new TaskManager(), Collections.emptyList());
        assertTrue(helpShown);
    }

    @Test
    public void execute_exit() {
        assertCommandSuccess("EXIT", ExitCommand.MESSAGE_EXIT_ACKNOWLEDGEMENT, new TaskManager(),
                Collections.emptyList());
    }

    @Test
    public void execute_clear() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        model.addTask(helper.generateTask(1));
        model.addTask(helper.generateTask(2));
        model.addTask(helper.generateTask(3));

        assertCommandSuccess("CLEAR", ClearCommand.MESSAGE_SUCCESS, new TaskManager(), Collections.emptyList());
    }

    @Test
    public void execute_add_invalidArgsFormat() {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE);
        assertCommandFailure("ADD Valid TaskName ON date FROM starttime TO endtime", expectedMessage);
        assertCommandFailure("ADD Valid TaskName TO endtime", expectedMessage);
        assertCommandFailure("ADD Valid TaskName FROM starttime", expectedMessage);
    }

    @Test
    public void execute_add_invalidTaskData() {
        assertCommandFailure("ADD Valid TaskName ON wrongdateformat 1400 TO 1600", StartDate.MESSAGE_DATE_CONSTRAINTS);
        // assertCommandFailure("ADD Valid TaskName ON thursday 1400hrs TO
        // 1600", StartTime.MESSAGE_STARTTIME_CONSTRAINTS);
        // assertCommandFailure("ADD Valid Name ON thursday 1400 TO 1600hrs",
        // EndTime.MESSAGE_ENDTIME_CONSTRAINTS);
        // assertCommandFailure("add Valid Name p/12345 e/valid@e.mail a/valid,
        // address t/invalid_-[.tag",
        // Category.MESSAGE_TAG_CONSTRAINTS);
    }

    @Test
    public void execute_add_successful() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.travis();
        TaskManager expectedAB = new TaskManager();
        int addIndex = expectedAB.addTask(toBeAdded) + 1;

        // execute command and verify result
        assertCommandSuccess(helper.generateAddCommand(toBeAdded), String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded)
                + "\n" + "Task added at index: " + Integer.toString(addIndex), expectedAB, expectedAB.getTaskList());
    }

    @Test
    public void execute_addDuplicate_notAllowed() throws Exception {
        // setup expectations
        TestDataHelper helper = new TestDataHelper();
        Task toBeAdded = helper.travis();

        // setup starting state
        model.addTask(toBeAdded); // task already in internal task manager

        // execute command and verify result
        assertCommandFailure(helper.generateAddCommand(toBeAdded), AddCommand.MESSAGE_DUPLICATE_TASK);

    }

    @Test
    public void execute_list_showsAllTasks() throws Exception {
        // prepare expectations
        TestDataHelper helper = new TestDataHelper();
        TaskManager expectedAB = helper.generateTaskManager(2);
        List<? extends ReadOnlyTask> expectedList = expectedAB.getTaskList();

        // prepare task manager state
        helper.addToModel(model, 2);

        assertCommandSuccess("LIST", ListCommand.MESSAGE_SUCCESS_ALL_TASK, expectedAB, expectedList);
    }

    /**
     * Confirms the 'invalid argument index number behaviour' for the given
     * command targeting a single task in the shown list, using visible index.
     *
     * @param commandWord
     *            to test assuming it targets a single task in the last shown
     *            list based on visible index.
     */
    private void assertIncorrectIndexFormatBehaviorForCommand(String commandWord, String expectedMessage)
            throws Exception {
        assertCommandFailure(commandWord, expectedMessage); // index or name
                                                            // missing
        // assertCommandFailure(commandWord + " +1", expectedMessage); //index
        // should be unsigned
        // assertCommandFailure(commandWord + " -1", expectedMessage); //index
        // should be unsigned
        // assertCommandFailure(commandWord + " 0", expectedMessage); //index
        // cannot be 0
        // assertCommandFailure(commandWord + " not_a_number", expectedMessage);
    }

    /**
     * Confirms the 'invalid argument index number behaviour' for the given
     * command targeting a single task in the shown list, using visible index.
     *
     * @param commandWord
     *            to test assuming it targets a single taskin the last shown
     *            list based on visible index.
     */
    private void assertIndexNotFoundBehaviorForCommand(String commandWord) throws Exception {
        String expectedMessage = MESSAGE_INVALID_TASK_DISPLAYED_INDEX;
        TestDataHelper helper = new TestDataHelper();
        List<Task> taskList = helper.generateTaskList(2);

        // set AB state to 2 persons
        model.resetData(new TaskManager());
        for (Task t : taskList) {
            model.addTask(t);
        }

        assertCommandFailure(commandWord + " 3", expectedMessage);
    }

    @Test
    public void execute_selectInvalidArgsFormat_errorMessageShown() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectCommand.MESSAGE_USAGE);
        assertIncorrectIndexFormatBehaviorForCommand("SELECT", expectedMessage);
    }

    @Test
    public void execute_selectIndexNotFound_errorMessageShown() throws Exception {
        assertIndexNotFoundBehaviorForCommand("SELECT");
    }

    @Test
    public void execute_select_jumpsToCorrectTask() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        List<Task> threeTasks = helper.generateTaskList(3);

        TaskManager expectedAB = helper.generateTaskManager(threeTasks);
        helper.addToModel(model, threeTasks);

        assertCommandSuccess("SELECT 2", String.format(SelectCommand.MESSAGE_SELECT_TASK_SUCCESS, 2), expectedAB,
                expectedAB.getTaskList());
        assertEquals(1, targetedJumpIndex);
        assertEquals(model.getFilteredTaskList().get(1), threeTasks.get(1));
    }

    @Test
    public void execute_deleteInvalidArgsFormat_errorMessageShown() throws Exception {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE);
        assertIncorrectIndexFormatBehaviorForCommand("DELETE", expectedMessage);
    }

    @Test
    public void execute_deleteIndexNotFound_errorMessageShown() throws Exception {
        assertIndexNotFoundBehaviorForCommand("DELETE");
    }

    @Test
    public void execute_delete_removesCorrectTask() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        List<Task> threeTasks = helper.generateTaskList(3);

        TaskManager expectedAB = helper.generateTaskManager(threeTasks);
        expectedAB.removeTask(threeTasks.get(1));
        helper.addToModel(model, threeTasks);

        assertCommandSuccess("DELETE 2", String.format(DeleteCommand.MESSAGE_DELETE_TASK_SUCCESS, threeTasks.get(1)),
                expectedAB, expectedAB.getTaskList());
    }

    @Test
    public void execute_search_invalidArgsFormat() {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, SearchCommand.MESSAGE_USAGE);
        assertCommandFailure("SEARCH ", expectedMessage);
    }

    @Test
    public void execute_search_onlyMatchesFullTaskWordsInNames() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task pTarget1 = helper.generateTaskWithName("bla bla KEY bla");
        Task pTarget2 = helper.generateTaskWithName("bla KEY bla bceofeia");
        Task p1 = helper.generateTaskWithName("KE Y");
        Task p2 = helper.generateTaskWithName("KEYKEYKEY sduauo");

        List<Task> fourTasks = helper.generateTaskList(p1, pTarget1, p2, pTarget2);
        TaskManager expectedAB = helper.generateTaskManager(fourTasks);
        List<Task> expectedList = helper.generateTaskList(pTarget1, pTarget2);
        helper.addToModel(model, fourTasks);

        assertCommandSuccess("SEARCH KEY", Command.getMessageForTaskListShownSummary(expectedList.size()), expectedAB,
                expectedList);
    }

    @Test
    public void execute_find_isNotCaseSensitive() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task p1 = helper.generateTaskWithName("bla bla KEY bla");
        Task p2 = helper.generateTaskWithName("bla KEY bla bceofeia");
        Task p3 = helper.generateTaskWithName("key key");
        Task p4 = helper.generateTaskWithName("KEy sduauo");

        List<Task> fourTasks = helper.generateTaskList(p3, p1, p4, p2);
        TaskManager expectedAB = helper.generateTaskManager(fourTasks);
        List<Task> expectedList = fourTasks;
        helper.addToModel(model, fourTasks);

        assertCommandSuccess("SEARCH KEY", Command.getMessageForTaskListShownSummary(expectedList.size()), expectedAB,
                expectedList);
    }

    @Test
    public void execute_find_matchesIfAnyKeywordPresent() throws Exception {
        TestDataHelper helper = new TestDataHelper();
        Task pTarget1 = helper.generateTaskWithName("bla bla KEY bla");
        Task pTarget2 = helper.generateTaskWithName("bla rAnDoM bla bceofeia");
        Task pTarget3 = helper.generateTaskWithName("key key");
        Task p1 = helper.generateTaskWithName("sduauo");

        List<Task> fourTasks = helper.generateTaskList(pTarget1, p1, pTarget2, pTarget3);
        TaskManager expectedAB = helper.generateTaskManager(fourTasks);
        List<Task> expectedList = helper.generateTaskList(pTarget1, pTarget2, pTarget3);
        helper.addToModel(model, fourTasks);

        assertCommandSuccess("SEARCH key rAnDoM", Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedAB, expectedList);
    }

    /**
     * A utility class to generate test data.
     */
    class TestDataHelper {

        Task travis() throws Exception {
            TaskName taskName = new TaskName("Travis the bro is assisting");
            StartDate privateStartDate = new StartDate("03/03/17");
            StartTime privateStartTime = new StartTime("1200");
            EndDate privateEndDate = new EndDate("04/03/17");
            EndTime privateEndTime = new EndTime("1400");
            Boolean isCompleted = false;
            Category category1 = new Category("category1");
            Category category2 = new Category("longercategory2");
            UniqueCategoryList privateCategories = new UniqueCategoryList(category1, category2);
            return new Task(taskName, privateStartDate, privateStartTime, privateEndDate, privateEndTime, isCompleted,
                    privateCategories);
        }

        /**
         * Generates a valid task using the given seed. Running this function
         * with the same parameter values guarantees the returned task will have
         * the same state. Each unique seed will generate a unique Task object.
         *
         * @param seed
         *            used to generate the person data field values
         */
        Task generateTask(int seed) throws Exception {
            int randomNumber = seed % 10;
            return new Task(new TaskName("Task " + randomNumber), new StartDate("0" + randomNumber + "/02/17"),
                    new StartTime("140" + seed), new EndDate("0" + randomNumber + "/03/17"),
                    new EndTime("160" + randomNumber), Boolean.FALSE,
                    new UniqueCategoryList(new Category("category" + Math.abs(randomNumber)),
                            new Category("category" + Math.abs(randomNumber + 1))));
        }

        /** Generates the correct add command based on the task given */
        String generateAddCommand(Task p) {
            StringBuffer cmd = new StringBuffer();

            cmd.append("ADD ");

            cmd.append(p.getTaskName().toString());
            cmd.append(" FROM ");
            cmd.append(p.getStartDate().toString());
            cmd.append(" ");
            cmd.append(p.getStartTime().toString());
            // cmd.append(" FROM").append(p.getStartTime());
            cmd.append(" TO ");
            cmd.append(p.getEndDate().toString());
            cmd.append(" ");
            cmd.append(p.getEndTime().toString());

            UniqueCategoryList categories = p.getCategories();
            for (Category t : categories) {
                cmd.append(" CATEGORY ").append(t.categoryName);
            }

            return cmd.toString();
        }

        /**
         * Generates an TaskManager with auto-generated tasks.
         */
        TaskManager generateTaskManager(int numGenerated) throws Exception {
            TaskManager taskManager = new TaskManager();
            addToTaskManager(taskManager, numGenerated);
            return taskManager;
        }

        /**
         * Generates an TaskManager based on the list of tasks given.
         */
        TaskManager generateTaskManager(List<Task> tasks) throws Exception {
            TaskManager taskManager = new TaskManager();
            addToTaskManager(taskManager, tasks);
            return taskManager;
        }

        /**
         * Adds auto-generated Task objects to the given TaskManager
         *
         * @param taskManager
         *            The TaskManager to which the Tasks will be added
         */
        void addToTaskManager(TaskManager taskManager, int numGenerated) throws Exception {
            addToTaskManager(taskManager, generateTaskList(numGenerated));
        }

        /**
         * Adds the given list of Tasks to the given TaskManager
         */
        void addToTaskManager(TaskManager taskManager, List<Task> tasksToAdd) throws Exception {
            for (Task t : tasksToAdd) {
                taskManager.addTask(t);
            }
        }

        /**
         * Adds auto-generated Task objects to the given model
         *
         * @param model
         *            The model to which the Tasks will be added
         */
        void addToModel(Model model, int numGenerated) throws Exception {
            addToModel(model, generateTaskList(numGenerated));
        }

        /**
         * Adds the given list of Tasks to the given model
         */
        void addToModel(Model model, List<Task> tasksToAdd) throws Exception {
            for (Task t : tasksToAdd) {
                model.addTask(t);
            }
        }

        /**
         * Generates a list of Tasks based on the flags.
         */
        List<Task> generateTaskList(int numGenerated) throws Exception {
            List<Task> tasks = new ArrayList<>();
            for (int i = 1; i <= numGenerated; i++) {
                tasks.add(generateTask(i));
            }
            return tasks;
        }

        List<Task> generateTaskList(Task... tasks) {
            return Arrays.asList(tasks);
        }

        /**
         * Generates a Task object with given name. Other fields will have some
         * dummy values.
         */
        Task generateTaskWithName(String taskname) throws Exception {
            return new Task(new TaskName(taskname), new StartDate("03/03/17"), new StartTime("1400"),
                    new EndDate("03/03/17"), new EndTime("1600"), Boolean.FALSE,
                    new UniqueCategoryList(new Category("category")));
        }
    }
}
```
###### \java\seedu\taskmanager\logic\parser\ArgumentTokenizerTest.java
``` java
    @Test
    public void accessors_notTokenizedYet() {
        ArgumentTokenizer tokenizer = new ArgumentTokenizer(slashP);
        assertPreambleAbsent(tokenizer);
        assertArgumentAbsent(tokenizer, slashP);
    }

    @Test
    public void tokenize_emptyArgsString_noValues() {
        ArgumentTokenizer tokenizer = new ArgumentTokenizer(slashP);
        String argsString = "  ";
        tokenizer.tokenize(argsString);

        assertPreambleAbsent(tokenizer);
        assertArgumentAbsent(tokenizer, slashP);
    }

    private void assertPreamblePresent(ArgumentTokenizer argsTokenizer, String expectedPreamble) {
        assertEquals(expectedPreamble, argsTokenizer.getPreamble().get());
    }

    private void assertPreambleAbsent(ArgumentTokenizer argsTokenizer) {
        assertFalse(argsTokenizer.getPreamble().isPresent());
    }

    private void assertArgumentPresent(ArgumentTokenizer argsTokenizer, Prefix prefix, String... expectedValues) {

        // Verify the last value is returned
        assertEquals(expectedValues[expectedValues.length - 1], argsTokenizer.getValue(prefix).get());

        // Verify the number of values returned is as expected
        assertEquals(expectedValues.length, argsTokenizer.getAllValues(prefix).get().size());

        // Verify all values returned are as expected and in order
        for (int i = 0; i < expectedValues.length; i++) {
            assertEquals(expectedValues[i], argsTokenizer.getAllValues(prefix).get().get(i));
        }
    }

    private void assertArgumentAbsent(ArgumentTokenizer argsTokenizer, Prefix prefix) {
        assertFalse(argsTokenizer.getValue(prefix).isPresent());
    }

    @Test
    public void tokenize_noPrefixes_allTakenAsPreamble() {
        ArgumentTokenizer tokenizer = new ArgumentTokenizer();
        String argsString = "  some random string /t tag with leading and trailing spaces ";
        tokenizer.tokenize(argsString);

        // Same string expected as preamble, but leading/trailing spaces should
        // be trimmed
        assertPreamblePresent(tokenizer, argsString.trim());

    }

    @Test
    public void tokenize_oneArgument() {
        ArgumentTokenizer tokenizer = new ArgumentTokenizer(slashP);

        // Preamble present
        tokenizer.tokenize("  Some preamble string /p Argument value ");
        assertPreamblePresent(tokenizer, "Some preamble string");
        assertArgumentPresent(tokenizer, slashP, "Argument value");

        // No preamble
        tokenizer.tokenize(" /p   Argument value ");
        assertPreambleAbsent(tokenizer);
        assertArgumentPresent(tokenizer, slashP, "Argument value");

    }

    @Test
    public void tokenize_multipleArguments() {
        ArgumentTokenizer tokenizer = new ArgumentTokenizer(slashP, dashT, hatQ);

        // Only two arguments are present
        tokenizer.tokenize("SomePreambleString -t dashT-Value/pslashP value");
        assertPreamblePresent(tokenizer, "SomePreambleString");
        assertArgumentPresent(tokenizer, slashP, "slashP value");
        assertArgumentPresent(tokenizer, dashT, "dashT-Value");
        assertArgumentAbsent(tokenizer, hatQ);

        /*
         * Also covers: Cases where the prefix doesn't have a space before/after
         * it
         */

        // All three arguments are present, no spaces before the prefixes
        tokenizer.tokenize("Different Preamble String^Q 111-t dashT-Value/p slashP value");
        assertPreamblePresent(tokenizer, "Different Preamble String");
        assertArgumentPresent(tokenizer, slashP, "slashP value");
        assertArgumentPresent(tokenizer, dashT, "dashT-Value");
        assertArgumentPresent(tokenizer, hatQ, "111");

        /* Also covers: Reusing of the tokenizer multiple times */

        // Reuse tokenizer on an empty string to ensure state is correctly reset
        // (i.e. no stale values from the previous tokenizing remain in the
        // state)
        tokenizer.tokenize("");
        assertPreambleAbsent(tokenizer);
        assertArgumentAbsent(tokenizer, slashP);

        /** Also covers: testing for prefixes not specified as a prefix **/

        // Prefixes not previously given to the tokenizer should not return any
        // values
        String stringWithUnknownPrefix = unknownPrefix.getPrefix() + "some value";
        tokenizer.tokenize(stringWithUnknownPrefix);
        assertArgumentAbsent(tokenizer, unknownPrefix);
        assertPreamblePresent(tokenizer, stringWithUnknownPrefix); // Unknown
                                                                   // prefix is
                                                                   // taken as
                                                                   // part of
                                                                   // preamble
    }

    @Test
    public void tokenize_multipleArgumentsWithRepeats() {
        ArgumentTokenizer tokenizer = new ArgumentTokenizer(slashP, dashT, hatQ);

        // Two arguments repeated, some have empty values
        tokenizer.tokenize("SomePreambleString -t dashT-Value ^Q asd ^Q sdr -t another dashT value /p slashP value -t");
        assertPreamblePresent(tokenizer, "SomePreambleString -t dashT-Value ^Q asd");
        assertArgumentPresent(tokenizer, slashP, "slashP value");
        assertArgumentPresent(tokenizer, dashT, "");
        assertArgumentPresent(tokenizer, hatQ, "sdr -t another dashT value");
    }

    @Test
    public void equalsMethod() {
        Prefix aaa = new Prefix("aaa");

        assertEquals(aaa, aaa);
        assertEquals(aaa, new Prefix("aaa"));

        assertNotEquals(aaa, "aaa");
        assertNotEquals(aaa, new Prefix("aab"));
    }

}
```
###### \java\seedu\taskmanager\model\task\EndDateTest.java
``` java
    @Test
    public void isValidEndDate() {
        // invalid end date
        assertFalse(EndDate.isValidEndDate("")); // empty string
        assertFalse(EndDate.isValidEndDate(" ")); // spaces only
        assertFalse(EndDate.isValidEndDate("030317")); // DDMMYY with no /
        assertFalse(EndDate.isValidEndDate("4th of May 2016")); // Full date
                                                                // spelling
        assertFalse(EndDate.isValidEndDate("03/05/2017")); // DDMMYYYY format

        // valid end date
        // assertTrue(EndDate.isValidEndDate("thursday")); // full spelling of
        // day
        // assertTrue(EndDate.isValidEndDate("saturday"));
        // assertTrue(EndDate.isValidEndDate("thurs")); // short form
        // assertTrue(EndDate.isValidEndDate("tmr"));
        assertTrue(EndDate.isValidEndDate("03/03/17")); // DD/MM/YY format
        assertTrue(EndDate.isValidEndDate("04/08/15"));
    }
}
```
###### \java\seedu\taskmanager\model\task\EndTimeTest.java
``` java
    @Test
    public void isValidEndTime() {
        // invalid end time
        assertFalse(EndTime.isValidEndTime("")); // empty string
        assertFalse(EndTime.isValidEndTime(" ")); // spaces only
        // assertFalse(EndTime.isValidEndTime("00000")); // extra digit in 24hr
        // format
        // assertFalse(EndTime.isValidEndTime("2401")); // exceed the 2359 limit
        assertFalse(EndTime.isValidEndTime("2:00")); // time format with ":"
        assertFalse(EndTime.isValidEndTime("2pm")); // am/pm format

        // valid end time
        assertTrue(EndTime.isValidEndTime("1600")); // 24hr format
        assertTrue(EndTime.isValidEndTime("1200"));
        assertTrue(EndTime.isValidEndTime("1400"));
    }
}
```
###### \java\seedu\taskmanager\model\task\StartDateTest.java
``` java
    @Test
    public void isValidStartDate() {
        // invalid start date
        assertFalse(StartDate.isValidStartDate("")); // empty string
        assertFalse(StartDate.isValidStartDate(" ")); // spaces only
        assertFalse(StartDate.isValidStartDate("030317")); // DDMMYY with no /
        assertFalse(StartDate.isValidStartDate("4th of May 2016")); // Full date
                                                                    // spelling
        assertFalse(StartDate.isValidStartDate("03/05/2017")); // DDMMYYYY
                                                               // format

        // valid start date
        // assertTrue(StartDate.isValidStartDate("thursday")); // full spelling
        // of day
        // assertTrue(StartDate.isValidStartDate("saturday"));
        // assertTrue(StartDate.isValidStartDate("thurs")); // short form
        // assertTrue(StartDate.isValidStartDate("tmr"));
        assertTrue(StartDate.isValidStartDate("03/03/17")); // DD/MM/YY format
        assertTrue(StartDate.isValidStartDate("04/08/15"));
    }
}
```
###### \java\seedu\taskmanager\model\task\StartTimeTest.java
``` java
    @Test
    public void isValidStartTime() {
        // invalid start time
        assertFalse(StartTime.isValidStartTime("")); // empty string
        assertFalse(StartTime.isValidStartTime(" ")); // spaces only
        // assertFalse(StartTime.isValidStartTime("00000")); // extra digit in
        // 24hr format
        // assertFalse(StartTime.isValidStartTime("2401")); // exceed the 2359
        // limit
        assertFalse(StartTime.isValidStartTime("2:00")); // time format with ":"
        assertFalse(StartTime.isValidStartTime("2pm")); // am/pm format

        // valid start time
        assertTrue(StartTime.isValidStartTime("1600")); // 24hr format
        assertTrue(StartTime.isValidStartTime("1200"));
        assertTrue(StartTime.isValidStartTime("1400"));
    }
}
```
###### \java\seedu\taskmanager\model\task\TaskNameTest.java
``` java
    @Test
    public void isValidName() {
        // invalid task name
        assertFalse(TaskName.isValidName("")); // empty string
        assertFalse(TaskName.isValidName(" ")); // spaces only

        // valid task name
        assertTrue(TaskName.isValidName("eat food")); // alphabets only
        assertTrue(TaskName.isValidName("1 22 333 4444 55555")); // numbers only
        assertTrue(TaskName.isValidName("hungry b0i")); // alphanumeric
                                                        // characters
        assertTrue(TaskName.isValidName("EAT FOOD")); // with capital letters
        assertTrue(TaskName.isValidName("This is a run on sentence created" + "solely to prove a point")); // long
                                                                                                           // task
                                                                                                           // names
    }
}
```
###### \java\seedu\taskmanager\model\TaskManagerTest.java
``` java
    @Rule
    public ExpectedException thrown = ExpectedException.none();

    private final TaskManager taskManager = new TaskManager();

    @Test
    public void constructor() {
        assertEquals(Collections.emptyList(), taskManager.getTaskList());
        // assertEquals(Collections.emptyList(), taskManager.getCategoryList());
    }

    @Test
    public void resetData_null_throwsAssertionError() {
        thrown.expect(AssertionError.class);
        taskManager.resetData(null);
    }

    @Test
    public void resetData_withValidReadOnlyTaskManager_replacesData() {
        TaskManager newData = new TypicalTestTasks().getTypicalTaskManager();
        taskManager.resetData(newData);
        assertEquals(newData, taskManager);
    }

    @Test
    public void resetData_withDuplicateTasks_throwsAssertionError() {
        TypicalTestTasks td = new TypicalTestTasks();
        // Repeat td.eatbreakfast twice
        List<Task> newTasks = Arrays.asList(new Task(td.eatBreakfast), new Task(td.eatBreakfast));
        List<Category> newCategories = td.eatBreakfast.getCategories().asObservableList();
        TaskManagerStub newData = new TaskManagerStub(newTasks, newCategories);

        thrown.expect(AssertionError.class);
        taskManager.resetData(newData);
    }

    /*
     * @Test public void
     * resetData_withDuplicateCategories_throwsAssertionError() { TaskManager
     * typicalTaskManager = new TypicalTestTasks().getTypicalTaskManager();
     * List<ReadOnlyTask> newTasks = typicalTaskManager.getTaskList();
     * List<Category> newCategories = new
     * ArrayList<>(typicalTaskManager.getCategoryList()); // Repeat the first
     * category twice newCategories.add(newCategories.get(0)); TaskManagerStub
     * newData = new TaskManagerStub(newTasks, newCategories);
     *
     * thrown.expect(AssertionError.class); taskManager.resetData(newData); }
     */
    /**
     * A stub ReadOnlyTaskManager whose tasks and categories lists can violate
     * interface constraints.
     */
    private static class TaskManagerStub implements ReadOnlyTaskManager {
        private final ObservableList<ReadOnlyTask> tasks = FXCollections.observableArrayList();
        private final ObservableList<Category> categories = FXCollections.observableArrayList();

        TaskManagerStub(Collection<? extends ReadOnlyTask> tasks, Collection<? extends Category> categories) {
            this.tasks.setAll(tasks);
            this.categories.setAll(categories);
        }

        @Override
        public ObservableList<ReadOnlyTask> getTaskList() {
            return tasks;
        }

        @Override
        public ObservableList<Category> getCategoryList() {
            return categories;
        }
    }
}
```
###### \java\seedu\taskmanager\TestApp.java
``` java
    public TestApp(Supplier<ReadOnlyTaskManager> initialDataSupplier, String saveFileLocation) {
        super();
        this.initialDataSupplier = initialDataSupplier;
        this.saveFileLocation = saveFileLocation;

        // If some initial local data has been provided, write those to the file
        if (initialDataSupplier.get() != null) {
            TestUtil.createDataFileWithData(new XmlSerializableTaskManager(this.initialDataSupplier.get()),
                    this.saveFileLocation);
        }
    }

    @Override
    protected Config initConfig(String configFilePath) throws Exception {
        Config config = super.initConfig(configFilePath);
        config.setAppTitle(APP_TITLE);
        config.setTaskManagerFilePath(saveFileLocation);
        config.setUserPrefsFilePath(DEFAULT_PREF_FILE_LOCATION_FOR_TESTING);
        config.setTaskManagerName(TASK_MANAGER_NAME);
        return config;
    }

    @Override
    protected UserPrefs initPrefs(Config config) {
        UserPrefs userPrefs = super.initPrefs(config);
        double x = Screen.getPrimary().getVisualBounds().getMinX();
        double y = Screen.getPrimary().getVisualBounds().getMinY();
        userPrefs.updateLastUsedGuiSetting(new GuiSettings(600.0, 600.0, (int) x, (int) y));
        return userPrefs;
    }

    @Override
    public void start(Stage primaryStage) {
        ui.start(primaryStage);
    }

    public static void main(String[] args) {
        launch(args);
    }
}
```
###### \java\seedu\taskmanager\testutil\SerializableTestClass.java
``` java
/**
 * A class used to test serialization and deserialization
 */
public class SerializableTestClass {
    public static final String JSON_STRING_REPRESENTATION = String.format("{%n"
            + "  \"name\" : \"This is a test class\",%n"
            + "  \"listOfLocalDateTimes\" : "
            + "[ \"-999999999-01-01T00:00:00\", \"+999999999-12-31T23:59:59.999999999\", "
            + "\"0001-01-01T01:01:00\" ],%n"
            + "  \"mapOfIntegerToString\" : {%n"
            + "    \"1\" : \"One\",%n"
            + "    \"2\" : \"Two\",%n"
            + "    \"3\" : \"Three\"%n"
            + "  }%n"
            + "}");

    private static final String NAME_TEST_VALUE = "This is a test class";

    private String name;

    private List<LocalDateTime> listOfLocalDateTimes;
    private HashMap<Integer, String> mapOfIntegerToString;

    public static String getNameTestValue() {
        return NAME_TEST_VALUE;
    }

    public static List<LocalDateTime> getListTestValues() {
        List<LocalDateTime> listOfLocalDateTimes = new ArrayList<>();

        listOfLocalDateTimes.add(LocalDateTime.MIN);
        listOfLocalDateTimes.add(LocalDateTime.MAX);
        listOfLocalDateTimes.add(LocalDateTime.of(1, 1, 1, 1, 1));

        return listOfLocalDateTimes;
    }

    public static HashMap<Integer, String> getHashMapTestValues() {
        HashMap<Integer, String> mapOfIntegerToString = new HashMap<>();

        mapOfIntegerToString.put(1, "One");
        mapOfIntegerToString.put(2, "Two");
        mapOfIntegerToString.put(3, "Three");

        return mapOfIntegerToString;
    }

    public void setTestValues() {
        name = getNameTestValue();
        listOfLocalDateTimes = getListTestValues();
        mapOfIntegerToString = getHashMapTestValues();
    }

    public String getName() {
        return name;
    }

    public List<LocalDateTime> getListOfLocalDateTimes() {
        return listOfLocalDateTimes;
    }

    public HashMap<Integer, String> getMapOfIntegerToString() {
        return mapOfIntegerToString;
    }
}
```
###### \java\seedu\taskmanager\testutil\TaskBuilder.java
``` java
public class TaskBuilder {

    private TestTask task;

    public TaskBuilder() {
        this.task = new TestTask();
    }

    /**
     * Initializes the PersonBuilder with the data of {@code taskToCopy}.
     */
    public TaskBuilder(TestTask taskToCopy) {
        this.task = new TestTask(taskToCopy);
    }

    public TaskBuilder withTaskName(String taskname) throws IllegalValueException {
        this.task.setTaskName(new TaskName(taskname));
        return this;
    }

    public TaskBuilder withStartDate(String date) throws IllegalValueException {
        this.task.setStartDate(new StartDate(date));
        return this;
    }

    public TaskBuilder withStartTime(String startTime) throws IllegalValueException {
        this.task.setStartTime(new StartTime(startTime));
        return this;
    }

    public TaskBuilder withEndDate(String endDate) throws IllegalValueException {
        this.task.setEndDate(new EndDate(endDate));
        return this;
    }

    public TaskBuilder withEndTime(String endTime) throws IllegalValueException {
        this.task.setEndTime(new EndTime(endTime));
        return this;
    }

    public TaskBuilder withCompletion(Boolean isComplete) {
        this.task.setCompleted(new Boolean(isComplete));
        return this;
    }

    public TaskBuilder withCategories(String... categories) throws IllegalValueException {
        task.setCategories(new UniqueCategoryList());
        for (String category : categories) {
            task.getCategories().add(new Category(category));
        }
        return this;
    }

    public TestTask build() {
        return this.task;
    }

}
```
###### \java\seedu\taskmanager\testutil\TestTask.java
``` java
/**
 * A mutable task object. For testing only.
 */
public class TestTask implements ReadOnlyTask {

    private TaskName taskName;
    private StartDate startDate;
    private StartTime startTime;
    private EndDate endDate;
    private EndTime endTime;
    private boolean completed;
    private UniqueCategoryList categories;

    private final String EMPTY_FIELD = "EMPTY_FIELD";

    public TestTask() {
        categories = new UniqueCategoryList();
    }

    /**
     * Creates a copy of {@code taskToCopy}.
     */
    public TestTask(TestTask taskToCopy) {
        this.taskName = taskToCopy.getTaskName();
        this.startDate = taskToCopy.getStartDate();
        this.startTime = taskToCopy.getStartTime();
        this.endDate = taskToCopy.getEndDate();
        this.endTime = taskToCopy.getEndTime();
        this.completed = taskToCopy.getIsMarkedAsComplete();
        this.categories = taskToCopy.getCategories();
    }

    public void setTaskName(TaskName taskname) {
        this.taskName = taskname;
    }

    public void setStartDate(StartDate startdate) {
        this.startDate = startdate;
    }

    public void setStartTime(StartTime starttime) {
        this.startTime = starttime;
    }

    public void setEndDate(EndDate enddate) {
        this.endDate = enddate;
    }

    public void setEndTime(EndTime endtime) {
        this.endTime = endtime;
    }

    public void setCompleted(Boolean isCompleted) {
        this.completed = isCompleted;
    }

    public void setCategories(UniqueCategoryList categories) {
        this.categories = categories;
    }

    @Override
    public TaskName getTaskName() {
        return taskName;
    }

    @Override
    public StartDate getStartDate() {
        return startDate;
    }

    @Override
    public StartTime getStartTime() {
        return startTime;
    }

    @Override
    public EndDate getEndDate() {
        return endDate;
    }

    @Override
    public EndTime getEndTime() {
        return endTime;
    }

    @Override
    public UniqueCategoryList getCategories() {
        return categories;
    }

    @Override
    public Boolean getIsMarkedAsComplete() {
        return completed;
    }

    @Override
    public String toString() {
        return getAsText();
    }

    public String getAddCommand() {
        StringBuilder sb = new StringBuilder();
        sb.append("ADD " + this.getTaskName().fullTaskName + " ");
        sb.append("FROM " + this.getStartDate().value + " ");
        sb.append(this.getStartTime().value + " ");
        sb.append("TO " + this.getEndDate().value + " ");
        sb.append(this.getEndTime().value + " ");
        this.getCategories().asObservableList().stream().forEach(s -> sb.append("CATEGORY " + s.categoryName + " "));
        return sb.toString();
    }

```
###### \java\seedu\taskmanager\testutil\TestUtil.java
``` java
/**
 * A utility class for test cases.
 */
public class TestUtil {

    public static final String LS = System.lineSeparator();

    /**
     * Folder used for temp files created during testing. Ignored by Git.
     */
    public static final String SANDBOX_FOLDER = FileUtil.getPath("./src/test/data/sandbox/");

    public static final Task[] SAMPLE_TASK_DATA = getSampleTaskData();

    public static final Category[] SAMPLE_CATEGORY_DATA = getSampleCategoryData();

    public static void assertThrows(Class<? extends Throwable> expected, Runnable executable) {
        try {
            executable.run();
        } catch (Throwable actualException) {
            if (actualException.getClass().isAssignableFrom(expected)) {
                return;
            }
            String message = String.format("Expected thrown: %s, actual: %s", expected.getName(),
                    actualException.getClass().getName());
            throw new AssertionFailedError(message);
        }
        throw new AssertionFailedError(
                String.format("Expected %s to be thrown, but nothing was thrown.", expected.getName()));
    }

    private static Task[] getSampleTaskData() {
        try {
            // CHECKSTYLE.OFF: LineLength
            return new Task[] {
                new Task(new TaskName("Eat breakfast with mom"), new StartDate("03/03/17"), new StartTime("1000"),
                        new EndDate("03/03/17"), new EndTime("1100"), Boolean.FALSE,
                        new UniqueCategoryList("just", "friends")),
                new Task(new TaskName("Start on the CS2103 project"), new StartDate("03/03/17"),
                        new StartTime("1400"), new EndDate("03/04/17"), new EndTime("1800"), Boolean.TRUE,
                        new UniqueCategoryList("work")),
                new Task(new TaskName("Eat dinner with my only 2 friends"), new StartDate("09/03/17"),
                        new StartTime("1800"), new EndDate("09/03/17"), new EndTime("2000"), Boolean.TRUE,
                        new UniqueCategoryList()),
                new Task(new TaskName("Try harder for CS2103 project"), new StartDate("04/04/17"),
                        new StartTime("1400"), new EndDate("05/04/17"), new EndTime("1500"), Boolean.FALSE,
                        new UniqueCategoryList("lepak")),
                new Task(new TaskName("Try even harder for CS2103"), new StartDate("05/04/17"),
                        new StartTime("1500"), new EndDate("05/05/17"), new EndTime("1600"), Boolean.FALSE,
                        new UniqueCategoryList("work")),
                new Task(new TaskName("Eat lunch at techno"), new StartDate("EMPTY_FIELD"),
                        new StartTime("EMPTY_FIELD"), new EndDate("04/03/17"), new EndTime("1400"), Boolean.FALSE,
                        new UniqueCategoryList("no", "friends")),
                new Task(new TaskName("Run 2.4km in 10 mins"), new StartDate("EMPTY_FIELD"),
                        new StartTime("EMPTY_FIELD"), new EndDate("EMPTY_FIELD"), new EndTime("EMPTY_FIELD"),
                        Boolean.FALSE, new UniqueCategoryList("lepak")),
                new Task(new TaskName("Time to relax a little"), new StartDate("06/05/17"), new StartTime("1400"),
                        new EndDate("06/05/17"), new EndTime("1800"), Boolean.FALSE,
                        new UniqueCategoryList("lepak")),
                new Task(new TaskName("Chiong all day everyday"), new StartDate("EMPTY_FIELD"),
                        new StartTime("EMPTY_FIELD"), new EndDate("EMPTY_FIELD"), new EndTime("EMPTY_FIELD"),
                        Boolean.FALSE, new UniqueCategoryList("work")),
                new Task(new TaskName("Get it done"), new StartDate("EMPTY_FIELD"), new StartTime("EMPTY_FIELD"),
                        new EndDate("06/05/17"), new EndTime("1700"), Boolean.TRUE,
                        new UniqueCategoryList("work")) };
            // CHECKSTYLE.ON: LineLength
        } catch (IllegalValueException e) {
            assert false;
            // not possible
            return null;
        }
    }

    private static Category[] getSampleCategoryData() {
        try {
            return new Category[] { new Category("relatives"), new Category("friends") };
        } catch (IllegalValueException e) {
            assert false;
            return null;
            // not possible
        }
    }

    public static List<Task> generateSampleTaskData() {
        return Arrays.asList(SAMPLE_TASK_DATA);
    }

    /**
     * Appends the file TaskName to the sandbox folder path. Creates the sandbox
     * folder if it doesn't exist.
     *
     * @param fileName
     * @return
     */
    public static String getFilePathInSandboxFolder(String fileName) {
        try {
            FileUtil.createDirs(new File(SANDBOX_FOLDER));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return SANDBOX_FOLDER + fileName;
    }

    public static void createDataFileWithSampleData(String filePath) {
        createDataFileWithData(generateSampleStorageTaskManager(), filePath);
    }

    public static <T> void createDataFileWithData(T data, String filePath) {
        try {
            File saveFileForTesting = new File(filePath);
            FileUtil.createIfMissing(saveFileForTesting);
            XmlUtil.saveDataToFile(saveFileForTesting, data);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public static void main(String... s) {
        createDataFileWithSampleData(TestApp.SAVE_LOCATION_FOR_TESTING);
    }

    public static XmlSerializableTaskManager generateSampleStorageTaskManager() {
        return new XmlSerializableTaskManager(new TaskManager());
    }

    /**
     * Tweaks the {@code keyCodeCombination} to resolve the
     * {@code KeyCode.SHORTCUT} to their respective platform-specific keycodes
     */
    public static KeyCode[] scrub(KeyCodeCombination keyCodeCombination) {
        List<KeyCode> keys = new ArrayList<>();
        if (keyCodeCombination.getAlt() == KeyCombination.ModifierValue.DOWN) {
            keys.add(KeyCode.ALT);
        }
        if (keyCodeCombination.getShift() == KeyCombination.ModifierValue.DOWN) {
            keys.add(KeyCode.SHIFT);
        }
        if (keyCodeCombination.getMeta() == KeyCombination.ModifierValue.DOWN) {
            keys.add(KeyCode.META);
        }
        if (keyCodeCombination.getControl() == KeyCombination.ModifierValue.DOWN) {
            keys.add(KeyCode.CONTROL);
        }
        keys.add(keyCodeCombination.getCode());
        return keys.toArray(new KeyCode[] {});
    }

    public static boolean isHeadlessEnvironment() {
        String headlessProperty = System.getProperty("testfx.headless");
        return headlessProperty != null && headlessProperty.equals("true");
    }

    public static void captureScreenShot(String fileName) {
        File file = GuiTest.captureScreenshot();
        try {
            Files.copy(file, new File(fileName + ".png"));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static String descOnFail(Object... comparedObjects) {
        return "Comparison failed \n"
                + Arrays.asList(comparedObjects).stream().map(Object::toString).collect(Collectors.joining("\n"));
    }

    public static void setFinalStatic(Field field, Object newValue)
            throws NoSuchFieldException, IllegalAccessException {
        field.setAccessible(true);
        // remove final modifier from field
        Field modifiersField = Field.class.getDeclaredField("modifiers");
        modifiersField.setAccessible(true);
        // ~Modifier.FINAL is used to remove the final modifier from field so
        // that its value is no longer
        // final and can be changed
        modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);
        field.set(null, newValue);
    }

    public static void initRuntime() throws TimeoutException {
        FxToolkit.registerPrimaryStage();
        FxToolkit.hideStage();
    }

    public static void tearDownRuntime() throws Exception {
        FxToolkit.cleanupStages();
    }

    /**
     * Gets private method of a class Invoke the method using
     * method.invoke(objectInstance, params...)
     *
     * Caveat: only find method declared in the current Class, not inherited
     * from supertypes
     */
    public static Method getPrivateMethod(Class<?> objectClass, String methodName) throws NoSuchMethodException {
        Method method = objectClass.getDeclaredMethod(methodName);
        method.setAccessible(true);
        return method;
    }

    public static void renameFile(File file, String newFileName) {
        try {
            Files.copy(file, new File(newFileName));
        } catch (IOException e1) {
            e1.printStackTrace();
        }
    }

    /**
     * Gets mid point of a node relative to the screen.
     *
     * @param node
     * @return
     */
    public static Point2D getScreenMidPoint(Node node) {
        double x = getScreenPos(node).getMinX() + node.getLayoutBounds().getWidth() / 2;
        double y = getScreenPos(node).getMinY() + node.getLayoutBounds().getHeight() / 2;
        return new Point2D(x, y);
    }

    /**
     * Gets mid point of a node relative to its scene.
     *
     * @param node
     * @return
     */
    public static Point2D getSceneMidPoint(Node node) {
        double x = getScenePos(node).getMinX() + node.getLayoutBounds().getWidth() / 2;
        double y = getScenePos(node).getMinY() + node.getLayoutBounds().getHeight() / 2;
        return new Point2D(x, y);
    }

    /**
     * Gets the bound of the node relative to the parent scene.
     *
     * @param node
     * @return
     */
    public static Bounds getScenePos(Node node) {
        return node.localToScene(node.getBoundsInLocal());
    }

    public static Bounds getScreenPos(Node node) {
        return node.localToScreen(node.getBoundsInLocal());
    }

    public static double getSceneMaxX(Scene scene) {
        return scene.getX() + scene.getWidth();
    }

    public static double getSceneMaxY(Scene scene) {
        return scene.getX() + scene.getHeight();
    }

    public static Object getLastElement(List<?> list) {
        return list.get(list.size() - 1);
    }

    /**
     * Removes a subset from the list of tasks.
     *
     * @param tasks
     *            The list of tasks
     * @param tasksToRemove
     *            The subset of tasks.
     * @return The modified tasks after removal of the subset from tasks.
     */
    public static TestTask[] removeTasksFromList(final TestTask[] tasks, TestTask... tasksToRemove) {
        List<TestTask> listOfTasks = asList(tasks);
        listOfTasks.removeAll(asList(tasksToRemove));
        return listOfTasks.toArray(new TestTask[listOfTasks.size()]);
    }

    /**
     * Returns a copy of the list with the task at specified index removed.
     *
     * @param list
     *            original list to copy from
     * @param targetIndexInOneIndexedFormat
     *            e.g. index 1 if the first element is to be removed
     */
    public static TestTask[] removeTaskFromList(final TestTask[] list, int targetIndexInOneIndexedFormat) {
        return removeTasksFromList(list, list[targetIndexInOneIndexedFormat - 1]);
    }

    /**
     * Replaces tasks[i] with a task.
     *
     * @param tasks
     *            The array of tasks.
     * @param task
     *            The replacement task
     * @param index
     *            The index of the task to be replaced.
     * @return
     */
    public static TestTask[] replaceTaskFromList(TestTask[] tasks, TestTask task, int index) {
        tasks[index] = task;
        return tasks;
    }

    /**
     * Appends tasks to the array of tasks.
     *
     * @param tasks
     *            A array of tasks.
     * @param tasksToAdd
     *            The tasks that are to be appended behind the original array.
     * @return The modified array of tasks.
     */
    public static Pair<TestTask[], Integer> addTasksToList(final TestTask[] tasks, TestTask taskToAdd) {
        List<TestTask> listOfTasks = asList(tasks);
        int addIndex = findSortedPositionToAdd(taskToAdd, listOfTasks);
        listOfTasks.add(addIndex, taskToAdd);
        return new Pair<TestTask[], Integer>(listOfTasks.toArray(new TestTask[listOfTasks.size()]), addIndex);
    }

    private static <T> List<T> asList(T[] objs) {
        List<T> list = new ArrayList<>();
        for (T obj : objs) {
            list.add(obj);
        }
        return list;
    }

    public static boolean compareCardAndTask(EventTaskCardHandle card, ReadOnlyTask task) {
        return card.isSameTask(task);
    }

    public static boolean compareCardAndTask(DeadlineTaskCardHandle card, ReadOnlyTask task) {
        return card.isSameTask(task);
    }

    public static boolean compareCardAndTask(FloatingTaskCardHandle card, ReadOnlyTask task) {
        return card.isSameTask(task);
    }

    public static Category[] getCategoryList(String categories) {
        if ("".equals(categories)) {
            return new Category[] {};
        }

        final String[] split = categories.split(", ");

        final List<Category> collect = Arrays.asList(split).stream().map(e -> {
            try {
                return new Category(e.replaceFirst("Category: ", ""));
            } catch (IllegalValueException e1) {
                // not possible
                assert false;
                return null;
            }
        }).collect(Collectors.toList());

        return collect.toArray(new Category[split.length]);
    }

```
###### \java\seedu\taskmanager\testutil\TypicalTestTasks.java
``` java
/**
 *
 */
public class TypicalTestTasks {

    public TestTask eatBreakfast, eatLunch, eatDinner, doCS, tryHarderCS, tryAgainCS, getFit, sampleEvent,
            sampleFloatingTask, sampleDeadline, sampleClashBetweenOneDayEvent, sampleClashBetweenMultipleDaysEvent,
            sampleClashAcrossMultipleDaysEvent, sampleClashStartOfMultipleDaysEvent, sampleClashEndOfMultipleDaysEvent,
            sampleNoClashSameDayEvent, sampleNoClashSeparateDayEvent, recurTestDay, recurTestDayOnce, recurTestDayTwice,
            recurTestDayThrice, recurTestWeek, recurTestWeekOnce, recurTestWeekTwice, recurTestWeekThrice,
            recurTestMonth, recurTestMonthOnce, recurTestMonthTwice, recurTestMonthThrice, recurTestYear,
            recurTestYearOnce, recurTestYearTwice, recurTestYearThrice, eventTestMon, eventTestTuesThurs,
            eventTestThurs, eventTestFriSat, updateEventFromIndexBeforeToAfter, updateEventFromIndexBeforeToBefore,
            updateEventFromIndexAfterToBefore, updateEventFromIndexAfterToAfter, updateEventFromClashToNoClash,
            completedEatBreakfast, fromToEventWithoutTime, onToEventWithEndTime, byDeadlineWithoutTime,
            byDeadlineWithTime;

    public TypicalTestTasks() {
        try {
            eatBreakfast = new TaskBuilder().withTaskName("Eat breakfast with mom").withStartDate("03/03/17")
                    .withStartTime("1000").withEndDate("03/03/17").withEndTime("1100").withCompletion(false)
                    .withCategories("just", "friends").build(); // event
            doCS = new TaskBuilder().withTaskName("Start on the CS2103 project").withStartDate("03/03/17")
                    .withStartTime("1400").withEndDate("03/04/17").withEndTime("1800").withCompletion(false)
                    .withCategories("work").build(); // event
            eatDinner = new TaskBuilder().withTaskName("Eat dinner with my only 2 friends").withStartDate("09/03/17")
                    .withStartTime("1800").withEndDate("09/03/17").withEndTime("2000").withCompletion(false).build();
            tryHarderCS = new TaskBuilder().withTaskName("Try harder for CS2103 project").withStartDate("04/04/17")
                    .withStartTime("1400").withEndDate("05/04/17").withEndTime("1500").withCompletion(false)
                    .withCategories("lepak").build(); // event
            tryAgainCS = new TaskBuilder().withTaskName("Try even harder for CS2103").withStartDate("05/04/17")
                    .withStartTime("1500").withEndDate("05/05/17").withEndTime("1600").withCompletion(false)
                    .withCategories("work").build(); // event
            eatLunch = new TaskBuilder().withTaskName("Eat lunch at techno").withStartDate("EMPTY_FIELD")
                    .withStartTime("EMPTY_FIELD").withEndDate("04/03/17").withEndTime("1400").withCompletion(false)
                    .withCategories("no", "friends").build(); // deadline
            getFit = new TaskBuilder().withTaskName("Run 2.4km in 10 mins").withStartDate("EMPTY_FIELD")
                    .withStartTime("EMPTY_FIELD").withEndDate("EMPTY_FIELD").withEndTime("EMPTY_FIELD")
                    .withCompletion(false).withCategories("lepak").build(); // floating
                                                                            // task

            // Manually added
            sampleEvent = new TaskBuilder().withTaskName("Time to relax a little").withStartDate("06/05/17")
                    .withStartTime("1400").withEndDate("06/05/17").withEndTime("1800").withCompletion(false)
                    .withCategories("lepak").build();
            sampleFloatingTask = new TaskBuilder().withTaskName("Chiong all day everyday").withStartDate("EMPTY_FIELD")
                    .withStartTime("EMPTY_FIELD").withEndDate("EMPTY_FIELD").withEndTime("EMPTY_FIELD")
                    .withCompletion(false).withCategories("work").build();
            sampleDeadline = new TaskBuilder().withTaskName("Get it done").withStartDate("EMPTY_FIELD")
                    .withStartTime("EMPTY_FIELD").withEndDate("06/05/17").withEndTime("1700").withCompletion(false)
                    .withCategories("work").build();
            fromToEventWithoutTime = new TaskBuilder().withTaskName("Hell week").withStartDate("08/04/17")
                    .withStartTime("0000").withEndDate("11/04/17").withEndTime("2359").withCompletion(false)
                    .withCategories("rekt").build();
            onToEventWithEndTime = new TaskBuilder().withTaskName("Hell week").withStartDate("08/04/17")
                    .withStartTime("0000").withEndDate("08/04/17").withEndTime("1200").withCompletion(false)
                    .withCategories("rekt").build();
            byDeadlineWithoutTime = new TaskBuilder().withTaskName("Deadline").withStartDate("EMPTY_FIELD")
                    .withStartTime("EMPTY_FIELD").withEndDate("08/04/17").withEndTime("2359").withCompletion(false)
                    .withCategories("rekt").build();
            byDeadlineWithTime = new TaskBuilder().withTaskName("DedLine").withStartDate("EMPTY_FIELD")
                    .withStartTime("EMPTY_FIELD").withEndDate("08/04/17").withEndTime("1200").withCompletion(false)
                    .withCategories("rekt").build();

            // blocking time slots test tasks
            sampleClashBetweenOneDayEvent = new TaskBuilder().withTaskName("Escape Reality").withStartDate("13/04/17")
                    .withStartTime("1130").withEndDate("13/04/17").withEndTime("1800").withCompletion(false)
                    .withCategories("CS", "NO").build();
            sampleClashBetweenMultipleDaysEvent = new TaskBuilder().withTaskName("Midweek blues")
                    .withStartDate("12/04/17").withStartTime("1900").withEndDate("12/04/17").withEndTime("2200")
                    .withCompletion(false).withCategories("no", "dance").build();
            sampleClashAcrossMultipleDaysEvent = new TaskBuilder().withTaskName("No gap").withStartDate("10/04/17")
                    .withStartTime("1200").withEndDate("14/04/17").withEndTime("1000").withCompletion(false)
                    .withCategories("thigh", "gap").build();
            sampleClashStartOfMultipleDaysEvent = new TaskBuilder().withTaskName("Sighpie").withStartDate("11/04/17")
                    .withStartTime("1500").withEndDate("11/04/17").withEndTime("1800").withCompletion(false)
                    .withCategories("approaching", "submission").build();
            sampleClashEndOfMultipleDaysEvent = new TaskBuilder().withTaskName("Fixing Travis")
                    .withStartDate("13/04/17").withStartTime("0700").withEndDate("13/04/17").withEndTime("1100")
                    .withCompletion(false).withCategories("NoTravis").build();
            sampleNoClashSameDayEvent = new TaskBuilder().withTaskName("Reality hits hard").withStartDate("13/04/17")
                    .withStartTime("1200").withEndDate("14/04/17").withEndTime("1100").withCompletion(false)
                    .withCategories("CS", "rekt").build();
            sampleNoClashSeparateDayEvent = new TaskBuilder().withTaskName("Coding in Progress")
                    .withStartDate("16/04/17").withStartTime("2330").withEndDate("17/04/17").withEndTime("0030")
                    .withCompletion(false).withCategories("code", "work").build();

            eventTestMon = new TaskBuilder().withTaskName("Monday Blues").withStartDate("10/04/17")
                    .withStartTime("1000").withEndDate("10/04/17").withEndTime("1100").withCompletion(false)
                    .withCategories("not", "red").build();
            eventTestTuesThurs = new TaskBuilder().withTaskName("TwoDays").withStartDate("11/04/17")
                    .withStartTime("1700").withEndDate("13/04/17").withEndTime("0800").withCompletion(false)
                    .withCategories("not", "one").build();
            eventTestThurs = new TaskBuilder().withTaskName("Depressing Thursday").withStartDate("13/04/17")
                    .withStartTime("1100").withEndDate("13/04/17").withEndTime("1200").withCompletion(false)
                    .withCategories("CS2013", "impossible").build();
            eventTestFriSat = new TaskBuilder().withTaskName("Weekend").withStartDate("14/04/17").withStartTime("1230")
                    .withEndDate("15/04/17").withEndTime("1900").withCompletion(false).withCategories("still", "coding")
                    .build();

            updateEventFromIndexBeforeToBefore = new TaskBuilder().withTaskName("Eat breakfast with mom")
                    .withStartDate("03/03/17").withStartTime("1000").withEndDate("03/03/17").withEndTime("1500")
                    .withCompletion(false).withCategories("just", "friends").build();
            updateEventFromIndexBeforeToAfter = new TaskBuilder().withTaskName("Start on the CS2103 project")
                    .withStartDate("09/03/17").withStartTime("1900").withEndDate("11/03/17").withEndTime("1100")
                    .withCompletion(false).withCategories("work").build();
            updateEventFromIndexAfterToBefore = new TaskBuilder().withTaskName("Start on the CS2103 project")
                    .withStartDate("08/03/17").withStartTime("1000").withEndDate("11/03/17").withEndTime("1100")
                    .withCompletion(false).withCategories("work").build();
            updateEventFromIndexAfterToAfter = new TaskBuilder().withTaskName("Try even harder for CS2103")
                    .withStartDate("05/04/17").withStartTime("1430").withEndDate("05/04/17").withEndTime("1530")
                    .withCompletion(false).withCategories("work").build();
            updateEventFromClashToNoClash = new TaskBuilder().withTaskName("Salvage CS2103").withStartDate("05/04/17")
                    .withStartTime("1700").withEndDate("14/04/17").withEndTime("1100").withCompletion(false)
                    .withCategories("work").build();

            // completedTask
            completedEatBreakfast = new TaskBuilder().withTaskName("Eat breakfast with mom").withStartDate("03/03/17")
                    .withStartTime("1000").withEndDate("03/03/17").withEndTime("1100").withCompletion(true)
                    .withCategories("just", "friends").build(); // event

            // Recurring task
            recurTestDay = new TaskBuilder().withTaskName("I'm recurring").withStartDate("30/12/17")
                    .withStartTime("1000").withEndDate("30/12/17").withEndTime("1100").withCompletion(false)
                    .withCategories("Test").build();
            recurTestDayOnce = new TaskBuilder().withTaskName("I'm recurring").withStartDate("31/12/17")
                    .withStartTime("1000").withEndDate("31/12/17").withEndTime("1100").withCompletion(false)
                    .withCategories("Test").build();
            recurTestDayTwice = new TaskBuilder().withTaskName("I'm recurring").withStartDate("01/01/18")
                    .withStartTime("1000").withEndDate("01/01/18").withEndTime("1100").withCompletion(false)
                    .withCategories("Test").build();
            recurTestDayThrice = new TaskBuilder().withTaskName("I'm recurring").withStartDate("02/01/18")
                    .withStartTime("1000").withEndDate("02/01/18").withEndTime("1100").withCompletion(false)
                    .withCategories("Test").build();
            recurTestWeek = new TaskBuilder().withTaskName("I'm recurring").withStartDate("17/12/17")
                    .withStartTime("1000").withEndDate("17/12/17").withEndTime("1100").withCompletion(false)
                    .withCategories("Test").build();
            recurTestWeekOnce = new TaskBuilder().withTaskName("I'm recurring").withStartDate("24/12/17")
                    .withStartTime("1000").withEndDate("24/12/17").withEndTime("1100").withCompletion(false)
                    .withCategories("Test").build();
            recurTestWeekTwice = new TaskBuilder().withTaskName("I'm recurring").withStartDate("31/12/17")
                    .withStartTime("1000").withEndDate("31/12/17").withEndTime("1100").withCompletion(false)
                    .withCategories("Test").build();
            recurTestWeekThrice = new TaskBuilder().withTaskName("I'm recurring").withStartDate("07/01/18")
                    .withStartTime("1000").withEndDate("07/01/17").withEndTime("1100").withCompletion(false)
                    .withCategories("Test").build();
            recurTestMonth = new TaskBuilder().withTaskName("I'm recurring").withStartDate("EMPTY_FIELD")
                    .withStartTime("EMPTY_FIELD").withEndDate("03/11/17").withEndTime("1100").withCompletion(false)
                    .withCategories("Test").build();
            recurTestMonthOnce = new TaskBuilder().withTaskName("I'm recurring").withStartDate("EMPTY_FIELD")
                    .withStartTime("EMPTY_FIELD").withEndDate("03/12/17").withEndTime("1100").withCompletion(false)
                    .withCategories("Test").build();
            recurTestMonthTwice = new TaskBuilder().withTaskName("I'm recurring").withStartDate("EMPTY_FIELD")
                    .withStartTime("EMPTY_FIELD").withEndDate("03/01/18").withEndTime("1100").withCompletion(false)
                    .withCategories("Test").build();
            recurTestMonthThrice = new TaskBuilder().withTaskName("I'm recurring").withStartDate("EMPTY_FIELD")
                    .withStartTime("EMPTY_FIELD").withEndDate("03/02/18").withEndTime("1100").withCompletion(false)
                    .withCategories("Test").build();
            recurTestYear = new TaskBuilder().withTaskName("I'm recurring").withStartDate("EMPTY_FIELD")
                    .withStartTime("EMPTY_FIELD").withEndDate("03/03/17").withEndTime("1100").withCompletion(false)
                    .withCategories("Test").build();
            recurTestYearOnce = new TaskBuilder().withTaskName("I'm recurring").withStartDate("EMPTY_FIELD")
                    .withStartTime("EMPTY_FIELD").withEndDate("03/03/18").withEndTime("1100").withCompletion(false)
                    .withCategories("Test").build();
            recurTestYearTwice = new TaskBuilder().withTaskName("I'm recurring").withStartDate("EMPTY_FIELD")
                    .withStartTime("EMPTY_FIELD").withEndDate("03/03/19").withEndTime("1100").withCompletion(false)
                    .withCategories("Test").build();
            recurTestYearThrice = new TaskBuilder().withTaskName("I'm recurring").withStartDate("EMPTY_FIELD")
                    .withStartTime("EMPTY_FIELD").withEndDate("03/03/20").withEndTime("1100").withCompletion(false)
                    .withCategories("Test").build();

        } catch (IllegalValueException e) {
            e.printStackTrace();
            assert false : "not possible";
        }
    }

    public void TypicalTestEventsForBlockingTimeSlots() {
        try {
            // add command
            eventTestMon = new TaskBuilder().withTaskName("Monday Blues").withStartDate("10/04/17")
                    .withStartTime("1000").withEndDate("10/04/17").withEndTime("1100").withCompletion(false)
                    .withCategories("not", "red").build();
            eventTestTuesThurs = new TaskBuilder().withTaskName("TwoDays").withStartDate("11/04/17")
                    .withStartTime("1700").withEndDate("13/04/17").withEndTime("0800").withCompletion(false)
                    .withCategories("not", "one").build();
            eventTestThurs = new TaskBuilder().withTaskName("Depressing Thursday").withStartDate("13/04/17")
                    .withStartTime("1100").withEndDate("13/04/17").withEndTime("1200").withCompletion(false)
                    .withCategories("CS2013", "impossible").build();
            eventTestFriSat = new TaskBuilder().withTaskName("Weekend").withStartDate("14/04/17").withStartTime("1230")
                    .withEndDate("15/04/17").withEndTime("1900").withCompletion(false).withCategories("still", "coding")
                    .build();

            // update command

            updateEventFromIndexBeforeToBefore = new TaskBuilder().withTaskName("Eat breakfast with mom")
                    .withStartDate("03/03/17").withStartTime("1000").withEndDate("03/03/17").withEndTime("1500")
                    .withCompletion(false).withCategories("just", "friends").build();

            updateEventFromIndexBeforeToAfter = new TaskBuilder().withTaskName("Start on the CS2103 project")
                    .withStartDate("09/03/17").withStartTime("1900").withEndDate("11/03/17").withEndTime("1100")
                    .withCompletion(false).withCategories("work").build();

            updateEventFromIndexAfterToBefore = new TaskBuilder().withTaskName("Start on the CS2103 project")
                    .withStartDate("08/03/17").withStartTime("1000").withEndDate("11/03/17").withEndTime("1100")
                    .withCompletion(false).withCategories("not", "red").build();

            updateEventFromIndexAfterToAfter = new TaskBuilder().withTaskName("Try even harder for CS2103")
                    .withStartDate("05/04/17").withStartTime("1430").withEndDate("05/04/17").withEndTime("1530")
                    .withCompletion(false).withCategories("work").build();

            updateEventFromClashToNoClash = new TaskBuilder().withTaskName("Salvage CS2103").withStartDate("05/04/17")
                    .withStartTime("1700").withEndDate("14/04/17").withEndTime("1100").withCompletion(false)
                    .withCategories("work").build();

        } catch (IllegalValueException e) {
            e.printStackTrace();
            assert false : "not possible";
        }
    }

    public static void loadTaskManagerWithSampleData(TaskManager tm) {
        for (TestTask task : new TypicalTestTasks().getTypicalTasks()) {
            try {
                tm.addTask(new Task(task));
            } catch (UniqueTaskList.DuplicateTaskException e) {
                assert false : "not possible";
            }
        }
    }

    public TestTask[] getTypicalTasks() {
        return new TestTask[] { eatBreakfast, doCS, eatDinner, tryHarderCS, tryAgainCS, eatLunch, getFit };
    }

    public TestTask[] getTypicalRecurringEventTasksForDays() {
        return new TestTask[] { recurTestDay, recurTestDayOnce, recurTestDayTwice, recurTestDayThrice };
    }

    public TestTask[] getTypicalRecurringEventTasksForWeeks() {
        return new TestTask[] { recurTestWeek, recurTestWeekOnce, recurTestWeekTwice, recurTestWeekThrice };
    }

    public TestTask[] getTypicalRecurringDeadlineTasksForMonths() {
        return new TestTask[] { recurTestMonth, recurTestMonthOnce, recurTestMonthTwice, recurTestMonthThrice };
    }

    public TestTask[] getTypicalRecurringDeadlineTasksForYears() {
        return new TestTask[] { recurTestYear, recurTestYearOnce, recurTestYearTwice, recurTestYearThrice };
    }

    public TestTask[] getTypicalTestEventsForBlockingTimeSlots() {
        return new TestTask[] { eventTestMon, eventTestTuesThurs, eventTestThurs, eventTestFriSat };
    }

    public TaskManager getTypicalTaskManager() {
        TaskManager tm = new TaskManager();
        loadTaskManagerWithSampleData(tm);
        return tm;
    }
}
```
