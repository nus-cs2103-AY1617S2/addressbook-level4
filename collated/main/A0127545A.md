# A0127545A
###### /java/seedu/toluist/commons/util/DateTimeFormatterUtil.java
``` java
    /**
     * Format recurring floating task
     */
    public static String formatRecurringFloatingTask(LocalDateTime recurringEndDateTime,
            RecurringFrequency recurringFrequency) {
        String formattedResult = StringUtil.EMPTY_STRING;
        switch (recurringFrequency) {
        case DAILY:
            formattedResult += String.join(StringUtil.SINGLE_SPACE, EVERY, DAY);
            break;
        case WEEKLY:
            formattedResult += String.join(StringUtil.SINGLE_SPACE, EVERY, WEEK);
            break;
        case MONTHLY:
            formattedResult += String.join(StringUtil.SINGLE_SPACE, EVERY, MONTH);
            break;
        case YEARLY:
            formattedResult += String.join(StringUtil.SINGLE_SPACE, EVERY, YEAR);
            break;
        default:
            // won't happen
        }
        if (recurringEndDateTime != null) {
            formattedResult += RECURRING_DATE_SEPARATOR
                    + String.join(StringUtil.SINGLE_SPACE, UNTIL, formatDate(recurringEndDateTime));
        }
        return formattedResult;
    }

    /**
     * Format recurring task with deadline
     */
    public static String formatRecurringTaskDeadline(LocalDateTime deadline, LocalDateTime recurringEndDateTime,
            RecurringFrequency recurringFrequency) {
        String formattedResult = StringUtil.EMPTY_STRING;
        switch (recurringFrequency) {
        case DAILY:
            formattedResult += String.join(StringUtil.SINGLE_SPACE, EVERY, formatTime(deadline), OF_THE, DAY);
            break;
        case WEEKLY:
            formattedResult += String.join(StringUtil.SINGLE_SPACE, EVERY, formatDayOfWeek(deadline), OF_THE, WEEK);
            break;
        case MONTHLY:
            formattedResult += String.join(StringUtil.SINGLE_SPACE, EVERY, formatDayOfMonth(deadline), OF_THE, MONTH);
            break;
        case YEARLY:
            formattedResult += String.join(StringUtil.SINGLE_SPACE, EVERY, formatDateOfYear(deadline), OF_THE, YEAR);
            break;
        default:
            // won't happen
        }
        if (recurringEndDateTime != null) {
            formattedResult += RECURRING_DATE_SEPARATOR
                    + String.join(StringUtil.SINGLE_SPACE, UNTIL, formatDate(recurringEndDateTime));
        }
        return formattedResult;
    }

    /**
     * Format recurring event
     */
    public static String formatRecurringEvent(LocalDateTime from, LocalDateTime to,
            LocalDateTime recurringEndDateTime, RecurringFrequency recurringFrequency) {
        String formattedResult = StringUtil.EMPTY_STRING;
        switch (recurringFrequency) {
        case DAILY:
            if (formatTime(from).equals(formatTime(to))) {
                formattedResult += String.join(StringUtil.SINGLE_SPACE, EVERY, formatTime(from), OF_THE, DAY);
            } else {
                formattedResult += String.join(StringUtil.SINGLE_SPACE, EVERY,
                        formatTime(from), TO, formatTime(to), OF_THE, DAY);
            }
            break;
        case WEEKLY:
            if (formatDayOfWeek(from).equals(formatDayOfWeek(to))) {
                formattedResult +=
                        String.join(StringUtil.SINGLE_SPACE, EVERY, formatDayOfWeek(from), OF_THE, WEEK);
            } else {
                formattedResult += String.join(StringUtil.SINGLE_SPACE, EVERY, formatDayOfWeek(from),
                                                       TO, formatDayOfWeek(to), OF_THE, WEEK);
            }
            break;
        case MONTHLY:
            if (formatDayOfMonth(from).equals(formatDayOfMonth(to))) {
                formattedResult += String.join(StringUtil.SINGLE_SPACE, EVERY, formatDayOfMonth(from),
                        OF_THE, MONTH);
            } else {
                formattedResult += String.join(StringUtil.SINGLE_SPACE, EVERY, formatDayOfMonth(from),
                                                       TO, formatDayOfMonth(to), OF_THE, MONTH);
            }
            break;
        case YEARLY:
            if (formatDateOfYear(from).equals(formatDateOfYear(to))) {
                formattedResult += String.join(StringUtil.SINGLE_SPACE, EVERY, formatDateOfYear(from),
                        OF_THE, YEAR);
            } else {
                formattedResult += String.join(StringUtil.SINGLE_SPACE, EVERY, formatDateOfYear(from),
                                                       TO, formatDateOfYear(to), OF_THE, YEAR);
            }
            break;
        default:
            // won't happen
        }
        if (recurringEndDateTime != null) {
            formattedResult += RECURRING_DATE_SEPARATOR + String.join(StringUtil.SINGLE_SPACE, UNTIL,
                    formatDate(recurringEndDateTime));
        }
        return formattedResult;
    }

    public static String formatDayOfWeek(LocalDateTime dateTime) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(FORMAT_DAY_OF_WEEK);
        return dateTime.format(formatter);
    }

    public static String formatDayOfMonth(LocalDateTime dateTime) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(FORMAT_DAY_OF_MONTH);
        String formattedDateTime = dateTime.format(formatter);
        return formattedDateTime + getDayNumberSuffix(Integer.valueOf(formattedDateTime));
    }

```
###### /java/seedu/toluist/commons/util/DateTimeFormatterUtil.java
``` java
    /**
     * Gets the suffix for a given day number
     * e.g.  3 -> rd
     *      12 -> th
     *      15 -> th
     *      21 -> st
     */
    public static String getDayNumberSuffix(int day) {
        if (day >= 11 && day <= 13) {
            return SUFFIX_FOURTH_ONWARDS;
        }
        switch (day % 10) {
        case 1:
            return SUFFIX_FIRST;
        case 2:
            return SUFFIX_SECOND;
        case 3:
            return SUFFIX_THIRD;
        default:
            return SUFFIX_FOURTH_ONWARDS;
        }
    }
}
```
###### /java/seedu/toluist/commons/util/DateTimeUtil.java
``` java
    /**
     * Given a date string, parse it using Natty (NLP library for dates) and return a LocalDateTime
     * @param stringDate
     * @return LocalDateTime of the first Date returned by Natty
     */
    public static LocalDateTime parseDateString(String stringDate) {
        if (stringDate == null) {
            return null;
        }
        Parser parser = new Parser();
        List<DateGroup> dateGroups = parser.parse(stringDate);
        if (dateGroups.isEmpty()) {
            return null;
        }
        DateGroup dateGroup = dateGroups.get(0);
        List<Date> dates = dateGroup.getDates();
        if (dates.isEmpty()) {
            return null;
        }
        Date date = dates.get(0);
        return LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());
    }

```
###### /java/seedu/toluist/commons/util/StringUtil.java
``` java
    /**
     * Returns true if string is not null and not empty
     * @param string
     */
    public static boolean isPresent(String string) {
        return string != null && !string.trim().isEmpty();
    }

```
###### /java/seedu/toluist/controller/AddTaskController.java
``` java
package seedu.toluist.controller;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;

import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.DateTimeUtil;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.controller.commons.TagParser;
import seedu.toluist.controller.commons.TaskTokenizer;
import seedu.toluist.model.Tag;
import seedu.toluist.model.Task;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.UiStore;
import seedu.toluist.ui.commons.CommandResult;
import seedu.toluist.ui.commons.ResultMessage;

/**
 * AddTaskController is responsible for adding a task (and event)
 */
public class AddTaskController extends Controller {
    private static final Logger logger = LogsCenter.getLogger(AddTaskController.class);

    private static final String COMMAND_TEMPLATE = "(?iu)^\\s*add"
            + "(\\s+(?<description>.+))?\\s*";

    private static final String COMMAND_ADD_TASK = "add";

    private static final String MESSAGE_RESULT_ERROR_EMPTY_DESCRIPTION =
            "Please provide a description.";
    private static final String MESSAGE_RESULT_ERROR_DUPLICATED_TASK =
            "Task provided already exist in the list.";
    private static final String MESSAGE_RESULT_ERROR_UNCLASSIFIED_TASK =
            "The task cannot be classified as a floating task, deadline, or event.";
    private static final String MESSAGE_RESULT_ERROR_EVENT_MUST_HAVE_START_AND_END_DATE =
            "An event must have both a start date (from/) and an end date (to/).";

```
###### /java/seedu/toluist/controller/AddTaskController.java
``` java
    public void execute(Map<String, String> tokens) throws InvalidCommandException {
        logger.info(getClass().getName() + " will handle command");

        TodoList todoList = TodoList.getInstance();
        UiStore uiStore = UiStore.getInstance();
        CommandResult commandResult;

        String description = tokens.get(TaskTokenizer.PARAMETER_TASK_DESCRIPTION);

        String eventStartDateToken = tokens.get(TaskTokenizer.KEYWORD_EVENT_START_DATE);
        LocalDateTime eventStartDateTime = DateTimeUtil.parseDateString(eventStartDateToken);

        String eventEndDateToken = tokens.get(TaskTokenizer.KEYWORD_EVENT_END_DATE);
        LocalDateTime eventEndDateTime = DateTimeUtil.parseDateString(eventEndDateToken);

        String taskDeadlineToken = tokens.get(TaskTokenizer.KEYWORD_TASK_DEADLINE);
        LocalDateTime taskDeadline = DateTimeUtil.parseDateString(taskDeadlineToken);

        String tagsToken = tokens.get(TaskTokenizer.KEYWORD_TASK_TAGS);
        Set<Tag> tags = TagParser.parseTags(tagsToken);

        String taskPriority = tokens.get(TaskTokenizer.KEYWORD_TASK_PRIORITY);

        String recurringFrequency = tokens.get(TaskTokenizer.KEYWORD_TASK_RECURRING_FREQUENCY);

        String recurringUntilEndDateToken = tokens.get(TaskTokenizer.KEYWORD_TASK_RECURRING_UNTIL_END_DATE);
        LocalDateTime recurringUntilEndDate = DateTimeUtil.parseDateString(recurringUntilEndDateToken);

        commandResult = add(todoList, description, eventStartDateTime, eventEndDateTime,
                taskDeadline, taskPriority, tags, recurringFrequency, recurringUntilEndDate);
        uiStore.setCommandResult(commandResult);
    }

    public Map<String, String> tokenize(String command) {
        return TaskTokenizer.tokenize(COMMAND_TEMPLATE, command, false, true);
    }

    private CommandResult add(TodoList todoList, String description,
            LocalDateTime eventStartDateTime, LocalDateTime eventEndDateTime,
            LocalDateTime taskDeadline, String taskPriority, Set<Tag> tags,
            String recurringFrequency, LocalDateTime recurringUntilEndDate) throws InvalidCommandException {
        try {
            validateTaskDescription(description);
            validateTaskDatesInput(eventStartDateTime, eventEndDateTime, taskDeadline);
            UiStore uiStore = UiStore.getInstance();
            Task task = createTask(description, eventStartDateTime, eventEndDateTime, taskDeadline);
            task = addPriorityToTask(task, taskPriority);
            task = addRecurringStatusToTask(task, recurringFrequency, recurringUntilEndDate);
            task = addTagsToTask(task, tags);

            validatesNoDuplicateTask(task, todoList);
            addTaskToTodoList(task, todoList);
            return new CommandResult(ResultMessage.getAddCommandResultMessage(task, uiStore));
        } catch (IllegalArgumentException illegalArgumentException) {
            throw new InvalidCommandException(illegalArgumentException.getMessage());
        }
    }

    /**
     * Checks whether the user input for description is present
     * @param description
     * @throws IllegalArgumentException when there is no description
     */
    private void validateTaskDescription(String description) throws IllegalArgumentException {
        if (!StringUtil.isPresent(description)) {
            throw new IllegalArgumentException(MESSAGE_RESULT_ERROR_EMPTY_DESCRIPTION);
        }
    }

    /**
     * Checks whether the user input for dates is valid (belongs to only one type of task)
     * @param eventStartDateTime
     * @param eventEndDateTime
     * @param taskDeadline
     * @throws IllegalArgumentException when the input for dates is invalid
     */
    private void validateTaskDatesInput(LocalDateTime eventStartDateTime, LocalDateTime eventEndDateTime,
            LocalDateTime taskDeadline) throws IllegalArgumentException {
        if (eventStartDateTime != null && eventEndDateTime != null) {
            if (taskDeadline != null) {
                throw new IllegalArgumentException(MESSAGE_RESULT_ERROR_UNCLASSIFIED_TASK);
            } // else it is a valid event
        } else if (eventStartDateTime != null || eventEndDateTime != null) {
            if (taskDeadline != null) {
                throw new IllegalArgumentException(MESSAGE_RESULT_ERROR_UNCLASSIFIED_TASK);
            } else {
                throw new IllegalArgumentException(MESSAGE_RESULT_ERROR_EVENT_MUST_HAVE_START_AND_END_DATE);
            }
        } // else it is a valid task (floating or deadline)
    }

    private Task createTask(String description, LocalDateTime eventStartDateTime,
            LocalDateTime eventEndDateTime, LocalDateTime taskDeadline) throws IllegalArgumentException {
        Task task = null;
        if (eventStartDateTime != null && eventEndDateTime != null) {
            task = new Task(description, eventStartDateTime, eventEndDateTime);
        } else if (taskDeadline != null) {
            task = new Task(description, taskDeadline);
        } else if (eventStartDateTime == null && eventEndDateTime == null && taskDeadline == null) {
            task = new Task(description);
        } else {
            // should not reach here since it will fail validation at the top
            throw new IllegalArgumentException(MESSAGE_RESULT_ERROR_UNCLASSIFIED_TASK);
        }
        return task;
    }

    private Task addPriorityToTask(Task task, String taskPriority) {
        if (taskPriority != null) {
            task.setTaskPriority(taskPriority);
        }
        return task;
    }

    private Task addRecurringStatusToTask(Task task,
            String recurringFrequency, LocalDateTime recurringUntilEndDate) {
        if (StringUtil.isPresent(recurringFrequency)) {
            if (recurringUntilEndDate == null) {
                task.setRecurring(recurringFrequency);
            } else {
                task.setRecurring(recurringUntilEndDate, recurringFrequency);
            }
        }
        return task;
    }

    private Task addTagsToTask(Task task, Set<Tag> tags) {
        task.replaceTags(tags);
        return task;
    }

    private void validatesNoDuplicateTask(Task task, TodoList todoList) throws IllegalArgumentException {
        if (todoList.getTasks().contains(task)) {
            throw new IllegalArgumentException(MESSAGE_RESULT_ERROR_DUPLICATED_TASK);
        }
    }

    private void addTaskToTodoList(Task task, TodoList todoList) throws IllegalArgumentException {
        UiStore uiStore = UiStore.getInstance();
        todoList.add(task);
        if (todoList.save()) {
            uiStore.setTasks(todoList.getTasks(), task);
        }
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public String[] getCommandWords() {
        return new String[] { COMMAND_ADD_TASK };
    }

    public Map<String, String[]> getCommandKeywordMap() {
        String[] keywords = new String[] {
            TaskTokenizer.KEYWORD_EVENT_END_DATE,
            TaskTokenizer.KEYWORD_EVENT_START_DATE,
            TaskTokenizer.KEYWORD_TASK_DEADLINE,
            TaskTokenizer.KEYWORD_TASK_PRIORITY,
            TaskTokenizer.KEYWORD_TASK_RECURRING_FREQUENCY,
            TaskTokenizer.KEYWORD_TASK_RECURRING_UNTIL_END_DATE,
            TaskTokenizer.KEYWORD_TASK_TAGS
        };
        HashMap<String, String[]> keywordMap = new HashMap<>();
        for (String keyword : keywords) {
            keywordMap.put(keyword, new String[0]);
        }
        keywordMap.put(TaskTokenizer.KEYWORD_TASK_PRIORITY,
                new String[] { Task.HIGH_PRIORITY_STRING, Task.LOW_PRIORITY_STRING });
        keywordMap.put(TaskTokenizer.KEYWORD_TASK_RECURRING_FREQUENCY,
                new String[] {
                    Task.RecurringFrequency.DAILY.name().toLowerCase(),
                    Task.RecurringFrequency.WEEKLY.name().toLowerCase(),
                    Task.RecurringFrequency.MONTHLY.name().toLowerCase(),
                    Task.RecurringFrequency.YEARLY.name().toLowerCase()
                });
        return keywordMap;
    }

    public String[][][] getConflictingKeywordsList() {
        return new String[][][] { new String[][] {
            new String[] { TaskTokenizer.KEYWORD_EVENT_START_DATE, TaskTokenizer.KEYWORD_EVENT_END_DATE },
            new String[] { TaskTokenizer.KEYWORD_TASK_DEADLINE }
        }};
    }

```
###### /java/seedu/toluist/controller/commons/IndexParser.java
``` java
package seedu.toluist.controller.commons;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import seedu.toluist.commons.util.StringUtil;

/**
 * Parse string of indexes into a list of integer index.
 */
public class IndexParser {
    private static final String HYPHEN = "-";
    private static final String COMMA = ",";

    /**
     * Split a string of unprocessed indexes into a list.
     * This function splits the list by comma (","), then parse each substring to get a list of index.
     * @return the list of unique indexes in sorted order (which is the union of all the parsed substring)
     */
    public static List<Integer> splitStringToIndexes(String indexToken, int maxIndex) {
        if (!StringUtil.isPresent(indexToken)) {
            return new ArrayList();
        }
        String[] splittedStringIndexes = indexToken.split(COMMA);
        Set<Integer> indexes = new TreeSet();
        for (String splittedStringIndex : splittedStringIndexes) {
            List<Integer> splittedIndexes = parseIndexes(splittedStringIndex, maxIndex);
            for (int splittedIndex : splittedIndexes) {
                indexes.add(splittedIndex);
            }
        }
        return new ArrayList<Integer>(indexes);
    }

    /**
     * Splits a string of indexes into a list.
     *   Examples:
     *   splitIndexes(" - 3",           8) -> [1, 2, 3]
     *   splitIndexes(" 3 -",           8) -> [3, 4, 5, 6, 7, 8]
     *   splitIndexes("3 4  5",         8) -> [3, 4, 5]
     *   splitIndexes("3 - 5",          8) -> [3, 4, 5]
     *   splitIndexes("- 3 5 7 - 12",   8) -> [1, 2, 3, 5, 7, 8]
     * This function is robust enough to handle excessive white spaces (" ").
     * @param stringIndexes, the unprocessed string of indexes from user's input
     * @param maxIndex, the maximum possible index number
     * @return a list of integer containing all valid indexes
     */
    private static List<Integer> parseIndexes(String stringIndexes, int maxIndex) {
        // Prepare stringIndexes in the correct format to be processed
        // Correct format example: ["2", "-", "5", "7", "11", "-", "13", "15"]
        String processedStringIndexes = stringIndexes.replaceAll(HYPHEN,
                StringUtil.SINGLE_SPACE + HYPHEN + StringUtil.SINGLE_SPACE);
        String[] splittedStringIndexes = processedStringIndexes.split(StringUtil.WHITE_SPACE);
        splittedStringIndexes = Arrays
                .stream(splittedStringIndexes)
                .filter(s -> !s.isEmpty())
                .toArray(String[]::new);

        // Process formatted stringIndexes
        List<Integer> indexes = new ArrayList();
        int i = 0;
        while (i < splittedStringIndexes.length) {
            String splittedStringIndex = splittedStringIndexes[i];
            if (!StringUtil.isPositiveInteger(splittedStringIndex) && !splittedStringIndex.equals(HYPHEN)) {
                // Invalid state, early termination
                return indexes;
            }
            if (StringUtil.isPositiveInteger(splittedStringIndex)) {
                int index = Integer.valueOf(splittedStringIndex);
                if (index > maxIndex) {
                    // Invalid state, early termination
                    return indexes;
                }
                indexes.add(Integer.valueOf(splittedStringIndex));
                i++;
            } else if (splittedStringIndex.equals(HYPHEN)) {
                // If stringIndexes starts with "-", the startIndex will be 0
                int startIndex = (indexes.isEmpty()) ? 0 : indexes.get(indexes.size() - 1);
                // If stringIndexes ends with "-", the endIndex will be maxIndex
                int endIndex = maxIndex;
                if (i + 1 > splittedStringIndexes.length
                    || (i + 1 < splittedStringIndexes.length
                    && !StringUtil.isPositiveInteger(splittedStringIndexes[i + 1]))) {
                    // Invalid state, early termination
                    return indexes;
                }
                // Valid states: Negation of the above if-statement, one of the following 2 cases must be true.
                // If (i + 1 == splittedStringIndexes.length) is true, let endIndex = maxIndex
                // If (next splittedStringIndex) is a positive integer, let endIndex = next splittedStringIndex.
                if (i + 1 < splittedStringIndexes.length) {
                    endIndex = Integer.valueOf(splittedStringIndexes[i + 1]);
                }
                for (int value = startIndex + 1; value <= Integer.min(endIndex, maxIndex); value++) {
                    indexes.add(value);
                }
                i += 2;
            }
        }
        return indexes;
    }

}
```
###### /java/seedu/toluist/controller/commons/KeywordTokenizer.java
``` java
package seedu.toluist.controller.commons;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;

import edu.emory.mathcs.backport.java.util.Collections;
import javafx.util.Pair;
import seedu.toluist.commons.util.StringUtil;

/**
 * Tokenize string of description by keywords
 */
public class KeywordTokenizer {
    public static final int INDEX_INVALID = -1;
    public static final int INDEX_START = 0;

    /**
     * Tokenize a string description into their respective keywords (by best effort matching)
     * @param description is the full text supplied by the user to be tokenized
     * @param defaultKeyword is for the rest of the text that did not get tokenized by any user-specified keywords
     * @param keywords is the list of keywords to find and to tokenize
     * @return a HashMap of keyword-token pairs
     */
    public static HashMap<String, String> tokenize(String description, String defaultKeyword, String... keywords) {
        HashMap<String, String> tokens = new HashMap<>();
        for (Pair<String, String> token : tokenizeInOrder(description, defaultKeyword, keywords)) {
            tokens.put(token.getKey(), token.getValue());
        }
        return tokens;
    }

    /**
     * Tokenize a string description into their respective keywords (by best effort matching)
     * @param description is the full text supplied by the user to be tokenized
     * @param defaultKeyword is for the rest of the text that did not get tokenized by any user-specified keywords
     * @param keywords is the list of keywords to find and to tokenize
     * @return a list of keyword-token pairs, in order of appearances
     */
    public static List<Pair<String, String>> tokenizeInOrder(String description, String defaultKeyword,
                                                             String... keywords) {
        List<Pair<String, String>> tokens = new ArrayList<>();
        if (!StringUtil.isPresent(description)) {
            // Early termination, no description means there is nothing to tokenize.
            return tokens;
        }
        String normalizedDescription = StringUtil.SINGLE_SPACE + description + StringUtil.SINGLE_SPACE;
        String normalizedDescriptionInLowerCase = normalizedDescription.toLowerCase();

        ArrayList<Pair<Integer, String>> indexKeywordPairs = new ArrayList<>();
        String[] nonNullKeywords = keywords == null ? new String[0] : keywords;
        if (defaultKeyword != null) {
            // Everything that is not matched (guaranteed to be at the left) will be tokenized to the default keyword
            indexKeywordPairs.add(new Pair<>(INDEX_START, defaultKeyword));
        }

        for (String keyword : nonNullKeywords) {
            int index = normalizedDescriptionInLowerCase
                    .lastIndexOf(StringUtil.SINGLE_SPACE + keyword + StringUtil.SINGLE_SPACE);

            if (index != INDEX_INVALID) {
                // Index in indexKeywordPairs refers to the index behind the last character of the keyword.
                Pair<Integer, String> indexKeywordPair = new Pair<>(index + keyword.length() + 1, keyword);
                indexKeywordPairs.add(indexKeywordPair);
            }
        }

        Collections.sort(indexKeywordPairs, Comparator.comparing(pair -> ((Pair<Integer, String>) pair).getKey()));


        for (int i = 0; i < indexKeywordPairs.size(); i++) {
            Pair<Integer, String> currentIndexKeywordPair = indexKeywordPairs.get(i);
            int startIndex = currentIndexKeywordPair.getKey();
            // Generally, we match the text to the index before the first character of the next keyword.
            // For last pair of currentIndexKeywordPair, we simply match the text to the end of the description.
            int endIndex = i + 1 < indexKeywordPairs.size()
                    ? indexKeywordPairs.get(i + 1).getKey() - indexKeywordPairs.get(i + 1).getValue().length()
                    : normalizedDescription.length();
            String keyword = currentIndexKeywordPair.getValue();
            String token = normalizedDescription.substring(startIndex, endIndex).trim();
            tokens.add(new Pair<>(keyword, token));
        }

        return tokens;
    }
}
```
###### /java/seedu/toluist/controller/commons/TagParser.java
``` java
package seedu.toluist.controller.commons;

import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.model.Tag;

/**
 * Parse string of tags into a set of tags.
 */
public class TagParser {
    private static final String SEPARATOR_REGEX_TAGS = StringUtil.SINGLE_SPACE;

    public static Set<Tag> parseTags(String tagsString) {
        String[] tagStrings = tagsString == null ? new String[] {} : tagsString.split(SEPARATOR_REGEX_TAGS);
        List<String> tagList = Arrays.asList(tagStrings);
        Set<Tag> tags = tagList
                .stream()
                .filter(tagString -> !tagString.isEmpty())
                .map(tagString -> new Tag(tagString))
                .collect(Collectors.toSet());
        return tags;
    }
}
```
###### /java/seedu/toluist/controller/commons/TaskTokenizer.java
``` java
package seedu.toluist.controller.commons;

import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Tokenize task into index, description, start date and/or end date.
 */
public class TaskTokenizer {
    public static final String TASK_VIEW_INDEX = "index";
    public static final String PARAMETER_TASK_DESCRIPTION = "description";
    public static final String KEYWORD_TASK_DEADLINE = "/by";
    public static final String KEYWORD_EVENT_START_DATE = "/from";
    public static final String KEYWORD_EVENT_END_DATE = "/to";
    public static final String KEYWORD_TASK_TAGS = "/tags";
    public static final String KEYWORD_TASK_FLOATING = "/floating";
    public static final String KEYWORD_TASK_PRIORITY = "/priority";
    public static final String KEYWORD_TASK_RECURRING_FREQUENCY = "/repeat";
    public static final String KEYWORD_TASK_RECURRING_UNTIL_END_DATE = "/repeatuntil";
    public static final String KEYWORD_TASK_STOP_RECURRING = "/stoprepeating";

    public static HashMap<String, String> tokenize(String commandTemplate, String commandArgs,
            boolean hasIndex, boolean hasDescription) {
        Pattern pattern = Pattern.compile(commandTemplate);
        Matcher matcher = pattern.matcher(commandArgs.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        if (hasIndex) {
            tokens.put(TASK_VIEW_INDEX, matcher.group(TASK_VIEW_INDEX));
        }
        if (hasDescription) {
            String description = matcher.group(PARAMETER_TASK_DESCRIPTION);
            HashMap<String, String> descriptionTokens = KeywordTokenizer.tokenize(
                    description,
                    PARAMETER_TASK_DESCRIPTION,
                    KEYWORD_EVENT_START_DATE,
                    KEYWORD_EVENT_END_DATE,
                    KEYWORD_TASK_DEADLINE,
                    KEYWORD_TASK_TAGS,
                    KEYWORD_TASK_FLOATING,
                    KEYWORD_TASK_PRIORITY,
                    KEYWORD_TASK_RECURRING_FREQUENCY,
                    KEYWORD_TASK_RECURRING_UNTIL_END_DATE,
                    KEYWORD_TASK_STOP_RECURRING);
            tokens.putAll(descriptionTokens);
        }
        return tokens;
    }
}
```
###### /java/seedu/toluist/controller/DeleteTaskController.java
``` java
package seedu.toluist.controller;

import java.util.List;
import java.util.Map;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.controller.commons.IndexParser;
import seedu.toluist.controller.commons.TaskTokenizer;
import seedu.toluist.model.Task;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.UiStore;
import seedu.toluist.ui.commons.CommandResult;

/**
 * DeleteTaskController is responsible for deleting a task
 */
public class DeleteTaskController extends Controller {

    private static final String COMMAND_TEMPLATE = "(?iu)^\\s*delete"
            + "(\\s+(?<index>.+))?\\s*";

    private static final String COMMAND_DELETE_TASK = "delete";

    private static final String MESSAGE_RESULT_DELETE_TASK = "Deleted %s: %s";
    private static final String MESSAGE_RESULT_ERROR_NO_VALID_INDEX_PROVIDED = "No valid index found.";

```
###### /java/seedu/toluist/controller/DeleteTaskController.java
``` java
    private static final Logger logger = LogsCenter.getLogger(DeleteTaskController.class);

    public void execute(Map<String, String> tokens) throws InvalidCommandException  {
        logger.info(getClass().getName() + " will handle command");

        TodoList todoList = TodoList.getInstance();
        UiStore uiStore = UiStore.getInstance();
        CommandResult commandResult;

        String indexToken = tokens.get(TaskTokenizer.TASK_VIEW_INDEX);
        List<Integer> indexes = IndexParser.splitStringToIndexes(indexToken, todoList.getTasks().size());
        try {
            validateIndexIsPresent(indexes);
        } catch (IllegalArgumentException illegalArgumentException) {
            throw new InvalidCommandException(illegalArgumentException.getMessage());
        }
        List<Task> tasks = uiStore.getShownTasks(indexes);
        commandResult = delete(todoList, tasks);

        if (todoList.save()) {
            uiStore.setTasks(todoList.getTasks());
        }

        uiStore.setCommandResult(commandResult);
    }

    public Map<String, String> tokenize(String command) {
        return TaskTokenizer.tokenize(COMMAND_TEMPLATE, command, true, false);
    }

    private void validateIndexIsPresent(List<Integer> indexes) throws IllegalArgumentException {
        if (indexes == null || indexes.isEmpty()) {
            throw new IllegalArgumentException(MESSAGE_RESULT_ERROR_NO_VALID_INDEX_PROVIDED);
        }
    }

    private CommandResult delete(TodoList todoList, List<Task> tasks) {
        List<String> messages = tasks.
                                stream().
                                map(task -> delete(todoList, task).
                                        getFeedbackToUser()).
                                collect(Collectors.toList());
        return new CommandResult(String.join("\n", messages));
    }

    private CommandResult delete(TodoList todoList, Task task) {
        if (task.canUpdateToNextRecurringTask()) {
            task.updateToNextRecurringTask();
        } else {
            todoList.remove(task);
        }
        String taskType = task.isEvent() ? "Event" : "Task";
        return new CommandResult(String.format(MESSAGE_RESULT_DELETE_TASK, taskType, task.getDescription()));
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public String[] getCommandWords() {
        return new String[] { COMMAND_DELETE_TASK };
    }

```
###### /java/seedu/toluist/controller/UpdateTaskController.java
``` java
package seedu.toluist.controller;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;

import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.DateTimeUtil;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.controller.commons.IndexParser;
import seedu.toluist.controller.commons.TagParser;
import seedu.toluist.controller.commons.TaskTokenizer;
import seedu.toluist.model.Tag;
import seedu.toluist.model.Task;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.UiStore;
import seedu.toluist.ui.commons.CommandResult;
import seedu.toluist.ui.commons.ResultMessage;

/**
 * UpdateTaskController is responsible for updating a task
 */
public class UpdateTaskController extends Controller {

    private static final String COMMAND_TEMPLATE = "(?iu)^\\s*update"
            + "(\\s+(?<index>\\d+))?"
            + "(\\s+(?<description>.+))?\\s*";

    private static final String COMMAND_UPDATE_TASK = "update";

    private static final int MAX_NUMBER_OF_TASK_TYPE = 1;

    private static final String MESSAGE_RESULT_ERROR_DUPLICATED_TASK =
            "Task provided already exist in the list.";
    private static final String MESSAGE_RESULT_ERROR_INVALID_INDEX =
            "No valid index found.";
    private static final String MESSAGE_RESULT_ERROR_UNCLASSIFIED_TASK =
            "The task cannot be classified as a floating task, deadline, or event.";
    private static final String MESSAGE_RESULT_ERROR_RECURRING_AND_STOP_RECURRING =
            "Input contains both recurring and stop recurring arguments at the same time.";
    private static final String MESSAGE_RESULT_ERROR_FLOATING_AND_NON_FLOATING =
            "Input contains both floating and non-floating task arguments at the same time.";
    private static final String MESSAGE_RESULT_ERROR_CLONING_ERROR =
            "Bad things happened and we have no idea why! Please contact the administrators.";

```
###### /java/seedu/toluist/controller/UpdateTaskController.java
``` java
    private static final Logger logger = LogsCenter.getLogger(UpdateTaskController.class);

    public void execute(Map<String, String> tokens) throws InvalidCommandException {
        logger.info(getClass().getName() + " will handle command");

        CommandResult commandResult;

        UiStore uiStore = UiStore.getInstance();
        String description = tokens.get(TaskTokenizer.PARAMETER_TASK_DESCRIPTION);

        String indexToken = tokens.get(TaskTokenizer.TASK_VIEW_INDEX);
        List<Integer> indexes = IndexParser.splitStringToIndexes(indexToken, uiStore.getShownTasks().size());
        if (indexes == null || indexes.isEmpty()) {
            throw new InvalidCommandException(MESSAGE_RESULT_ERROR_INVALID_INDEX);
        }
        List<Task> shownTasks = uiStore.getShownTasks(indexes);
        Task task = shownTasks.get(0);

        String eventStartDateToken = tokens.get(TaskTokenizer.KEYWORD_EVENT_START_DATE);
        LocalDateTime eventStartDateTime = DateTimeUtil.parseDateString(eventStartDateToken);

        String eventEndDateToken = tokens.get(TaskTokenizer.KEYWORD_EVENT_END_DATE);
        LocalDateTime eventEndDateTime = DateTimeUtil.parseDateString(eventEndDateToken);

        String taskDeadlineToken = tokens.get(TaskTokenizer.KEYWORD_TASK_DEADLINE);
        LocalDateTime taskDeadline = DateTimeUtil.parseDateString(taskDeadlineToken);

        boolean isFloating = tokens.containsKey(TaskTokenizer.KEYWORD_TASK_FLOATING);

        String taskPriority = tokens.get(TaskTokenizer.KEYWORD_TASK_PRIORITY);

        String tagsToken = tokens.get(TaskTokenizer.KEYWORD_TASK_TAGS);
        Set<Tag> tags = TagParser.parseTags(tagsToken);

        String recurringFrequency = tokens.get(TaskTokenizer.KEYWORD_TASK_RECURRING_FREQUENCY);

        String recurringUntilEndDateToken = tokens.get(TaskTokenizer.KEYWORD_TASK_RECURRING_UNTIL_END_DATE);
        LocalDateTime recurringUntilEndDate = DateTimeUtil.parseDateString(recurringUntilEndDateToken);

        boolean isStopRecurring = tokens.containsKey(TaskTokenizer.KEYWORD_TASK_STOP_RECURRING);

        commandResult = update(task, description, eventStartDateTime, eventEndDateTime,
                taskDeadline, isFloating, taskPriority, tags,
                recurringFrequency, recurringUntilEndDate, isStopRecurring);

        uiStore.setCommandResult(commandResult);
    }

    public Map<String, String> tokenize(String command) {
        return TaskTokenizer.tokenize(COMMAND_TEMPLATE, command, true, true);
    }

    private CommandResult update(Task task, String description,
            LocalDateTime eventStartDateTime, LocalDateTime eventEndDateTime, LocalDateTime taskDeadline,
            boolean isFloating, String taskPriority, Set<Tag> tags,
            String recurringFrequency, LocalDateTime recurringUntilEndDate, boolean isStopRecurring)
            throws InvalidCommandException {
        try {
            UiStore uiStore = UiStore.getInstance();
            validateTaskDatesInput(eventStartDateTime, eventEndDateTime, taskDeadline, isFloating);
            validateTaskRecurringStatusInput(recurringFrequency, recurringUntilEndDate, isStopRecurring);
            validateTaskFloatingStatusInput(eventStartDateTime, eventEndDateTime, taskDeadline, isFloating);

            Task taskCopy = (Task) task.clone();
            taskCopy = updateTaskDates(taskCopy, isFloating, eventStartDateTime, eventEndDateTime, taskDeadline);
            taskCopy = updateTaskDescription(taskCopy, description);
            taskCopy = updateTaskPriority(taskCopy, taskPriority);
            taskCopy = updateTaskRecurringFrequency(taskCopy, recurringFrequency);
            taskCopy = updateTaskRecurringUntilEndDate(taskCopy, recurringUntilEndDate);
            taskCopy = updateTaskTags(taskCopy, tags);
            taskCopy = updateTaskUnsetRecurringStatus(taskCopy, isStopRecurring);

            TodoList todoList = TodoList.getInstance();
            validatesNoDuplicateTask(taskCopy, todoList);

            // Update all changes in taskCopy to task
            Task oldTask = (Task) task.clone();
            task.setTask(taskCopy);

            updateTaskInTodoList(task, todoList);
            return new CommandResult(ResultMessage.getUpdateCommandResultMessage(oldTask, task, uiStore));
        } catch (IllegalArgumentException illegalArgumentException) {
            throw new InvalidCommandException(illegalArgumentException.getMessage());
        } catch (CloneNotSupportedException cloneNotSupportedException) {
            throw new InvalidCommandException(MESSAGE_RESULT_ERROR_CLONING_ERROR);
        }
    }

    /**
     * Checks whether the user input for dates is valid.
     * The input is valid if there is only one possible task type, or zero (task type is unchanged).
     * @param eventStartDateTime
     * @param eventEndDateTime
     * @param taskDeadline
     * @param isFloating
     * @throws IllegalArgumentException if there is more than 1 possible task type
     */
    private void validateTaskDatesInput(LocalDateTime eventStartDateTime, LocalDateTime eventEndDateTime,
            LocalDateTime taskDeadline, boolean isFloating) throws IllegalArgumentException {
        int numberOfTaskTypes = 0;
        // Can update event start date time OR end date time
        if (eventStartDateTime != null || eventEndDateTime != null) {
            numberOfTaskTypes++;
        }
        if (taskDeadline != null) {
            numberOfTaskTypes++;
        }
        if (isFloating) {
            numberOfTaskTypes++;
        }
        if (numberOfTaskTypes > MAX_NUMBER_OF_TASK_TYPE) {
            throw new IllegalArgumentException(MESSAGE_RESULT_ERROR_UNCLASSIFIED_TASK);
        }
    }

    /**
     * Check that there is no recurring task arguments together with non-recurring task arguments
     * @param recurringFrequency
     * @param recurringUntilEndDate
     * @param isStopRecurring
     * @throws IllegalArgumentException if both recurring and non-recurring task arguments are present
     */
    private void validateTaskRecurringStatusInput(String recurringFrequency, LocalDateTime recurringUntilEndDate,
            boolean isStopRecurring) throws IllegalArgumentException {
        if (isStopRecurring && (StringUtil.isPresent(recurringFrequency) || recurringUntilEndDate != null)) {
            throw new IllegalArgumentException(MESSAGE_RESULT_ERROR_RECURRING_AND_STOP_RECURRING);
        }
    }

    /**
     * Check that there is no floating task arguments together with non-floating task arguments
     * @param eventStartDateTime
     * @param eventEndDateTime
     * @param taskDeadline
     * @param isFloating
     * @throws IllegalArgumentException if both floating and non-floating task arguments are present
     */
    private void validateTaskFloatingStatusInput(LocalDateTime eventStartDateTime, LocalDateTime eventEndDateTime,
            LocalDateTime taskDeadline, boolean isFloating) throws IllegalArgumentException {
        if (isFloating && (eventStartDateTime != null || eventEndDateTime != null || taskDeadline != null)) {
            throw new IllegalArgumentException(MESSAGE_RESULT_ERROR_FLOATING_AND_NON_FLOATING);
        }
    }

    private Task updateTaskDates(Task task, boolean isFloating,
            LocalDateTime eventStartDateTime, LocalDateTime eventEndDateTime, LocalDateTime taskDeadline) {
        if (isFloating) {
            task.setStartDateTime(null);
            task.setEndDateTime(null);
        } else if (taskDeadline != null) {
            task.setStartDateTime(null);
            task.setEndDateTime(taskDeadline);
        } else {
            if (eventStartDateTime != null) {
                task.setStartDateTime(eventStartDateTime);
            }
            if (eventEndDateTime != null) {
                task.setEndDateTime(eventEndDateTime);
            }
        }
        return task;
    }

    private Task updateTaskDescription(Task task, String description) {
        if (StringUtil.isPresent(description)) {
            task.setDescription(description);
        }
        return task;
    }

    private Task updateTaskPriority(Task task, String taskPriority) {
        if (StringUtil.isPresent(taskPriority)) {
            task.setTaskPriority(taskPriority);
        }
        return task;
    }

    private Task updateTaskRecurringFrequency(Task task, String recurringFrequency) {
        if (StringUtil.isPresent(recurringFrequency)) {
            task.setRecurringFrequency(recurringFrequency);
        }
        return task;
    }

    private Task updateTaskRecurringUntilEndDate(Task task, LocalDateTime recurringUntilEndDate) {
        if (recurringUntilEndDate != null) {
            task.setRecurringEndDateTime(recurringUntilEndDate);
        }
        return task;
    }

    private Task updateTaskTags(Task task, Set<Tag> tags) {
        if (!tags.isEmpty()) {
            task.replaceTags(tags);
        }
        return task;
    }

    private Task updateTaskUnsetRecurringStatus(Task task, boolean isStopRecurring) {
        if (isStopRecurring) {
            task.unsetRecurring();
        }
        return task;
    }

    private void validatesNoDuplicateTask(Task task, TodoList todoList) throws IllegalArgumentException {
        if (todoList.getTasks().contains(task)) {
            throw new IllegalArgumentException(MESSAGE_RESULT_ERROR_DUPLICATED_TASK);
        }
    }

    private void updateTaskInTodoList(Task task, TodoList todoList) {
        UiStore uiStore = UiStore.getInstance();
        if (todoList.save()) {
            uiStore.setTasks(todoList.getTasks(), task);
        }
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public String[] getCommandWords() {
        return new String[] { COMMAND_UPDATE_TASK };
    }

    public Map<String, String[]> getCommandKeywordMap() {
        String[] keywords = new String[] {
            TaskTokenizer.KEYWORD_EVENT_END_DATE,
            TaskTokenizer.KEYWORD_EVENT_START_DATE,
            TaskTokenizer.KEYWORD_TASK_DEADLINE,
            TaskTokenizer.KEYWORD_TASK_PRIORITY,
            TaskTokenizer.KEYWORD_TASK_RECURRING_FREQUENCY,
            TaskTokenizer.KEYWORD_TASK_RECURRING_UNTIL_END_DATE,
            TaskTokenizer.KEYWORD_TASK_TAGS,
            TaskTokenizer.KEYWORD_TASK_STOP_RECURRING,
            TaskTokenizer.KEYWORD_TASK_FLOATING,
        };
        HashMap<String, String[]> keywordMap = new HashMap<>();
        for (String keyword : keywords) {
            keywordMap.put(keyword, new String[0]);
        }
        keywordMap.put(TaskTokenizer.KEYWORD_TASK_PRIORITY,
                new String[] { Task.HIGH_PRIORITY_STRING, Task.LOW_PRIORITY_STRING });
        keywordMap.put(TaskTokenizer.KEYWORD_TASK_RECURRING_FREQUENCY,
                new String[] {
                    Task.RecurringFrequency.DAILY.name(), Task.RecurringFrequency.WEEKLY.name(),
                    Task.RecurringFrequency.MONTHLY.name(), Task.RecurringFrequency.YEARLY.name()
                });
        return keywordMap;
    }

    public String[][][] getConflictingKeywordsList() {
        return new String[][][] {
            new String[][] {
                new String[] { TaskTokenizer.KEYWORD_EVENT_START_DATE, TaskTokenizer.KEYWORD_EVENT_END_DATE },
                new String[] { TaskTokenizer.KEYWORD_TASK_DEADLINE },
                new String[] { TaskTokenizer.KEYWORD_TASK_FLOATING }
            },
            new String[][] {
                new String[] {
                    TaskTokenizer.KEYWORD_TASK_RECURRING_FREQUENCY,
                    TaskTokenizer.KEYWORD_TASK_RECURRING_UNTIL_END_DATE
                },
                new String[] { TaskTokenizer.KEYWORD_TASK_STOP_RECURRING }
            }
        };
    }

```
###### /java/seedu/toluist/model/Task.java
``` java
    public Task(String description, LocalDateTime startDateTime, LocalDateTime endDateTime) {
        this.setDescription(description.trim());
        this.setStartDateTime(startDateTime);
        this.setEndDateTime(endDateTime);
        validate();
    }

    public void setTask(Task task) {
        allTags = task.allTags;
        description = task.description;
        startDateTime = task.startDateTime;
        endDateTime = task.endDateTime;
        completionDateTime = task.completionDateTime;
        recurringEndDateTime = task.recurringEndDateTime;
        recurringFrequency = task.recurringFrequency;
        priority = task.priority;
    }

    public void validate() {
        if (!validateDescriptionMustNotBeEmpty()) {
            throw new IllegalArgumentException(ERROR_VALIDATION_EMPTY_DESCRIPTION);
        }
        if (!validateStartDateMustBeBeforeEndDate()) {
            throw new IllegalArgumentException(ERROR_VALIDATION_START_DATE_AFTER_END_DATE);
        }
        if (!validateTaskIsFloatingIsEventOrHasDeadline()) {
            throw new IllegalArgumentException(ERROR_VALIDATION_UNCLASSIFIED_TASK);
        }
    }

    public boolean validateDescriptionMustNotBeEmpty() {
        return StringUtil.isPresent(description);
    }

    public boolean validateStartDateMustBeBeforeEndDate() {
        if (startDateTime != null && endDateTime != null) {
            return startDateTime.isBefore(endDateTime);
        }
        return true;
    }

    public boolean validateTaskIsFloatingIsEventOrHasDeadline() {
        return startDateTime == null || endDateTime != null;
    }

    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

    public TaskType getTaskType() {
        if (isEvent()) {
            return TaskType.EVENT;
        } else if (isTaskWithDeadline()) {
            return TaskType.DEADLINE;
        } else {
            return TaskType.TASK;
        }
    }

```
###### /java/seedu/toluist/model/Task.java
``` java
    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public LocalDateTime getEndDateTime() {
        return endDateTime;
    }

    public void setEndDateTime(LocalDateTime endDateTime) {
        this.endDateTime = endDateTime;
    }

    public LocalDateTime getStartDateTime() {
        return startDateTime;
    }

    public void setStartDateTime(LocalDateTime startDateTime) {
        this.startDateTime = startDateTime;
    }

```
###### /java/seedu/toluist/model/Task.java
``` java
    public LocalDateTime getRecurringEndDateTime() {
        return recurringEndDateTime;
    }

    public RecurringFrequency getRecurringFrequency() {
        return recurringFrequency;
    }

    public RecurringFrequency toRecurringFrequency(String recurringFrequencyString)
        throws IllegalArgumentException, NullPointerException {
        try {
            return RecurringFrequency.valueOf(recurringFrequencyString.toUpperCase());
        } catch (IllegalArgumentException | NullPointerException exception) {
            throw new IllegalArgumentException(ERROR_INVALID_RECURRING_FREQUENCY);
        }
    }

    public void setRecurringFrequency(String recurringFrequencyString) {
        setRecurringFrequency(toRecurringFrequency(recurringFrequencyString));
    }

    public void setRecurringFrequency(RecurringFrequency recurringFrequency) {
        if (isRecurring()) {
            this.recurringFrequency = recurringFrequency;
        } else {
            setRecurring(recurringFrequency);
        }
    }

    public void setRecurringEndDateTime(LocalDateTime recurringEndDateTime) throws IllegalArgumentException {
        if (isRecurring()) {
            this.recurringEndDateTime = recurringEndDateTime;
        } else {
            throw new IllegalArgumentException(ERROR_INVALID_RECURRING_END_DATE);
        }
    }

    public void setRecurring(String recurringFrequencyString) {
        setRecurring(toRecurringFrequency(recurringFrequencyString));
    }

    public void setRecurring(RecurringFrequency recurringFrequency) {
        setRecurring(null, recurringFrequency);
    }

    public void setRecurring(LocalDateTime recurringEndDateTime, String recurringFrequencyString) {
        setRecurring(recurringEndDateTime, toRecurringFrequency(recurringFrequencyString));
    }

    public void setRecurring(LocalDateTime recurringEndDateTime, RecurringFrequency recurringFrequency)
        throws IllegalArgumentException {
        if (recurringFrequency == null) {
            throw new IllegalArgumentException(ERROR_INVALID_RECURRING_FREQUENCY);
        }
        this.recurringEndDateTime = recurringEndDateTime;
        this.recurringFrequency = recurringFrequency;
    }

    public void unsetRecurring() {
        this.recurringEndDateTime = null;
        this.recurringFrequency = null;
    }

    public boolean canUpdateToNextRecurringTask() {
        if (!isRecurring()) {
            return false;
        }
        if (recurringEndDateTime == null) {
            return true;
        }
        if (endDateTime == null) {
            return LocalDateTime.now().isBefore(recurringEndDateTime);
        }
        return getNextRecurringDateTime(endDateTime).isBefore(recurringEndDateTime);
    }

    /**
     * For this recurring task, update to the next recurring task
     * Start date and end date will be updated (if they exist)
     */
    public void updateToNextRecurringTask() {
        assert isRecurring();
        if (isTaskWithDeadline()) {
            setStartDateTime(getNextRecurringDateTime(startDateTime));
            setEndDateTime(getNextRecurringDateTime(endDateTime));
        } else if (isEvent()) {
            long days = ChronoUnit.DAYS.between(endDateTime, getNextRecurringDateTime(endDateTime));
            setStartDateTime(startDateTime.plusDays(days));
            setEndDateTime(endDateTime.plusDays(days));
        }
        setCompleted(false);
    }

    public LocalDateTime getNextRecurringDateTime(LocalDateTime dateTime) {
        if (dateTime == null || this.recurringFrequency == null) {
            return null;
        }
        switch (recurringFrequency) {
        case DAILY:
            return dateTime.plusDays(1);
        case WEEKLY:
            return dateTime.plusWeeks(1);
        case MONTHLY:
            int numberOfMonths = 1;
            while (dateTime.plusMonths(numberOfMonths).getDayOfMonth() != dateTime.getDayOfMonth()) {
                numberOfMonths++;
            }
            return dateTime.plusMonths(numberOfMonths);
        case YEARLY:
            return dateTime.plusYears(1);
        default:
            return null;
        }
    }

```
###### /java/seedu/toluist/ui/view/TaskView.java
``` java
package seedu.toluist.ui.view;

import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.image.ImageView;
import javafx.scene.layout.FlowPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import seedu.toluist.commons.util.AppUtil;
import seedu.toluist.commons.util.DateTimeFormatterUtil;
import seedu.toluist.commons.util.FxViewUtil;
import seedu.toluist.model.Tag;
import seedu.toluist.model.Task;
import seedu.toluist.ui.UiStore;

/**
 * View to display task row
 */
public class TaskView extends UiView {

    private static final String FXML = "TaskView.fxml";
    private static final String IMAGE_PATH_CLOCK_ICON = "/images/clock.png";
    private static final String IMAGE_PATH_OVERDUE_ICON = "/images/warning.png";
    private static final String IMAGE_PATH_HIGH_PRIORITY_ICON = "/images/star.png";
    private static final String IMAGE_PATH_RECURRING_ICON = "/images/recurring_icon.png";
    private static final String STYLE_CLASS_COMPLETED = "completed";
    private static final String STYLE_CLASS_OVERDUE = "overdue";
    private static final String STYLE_CLASS_NEW = "new";
    private static final double STATUS_BOX_SPACING_VALUE = 10.0;

    @FXML
    private Pane taskPane;
    @FXML
    private FlowPane tagsPane;
    @FXML
    private Label name;
    @FXML
    private Label id;
    @FXML
    private Label date;
    @FXML
    private Label recurringDate;
    @FXML
    private HBox statusBox;
    @FXML
    private HBox dateBox;
    @FXML
    private HBox recurringBox;
    @FXML
    private ImageView clockIcon;
    @FXML
    private ImageView recurringIcon;

    private Task task;
    private int displayedIndex;


    public TaskView(Task task, int displayedIndex) {
        super(FXML);
        this.task = task;
        this.displayedIndex = displayedIndex;
    }

    @Override
    protected void viewDidMount() {
        initializeView();
        handleTaskType();
        handleTaskWithTags();
        handleOverdueTask();
        handleHighPriorityTask();
        handleTaskDescriptionAndId();
        handleTaskWithDates(task.isTaskWithDeadline() || task.isEvent());
        handleRecurringTask(task.isRecurring());
        handleCompletedTask();
        handleNewTask(task.equals(UiStore.getInstance().getLastEditedTask()));
        handleStatusBox(!statusBox.getChildren().isEmpty());
    }

    private void initializeView() {
        tagsPane.getChildren().clear();
        statusBox.getChildren().clear();
        statusBox.setSpacing(STATUS_BOX_SPACING_VALUE);
    }

    private void handleTaskType() {
        TaskTypeTagView taskTypeTagView = new TaskTypeTagView(task.isFloatingTask() || task.isTaskWithDeadline());
        taskTypeTagView.setParent(tagsPane);
        taskTypeTagView.render();
    }

    private void handleTaskWithTags() {
        for (Tag tag : task.getAllTags()) {
            renderTag(tag);
        }
    }

    private void renderTag(Tag tag) {
        TagView tagView = new TagView(tag.getTagName());
        tagView.setParent(tagsPane);
        tagView.render();
    }

    private void handleOverdueTask() {
        if (task.isOverdue()) {
            TaskStatusView statusView = new TaskStatusView(AppUtil.getImage(IMAGE_PATH_OVERDUE_ICON));
            statusView.setParent(statusBox);
            statusView.render();
            FxViewUtil.addStyleClass(taskPane, STYLE_CLASS_OVERDUE);
        }
    }

    private void handleHighPriorityTask() {
        if (task.isHighPriority()) {
            TaskStatusView highPriorityView = new TaskStatusView(AppUtil.getImage(IMAGE_PATH_HIGH_PRIORITY_ICON));
            highPriorityView.setParent(statusBox);
            highPriorityView.render();
        }
    }

    private void handleTaskDescriptionAndId() {
        name.setText(task.getDescription());
        id.setText(displayedIndex + ". ");
    }

    private void handleTaskWithDates(boolean isShown) {
        dateBox.setVisible(isShown);
        dateBox.setManaged(isShown);
        if (isShown) {
            clockIcon.setImage(AppUtil.getImage(IMAGE_PATH_CLOCK_ICON));
            if (task.isTaskWithDeadline()) {
                date.setText(DateTimeFormatterUtil.formatTaskDeadline(task.getEndDateTime()));
            } else if (task.isEvent()) {
                date.setText(DateTimeFormatterUtil.formatEventRange(task.getStartDateTime(), task.getEndDateTime()));
            }
        }
    }

    private void handleRecurringTask(boolean isShown) {
        recurringBox.setVisible(isShown);
        recurringBox.setManaged(isShown);
        if (isShown) {
            recurringIcon.setImage(AppUtil.getImage(IMAGE_PATH_RECURRING_ICON));
            if (task.isFloatingTask()) {
                recurringDate.setText(
                        DateTimeFormatterUtil.formatRecurringFloatingTask(
                        task.getRecurringEndDateTime(),
                        task.getRecurringFrequency()));
            } else if (task.isTaskWithDeadline()) {
                recurringDate.setText(
                        DateTimeFormatterUtil.formatRecurringTaskDeadline(
                        task.getEndDateTime(),
                        task.getRecurringEndDateTime(),
                        task.getRecurringFrequency()));
            } else if (task.isEvent()) {
                recurringDate.setText(
                        DateTimeFormatterUtil.formatRecurringEvent(
                        task.getStartDateTime(),
                        task.getEndDateTime(),
                        task.getRecurringEndDateTime(),
                        task.getRecurringFrequency()));
            }
        }
    }

    private void handleCompletedTask() {
        if (task.isCompleted()) {
            FxViewUtil.addStyleClass(taskPane, STYLE_CLASS_COMPLETED);
        }
    }

    private void handleNewTask(boolean isNew) {
        if (isNew) {
            FxViewUtil.addStyleClass(taskPane, STYLE_CLASS_NEW);
        }
    }

    private void handleStatusBox(boolean isShown) {
        statusBox.setVisible(isShown);
        statusBox.setManaged(isShown);
    }
}
```
###### /resources/view/TaskView.fxml
``` fxml

<?import java.lang.String?>
<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.FlowPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Font?>

<BorderPane fx:id="taskPane" styleClass="task" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <right>
      <HBox fx:id="statusBox" alignment="CENTER" BorderPane.alignment="CENTER" />
   </right>
   <center>
      <VBox alignment="CENTER_LEFT" BorderPane.alignment="CENTER">
         <stylesheets>
            <URL value="@../stylesheet/DefaultTheme.css" />
         </stylesheets>
         <children>
            <FlowPane fx:id="primaryTaskPane" alignment="CENTER_LEFT">
               <children>
                  <Label fx:id="id" styleClass="bold-text" text="Label">
                     <FlowPane.margin>
                        <Insets />
                     </FlowPane.margin>
                     <font>
                        <Font size="20.0" />
                     </font>
                  </Label>
                  <Label fx:id="name" styleClass="status-text" text="Label" wrapText="true">
                     <FlowPane.margin>
                        <Insets left="5.0" />
                     </FlowPane.margin>
                     <font>
                        <Font size="20.0" />
                     </font>
                  </Label>
                  <FlowPane fx:id="tagsPane" alignment="CENTER_LEFT" columnHalignment="CENTER" hgap="5.0" vgap="5.0">
                     <FlowPane.margin>
                        <Insets left="5.0" />
                     </FlowPane.margin>
                  </FlowPane>
               </children>
            </FlowPane>
            <HBox fx:id="dateBox" alignment="CENTER_LEFT">
               <children>
                  <ImageView fx:id="clockIcon" fitHeight="20.0" fitWidth="20.0" pickOnBounds="true" preserveRatio="true" />
                  <Label fx:id="date">
                     <font>
                        <Font size="15.0" />
                     </font>
                     <HBox.margin>
                        <Insets left="5.0" />
                     </HBox.margin>
                     <styleClass>
                        <String fx:value="status-text" />
                        <String fx:value="meta-text" />
                     </styleClass>
                  </Label>
               </children>
               <VBox.margin>
                  <Insets top="5.0" />
               </VBox.margin>
            </HBox>
            <HBox fx:id="recurringBox" alignment="CENTER_LEFT">
               <children>
                  <ImageView fx:id="recurringIcon" fitHeight="20.0" fitWidth="20.0" pickOnBounds="true" preserveRatio="true" />
                  <Label fx:id="recurringDate">
                     <font>
                        <Font size="15.0" />
                     </font>
                     <HBox.margin>
                        <Insets left="5.0" />
                     </HBox.margin>
                     <styleClass>
                        <String fx:value="status-text" />
                        <String fx:value="meta-text" />
                     </styleClass>
                  </Label>
                </children>
               <VBox.margin>
                  <Insets top="5.0" />
               </VBox.margin>
            </HBox>
         </children>
         <padding>
            <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
         </padding>
      </VBox>
   </center>
</BorderPane>
```
