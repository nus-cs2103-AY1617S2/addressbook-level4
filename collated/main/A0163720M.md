# A0163720M
###### /java/seedu/todolist/logic/commands/AddCommand.java
``` java
    /**
     * Creates an AddCommand using raw values to create a todo with start time and end time (event)
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String todo, String startTime, String endTime, Set<String> tags) throws IllegalValueException {
        try {
            // Parse through the set of tags
            final Set<Tag> tagSet = new HashSet<>();
            for (String tagName : tags) {
                tagSet.add(new Tag(tagName));
            }

            // Check for existence of each of the fields
            Name name = (todo != null) ? new Name(todo) : null;
            Date start = (startTime != null) ? StringUtil.parseDate(startTime, DATE_FORMAT) : null;
            Date end = (endTime != null) ? StringUtil.parseDate(endTime, DATE_FORMAT) : null;
            UniqueTagList tagList = new UniqueTagList(tagSet);

            // Todo(name, start_time, end_time, complete_time, taglist)
            this.toAdd = new Todo(name, start, end, null, tagList);
        } catch (IllegalValueException e) {
            throw e;
        }
    }
```
###### /java/seedu/todolist/logic/commands/AddCommand.java
``` java
    /**
     * Creates an AddCommand using raw values to create a todo with just the end time (deadline)
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String todo, String endTime, Set<String> tags) throws IllegalValueException {
        // Cannot throw an exception since there's only one line in the constructor
        // and the first line must be the call to the constructor, not try{}
        this(todo, null, endTime, tags);
    }
```
###### /java/seedu/todolist/logic/commands/AddCommand.java
``` java
    /**
     * Creates an AddCommand using raw values to create a floating task
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String todo, Set<String> tags) throws IllegalValueException {
        // Cannot throw an exception since there's only one line in the constructor and the first line cannot be try{}
        this(todo, null, null, tags);
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            model.addTodo(toAdd);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTodoList.DuplicateTodoException e) {
            throw new CommandException(MESSAGE_DUPLICATE_TODO);
        }
    }
}
```
###### /java/seedu/todolist/logic/commands/FindCommand.java
``` java
    @Override
    public CommandResult execute() {
        model.updateFilteredTodoList(keywords, startTime, endTime, completeTime, tags);
        return new CommandResult(getMessageForTodoListShownSummary(model.getFilteredTodoList().size()));
    }
```
###### /java/seedu/todolist/logic/commands/SaveFileCommand.java
``` java
package seedu.todolist.logic.commands;

import java.io.File;
import java.io.IOException;

import seedu.todolist.commons.core.Config;
import seedu.todolist.commons.core.Messages;
import seedu.todolist.commons.exceptions.DataConversionException;
import seedu.todolist.commons.util.ConfigUtil;
import seedu.todolist.logic.commands.exceptions.CommandException;
import seedu.todolist.storage.StorageManager;

public class SaveFileCommand extends Command {
    private String saveFilePath;
    public static final String MESSAGE_CONFIG_ERROR = "Error handling the config file.";
    public static final String MESSAGE_SUCCESS = "Save file updated!";
    public static final String COMMAND_WORD = "savefile";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Updates the save file location.\n"
            + "Parameters: PATH (must be a valid path string pointing to existing .xml file)\n" + "Example: "
            + COMMAND_WORD + " data/newtodolist.xml";

    public SaveFileCommand(String saveFilePath) {
        this.saveFilePath = saveFilePath;
    }

    @Override
    public CommandResult execute() throws CommandException {
        File f = new File(saveFilePath);

        if (!f.exists() || f.isDirectory()) {
            throw new CommandException(Messages.MESSAGE_FILE_NOT_FOUND);
        }

        try {
            // There should only be one instance of config each session - grab a
            // handle on that specific one
            Config config = ConfigUtil.readConfig(Config.DEFAULT_CONFIG_FILE).get();
            String todoListFilePath = config.getTodoListFilePath();
            String userPrefsFilePath = config.getUserPrefsFilePath();
            StorageManager storageManager = new StorageManager(todoListFilePath,  userPrefsFilePath);
            storageManager.updateSaveFilePath(saveFilePath);
            return new CommandResult(MESSAGE_SUCCESS);
        } catch (DataConversionException e) {
            // Catch for data conversion from Optional<Config> to Config
            throw new CommandException(MESSAGE_CONFIG_ERROR);
        } catch (IOException e) {
            throw new CommandException(Messages.MESSAGE_FILE_NOT_FOUND);
        }
    }
}
```
###### /java/seedu/todolist/logic/parser/AddCommandParser.java
``` java
    /**
     * Parses the given {@code String} of arguments in the context of the AddCommand
     * and returns an AddCommand object for execution.
     */
    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer(PREFIX_START_TIME, PREFIX_END_TIME, PREFIX_TAG);
        argsTokenizer.tokenize(args);
        try {
            Optional<String> startTime = argsTokenizer.getValue(PREFIX_START_TIME);
            Optional<String> endTime = argsTokenizer.getValue(PREFIX_END_TIME);

            if (startTime.isPresent() && endTime.isPresent()) {
                return new AddCommand (
                        argsTokenizer.getPreamble().get(),
                        startTime.get(),
                        endTime.get(),
                        ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG))
                );
            } else if (endTime.isPresent() && !startTime.isPresent()) {
                return new AddCommand(
                        argsTokenizer.getPreamble().get(),
                        endTime.get(),
                        ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG))
                );
            } else {
                return new AddCommand(
                        argsTokenizer.getPreamble().get(),
                        ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG))
                );
            }

        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
```
###### /java/seedu/todolist/logic/parser/FindCommandParser.java
``` java
    // Format used to parse Date with zero time
    private static final String NO_TIME_FORMAT = "dd/MM/yyyy";
    /**
     * Parses the given {@code String} of arguments in the context of the FindCommand
     * and returns an FindCommand object for execution.
     * @throws IllegalValueException
     */
    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer(PREFIX_START_TIME, PREFIX_END_TIME, PREFIX_TAG, PREFIX_COMPLETE_TIME);
        argsTokenizer.tokenize(args);
        // Fetch the keyword string before the prefix
        Optional<String> keywordsString = argsTokenizer.getPreamble();
        Optional<List<String>> tags = argsTokenizer.getAllValues(PREFIX_TAG);
        Optional<String> startTime = argsTokenizer.getValue(PREFIX_START_TIME);
        Optional<String> endTime = argsTokenizer.getValue(PREFIX_END_TIME);
        Optional<String> completeTime = argsTokenizer.getValue(PREFIX_COMPLETE_TIME);

        // User must enter either the search keyword or at least one parameter
        if (!(keywordsString.isPresent() || tags.isPresent() || startTime.isPresent()
            || endTime.isPresent() || completeTime.isPresent())) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }

        try {
            Set<String> keywordsSet = new HashSet<>();
            Date startTimeSet = null;
            Date endTimeSet = null;
            Object completeTimeSet = null;
            final Set<Tag> tagsSet = new HashSet<>();

            if (keywordsString.isPresent()) {
                final String[] keywords = keywordsString.get().split("\\s+");
                keywordsSet.addAll(Arrays.asList(keywords));
            }
            if (startTime.isPresent()) {
                startTimeSet = parseDateParameter(startTime.get());
            }
```
###### /java/seedu/todolist/logic/parser/SaveFileCommandParser.java
``` java
package seedu.todolist.logic.parser;

import static seedu.todolist.commons.core.Messages.MESSAGE_FILE_NOT_FOUND;

import java.io.File;
import java.text.ParseException;
import java.util.List;
import java.util.Optional;

import seedu.todolist.logic.commands.Command;
import seedu.todolist.logic.commands.IncorrectCommand;
import seedu.todolist.logic.commands.SaveFileCommand;
/**
 * Parses input arguments and creates a new SaveFileCommand object
 */
public class SaveFileCommandParser {
    /**
     * Parses the given {@code String} of arguments in the context of the SaveFileCommand
     * and returns a SaveFileCommand object for execution.
     * @throws ParseException
     */
    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer();
        argsTokenizer.tokenize(args);
        List<Optional<String>> preambleFields = ParserUtil.splitPreamble(argsTokenizer.getPreamble().orElse(null), 1);
        String saveFilePath = preambleFields.get(0).get();
        File saveFile = new File(saveFilePath);

        if (!saveFile.isFile()) {
            return new IncorrectCommand(String.format(MESSAGE_FILE_NOT_FOUND));
        }

        return new SaveFileCommand(saveFilePath);
    }
}
```
###### /java/seedu/todolist/model/ModelManager.java
``` java
    private class NameQualifier implements Qualifier {
        private Set<String> nameKeyWords;
        private Set<Tag> tags;
        private Set<String> tagKeyWords;
        private Date startTime;
        private Date endTime;
        private Object completeTime;

        NameQualifier(Set<String> nameKeyWords, Date startTime, Date endTime, Object completeTime, UniqueTagList tags) {
            this.nameKeyWords = nameKeyWords;
            this.startTime = startTime;
            this.endTime = endTime;
            this.completeTime = completeTime;
            this.tags = tags.toSet();

            // for simplicity sake, convert the Set<Tag> into Set<String> so that it can easily be filtered out
            // similar to filtering out by name
            this.tagKeyWords = new HashSet<String>();

            for (Tag tag:tags) {
                this.tagKeyWords.add(tag.tagName);
            }
        }
```
###### /java/seedu/todolist/model/ModelManager.java
``` java
        /**
         * Returns the tags or the name of the todo depending on which field is present
         */
        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            if (!nameKeyWords.isEmpty()) {
                sb.append("name=" + String.join(", ", nameKeyWords));
            }
            if (startTime != null) {
                sb.append("\nstart time=" + new SimpleDateFormat(DATE_FORMAT).format(startTime));
            }
            if (endTime != null) {
                sb.append("\nend time=" + new SimpleDateFormat(DATE_FORMAT).format(endTime));
            }
            if (completeTime != null) {
                if (completeTime instanceof Date) {
                    sb.append("\ncomplete time=" + new SimpleDateFormat(DATE_FORMAT).format(completeTime));
                } else {
                    sb.append("\ncomplete time=any");
                }
            }
            if (!tags.isEmpty()) {
                sb.append("\ntag=" + String.join(", ", tagKeyWords));
            }
            return sb.toString();
        }
```
###### /java/seedu/todolist/model/tag/UniqueTagList.java
``` java
    public boolean isEmpty() {
        return this.internalList.isEmpty();
    }
```
###### /java/seedu/todolist/model/todo/ReadOnlyTodo.java
``` java
    /**
     * Formats the todo as text, showing all todo details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();

        builder.append(getName());

        if (getStartTime() != null) {
            builder.append(" Start: ")
                .append(getStartTime());
        }

        if (getEndTime() != null) {
            builder.append(" End: ")
                .append(getEndTime());
        }

        if (getCompleteTime() != null) {
            builder.append(" Complete: ")
                .append(getCompleteTime());
        }

        builder.append(" Tags: ");
        builder.append(getTagsAsString());

        return builder.toString();
    }
```
###### /java/seedu/todolist/model/todo/ReadOnlyTodo.java
``` java
    /**
     *  Formats the todo's tags as a string
     */
    default String getTagsAsString() {
        final StringBuilder builder = new StringBuilder();

        for (Tag tag:getTags()) {
            builder.append(tag.tagName + " ");
        }

        return builder.toString();
    }
```
###### /java/seedu/todolist/storage/StorageManager.java
``` java
    /** Raises an event to indicate the save file path has changed */
    private void indicateSaveFilePathChanged(String saveFilePath) {
        raise(new SaveFilePathChangedEvent(saveFilePath));
    }
```
###### /java/seedu/todolist/storage/StorageManager.java
``` java
    public void updateSaveFilePath(String saveFilePath) throws DataConversionException, IOException {
        logger.fine("Attempting to update save file: " + saveFilePath);

        // There should only be one instance of config each session - grab a
        // handle on that specific one
        Config config = ConfigUtil.readConfig(Config.DEFAULT_CONFIG_FILE).get();
        config.setTodoListFilePath(saveFilePath);
        // Update config file in case it was missing to begin with or there
        // are new/unused fields
```
###### /java/seedu/todolist/storage/StorageManager.java
``` java
    @Override
    @Subscribe
    public void handleSaveFilePathChangedEvent(SaveFilePathChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Save file location changed"));
    }
```
###### /java/seedu/todolist/ui/StatusBarFooter.java
``` java
    @Subscribe
    public void handleSaveFileChangedEvent(SaveFilePathChangedEvent evt) {
        String lastUpdated = (new Date()).toString();
        setSaveLocation(evt.saveFilePath);
        logger.info(LogsCenter.getEventHandlingLogMessage(evt, "Setting last updated status to " + lastUpdated));
        setSyncStatus("Last Updated: " + lastUpdated);
    }
```
