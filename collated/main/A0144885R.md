# A0144885R
###### \java\seedu\address\commons\events\storage\StorageFileChangeEvent.java
``` java
package seedu.address.commons.events.storage;

import seedu.address.commons.events.BaseEvent;

/**
 * Indicates a request for App termination
 */
public class StorageFileChangeEvent extends BaseEvent {

    public String filePath;

    public StorageFileChangeEvent(String filePath) {
        this.filePath = filePath;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\seedu\address\commons\events\ui\ChangeViewRequestEvent.java
``` java
package seedu.address.commons.events.ui;

import java.util.List;

import seedu.address.commons.events.BaseEvent;

/**
 * Indicates a request to show one task group and hide the current ons.
 */
public class ChangeViewRequestEvent extends BaseEvent {

    public final List<String> viewGroups;

    public ChangeViewRequestEvent(List<String> viewGroups) {
        this.viewGroups = viewGroups;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\address\commons\events\ui\ShowTaskGroupEvent.java
``` java
package seedu.address.commons.events.ui;

import seedu.address.commons.events.BaseEvent;

/**
 * Indicates a request to show one task group and hide the current ons.
 */
public class ShowTaskGroupEvent extends BaseEvent {

    public final String title;

    public ShowTaskGroupEvent(String title) {
        this.title = title;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\address\commons\util\DateUtil.java
``` java
package seedu.address.commons.util;

import seedu.address.model.task.date.DateTime;
import seedu.address.model.task.date.DateValue;

/**
 * Helper functions for handling DateValue.
 */
public class DateUtil {

    /* Number of milliseconds in one day */
    public static final long ONE_DAY_IN_MILLISECONDS = 24 * 3600 * 1000;

    public static final long MONDAY = 1;
    public static final long SUNDAY = 0;

    /**
     * Returns DateValue object with date set to today.
     */
    public static DateValue getToday() {
        return (DateValue) new DateTime();
    }

    /**
     * Returns DateValue object with date set to tomorrow.
     */
    public static DateValue getTomorrow() {
        return getNextDay(getToday());
    }

    /**
     * Returns true if the two pairs of Dates intersecting
     *
     * @param firstBegin beginning Date of the first pair
     * @param firstEnd   ending Date of the first pair
     * @param secondBegin beginning Date of the first pair
     * @param secondEnd  ending Date of the first pair
     */
    public static boolean haveIntersection(DateValue firstBegin, DateValue firstEnd,
                                                DateValue secondBegin, DateValue secondEnd) {
        if (firstBegin.after(secondEnd) || secondBegin.after(firstEnd)) {
            return false;
        } else {
            return true;
        }
    }

    /**
     * Return the next day of given date.
     */
    public static DateValue getNextDay(DateValue date) {
        DateValue newDate = new DateTime(date);
        return newDate.setTime(newDate.getTime() + ONE_DAY_IN_MILLISECONDS);
    }

    /**
     * Return the previous day of given date.
     */
    public static DateValue getPreviousDay(DateValue date) {
        DateValue newDate = new DateTime(date);
        return newDate.setTime(newDate.getTime() - ONE_DAY_IN_MILLISECONDS);
    }

    /**
     * Returns the beginning of day at time 00:00:00.
     */
    public static DateValue getBeginOfDay(DateValue date) {
        DateValue newDate = new DateTime(date);
        return newDate.setHours(0).setMinutes(0).setSeconds(0);
    }

    /**
     * Returns the end of day at time 23:59:59.
     */
    public static DateValue getEndOfDay(DateValue date) {
        DateValue newDate = new DateTime(date);
        return newDate.setHours(23).setMinutes(59).setSeconds(59);
    }

    /**
     * Returns the beginning of week at time Monday, 00:00:00.
     */
    public static DateValue getBeginOfWeek(DateValue date) {
        DateValue newDate = new DateTime(date);
        while (newDate.getDay() != MONDAY) {
            newDate = getPreviousDay(newDate);
        }
        return getBeginOfDay(newDate);
    }

    /**
     * Returns the end of week at time Sunday, 23:59:59.
     */
    public static DateValue getEndOfWeek(DateValue date) {
        DateValue newDate = new DateTime(date);
        while (newDate.getDay() != SUNDAY) {
            newDate = getNextDay(newDate);
        }
        return getEndOfDay(newDate);
    }

}
```
###### \java\seedu\address\commons\util\StringUtil.java
``` java
    /**
     * Trims leading, trailing and continuous spaces in a string
     *
     * @param text cannot be null
     */
    public static String removeRedundantSpaces(String text) {
        assert text != null;
        return text.trim().replace(" +", " ");
    }
```
###### \java\seedu\address\logic\commands\SetStorageCommand.java
``` java
package seedu.address.logic.commands;

import java.io.File;
import java.io.IOException;
import java.nio.file.Paths;

import seedu.address.commons.core.EventsCenter;
import seedu.address.commons.events.storage.StorageFileChangeEvent;
import seedu.address.logic.commands.exceptions.CommandException;

/**
 * Selects a task identified using it's last displayed index from the address book.
 */
public class SetStorageCommand extends Command {

    public static final String COMMAND_WORD = "set-storage";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Set prefered storage file path.";

    public static final String MESSAGE_INVALID_FILE = "Invalid file/directory path";
    public static final String MESSAGE_SET_STORAGE_SUCCESS = "Storage file changed to %s";
    public static final String MESSAGE_ERROR_CREATE_FILE = "Invalid file/directory path";

    public static final String DEFAULT_FILENAME = "task_manager.xml";

    public String filePath;

    public SetStorageCommand(String filePath) {
        this.filePath = filePath.trim();
    }

    @Override
    public CommandResult execute() throws CommandException {

        File file = new File(filePath);
        System.out.println(filePath);

        if (!file.exists()) {
            throw new CommandException(MESSAGE_INVALID_FILE);
        }

        if (file.isDirectory()) {
            filePath = Paths.get(filePath, DEFAULT_FILENAME).toString();
            file = new File(filePath);
        }

        if (file.exists()) {
            EventsCenter.getInstance().post(new StorageFileChangeEvent(filePath));
        } else {
            try {
                file.createNewFile();
                EventsCenter.getInstance().post(new StorageFileChangeEvent(filePath));
            } catch (IOException e) {
                throw new CommandException(MESSAGE_ERROR_CREATE_FILE);
            }
        }
        return new CommandResult(String.format(MESSAGE_SET_STORAGE_SUCCESS, filePath));

    }

}
```
###### \java\seedu\address\logic\commands\ViewCommand.java
``` java
package seedu.address.logic.commands;

import java.util.ArrayList;

import seedu.address.commons.core.EventsCenter;

import seedu.address.commons.events.ui.ChangeViewRequestEvent;
import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.exceptions.CommandException;
import seedu.address.model.task.Status;

/**
 * Change the view of UI.
 */
public class ViewCommand extends Command {

    public static final String COMMAND_WORD = "view";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Change the view of UI."
        + "e.g. view [all|calendar|done|floating|overdue|today|tomorrow|future]";

    public static final String MESSAGE_SUCCESS = "View changed to %s";
    public static final String MESSAGE_ERROR = "Invalid input, allowed input: all|calendar|done|"
        + "floating|overdue|today|tomorrow|future";

    public static final String ALL = "All";
    public static final String CALENDAR = "Calendar";
    public static final String EMPTY = "";
    public static final int NOT_FOUND = -1;

    public static final String[] VIEW_GROUPS = {
        Status.DONE, Status.FLOATING, Status.OVERDUE, Status.TODAY, Status.TOMORROW, Status.FUTURE,
        ALL, CALENDAR
    };

    public final ArrayList<String> viewGroups;

    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public ViewCommand(String[] params) throws IllegalValueException {
        this.viewGroups = new ArrayList<String>();
        for (String param : params) {
            if (param.equals(EMPTY)) {
                continue;
            }
            int index = getIndex(param);
            if (index == NOT_FOUND) {
                throw new IllegalValueException(MESSAGE_ERROR);
            }
            this.viewGroups.add(VIEW_GROUPS[index]);
        }
    }

    int getIndex(String param) {
        int index = 0;
        for (String viewGroup : VIEW_GROUPS) {
            if (param.toLowerCase().equals(viewGroup.toLowerCase())) {
                return index;
            }
            index++;
        }
        return NOT_FOUND;
    }

    @Override
    public CommandResult execute() throws CommandException {
        model.updateFilteredListToShowAll();
        EventsCenter.getInstance().post(new ChangeViewRequestEvent(viewGroups));
        return new CommandResult(String.format(MESSAGE_SUCCESS, String.join("|", viewGroups)));
    }

}
```
###### \java\seedu\address\logic\parser\ViewCommandParser.java
``` java
package seedu.address.logic.parser;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.logic.commands.Command;
import seedu.address.logic.commands.IncorrectCommand;
import seedu.address.logic.commands.ViewCommand;

/**
 * Parses input arguments and creates a new ViewCommand object
 */
public class ViewCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the ViewCommand
     * and returns an ViewCommand object for execution.
     */
    public Command parse(String args) {

        try {
            return new ViewCommand(args.split("\\s+"));
        } catch (IllegalValueException e) {
            return new IncorrectCommand(e.getMessage());
        }
    }

}
```
###### \java\seedu\address\MainApp.java
``` java
    public void reload() {
        ui.stop();
        EventsCenter.clearSubscribers();

        storage = new StorageManager(config.getTaskManagerFilePath(), config.getUserPrefsFilePath());
        model = initModelManager(storage, userPrefs);
        logic = new LogicManager(model, storage);
        ui = new UiManager(logic, config, userPrefs);

        initEventsCenter();

        ui.start(new Stage());
    }
```
###### \java\seedu\address\MainApp.java
``` java
    @Subscribe
    public void handleStorageFileChangeEvent(StorageFileChangeEvent event) {
        logger.info("============================ [ Restarting Address Book ] =============================");

        config.setTaskManagerFilePath(event.filePath);
        saveConfig();
        reload();
    }
```
###### \java\seedu\address\model\ModelManager.java
``` java
package seedu.address.model;

import java.util.Set;
import java.util.logging.Logger;

import javafx.collections.transformation.FilteredList;
import seedu.address.commons.core.ComponentManager;
import seedu.address.commons.core.LogsCenter;
import seedu.address.commons.core.UnmodifiableObservableList;
import seedu.address.commons.events.model.TaskManagerChangedEvent;
import seedu.address.commons.util.CollectionUtil;
import seedu.address.commons.util.StringUtil;
import seedu.address.model.task.ReadOnlyTask;
import seedu.address.model.task.Task;
import seedu.address.model.task.TaskList.TaskNotFoundException;

/**
 * Represents the in-memory model of the address book data.
 * All changes to any model should be synchronized.
 */
public class ModelManager extends ComponentManager implements Model {
    private static final Logger logger = LogsCenter.getLogger(ModelManager.class);

    private final TaskManager taskManager;
    private final FilteredList<ReadOnlyTask> filteredTasks;
    private TaskManager taskManagerCopy;
    private String flag;

    /**
     * Initializes a ModelManager with the given taskManager and userPrefs.
     */
    public ModelManager(ReadOnlyTaskManager taskManager, UserPrefs userPrefs) {
        super();
        assert !CollectionUtil.isAnyNull(taskManager, userPrefs);

        logger.fine("Initializing with address book: " + taskManager + " and user prefs " + userPrefs);

        this.taskManager = new TaskManager(taskManager);
        filteredTasks = new FilteredList<>(this.taskManager.getTaskList());
        this.taskManagerCopy = new TaskManager(taskManager);
        this.flag = "empty copy";
    }

    public ModelManager() {
        this(new TaskManager(), new UserPrefs());
    }

    @Override
    public void resetData(ReadOnlyTaskManager newData) {
        taskManager.resetData(newData);
        indicateTaskManagerChanged();
    }

    @Override
    public ReadOnlyTaskManager getTaskManager() {
        return taskManager;
    }

    /** Raises an event to indicate the model has changed */
    private void indicateTaskManagerChanged() {
        raise(new TaskManagerChangedEvent(taskManager));
    }

    @Override
    public synchronized void deleteTask(ReadOnlyTask target) throws TaskNotFoundException {
        taskManager.removeTask(target);
        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void addTask(Task task) {
        taskManager.addTask(task);
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
    }

    @Override
    public void updateTask(int filteredTaskListIndex, ReadOnlyTask editedTask) {
        assert editedTask != null;

        int taskManagerIndex = filteredTasks.getSourceIndex(filteredTaskListIndex);
        taskManager.updateTask(taskManagerIndex, editedTask);
        indicateTaskManagerChanged();
    }
```
###### \java\seedu\address\model\ReadOnlyTaskManager.java
``` java
package seedu.address.model;

import javafx.collections.ObservableList;
import seedu.address.model.tag.Tag;
import seedu.address.model.task.ReadOnlyTask;

public interface ReadOnlyTaskManager {

    /**
     * Returns an unmodifiable view of the tasks list.
     */
    ObservableList<ReadOnlyTask> getTaskList();

    /**
     * Returns an unmodifiable view of the tags list.
     * This list will not contain any duplicate tags.
     */
    ObservableList<Tag> getTagList();

}
```
###### \java\seedu\address\model\task\date\DateFactory.java
``` java
package seedu.address.model.task.date;

import seedu.address.commons.exceptions.IllegalValueException;

/**
 * A factory class for producing TaskDate objects.
 */
public class DateFactory {

    public DateFactory() {}

    public TaskDate getTaskDateFromString(String dateString) throws IllegalValueException {

        try {
            return ((TaskDate) new TimePeriod(dateString));
        } catch (IllegalValueException e) {
            // Do nothing & continue with next case
        }

        return ((TaskDate) new TimePoint(dateString));
    }

    public TaskDate getUnassignedTime() {
        return (TaskDate) new TimeUnassigned();
    }
}

```
###### \java\seedu\address\model\task\date\DateOnly.java
``` java
package seedu.address.model.task.date;

import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * Represents a date with time.
 *
 * Date is default to be today
 */
public class DateOnly extends DateValue {

    public static final String MESSAGE_DATEONLY_CONSTRAINTS =
        "Allowed format for DateOnly obj: 20/2/2012";

    /**
    * Output format used to display deadline with both date and time.
    * Day, Month Date Year at Hour:Minute
    * Example: Tuesday, April 1 2013 at 23:59
    */
    public static final String READABLE_DATEONLY_OUTPUT_FORMAT = "EEE, MMM dd yyyy";

    public DateOnly() {
        super(new Date());
    }

    public DateOnly(Date date) {
        super(date);
    }

    public DateOnly(DateValue other) {
        super(other);
    }

    public DateOnly getBeginning() {
        Date date = new Date(getYear(), getMonth(), getDate(), 0, 0, 0);
        return new DateOnly(date);
    }

    public DateOnly getEnding() {
        Date date = new Date(getYear(), getMonth(), getDate(), 23, 59, 59);
        return new DateOnly(date);
    }

    @Override
    public boolean after(DateValue date) {
        return getBeginning().getValue().after(date.getValue());
    }

    @Override
    public boolean before(DateValue date) {
        return getEnding().getValue().before(date.getValue());
    }

    @Override
    public String toString() {
        return new SimpleDateFormat(READABLE_DATEONLY_OUTPUT_FORMAT).format(date);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof DateOnly // instanceof handles nulls
                    && this.date.equals(((DateOnly) other).date)); // state check
    }

    @Override
    public int hashCode() {
        return date.hashCode();
    }
}
```
###### \java\seedu\address\model\task\date\DateParser.java
``` java
package seedu.address.model.task.date;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

import seedu.address.commons.util.StringUtil;

/**
 * A Parser for TaskTime class.
 *
 * Strings will be converted to lowercase to make parsing easier
 * Default date will be today instead of 01/01/1970 as in Java implementation.
 */
public class DateParser {

    /* Preposition constants */
    public static final String FROM = "from";

    /* Regex constants */
    public static final String TIMEPERIOD_DELIMINATORS_REGEX = "(from|\\sto\\s)";

    public static final String[] DATE_NUMBERIC_REGEX = {
        "\\d{1,4}:\\d{1,2}:\\d{1,4}",
        "\\d{1,4}/\\d{1,2}/\\d{1,4}",
        "\\d{1,4}.\\d{1,2}.\\d{1,4}",
        "\\d{1,4}-\\d{1,2}-\\d{1,4}"
    };

    public static final String[] DATE_NUMBERIC_FORMATS = {
        "dd.MM.yy", "dd/MM/yy", "dd-MM-yy", "dd:MM:yy",
        "dd.MM.yyyy", "dd/MM/yyyy", "dd-MM-yyyy", "dd:MM:yyyy",
        "yyyy.MM.dd", "yyyy/MM/dd", "yyyy-MM-dd", "yyyy:MM:dd"
    };

    public static String convertDateStringToAmericanFormat(String dateString) {

        for (String regex : DATE_NUMBERIC_REGEX) {
            Pattern pattern = Pattern.compile(regex);
            Matcher matcher = pattern.matcher(dateString);

            // Only attempt once
            if (matcher.find()) {
                String matchedSubstr = matcher.group();

                // Converting
                for (String dateFormat : DATE_NUMBERIC_FORMATS) {
                    DateFormat df = new SimpleDateFormat(dateFormat);
                    df.setLenient(false);
                    try {
                        Date date = df.parse(matchedSubstr);
                        String convertedSubstr = (date.getMonth() + 1) + "/"   // Starting at 0
                                                    + date.getDate() + "/"
                                                    + (date.getYear() + 1900); // Years from 1900
                        return matcher.replaceFirst(convertedSubstr);
                    } catch (ParseException e) {
                        // Do nothing
                    }
                }
            }
        }

        // No conversion made
        return dateString;
    }


    /**
     * Parsers.
     */
    public static Optional<DateValue> parseString(String dateString) {
        // Natty only converts dates in American format.
        dateString = convertDateStringToAmericanFormat(dateString);

        Parser parser = new Parser();
        List<DateGroup> groups = parser.parse(dateString);

        // Accept no more than 1 result
        int count = 0;
        for (DateGroup group : groups) {
            count += group.getDates().size();
        }
        if (count > 1) {
            return Optional.ofNullable(null);
        }

        for (DateGroup group : groups) {
            List<Date> dates = group.getDates();
            for (Date date : dates) {
                if (group.isTimeInferred()) {
                    DateOnly result = new DateOnly(date);
                    return Optional.of((DateValue) result);
                } else {
                    DateTime result = new DateTime(date);
                    return Optional.of((DateValue) result);
                }
            }
        }
        return Optional.ofNullable(null);
    }


    public static Optional<DateValue> parseTimePointString(String dateString) {
        dateString = StringUtil.removeRedundantSpaces(dateString);
        dateString = dateString.toLowerCase();

        return parseString(dateString);
    }


    public static Optional<PairResult<DateValue, DateValue>> parseTimePeriodString(String dateString) {
        dateString = StringUtil.removeRedundantSpaces(dateString);
        dateString = dateString.toLowerCase();

        if (!dateString.startsWith(FROM)) {
            return Optional.ofNullable(null);
        }

        String[] texts = dateString.split(TIMEPERIOD_DELIMINATORS_REGEX);
        // DateString must be splitted into exactly 3 parts (empty, begin date and end date)
        if (texts.length != 3) {
            return Optional.ofNullable(null);
        }
        String beginDateString = texts[1];
        String endDateString = texts[2];

        Optional<DateValue> beginDate = parseTimePointString(beginDateString);
        Optional<DateValue> endDate = parseTimePointString(endDateString);

        if (beginDate.isPresent() && endDate.isPresent()) {
            return Optional.of(new PairResult<DateValue, DateValue>(beginDate.get(), endDate.get()));
        } else {
            return Optional.ofNullable(null);
        }
    }

    /**
     * A PairResult class for methods that return 2 objects as result.
     */
    public static class PairResult<T, S> {

        public T first;
        public S second;

        public PairResult(T first, S second) {
            this.first = first;
            this.second = second;
        }

        @Override
        public boolean equals(Object other) {
            return other == this // short circuit if same object
                || (other instanceof PairResult // instanceof handles nulls
                        && this.first.equals(((PairResult) other).first) // state check
                        && this.second.equals(((PairResult) other).second));
        }

        @Override
        public int hashCode() {
            return Objects.hash(first, second);
        }
    }

}
```
###### \java\seedu\address\model\task\date\DateTime.java
``` java
package seedu.address.model.task.date;

import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * Represents a date with time.
 *
 * Date is default to be today
 */
public class DateTime extends DateValue {

    public static final String MESSAGE_DATETIME_CONSTRAINTS =
        "Allowed format for DateTime obj: 20/2/2012 10:12 pm";

    /**
    * Output format used to display deadline with both date and time.
    * Day, Month Date Year at Hour:Minute
    * Example: Tuesday, April 1 2013 at 23:59
    */
    public static final String READABLE_DATETIME_OUTPUT_FORMAT = "EEE, MMM dd yyyy, hh:mm aaa";

    public DateTime() {
        super(new Date());
    }

    public DateTime(Date date) {
        super(date);
    }

    public DateTime(DateValue other) {
        super(other);
    }

    /**
     * Combine date and time from 2 DateValue objects with date taken from the first
     * and time taken from the second.
     */
    public DateTime(Date date, Date time) {
        super(new Date(date.getYear(), date.getMonth(), date.getDate(),
                                time.getHours(), time.getMinutes()));
    }

    public DateTime getBeginning() {
        return new DateTime(this.date);
    }

    public DateTime getEnding() {
        return new DateTime(this.date);
    }

    @Override
    public String toString() {
        return new SimpleDateFormat(READABLE_DATETIME_OUTPUT_FORMAT).format(date);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof DateTime // instanceof handles nulls
                    && this.date.equals(((DateTime) other).date)); // state check
    }

    @Override
    public int hashCode() {
        return date.hashCode();
    }
}
```
###### \java\seedu\address\model\task\date\DateValue.java
``` java
package seedu.address.model.task.date;

import java.util.Date;

/**
 * An interface represents date and time.
 */
public abstract class DateValue {

    protected final Date date;

    public DateValue() {
        this.date = new Date();
    }

    public DateValue(Date date) {
        this.date = new Date(date.getYear(), date.getMonth(), date.getDate(),
                                date.getHours(), date.getMinutes());
    }

    public DateValue(DateValue dateValue) {
        this(dateValue.getValue());
    }

    /* Getters */
    public Date getValue() {
        return date;
    }

    public int getYear() {
        return date.getYear();
    }

    public int getMonth() {
        return date.getMonth();
    }

    public int getDate() {
        return date.getDate();
    }

    public int getDay() {
        return date.getDay();
    }

    public int getHours() {
        return date.getHours();
    }

    public int getMinutes() {
        return date.getMinutes();
    }

    public int getSeconds() {
        return date.getSeconds();
    }

    public long getTime() {
        return date.getTime();
    }

    /* Setters */
    public DateValue setYear(int year) {
        this.date.setYear(year);
        return this;
    }

    public DateValue setMonth(int month) {
        this.date.setMonth(month);
        return this;
    }

    public DateValue setDate(int date) {
        this.date.setDate(date);
        return this;
    }

    public DateValue setHours(int hours) {
        this.date.setHours(hours);
        return this;
    }

    public DateValue setMinutes(int minutes) {
        this.date.setMinutes(minutes);
        return this;
    }

    public DateValue setSeconds(int seconds) {
        this.date.setSeconds(seconds);
        return this;
    }

    public DateValue setTime(long milliseconds) {
        this.date.setTime(milliseconds);
        return this;
    }

    public boolean after(DateValue date) {
        return this.date.after(date.getValue());
    }

    public boolean before(DateValue date) {
        return this.date.before(date.getValue());
    }

    public abstract DateValue getBeginning();
    public abstract DateValue getEnding();

    @Override
    public String toString() {
        return date.toString();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof DateValue // instanceof handles nulls
                    && this.date.equals(((DateValue) other).date)); // state check
    }

    @Override
    public int hashCode() {
        return date.hashCode();
    }
}
```
###### \java\seedu\address\model\task\date\TaskDate.java
``` java
package seedu.address.model.task.date;

/**
 * An interface represents date, time or a timeperiod.
 */
public interface TaskDate {

    /* Floating taskDate contains no value */
    public boolean isFloating();
    public boolean hasPassed();
    public boolean isHappeningToday();
    public boolean isHappeningTomorrow();
}
```
###### \java\seedu\address\model\task\date\TimePeriod.java
``` java
package seedu.address.model.task.date;

import java.util.Objects;
import java.util.Optional;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.commons.util.DateUtil;
import seedu.address.model.task.date.DateParser.PairResult;

/**
 * Represents a Time Period with beginning and ending dates.
 */
public class TimePeriod implements TaskDate {

    public static final String MESSAGE_TIMEPERIOD_CONSTRAINTS =
        "Allowed format for TimePeriod obj: from [Valid Date] to [Valid Date]";

    public static final String OUTPUT_FORMAT = "from %s to %s";

    private final DateValue beginDate;
    private final DateValue endDate;

    public TimePeriod(String dateString) throws IllegalValueException {
        Optional<PairResult<DateValue, DateValue>> parseResult = DateParser.parseTimePeriodString(dateString);
        if (!parseResult.isPresent()) {
            throw new IllegalValueException(MESSAGE_TIMEPERIOD_CONSTRAINTS);
        }
        beginDate = parseResult.get().first;
        endDate = parseResult.get().second;
        if (beginDate.after(endDate)) {
            throw new IllegalValueException(MESSAGE_TIMEPERIOD_CONSTRAINTS);
        }
    }

    /* Floating taskDate contains no value */
    public boolean isFloating() {
        return false;
    }

    public boolean hasPassed() {
        return endDate.before(DateUtil.getToday());
    }

    public boolean isHappeningToday() {
        DateValue today = DateUtil.getToday();
        return DateUtil.haveIntersection(beginDate.getBeginning(), endDate.getEnding(),
                                DateUtil.getBeginOfDay(today), DateUtil.getEndOfDay(today));
    }

    public boolean isHappeningTomorrow() {
        DateValue tmr = DateUtil.getTomorrow();
        return DateUtil.haveIntersection(beginDate.getBeginning(), endDate.getEnding(),
                                DateUtil.getBeginOfDay(tmr), DateUtil.getEndOfDay(tmr));
    }

    @Override
    public String toString() {
        return String.format(OUTPUT_FORMAT, beginDate.toString(), endDate.toString());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof TimePeriod // instanceof handles nulls
                    && this.beginDate.equals(((TimePeriod) other).beginDate) // state check
                    && this.endDate.equals(((TimePeriod) other).endDate));
    }

    @Override
    public int hashCode() {
        return Objects.hash(beginDate, endDate);
    }
}
```
###### \java\seedu\address\model\task\date\TimePoint.java
``` java
package seedu.address.model.task.date;

import java.util.Optional;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.commons.util.DateUtil;

/**
 * Represents a Time Period with beginning and ending dates.
 */
public class TimePoint implements TaskDate {

    public static final String MESSAGE_TIMEPOINT_CONSTRAINTS =
        "Allowed format for TimePoint obj: [preposition] [Valid Date]";

    public static final String OUTPUT_FORMAT = "%s";

    private final DateValue date;

    public TimePoint(String dateString) throws IllegalValueException {
        Optional<DateValue> parseResult = DateParser.parseTimePointString(dateString);
        if (!parseResult.isPresent()) {
            throw new IllegalValueException(MESSAGE_TIMEPOINT_CONSTRAINTS);
        }
        date = parseResult.get();
    }

    public boolean isFloating() {
        return false;
    }

    public boolean hasPassed() {
        return date.before(DateUtil.getToday());
    }

    public boolean isHappeningToday() {
        DateValue today = DateUtil.getToday();
        return DateUtil.haveIntersection(date.getBeginning(), date.getEnding(),
                                DateUtil.getBeginOfDay(today), DateUtil.getEndOfDay(today));
    }

    public boolean isHappeningTomorrow() {
        DateValue tmr = DateUtil.getTomorrow();
        return DateUtil.haveIntersection(date.getBeginning(), date.getEnding(),
                                DateUtil.getBeginOfDay(tmr), DateUtil.getEndOfDay(tmr));
    }

    @Override
    public String toString() {
        return String.format(OUTPUT_FORMAT, date.toString());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof TimePoint // instanceof handles nulls
                    && this.date.equals(((TimePoint) other).date)); // state check
    }

    @Override
    public int hashCode() {
        return date.hashCode();
    }
}
```
###### \java\seedu\address\model\task\date\TimeUnassigned.java
``` java
package seedu.address.model.task.date;

/**
 * Represents a Time Value that is unassigned by user.
 */
public class TimeUnassigned implements TaskDate {

    public final String MESSAGE_TIMEUNASSIGNED_CONSTRAINTS =
        "Leave deadline field empty for task with time unassigned";

    public final String MESSAGE_UNASSIGNED_DATE = "Unassigned";

    public TimeUnassigned() {}

    /**
     * For task with unassigned time, only isfloating is true
     */
    public boolean isFloating() {
        return true;
    }

    public boolean hasPassed() {
        return false;
    }

    public boolean isHappeningToday() {
        return false;
    }

    public boolean isHappeningTomorrow() {
        return false;
    }

    @Override
    public String toString() {
        return MESSAGE_UNASSIGNED_DATE;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof TimeUnassigned); // instanceof handles nulls
    }

    @Override
    public int hashCode() {
        return MESSAGE_UNASSIGNED_DATE.hashCode();
    }
}
```
###### \java\seedu\address\model\task\Deadline.java
``` java
package seedu.address.model.task;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.model.task.date.DateFactory;
import seedu.address.model.task.date.TaskDate;

/**
 * Represents a Task's deadline in the TaskManager.
 * Guarantees: immutable; is valid as declared in {@link #isValidDeadline(String)}
 */
public class Deadline {

    public static final String MESSAGE_DEADLINE_CONSTRAINTS =
        "Deadline accepts following formats: 30-10-2012 10:10 am; Sun, March 14 2017 23:59, ...\n"
        + "Please make sure valid existing date is used";


    public final TaskDate date;

    public Deadline() {
        DateFactory dateFactory = new DateFactory();
        date = dateFactory.getUnassignedTime();
    }

    /**
     * Constructor for Deadline.
     */
    public Deadline(String dateString) throws IllegalValueException {
        assert dateString != null;

        DateFactory dateFactory = new DateFactory();
        try {
            date = dateFactory.getTaskDateFromString(dateString);
        } catch (IllegalValueException e) {
            throw new IllegalValueException(MESSAGE_DEADLINE_CONSTRAINTS);
        }
    }

    public static boolean isValidDeadline(String dateString) {
        DateFactory dateFactory = new DateFactory();
        try {
            TaskDate date = dateFactory.getTaskDateFromString(dateString);
            return true;
        } catch (IllegalValueException e) {
            return false;
        }
    }

    public boolean isFloating() {
        return date.isFloating();
    }

    public boolean isOverdue() {
        return date.hasPassed();
    }

    public boolean isToday() {
        return date.isHappeningToday();
    }

    public boolean isTomorrow() {
        return date.isHappeningTomorrow();
    }

    @Override
    public String toString() {
        return date.toString();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof Deadline // instanceof handles nulls
                    && this.date.equals(((Deadline) other).date)); // state check
    }

    @Override
    public int hashCode() {
        return date.hashCode();
    }

}
```
###### \java\seedu\address\model\task\Description.java
``` java
package seedu.address.model.task;

/**
 * Represents a Task's description in the TaskManager.
 * Guarantees: immutable;
 */
public class Description {

    public final String DEFAULT_DESCRIPTION = "";

    public final String description;

    public Description() {
        this.description = DEFAULT_DESCRIPTION;
    }

    /**
     * Description just needs to be not null
     */
    public Description(String description) {
        assert description != null;
        this.description = description.trim();
    }


    @Override
    public String toString() {
        return description;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Description // instanceof handles nulls
                && this.description.equals(((Description) other).description)); // state check
    }

    @Override
    public int hashCode() {
        return description.hashCode();
    }

}
```
###### \java\seedu\address\model\task\Name.java
``` java
package seedu.address.model.task;

import seedu.address.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's name in the TaskManager.
 * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}
 */
public class Name {

    public static final String MESSAGE_NAME_CONSTRAINTS =
            "Task names should only contain alphanumeric characters and spaces, and it should not be blank";

    /*
     * The first character of the address must not be a whitespace,
     * otherwise " " (a blank string) becomes a valid input.
     */
    public static final String NAME_VALIDATION_REGEX = "[\\p{Alnum}][\\p{Alnum} ]*";

    public final String name;

    /**
     * Validates given name.
     *
     * @throws IllegalValueException if given name string is invalid.
     */
    public Name(String name) throws IllegalValueException {
        assert name != null;
        String trimmedName = name.trim();
        if (!isValidName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
        }
        this.name = trimmedName;
    }

    /**
     * Returns true if a given string is a valid person name.
     */
    public static boolean isValidName(String test) {
        return test.matches(NAME_VALIDATION_REGEX);
    }


    @Override
    public String toString() {
        return name;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Name // instanceof handles nulls
                && this.name.equals(((Name) other).name)); // state check
    }

    @Override
    public int hashCode() {
        return name.hashCode();
    }

}
```
###### \java\seedu\address\model\task\ReadOnlyTask.java
``` java
package seedu.address.model.task;

import seedu.address.model.tag.UniqueTagList;

/**
 * A read-only immutable interface for a Task in the addressbook.
 */
public interface ReadOnlyTask {

    Name getName();
    Deadline getDeadline();
    Description getDescription();
    UniqueTagList getTags();
    Status getStatus();

    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getName().equals(this.getName()) // state checks here onwards
                && other.getDeadline().equals(this.getDeadline())
                && other.getDescription().equals(this.getDescription())
                && other.getTags().equals(this.getTags())
                && other.getStatus().equals(this.getStatus()));
    }

    /**
     * Formats the task as text, showing all contact details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(" Name: ")
                .append(getName())
                .append(" Deadline: ")
                .append(getDeadline())
                .append(" Description: ")
                .append(getDescription())
                .append(" Status: ")
                .append(getStatus());
        return builder.toString();
    }

}
```
###### \java\seedu\address\model\task\Status.java
``` java
package seedu.address.model.task;

import seedu.address.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's status in the TaskManager.
 * Guarantees: immutable; is valid as declared in {@link #isValidStatus(String)}
 * Task status can be one of the following values:
 *      + Done
 *      + Floating
 *      + Overdue
 *      + Today
 *      + Tomorrow
 *      + This Week
 *      + future
 *  ** Status should not be used when comparing tasks as it is volatile and changes
 *  depending on current time **
 */
public class Status {

    public static final String MESSAGE_STATUS_CONSTRAINTS =
        "User can only set task status as Undone or Done";

    /*
     * The first character of the address must not be a whitespace,
     * otherwise " " (a blank string) becomes a valid input.
     */
    public static final String[] ALLOWED_STATUS_VALUES = {
        "Done", "Undone", "Floating", "Overdue",
        "Today", "Tomorrow", "Future"
    };

    /* Status values string contants */
    public static final String DONE = "Done";
    public static final String UNDONE = "Undone";
    public static final String FLOATING = "Floating";
    public static final String OVERDUE = "Overdue";
    public static final String TODAY = "Today";
    public static final String TOMORROW = "Tomorrow";
    public static final String FUTURE = "Future";

    public final String status;

    public Status() {
        status = UNDONE;
    }

    /**
     * Validates given status.
     *
     * @throws IllegalValueException if given status string is invalid.
     */
    public Status(String status) throws IllegalValueException {
        assert status != null;
        for (String statusString : ALLOWED_STATUS_VALUES) {
            // Compare insensitively
            if (statusString.toLowerCase().equals(status.toLowerCase())) {
                this.status = status;
                return;
            }
        }
        throw new IllegalValueException(MESSAGE_STATUS_CONSTRAINTS);
    }

    /**
     * Returns true if a given string is a valid task status.
     */
    public static boolean isValidStatus(String status) {
        for (String statusString : ALLOWED_STATUS_VALUES) {
            // Compare insensitively
            if (statusString.toLowerCase().equals(status.toLowerCase())) {
                return true;
            }
        }
        return false;
    }

    @Override
    public String toString() {
        return status;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Status // instanceof handles nulls
                && this.status.equals(((Status) other).status)); // state check
    }

    @Override
    public int hashCode() {
        return status.hashCode();
    }

}
```
###### \java\seedu\address\model\task\Task.java
``` java
package seedu.address.model.task;

import java.util.Objects;

import seedu.address.commons.exceptions.IllegalValueException;
import seedu.address.commons.util.CollectionUtil;
import seedu.address.model.tag.Tag;
import seedu.address.model.tag.UniqueTagList;

/**
 * Represents a Task in Task Manager.
 *
 * Status should be updated everytime task's deadline changes
 */
public class Task implements ReadOnlyTask {

    private static final String DEFAULT_DESCRIPTION = "No description";
    private static final IdentificationNumber DEFAULT_ID = IdentificationNumber.ZERO;

    //private IdentificationNumber ID;
    private Name name;
    private Description description;
    private Deadline deadline;
    private Status status;

    private UniqueTagList tags;

    /**
     * Name is required and must not be null
     */
    public Task(Name name, Object... params) {
        assert !CollectionUtil.isAnyNull(name);

        this.name = name;
        this.deadline = new Deadline();
        this.description = new Description(DEFAULT_DESCRIPTION);
        this.tags = new UniqueTagList();

        // Call update status immediately after creation
        this.status = new Status();

        // Optional parameters
        // ID tends to be set after Task creation,
        // so it is also included in optional params
        for (Object param : params) {
            if (param instanceof Description) {
                this.description = (Description) param;

            } else if (param instanceof Deadline) {
                this.deadline = (Deadline) param;

            } else if (param instanceof Status) {
                this.status = (Status) param;

            } else if (param instanceof UniqueTagList) {
                this.tags.mergeFrom((UniqueTagList) param);

            } else if (param instanceof Tag) {
                this.tags.add((Tag) param);
            }
        }
    }

    /**
     * Creates a copy of the given ReadOnlyTask.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getDeadline(), source.getDescription(), source.getStatus(), source.getTags());
    }

    public Task(Name name2, Description description2, Deadline deadline2,
        UniqueTagList uniqueTagList) {
        // TODO Auto-generated constructor stub
    }

    /**
     * Getters and setters
     */

    /*
    public Task setID(IdentificationNumber ID) {
        this.ID = ID;
        return this;
    }

    @Override
    public IdentificationNumber getID() {
        return ID;
    }

    public boolean isIDUnassigned() {
        return ID.equals(DEFAULT_ID);
    }
    */

    public Task setName(Name name) {
        assert name != null;
        this.name = name;
        return this;
    }

    @Override
    public Name getName() {
        return name;
    }

    public Task setDeadline(Deadline deadline) {
        assert deadline != null;
        this.deadline = deadline;
        // Status value depends on Deadline value and should be updated here
        updateStatus();
        return this;
    }

    @Override
    public Deadline getDeadline() {
        return deadline;
    }

    public Task setDescription(Description description) {
        if (description == null) {
            this.description = new Description(DEFAULT_DESCRIPTION);
        } else {
            this.description = description;
        }
        return this;
    }

    @Override
    public Description getDescription() {
        return description;
    }

    /**
     * Replaces this task's tags with the tags in the argument tag list.
     */
    public Task setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
        return this;
    }

    @Override
    public UniqueTagList getTags() {
        return new UniqueTagList(tags);
    }

    /**
     * Updates this task with the details of {@code replacement}.
     */
    public Task resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        this.setName(replacement.getName());
        this.setDeadline(replacement.getDeadline());
        this.setDescription(replacement.getDescription());
        this.setStatus(replacement.getStatus());
        this.setTags(replacement.getTags());
        return this;
    }

    @Override
    public Status getStatus() {
        return updateStatus();
    }

    public Task setStatus(Status status) {
        this.status = status;
        updateStatus();
        return this;
    }

    public Status updateStatus() {
        String currentStatus = status.toString();
        if (currentStatus.equals(Status.DONE)) {
            // No change
            return status;
        } else {
            // Update status base on Deadline and current time
            try {
                if (deadline.isFloating()) {
                    return status = new Status(Status.FLOATING);

                } else if (deadline.isOverdue()) {
                    return status = new Status(Status.OVERDUE);

                } else if (deadline.isToday()) {
                    return status = new Status(Status.TODAY);

                } else if (deadline.isTomorrow()) {
                    return status = new Status(Status.TOMORROW);

                } else {
                    return status = new Status(Status.FUTURE);
                }
            } catch (IllegalValueException e) {
                // Impossible
                return status;
            }
        }
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name, deadline, description);
    }

    @Override
    public String toString() {
        return getAsText();
    }

}
```
###### \java\seedu\address\ui\CommandBox.java
``` java
    @FXML
    private void handleKeyReleased(KeyEvent event) {
        switch (event.getCode()) {

        case UP:
        case KP_UP:
            moveUpHistoryStack();
            break;

        case DOWN:
        case KP_DOWN:
            moveDownHistoryStack();
            break;

        case ENTER:
            handleInputEntered();
            break;

        default:
            break;
        }
    }

    private void moveUpHistoryStack() {
        historyIndex = Math.max(historyIndex - 1, 0);
        String text = history.get(historyIndex);
        commandTextField.setText(text);
        commandTextField.end();
        logger.info("Key UP pressed: text changed to " + text);
    }

    private void moveDownHistoryStack() {
        historyIndex = Math.min(historyIndex + 1, history.size() - 1);
        String text = history.get(historyIndex);
        commandTextField.setText(text);
        commandTextField.end();
        logger.info("Key DOWN pressed: text changed to " + text);
    }

    private void handleInputEntered() {
        // Update history
        history.set(history.size() - 1, commandTextField.getText());

        try {
            CommandResult commandResult = logic.execute(commandTextField.getText());
            history.add(EMPTY_STRING);
            historyIndex = history.size() - 1;

            // process result of the command
            setStyleToIndicateCommandSuccess();
            commandTextField.clear();
            logger.info("Result: " + commandResult.feedbackToUser);
            raise(new NewResultAvailableEvent(commandResult.feedbackToUser));

        } catch (CommandException e) {
            // handle command failure
            historyIndex = history.size() - 1;
            setStyleToIndicateCommandFailure();
            logger.info("Invalid command: " + commandTextField.getText());
            raise(new NewResultAvailableEvent(e.getMessage()));
        }
    }
```
###### \resources\view\DarkTheme.css
``` css
@font-face {
	font-family: 'Open Sans';
	src: url('OpenSans-Regular.ttf');
}

@font-face {
	font-family: 'Open Sans Light';
	src: url('OpenSans-Light.ttf');
}

@font-face {
	font-family: 'Open Sans Semibold';
	src: url('OpenSans-Semibold.ttf');
}

#taskListPanelPlaceholder {
	-fx-background-image: url("../images/astronaut.png");
	-fx-background-repeat: stretch;
	-fx-background-position: bottom right;
}

.scroll-pane {
	-fx-border-width: 0 0 0 0;
}

.titled-pane {
	-fx-text-fill: #e74c3c;
	-fx-font-family: "Open Sans";
	-fx-font-size: 17px;
}

.titled-pane > .title {
	-fx-background-color: white;
	-fx-background-insets: 0, 1, 2;
	-fx-border-color: #e74c3c;
	-fx-border-width: 0 0 1 0;
}

.titled-pane > .title > .arrow-button .arrow {
	-fx-background-color: white;
	-fx-border-color: #e74c3c;
	-fx-border-width: 1 1 1 1;
	-fx-background-insets: 1 0 -1 0, 0;
	-fx-padding: 0.25em 0.3125em 0.25em 0.3125em; /* 3 3.75 3 3.75 */
	-fx-shape: "M 0 0 h 4 l -2 2 z";
	-fx-effect: null;
}

.titled-pane:collapsed > .title > .arrow-button .arrow {
	-fx-background-color: white;
	-fx-border-color: #e74c3c;
	-fx-border-width: 1 1 1 1;
	-fx-background-insets: 1 0 -1 0, 0;
	-fx-padding: 0.25em 0.3125em 0.25em 0.3125em; /* 3 3.75 3 3.75 */
	-fx-shape: "M 0 0 h 4 l -2 2 z";
	-fx-effect: null;
}

.titled-pane:collapsed > .title {
	-fx-border-color: white;
	-fx-border-width: 0 0 1 0;
}

.titled-pane > *.content {
	-fx-background-color: white;
	-fx-border-width: 0 0 0 0;
	-fx-font-family: "Open Sans";
	-fx-effect: null;
}

.background {
    -fx-background-color: derive(#1d1d1d, 20%);
}

.command-box-holder {
    -fx-background-color: #34495E;
}

.content-holder {
	-fx-background-color: #F8F9FA;
}

.result-display .content {
	-fx-background-color: white;
}

.result-display {
	-fx-background-color: white, white;
	-fx-font-family: "Open Sans";
	-fx-line-spacing: 1em;
}

.result-display:focused .content {
	-fx-background-color: white;
}

#commandTextField {
    -fx-background-color: #34495E;
	-fx-text-fill: #ecf0f1;
	-fx-font-family: "Open Sans";
	-fx-font-size: 17px;
}
```
