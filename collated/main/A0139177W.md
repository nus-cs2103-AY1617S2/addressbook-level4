# A0139177W
###### \java\seedu\ezdo\commons\core\Messages.java
``` java
    public static final String MESSAGE_RECUR_FAILURE = "Both the start and due dates cannot be empty "
            + "with a recur status present.";
```
###### \java\seedu\ezdo\commons\util\MultipleIndexCommandUtil.java
``` java
    /** checks if the tasks with the indexes specified are marked as done */
    public static boolean isDone(UnmodifiableObservableList<ReadOnlyTask> lastShownList,
            ArrayList<Integer> targetIndexes) {
        for (int i = 0; i < targetIndexes.size(); i++) {
            int taskIndex = targetIndexes.get(i) - 1;
            Task task = (Task) lastShownList.get(taskIndex);
            if (task.getDone()) {
                return false;
            }
        }
        return true;
    }
```
###### \java\seedu\ezdo\commons\util\RecurUtil.java
``` java
/**
 * Utility method for Recur
 */
public class RecurUtil {

    /**
     * Checks if a recurring status is valid with at least a start date and/or
     * due date present in a task. Floating tasks should not have a recurring
     * status.
     * @param task
     * @return false if the task is a floating task
     * @return true otherwise
     */
    public static boolean isRecurValid(ReadOnlyTask task) {
        assert task != null;
        String taskStartDate = task.getStartDate().toString();
        String taskDueDate = task.getDueDate().toString();

        final boolean isStartDateMissing = taskStartDate.isEmpty();
        final boolean isDueDateMissing = taskDueDate.isEmpty();
        final boolean isBothDatesMissing = isStartDateMissing && isDueDateMissing;

        final boolean recurStatus = task.getRecur().isRecur();
        final boolean recurValid = !(isBothDatesMissing && recurStatus);

        return recurValid;
    }

}
```
###### \java\seedu\ezdo\logic\commands\SelectCommand.java
``` java
/**
 * Selects a task identified using its last displayed index from ezDo.
 */
public class SelectCommand extends Command {

    public static final String COMMAND_WORD = "select";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Selects the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n" + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_SELECT_TASK_SUCCESS = "Selected Task: %1$s";
    private final ArrayList<Integer> targetIndexes;
    private final ArrayList<Task> tasksToToggle = new ArrayList<Task>();


    /**
     * Creates an arraylist of targetIndexes based on the total indexes quantity.
     * @param indexes
     */
    public SelectCommand(ArrayList<Integer> indexes) {
        this.targetIndexes = new ArrayList<Integer>(indexes);
    }

    /**
     * Executes the Select command.
     */
    @Override
    public CommandResult execute() throws CommandException {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        checkValidIndexes(lastShownList);
        checkTasksDone(lastShownList);

        MultipleIndexCommandUtil.addTasksToList(tasksToToggle, lastShownList, targetIndexes);
        model.toggleTasksSelect(tasksToToggle);

        scrollToFinalTask();

        return new CommandResult(String.format(MESSAGE_SELECT_TASK_SUCCESS, targetIndexes));

    }

    /** Scroll to the last task which was updated. **/
    private void scrollToFinalTask() {
        int offset = 1;
        int lastIndex = targetIndexes.size() - offset;
        int lastElementInTargetIndexes = targetIndexes.get(lastIndex);

        JumpToListRequestEvent scrollToTask = new JumpToListRequestEvent(lastElementInTargetIndexes - offset);
        EventsCenter.getInstance().post(scrollToTask);
    }

    /** checks if the tasks with the indexes specified are marked as done */
    private void checkTasksDone(UnmodifiableObservableList<ReadOnlyTask> lastShownList) throws CommandException {
        if (!MultipleIndexCommandUtil.isDone(lastShownList, targetIndexes)) {
            throw new CommandException(Messages.MESSAGE_TASK_DONE);
        }
    }

    /** checks if the indexes specified are all smaller than the size of the list and not 0 i.e. valid */
    private void checkValidIndexes(UnmodifiableObservableList<ReadOnlyTask> lastShownList) throws CommandException {
        if (!MultipleIndexCommandUtil.isIndexValid(lastShownList, targetIndexes)) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
    }

}
```
###### \java\seedu\ezdo\logic\parser\DateParser.java
``` java
    /**
     * Uses Natty dependency (natural language date parser) to manipulate date
     * input in String.
     * @throws IndexOutOfBoundsException when taskDate cannot be manipulated because
     * taskDate is optional or taskDate is not a valid NLP command.
     */
    private String nattyManipulation(String taskDate) {
        try {
            // Initialises Natty parser
            Parser parser = new Parser();

            // Parses input String into a list of DateGroups
            List<DateGroup> dateGroupList = parser.parse(taskDate);

            // Retrieves parsed date
            Date parsedDate = retrieveParsedDate(dateGroupList);

            // Format parsed date to suit the UI
            return USER_OUTPUT_DATE_FORMAT.format(parsedDate);

        } catch (IndexOutOfBoundsException e) {
            return taskDate;
        }
    }

    /**
     * Returns the parsed date from dateGroupList
     * @param dateGroupList  A list of DateGroup which contains a list of Dates.
     * @return parsedDate    The parsed date.
     */
    private Date retrieveParsedDate(List<DateGroup> dateGroupList) {
        int firstElement = 0;
        DateGroup parsedDateGroup = dateGroupList.get(firstElement);
        List<Date> parsedDateList = parsedDateGroup.getDates();
        Date parsedDate = parsedDateList.get(firstElement);
        return parsedDate;
    }
```
###### \java\seedu\ezdo\logic\parser\ParserUtil.java
``` java
    /**
     * Parses a {@code Optional<String> recur} into an {@code Optional<Recur>} if {@code recur} is present.
     */
    public static Optional<Recur> parseRecur(Optional<String> recur) throws IllegalValueException {
        assert recur != null;
        return recur.isPresent() ? Optional.of(new Recur(recur.get())) : Optional.empty();
    }
```
###### \java\seedu\ezdo\model\EzDo.java
``` java
    /**
     * Toggles the tasks select status in {@code p}.
     */
    public void toggleTasksSelect(ArrayList<Task> p) {
        for (int i = 0; i < p.size(); i++) {
            Task task = p.get(i);
            task.toggleStart();
        }
    }

    /**
     * Removes recurring status of the completed task.
     * Set the completed task as done.
     */
    private void moveCurrentTaskToDone(Task task) {
        String optionalRecur = "";
        try {
            task.setRecur(new Recur(optionalRecur));
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }
        task.toggleDone();
    }

    /**
     * Updates the start and due dates according to the recurring status.
     * Do nothing if there is no recurring status.
     * @param task    Task to have its start and due dates updated.
     * @throws IllegalValueException    The date is optional and cannot be parsed
     *                                  as Date object.
     */
    private void updateRecurringDates(Task task) {

        if (task.getRecur().isRecur()) {
            try {
                String recurIntervalInString = task.getRecur().toString().trim();
                int recurringInterval = Recur.RECUR_INTERVALS.get(recurIntervalInString);

                // Update start date
                String startDateInString = task.getStartDate().value;
                String startDate = updateDate(recurringInterval, startDateInString);

                // Update due date
                String dueDateInString = task.getDueDate().value;
                String dueDate = updateDate(recurringInterval, dueDateInString);

                // Add updated task to UniqueTaskList.
                tasks.add(new Task(task.getName(), task.getPriority(), new StartDate(startDate),
                        new DueDate(dueDate), task.getRecur(), task.getTags()));

            } catch (IllegalValueException ive) {
                ive.printStackTrace();
            }
        }
    }

    /**
     * Updates a given date according to the recurring status (type).
     * Do nothing if there is no recurring status.
     * @param type              The recurring status.
     * @param originalDate      The date to be updated.
     * @throws ParseException   The date is optional and cannot be parsed as Date object.
     */
    private String updateDate(int type, String originalDate) {
        try {
            int recurIntervalIncrement = 1;

            // get current date and time.
            Calendar c = Calendar.getInstance();

            // set given date and time.
            c.setTime(DateParser.USER_OUTPUT_DATE_FORMAT.parse(originalDate));

            // update date according to recurring status.
            c.add(type, recurIntervalIncrement);

            // Format the date according to user's input.
            String updatedDate = DateParser.USER_OUTPUT_DATE_FORMAT.format(c.getTime());

            return updatedDate;

        } catch (ParseException pe) {
            pe.printStackTrace();
        }
        return originalDate;
    }
```
###### \java\seedu\ezdo\model\ModelManager.java
``` java
    /**
     * Toggles the select status of the tasks in {@code toggleSelect}
     */
    @Override
    public boolean toggleTasksSelect(ArrayList<Task> tasksToToggle) {
        int firstElement = 0;
        ezDo.toggleTasksSelect(tasksToToggle);
        final boolean isSetToSelect = tasksToToggle.get(firstElement).getStarted();
        updateFilteredListToShowAll();
        ezDo.sortTasks(currentSortCriteria, currentIsSortedAscending);
        indicateEzDoChanged();
        return isSetToSelect;
    }
```
###### \java\seedu\ezdo\model\ModelManager.java
``` java
    /**
     * Throws a RecurException if a floating task is found with a recurring status.
     * @param   readOnlyTask
     * @throws  RecurException  A floating task is found with recurring status.
     */
    public void checkRecur(ReadOnlyTask readOnlyTask) throws RecurException {
        String recurErrorMessage = "To set a recur status, both start and due dates cannot be empty.";
        assert readOnlyTask != null;
        if (!RecurUtil.isRecurValid(readOnlyTask)) {
            throw new RecurException(recurErrorMessage);
        }
    }
}
```
###### \java\seedu\ezdo\model\todo\DueDate.java
``` java
/**
 * Represents the due date of a task.
 */
public class DueDate extends TaskDate {

    public static final String MESSAGE_DUEDATE_CONSTRAINTS =
            "Due dates should at least be in the format DD/MM/YYYY HH:MM (24 hours)";


    /**
     * Validates given due date.
     * @param dueDate   The due date of a task.
     * @throws IllegalValueException if given due date string is invalid.
     */
    public DueDate(String dueDate) throws IllegalValueException {
        super(dueDate);
        if (!isValidTaskDate(this.value)) {
            throw new IllegalValueException(MESSAGE_DUEDATE_CONSTRAINTS);
        }
    }

```
###### \java\seedu\ezdo\model\todo\Recur.java
``` java
/**
 * Represents a Task's recurring interval in ezDo. Guarantees: immutable; is
 * valid as declared in {@link #isValidRecurring(String)}
 */
public class Recur {

    public static final String MESSAGE_RECUR_CONSTRAINTS =
            "Recurring time interval should be 'daily', 'weekly', 'monthly' or 'yearly'.";

    public static final String INTERVAL_NONE = "";

    public static final HashMap<String, Integer> RECUR_INTERVALS = new HashMap<>();

    public final String value;

    /**
     * Adds a recurring time interval.
     * @param recur  The recur interval.
     * @throws IllegalValueException
     *             if given recurring time interval string is invalid.
     */
    public Recur(String recur) throws IllegalValueException {
        assert recur != null;
        initialiseRecurIntervals();  // initialises HashMap with respective intervals
        String trimmedRecur = recur.trim();
        checkIsValidRecur(trimmedRecur);
        this.value = trimmedRecur;
    }

    /**
     * Validates given recurring time interval.
     * @param recur     The recur interval.
     * @throws IllegalValueException
     *             if given recurring time interval string is invalid.
     */
    private void checkIsValidRecur(String recur) throws IllegalValueException {
        if (!isValidRecur(recur)) {
            throw new IllegalValueException(MESSAGE_RECUR_CONSTRAINTS);
        }
    }

    /**
     * Initialises recur intervals in RECUR_INTERVALS HashMap.
     */
    private void initialiseRecurIntervals() {

        String intervalDaily = "daily";
        String intervalWeekly = "weekly";
        String intervalMonthly = "monthly";
        String intervalYearly = "yearly";

        RECUR_INTERVALS.put(INTERVAL_NONE, Calendar.DATE);
        RECUR_INTERVALS.put(intervalDaily, Calendar.DAY_OF_MONTH);
        RECUR_INTERVALS.put(intervalWeekly, Calendar.WEEK_OF_MONTH);
        RECUR_INTERVALS.put(intervalMonthly, Calendar.MONTH);
        RECUR_INTERVALS.put(intervalYearly, Calendar.YEAR);
    }

    /**
     * Returns true if a given string is a valid recurring time interval.
     */
    public static boolean isValidRecur(String test) {
        return RECUR_INTERVALS.containsKey(test);
    }

    /**
     * Checks if a recurring interval is attached in a task.
     */
    public boolean isRecur() {
        return !value.equals(INTERVAL_NONE);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Recur // instanceof handles nulls
                        && this.value.equals(((Recur) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### \java\seedu\ezdo\model\util\SampleDataUtil.java
``` java
/**
 * Provides the sample data for the application.
 */
public class SampleDataUtil {

    private static final String MESSAGE_DUPLICATE_TASKS = "Sample data cannot contain duplicate tasks";
    private static final String MESSAGE_INVALID_SAMPLE_DATA = "Sample data cannot be invalid";

    public static Task[] getSampleTasks() {
        try {
            return new Task[] {
                new Task(new Name("Buy one cherry fruit"),
                    new Priority("1"),
                    new StartDate("12/12/2017 12:34"),
                    new DueDate("12/13/2018 20:00"),
                    new Recur("daily"), new UniqueTagList("groceries")),
                new Task(new Name("Study for two midterms"),
                    new Priority("2"),
                    new StartDate("12/12/2017 09:00"),
                    new DueDate("12/09/2018 21:30"),
                    new Recur(""),
                    new UniqueTagList("school", "exams")),
                new Task(new Name("Buy ps three"),
                    new Priority("3"),
                    new StartDate("12/12/2017"),
                    new DueDate("12/10/2018"),
                    new Recur(""),
                    new UniqueTagList("personal")),
                new Task(new Name("Visit four neighbours"),
                    new Priority("2"),
                    new StartDate("12/12/2017 10:30"),
                    new DueDate("12/11/2018 19:30"),
                    new Recur("weekly"),
                    new UniqueTagList("personal")),
                new Task(new Name("Prepare for five finals"),
                    new Priority("3"),
                    new StartDate("12/12/2017 09:00"),
                    new DueDate("12/12/2018 23:59"),
                    new Recur("yearly"),
                    new UniqueTagList("school", "exams")),
                new Task(new Name("Prepare six presentations"),
                    new Priority("1"),
                    new StartDate("12/12/2017 17:30"),
                    new DueDate("12/12/2018 22:00"),
                    new Recur("monthly"),
                    new UniqueTagList("school", "exams"))
            };
        } catch (IllegalValueException e) {
            throw new AssertionError(MESSAGE_INVALID_SAMPLE_DATA, e);
        }
    }

    /** Retrieves sample ezDo **/
    public static ReadOnlyEzDo getSampleEzDo() {
        try {
            EzDo sampleEzDo = new EzDo();
            addTasksInSampleEzDo(sampleEzDo);
            return sampleEzDo;
        } catch (DuplicateTaskException e) {
            throw new AssertionError(MESSAGE_DUPLICATE_TASKS, e);
        }
    }

    /** Adds sample tasks in sample ezDo **/
    private static void addTasksInSampleEzDo(EzDo sampleEzDo) throws DuplicateTaskException {
        for (Task sampleTask : getSampleTasks()) {
            sampleEzDo.addTask(sampleTask);
        }
    }
}
```
###### \java\seedu\ezdo\ui\CommandBox.java
``` java
    /**
     * Executes the command input by the user.
     */
    @FXML
    public void handleCommandInputChanged() {
        // reset command text field color if it is changed.
        resetCommandFieldListener();

        try {
            CommandResult commandResult = logic.execute(commandTextField.getText());

            // process result of the command
            commandTextField.setText(TEXT_NO_COMMAND_INPUT);
            setStyleToIndicateCommandSuccess();
            logger.info(MESSAGE_RESULT + commandResult.feedbackToUser);
            raise(new NewResultAvailableEvent(commandResult.feedbackToUser));

        } catch (CommandException e) {
            // handle command failure
            setStyleToIndicateCommandFailure();
            logger.info(MESSAGE_INVALID_COMMAND + commandTextField.getText());
            raise(new NewResultAvailableEvent(e.getMessage()));
        }
    }

    /**
     * Add command field listener to reset command text field color if it is changed.
     */
    private void resetCommandFieldListener() {
        commandTextField.textProperty().addListener((observable, oldValue, newValue) -> {
            commandTextField.getStyleClass().remove(ERROR_STYLE_CLASS);
            commandTextField.getStyleClass().remove(SUCCESS_STYLE_CLASS);
        });
    }

    /**
     * Sets the command box style to indicate a successful command.
     */
    private void setStyleToIndicateCommandSuccess() {
        commandTextField.getStyleClass().add(SUCCESS_STYLE_CLASS);
    }

    /**
     * Sets the command box style to indicate a failed command.
     */
    private void setStyleToIndicateCommandFailure() {
        commandTextField.getStyleClass().add(ERROR_STYLE_CLASS);
    }
```
###### \java\seedu\ezdo\ui\TaskCard.java
``` java
/**
 * The task card for the UI.
 */
public class TaskCard extends UiPart<Region> {

    private static final String NUMBERING_FORMAT = ". ";
    private static final String HAS_COMPLETED_LINK = "/images/tick.png";
    private static final String HAS_STARTED_LINK = "/images/wip.png";

    private static final String DEFAULT_PRIORITY_NUMBER = "";
    private static final String DEFAULT_PRIORITY_COLOR = "transparent";

    private static final String HIGH_PRIORITY_NUMBER = "1";
    private static final String HIGH_PRIORITY_COLOR = "red";

    private static final String MEDIUM_PRIORITY_NUMBER = "2";
    private static final String MEDIUM_PRIORITY_COLOR = "orange";

    private static final String LOW_PRIORITY_NUMBER = "3";
    private static final String LOW_PRIORITY_COLOR = "green";

    private static final String FXML = "TaskListCard.fxml";
    private static final String CSS_BACKGROUND_COLOR_PROPERTY = "-fx-background-color: ";

    private static final String CSS_STARTDATE_PAST_CURRENT_DATE_COLOR =
            "-fx-text-fill: darkgreen; -fx-font-weight: bold";

    private static final String CSS_OVERDUE_COLOR =
            "-fx-text-fill: red; -fx-font-weight: bold";

    private static final String CSS_ABOUT_TO_DUE_COLOR =
            "-fx-text-fill: orangered; -fx-font-weight: bold";

    private static final DateFormat DATE_FORMAT = new SimpleDateFormat(DateParser.USER_DATE_OUTPUT_FORMAT);

    public static final HashMap<String, String> PRIORITY_COLOR_HASHMAP = new HashMap<>();

    private String priorityInString;


    @FXML
    private HBox cardPane;
    @FXML
    private AnchorPane priorityColor;
    @FXML
    private Label name;
    @FXML
    private Label id;
    @FXML
    private Label status;
    @FXML
    private Label priority;
    @FXML
    private Label startDate;
    @FXML
    private Label dueDate;
    @FXML
    private Label recur;
    @FXML
    private FlowPane tags;

    /**
     * Creates a TaskCard object with all fields to be shown in UI.
     * @param task              The task to be updated.
     * @param displayedIndex    The index of the task.
     */
    public TaskCard(ReadOnlyTask task, int displayedIndex) {
        super(FXML);
        setPriorityColorHashMap();
        name.setText(task.getName().fullName);
        id.setText(displayedIndex + NUMBERING_FORMAT);
        setPriority(task);
        setStatus(task);
        setStartDate(task);
        setDueDate(task);
        recur.setText(task.getRecur().value);
        setStatus(task);
        initTags(task);
    }

    // ========================= STARTDATE ============================ //

    /**
     * Sets the text of start date.
     * Sets the color of start date when the date has commenced.
     * @param task      The task to be updated.
     */
    private void setStartDate(ReadOnlyTask task) {
        Date currentDate = new Date();  // current date and time
        startDate.setText(task.getStartDate().value);
        setStartDateColor(currentDate, CSS_STARTDATE_PAST_CURRENT_DATE_COLOR);
    }

    /**
     * Sets the color of the start date when it has commenced.
     * @param dateReference     The date to be referenced.
     * @param cssColor          The CSS formatting to be used.
     * @throws ParseException   If the start date is optional and cannot be parsed
     *                          as Date object.
     */
    private void setStartDateColor(Date dateReference, String cssColor) {
        try {
            if (dateReference.after(DATE_FORMAT.parse(startDate.getText()))) {
                startDate.setStyle(cssColor);
            }
        } catch (ParseException pe) {
            // Do nothing as the date is optional
            // and cannot be parsed as Date object.
        }
    }

    // ========================= DUEDATE ============================ //

    /**
     * Sets the text of the due date.
     * Sets the color of due date when it is overdue and when it's due in 7 days time.
     * @param task              The task to be updated.
     * @throws ParseException   If the due date is optional and cannot be parsed
     *                          as Date object.
     */
    private void setDueDate(ReadOnlyTask task) {
        Date currentDate = new Date();
        Date dateSevenDaysInAdvance = createDateSevenDaysInAdvance();

        dueDate.setText(task.getDueDate().value);

        setAboutToDueDateColor(dateSevenDaysInAdvance, CSS_ABOUT_TO_DUE_COLOR);
        setDueDateColor(currentDate, CSS_OVERDUE_COLOR);
    }

    /**
     * Removes the color of the start date when it's due in 7 days time.
     * Sets the color of the due date when it's due in 7 days time.
     * @param dateReference     The date to be referenced.
     * @param cssColor          The CSS formatting to be used.
     * @throws ParseException   If the due date is optional and cannot be parsed
     *                          as Date object.
     */
    private void setAboutToDueDateColor(Date dateReference, String cssColor) {
        try {
            if (dateReference.after(DATE_FORMAT.parse(dueDate.getText()))) {
                startDate.setStyle(null);
                dueDate.setStyle(cssColor);
            }
        } catch (ParseException pe) {
            // Do nothing as the date is optional
            // and cannot be parsed as Date object.
        }
    }

    /**
     * Sets the color of the start date when the due date is overdue.
     * Sets the color of the due date when the due date is overdue.
     * @param dateReference     The date to be referenced.
     * @param cssColor          The CSS formatting to be used.
     * @throws ParseException   If the due date is optional and cannot be parsed
     *                          as Date object.
     */
    private void setDueDateColor(Date dateReference, String cssColor) {
        try {
            if (dateReference.after(DATE_FORMAT.parse(dueDate.getText()))) {
                startDate.setStyle(cssColor);
                dueDate.setStyle(cssColor);
            }
        } catch (ParseException pe) {
            // Do nothing as the date is optional
            // and cannot be parsed as Date object.
        }
    }

    /** Returns the date seven days in advance of the current date and time. */
    private Date createDateSevenDaysInAdvance() {
        int weekIncrement = 7;
        Calendar cal = Calendar.getInstance();  // get current date and time
        cal.add(Calendar.DATE, weekIncrement);  // update to seven days ago
        return cal.getTime();
    }

    // ========================= PRIORITY ============================ //

    /** Sets priorityInString as a local variable. **/
    private void setPriorityInString(ReadOnlyTask task) {
        String priorityValue = task.getPriority().value;
        this.priorityInString = priorityValue;
    }

    /** Initialises the colors and priority numbers in PRIORITY_COLOR_HASHMAP. **/
    private void setPriorityColorHashMap() {
        PRIORITY_COLOR_HASHMAP.put(DEFAULT_PRIORITY_NUMBER, DEFAULT_PRIORITY_COLOR);
        PRIORITY_COLOR_HASHMAP.put(LOW_PRIORITY_NUMBER, LOW_PRIORITY_COLOR);
        PRIORITY_COLOR_HASHMAP.put(MEDIUM_PRIORITY_NUMBER, MEDIUM_PRIORITY_COLOR);
        PRIORITY_COLOR_HASHMAP.put(HIGH_PRIORITY_NUMBER, HIGH_PRIORITY_COLOR);
    }

    /**
     * Sets the priority text and color.
     * @param task      The task to be updated.
     */
    private void setPriority(ReadOnlyTask task) {
        setPriorityInString(task);
        priority.setText(priorityInString); // Invisible in UI (for testing purposes)
        priorityColor.setStyle(CSS_BACKGROUND_COLOR_PROPERTY + PRIORITY_COLOR_HASHMAP.get(priorityInString));
    }

    // ========================= STATUS ============================ //
    /**
     * Sets the image if a task has selected or if the task has completed.
     * @param task      The task to be updated.
     */
    private void setStatus(ReadOnlyTask task) {
        if (task.getStarted()) {
            status.setGraphic(new ImageView(HAS_STARTED_LINK));
        }
        if (task.getDone()) {
            status.setGraphic(new ImageView(HAS_COMPLETED_LINK));
        }
    }

    // ========================= TAGS ============================ //
    /**
     * Sets the tags given a task.
     * @param task      The task to be updated.
     */
    private void initTags(ReadOnlyTask task) {
        task.getTags().forEach(tag -> tags.getChildren().add(new Label(tag.tagName)));
    }
}
```
###### \java\seedu\ezdo\ui\TaskCardHeader.java
``` java
/**
 * The task card header for the UI.
 */
public class TaskCardHeader extends UiPart<Region> {

    private static final String FXML = "TaskCardHeader.fxml";

    public TaskCardHeader(AnchorPane taskCardHeaderPlaceHolder) {
        super(FXML);
        addToPlaceholder(taskCardHeaderPlaceHolder);
    }

    private void addToPlaceholder(AnchorPane placeHolderPane) {
        FxViewUtil.applyAnchorBoundaryParameters(getRoot(), 0.0, 0.0, 0.0, 0.0);
        placeHolderPane.getChildren().add(getRoot());
    }

}
```
###### \resources\view\DarkTheme.css
``` css

.background {
    -fx-background-color: derive(lightcyan, 10%);
    -fx-border-color: black;
    -fx-border-width: 1px;
}

.label {
    -fx-font-size: 11pt;
    -fx-font-family: "Arial Monotype";
    -fx-text-fill: #555555;
    -fx-opacity: 0.9;
}

.label-header {
    -fx-font-size: 28pt;
    -fx-font-family: "Arial Monotype";
    -fx-opacity: 1;
}

.command-text-field {
    -fx-border-color: derive(black, 50%);
    -fx-border-width: 3px;
    -fx-font-weight: bold;
    -fx-font-size: 24pt;
    -fx-font-family: "Arial Monotype";
}

.list-cell {
    -fx-background-color: transparent;
    -fx-label-padding: 0 0 0 0;
    -fx-graphic-text-gap : 0;
    -fx-padding: 0 0 0 0;
}

.list-cell:filled:focused {
    -fx-background-color: derive(-fx-focus-color, 70%);
}

.list-cell .label {
    -fx-text-fill: #010504;
}

.task {
    -fx-font-size: 18px;
    -fx-text-fill: #010504;
}

.task-header {
    -fx-font-size: 16px;
    -fx-font-weight: bold;
    -fx-text-fill: black;
}

.anchor-pane {
     -fx-background-color: transparent;
}

.anchor-pane .priority_number {
    -fx-font-size: 0px;
    -fx-text-fill: transparent;
}

.grid-pane {
    -fx-background-color: transparent;
}

.grid-pane .status-bar {
    -fx-background-color: transparent;
    -fx-font-weight: bold;
}

.result-display {
    -fx-text-fill: blue;
    -fx-background-color: green;
    -fx-font-weight: bold;
    -fx-font-size: 18px;
}

.context-menu {
    -fx-text-fill: black;
}

.menu-bar {
    -fx-background-color: transparent;
}

.menu-bar .label {
    -fx-font-size: 12pt;
    -fx-font-family: "Arial Monotype";
    -fx-text-fill: black;
}

.menu .label {
    -fx-text-fill: black;
}

/*
 * Metro style Push Button
 * Author: Pedro Duque Vieira
 * http://pixelduke.wordpress.com/2012/10/23/jmetro-windows-8-controls-on-java/
 */
.button {
    -fx-padding: 5 22 5 22;
    -fx-border-color: #e2e2e2;
    -fx-border-width: 2;
    -fx-background-radius: 0;
    -fx-background-color: #1d1d1d;
    -fx-font-family: "Segoe UI", Helvetica, Arial, sans-serif;
    -fx-font-size: 11pt;
    -fx-text-fill: #d8d8d8;
    -fx-background-insets: 0 0 0 0, 0, 1, 2;
}

.button:hover {
    -fx-background-color: #3a3a3a;
}

.button:pressed, .button:default:hover:pressed {
  -fx-background-color: white;
  -fx-text-fill: #1d1d1d;
}

.button:focused {
    -fx-border-color: white, white;
    -fx-border-width: 1, 1;
    -fx-border-style: solid, segments(1, 1);
    -fx-border-radius: 0, 0;
    -fx-border-insets: 1 1 1 1, 0;
}

.button:disabled, .button:default:disabled {
    -fx-opacity: 0.4;
    -fx-background-color: #1d1d1d;
    -fx-text-fill: white;
}

.button:default {
    -fx-background-color: -fx-focus-color;
    -fx-text-fill: #ffffff;
}

.button:default:hover {
    -fx-background-color: derive(-fx-focus-color, 30%);
}

.dialog-pane {
    -fx-background-color: #1d1d1d;
}

.dialog-pane > *.button-bar > *.container {
    -fx-background-color: #1d1d1d;
}

.dialog-pane > *.label.content {
    -fx-font-size: 12px;
    -fx-font-weight: bold;
    -fx-text-fill: white;
}

.dialog-pane:header *.header-panel {
    -fx-background-color: white;
}

.dialog-pane:header *.header-panel *.label {
    -fx-font-size: 16px;
    -fx-font-style: italic;
    -fx-fill: white;
    -fx-text-fill: white;
}

.scroll-bar .thumb {
    -fx-background-color: grey;
    -fx-background-insets: 3;
}

.scroll-bar .increment-button, .scroll-bar .decrement-button {
    -fx-background-color: grey;
    -fx-padding: 0 0 0 0;
}

.scroll-bar .increment-arrow, .scroll-bar .decrement-arrow {
    -fx-shape: " ";
}

.scroll-bar:vertical .increment-arrow, .scroll-bar:vertical .decrement-arrow {
    -fx-padding: 1 8 1 8;
}

.scroll-bar:horizontal .increment-arrow, .scroll-bar:horizontal .decrement-arrow {
    -fx-padding: 8 1 8 1;
}

#cardPane {
    -fx-background-color: transparent;
    -fx-border-color: #d6d6d6;
    -fx-border-width: 1 1 1 1;
}

#mainPane {
    -fx-background-color: transparent;
}

#tags {
    -fx-hgap: 15;
    -fx-vgap: 10;
}

#tags .label {
    -fx-text-fill: white;
    -fx-background-color: #383838;
    -fx-padding: 3 6 3 6;
    -fx-border-radius: 2;
    -fx-background-radius: 2;
    -fx-font-size: 16px;
}
```
###### \resources\view\Extensions.css
``` css
.error {
    -fx-background-color: pink;
}

.success {
    -fx-background-color: lightgreen;
}


.tag-selector {
    -fx-border-width: 1;
    -fx-border-color: white;
    -fx-border-radius: 3;
    -fx-background-radius: 3;
}

.tooltip-text {
    -fx-text-fill: white;
}
```
###### \resources\view\MainWindow.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Menu?>
<?import javafx.scene.control.MenuBar?>
<?import javafx.scene.control.MenuItem?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.ColumnConstraints?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.RowConstraints?>
<?import javafx.scene.layout.VBox?>

<VBox styleClass="background" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <stylesheets>
      <URL value="@DarkTheme.css" />
      <URL value="@Extensions.css" />
   </stylesheets>
   <children>
      <GridPane minHeight="30.0" styleClass="grid-pane">
        <columnConstraints>
          <ColumnConstraints hgrow="SOMETIMES" />
          <ColumnConstraints hgrow="SOMETIMES" minWidth="400.0" prefWidth="400.0" />
        </columnConstraints>
        <rowConstraints>
          <RowConstraints minHeight="10.0" prefHeight="30.0" vgrow="SOMETIMES" />
        </rowConstraints>
         <children>
            <MenuBar>
               <menus>
                  <Menu mnemonicParsing="false" text="File">
                     <items>
                        <MenuItem mnemonicParsing="false" onAction="#handleExit" text="Exit" />
                     </items>
                  </Menu>
                  <Menu mnemonicParsing="false" text="Help">
                     <items>
                        <MenuItem fx:id="helpMenuItem" mnemonicParsing="false" onAction="#handleHelp" text="Help" />
                     </items>
                  </Menu>
               </menus>
            </MenuBar>
            <AnchorPane fx:id="statusbarPlaceholder" styleClass="status-bar-with-border" GridPane.columnIndex="1" />
         </children>
         <VBox.margin>
            <Insets />
         </VBox.margin>
      </GridPane>
      <AnchorPane fx:id="commandBoxPlaceholder" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
         <VBox.margin>
            <Insets bottom="20.0" top="20.0" />
         </VBox.margin>
      </AnchorPane>
       <AnchorPane fx:id="resultDisplayPlaceholder" maxHeight="100.0" minHeight="100.0" prefHeight="100.0" VBox.vgrow="NEVER">
         <VBox.margin>
            <Insets bottom="5.0" top="5.0" />
         </VBox.margin>
       </AnchorPane>
      <AnchorPane fx:id="taskCardHeaderPlaceholder">
         <VBox.margin>
            <Insets top="10.0" />
         </VBox.margin></AnchorPane>
      <AnchorPane fx:id="taskListPanelPlaceholder" styleClass="list-cell" VBox.vgrow="ALWAYS">
         <VBox.margin>
            <Insets top="5.0" />
         </VBox.margin></AnchorPane>
   </children>
   <padding>
      <Insets bottom="20.0" left="20.0" right="20.0" top="20.0" />
   </padding>
</VBox>
```
###### \resources\view\TaskCardHeader.fxml
``` fxml

<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.ColumnConstraints?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.RowConstraints?>

<HBox stylesheets="@DarkTheme.css" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
    <children>
        <GridPane HBox.hgrow="ALWAYS">
            <columnConstraints>
                <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="150.0" />
            </columnConstraints>
         <rowConstraints>
            <RowConstraints />
         </rowConstraints>
         <children>
            <HBox spacing="10.0">
               <children>
                  <Label alignment="BOTTOM_RIGHT" minWidth="65.0" styleClass="task-header" text="Index" textAlignment="RIGHT" wrapText="true">
                     <HBox.margin>
                        <Insets right="10.0" />
                     </HBox.margin>
                  </Label>

                  <Label alignment="BOTTOM_LEFT" minWidth="250.0" prefWidth="250.0" styleClass="task-header" text="Task" wrapText="true">
                     <HBox.margin>
                        <Insets right="25.0" />
                     </HBox.margin>
                  </Label>
                  <Label alignment="BOTTOM_LEFT" minWidth="100.0" prefWidth="100.0" styleClass="task-header" text="Status" wrapText="true" />
                  <Label alignment="BOTTOM_LEFT" minWidth="120.0" prefWidth="120.0" styleClass="task-header" text="Start Date" wrapText="true">
                     <HBox.margin>
                        <Insets right="25.0" />
                     </HBox.margin>
                  </Label>
                  <Label alignment="BOTTOM_LEFT" minWidth="100.0" prefWidth="100.0" styleClass="task-header" text="Recur" wrapText="true">
                     <HBox.margin>
                        <Insets right="25.0" />
                     </HBox.margin>
                  </Label>
                  <Label alignment="BOTTOM_LEFT" minWidth="120.0" prefWidth="120.0" styleClass="task-header" text="Due Date" wrapText="true">
                     <HBox.margin>
                        <Insets right="25.0" />
                     </HBox.margin>
                  </Label>
                  <Label alignment="BOTTOM_LEFT" minWidth="180.0" prefWidth="180.0" styleClass="task-header" text="Tags" wrapText="true" />
               </children>
               <GridPane.margin>
                  <Insets />
               </GridPane.margin>
            </HBox>
         </children>
         <HBox.margin>
            <Insets left="30.0" right="30.0" top="15.0" />
         </HBox.margin>
        </GridPane>
    </children>
   <opaqueInsets>
      <Insets />
   </opaqueInsets>
</HBox>
```
###### \resources\view\TaskListCard.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.ColumnConstraints?>
<?import javafx.scene.layout.FlowPane?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.RowConstraints?>

<HBox id="cardPane" fx:id="cardPane" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
    <children>
        <GridPane HBox.hgrow="ALWAYS">
            <columnConstraints>
                <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="150.0" />
            </columnConstraints>
         <rowConstraints>
            <RowConstraints />
         </rowConstraints>
         <children>
            <HBox spacing="5.0">
               <children>
                  <AnchorPane fx:id="priorityColor" minHeight="60.0" minWidth="10.0" prefWidth="10.0" styleClass="anchor-pane">

                     <children>
                        <Label fx:id="priority" alignment="CENTER" maxWidth="0.0" styleClass="priority_number" textAlignment="CENTER" wrapText="true" />
                     </children>
                     <opaqueInsets>
                        <Insets right="30.0" />
                     </opaqueInsets>
                     <HBox.margin>
                        <Insets right="10.0" />
                     </HBox.margin>
                  </AnchorPane>
                  <Label fx:id="id" alignment="TOP_RIGHT" minWidth="50.0" styleClass="task" text="\$id" textAlignment="RIGHT" wrapText="true">
                     <HBox.margin>
                        <Insets right="10.0" />
                     </HBox.margin>
                  </Label>

                  <Label fx:id="name" alignment="TOP_LEFT" minWidth="250.0" prefWidth="250.0" styleClass="task" text="\\$name" wrapText="true">
                     <HBox.margin>
                        <Insets right="30.0" />
                     </HBox.margin>
                  </Label>
                  <Label fx:id="status" accessibleRole="IMAGE_VIEW" alignment="TOP_LEFT" minWidth="50.0" prefWidth="50.0" styleClass="task" wrapText="true">
                     <HBox.margin>
                        <Insets right="55.0" />
                     </HBox.margin></Label>
                  <Label fx:id="startDate" alignment="TOP_LEFT" minWidth="120.0" prefWidth="120.0" styleClass="task" text="\$startDate" wrapText="true">
                     <HBox.margin>
                        <Insets right="30.0" />
                     </HBox.margin>
                  </Label>
                  <Label fx:id="recur" alignment="TOP_LEFT" minWidth="100.0" prefWidth="100.0" styleClass="task" text="\\$recur" wrapText="true">
                     <HBox.margin>
                        <Insets right="30.0" />
                     </HBox.margin></Label>
                  <Label fx:id="dueDate" alignment="TOP_LEFT" minWidth="120.0" prefWidth="120.0" styleClass="task" text="\$dueDate" wrapText="true">
                     <HBox.margin>
                        <Insets right="30.0" />
                     </HBox.margin>
                  </Label>
                  <FlowPane fx:id="tags" prefWrapLength="800.0">
                     <HBox.margin>
                        <Insets />
                     </HBox.margin>
                  </FlowPane>
               </children>
               <GridPane.margin>
                  <Insets />
               </GridPane.margin>
            </HBox>
         </children>
         <HBox.margin>
            <Insets bottom="10.0" left="20.0" right="20.0" top="10.0" />
         </HBox.margin>
        </GridPane>
    </children>
   <stylesheets>
      <URL value="@DarkTheme.css" />
      <URL value="@Extensions.css" />
   </stylesheets>
   <opaqueInsets>
      <Insets />
   </opaqueInsets>
</HBox>
```
###### \resources\view\TaskListPanel.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.VBox?>

<VBox styleClass="background" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <stylesheets>
      <URL value="@DarkTheme.css" />
      <URL value="@Extensions.css" />
   </stylesheets>
   <children>
      <ListView fx:id="taskListView" styleClass="background" VBox.vgrow="ALWAYS" />
   </children>
   <opaqueInsets>
      <Insets bottom="50.0" />
   </opaqueInsets>
</VBox>
```
