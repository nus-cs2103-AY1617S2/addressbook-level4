# A0163962X
###### /java/project/taskcrusher/model/event/Location.java
``` java
/**
 * stores the location of an event. Location field is optional for an event.
 */
public class Location {

    public static final String MESSAGE_LOCATION_CONSTRAINTS =
            "Location should only contain alphanumeric characters and spaces";
    public static final String NO_LOCATION = "";
    public static final String LOCATION_VALIDATION_REGEX = "[\\p{Alnum}][\\p{Alnum} ]*";

    public final String location;

    /**
     * Creates a Location using the String passed
     *
     * @param deadline
     * @throws IllegalValueException if given location string is invalid.
     */
    public Location(String location) throws IllegalValueException {
        assert location != null;

        if (location.equals(NO_LOCATION)) {
            this.location = NO_LOCATION;
        } else if (isValidLocation(location)) {
            this.location = location;
        } else {
            throw new IllegalValueException(MESSAGE_LOCATION_CONSTRAINTS);
        }
    }

    @Override
    public String toString() {
        return location;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Location // instanceof handles nulls
                && this.location.equals(((Location) other).location)); // state check
    }

    @Override
    public int hashCode() {
        return location.hashCode();
    }

    /**
     * Checks whether a location is valid
     *
     * @param location
     * @return true if description exists and contains at least one
     *         non-whitespace character
     */
    public static boolean isValidLocation(String location) {
        return location.matches(LOCATION_VALIDATION_REGEX);
    }

    public boolean hasLocation() {
        return !location.equals(NO_LOCATION);
    }
}
```
###### /java/project/taskcrusher/model/event/Timeslot.java
``` java
/**
 * Represents a timeslot for an event from {@code start} to {@code end}
 */
public class Timeslot {

    public static final String MESSAGE_TIMESLOT_RANGE = "Start date must be before end date";
    public static final String MESSAGE_TIMESLOT_CLASH = "Timeslot clashes with one or more pre-existing events";
    public static final String MESSAGE_TIMESLOT_DNE = "One or more timeslots must be provided";
    public static final String MESSAGE_TIMESLOT_PAIRS = "Timeslot must contain pair of dates, "
            + "or if you intended to input a single date, it is invalid";

    public static final boolean IS_LOADING_FROM_STORAGE = false;
    public static final String NO_TIMESLOT = "";

    public final Date start;
    public final Date end;

    public static Timeslot constructTimeslotFromEndDate(String end) throws IllegalValueException {
        return new Timeslot(end);
    }

    private Timeslot(String end) throws IllegalValueException {
        assert end != null;

        this.start = new Date();
        this.end = DateUtilApache.parseDate(end, true);

        if (!isValidTimeslot(this.start, this.end)) {
            throw new IllegalValueException(MESSAGE_TIMESLOT_RANGE);
        }
    }

    public Timeslot(String start, String end) throws IllegalValueException {
        assert start != null;
        assert end != null;

        this.start = DateUtilApache.parseDate(start, true);
        this.end = DateUtilApache.parseDate(end, true);

        if (!isValidTimeslot(this.start, this.end)) {
            throw new IllegalValueException(MESSAGE_TIMESLOT_RANGE);
        }
    }

    public Timeslot(String start, String end, boolean isNew) throws IllegalValueException {
        assert start != null;
        assert end != null;

        this.start = DateUtilApache.parseDate(start, isNew);
        this.end = DateUtilApache.parseDate(end, isNew);

        if (!isValidTimeslot(this.start, this.end, isNew)) {
            throw new IllegalValueException(MESSAGE_TIMESLOT_RANGE);
        }
    }

    /**
     * Checks if {@code another} has overlapping timeslot with this Timeslot
     * object.
     *
     * @param another
     * @return true if overlapping, false otherwise.
     */
    public boolean isOverlapping(Timeslot another) {
        assert another != null;
        if (start.equals(another.start) || end.equals(another.end)) {
            return true;
        } else if (start.before(another.start) && end.after(another.start)) {
            return true;
        } else if (start.before(another.end) && end.after(another.end)) {
            return true;
        } else if (start.after(another.start) && start.before(another.end)) {
            return true;
        } else if (start.compareTo(another.start) == 0 && end.compareTo(another.end) == 0) {
            return true;
        } else {
            return false;
        }
    }

    private boolean isValidTimeslot(Date start, Date end) {
        if (!end.before(start)) {
            return true;
        } else {
            return false;
        }
    }

    private boolean isValidTimeslot(Date start, Date end, boolean isNew) {

        if (!isNew) {
            return true;
        } else if (!end.before(start)) {
            return true;
        } else {
            return false;
        }
    }

    @Override
    public String toString() {
        return DateUtilApache.dateAsStringForStorage(start) + " to " + DateUtilApache.dateAsStringForStorage(end);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Timeslot // instanceof handles nulls
                        && this.start.equals(((Timeslot) other).start)
                        && this.end.equals(((Timeslot) other).end)); // state check
    }

}
```
###### /java/project/taskcrusher/model/shared/Priority.java
``` java
/**
 * Represents a Task's priority. Can take on values from 1 to 3
 * Guarantees: immutable; is valid as declared in {@link #isValidPriority(String)}
 */
public class Priority implements Comparable<Priority> {

    public static final String MESSAGE_PRIORITY_CONSTRAINTS =
            "Priority should only take the value from 1 to 3 when specified. Its default is 0";
    public static final String NO_PRIORITY = "0";
    public static final String PRIORITY_VALIDATION_REGEX = "[1-3]";

    public final String priority;

    /**
     * Validates given priority value.
     *
     * @throws IllegalValueException if given priority value is invalid.
     */
    public Priority(String priority) throws IllegalValueException {
        assert priority != null;

        if (priority.equals(NO_PRIORITY)) {
            this.priority = NO_PRIORITY;
        } else if (isValidPriority(priority)) {
            this.priority = priority;
        } else {
            throw new IllegalValueException(MESSAGE_PRIORITY_CONSTRAINTS);
        }
    }

    @Override
    public String toString() {
        return priority;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Priority // instanceof handles nulls
                        && this.priority.equals(((Priority) other).priority)); // state check
    }

    @Override
    public int hashCode() {
        return priority.hashCode();
    }

    /**
     * Checks whether a priority is valid
     * @param priority
     * @return
     */
    public static boolean isValidPriority(String priority) {
        return priority.matches(PRIORITY_VALIDATION_REGEX);
    }

    public boolean hasPriority() {
        return !priority.equals(NO_PRIORITY);
    }

    @Override
    public int compareTo(Priority another) {
        int thisPriority = Integer.parseInt(this.priority);
        int anotherPriority = Integer.parseInt(another.priority);
        return anotherPriority - thisPriority;
    }

}
```
###### /java/project/taskcrusher/model/shared/DateUtilApache.java
``` java
/**
 * Utility class for parsing Dates
 *
 */
public class DateUtilApache {

    public static final String MESSAGE_DATE_PASSED = "Dates provided must not be in the past";
    public static final String MESSAGE_DATE_AMBIGUOUS = "Multiple dates provided."
            + "Please provide one date in a supported format";
    public static final String MESSAGE_DATE_NOT_FOUND = "Input provided cannot be parsed as Date"
            + "Please provide one date in a supported format";;

    public static final String[] PARSE_PATTERNS = { "yyyy-MM-dd hh:mma", "yyyy-MM-dd", "MM-dd hh:mma", "hh:mma" };
    public static final int FORMAT_DATE_ABSOLUTE = 0;
    public static final int FORMAT_THIS_YEAR = 2;
    public static final int FORMAT_DATE_RELATIVE = 3;

    public static Date parseDate(String toParse, boolean isNew) throws IllegalValueException {

        Parser nattyParser = new Parser();
        Date parsed = null;
        boolean needsTimeAdjustment = false;

        List<Date> tempDateList = nattyParser.parse(toParse).get(0).getDates();

        if (tempDateList != null && tempDateList.size() > 0) {
            parsed = tempDateList.get(0);
            needsTimeAdjustment = nattyParser.parse(toParse).get(0).isTimeInferred();
        } else {
            throw new IllegalValueException(MESSAGE_DATE_NOT_FOUND);
        }

        if (needsTimeAdjustment) {
            parsed = DateUtils.setHours(parsed, 23);
            parsed = DateUtils.setMinutes(parsed, 59);
            parsed = DateUtils.setSeconds(parsed, 59);
            parsed = DateUtils.setMilliseconds(parsed, 59);
        }

        if (isNew && hasPassed(parsed)) { // short circuit if not new/from
            // storage
            throw new IllegalValueException(MESSAGE_DATE_PASSED);
        }

        return parsed;
    }

    public static boolean hasPassed(Date date) {
        assert date != null;
        Date rightNow = new Date();
        if (date.before(rightNow)) {
            return true;
        } else {
            return false;
        }
    }

```
###### /java/project/taskcrusher/model/shared/Description.java
``` java
/**
 * Represents a Task's description. Guarantees: immutable; is valid as declared
 * in {@link #isValidDescription(String)}
 */
public class Description {

    public static final String MESSAGE_DESCRIPTION_CONSTRAINTS = "Descriptions can take any value, "
            + "but must not be blank";

    public static final String NO_DESCRIPTION = "";
    public static final String DESCRIPTION_VALIDATION_REGEX = "\\S.*";

    public final String description;

    /**
     * Creates a Description using the String passed
     *
     * @throws IllegalValueException if given description string is invalid.
     */
    public Description(String description) throws IllegalValueException {
        assert description != null;

        if (description.equals(NO_DESCRIPTION)) {
            this.description = NO_DESCRIPTION;
        } else if (isValidDescription(description)) {
            this.description = description;
        } else {
            throw new IllegalValueException(MESSAGE_DESCRIPTION_CONSTRAINTS);
        }
    }

    @Override
    public String toString() {
        return this.description;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Description // instanceof handles nulls
                        && this.description.equals(((Description) other).description)); // state
        // check
    }

    @Override
    public int hashCode() {
        return description.hashCode();
    }

    /**
     * Checks whether a description is valid
     *
     * @param description
     * @return true if description exists and contains at least one
     *         non-whitespace character
     */
    public static boolean isValidDescription(String description) {
        return description.matches(DESCRIPTION_VALIDATION_REGEX);
    }

    public boolean hasDescription() {
        return !description.equals(NO_DESCRIPTION);
    }

}
```
###### /java/project/taskcrusher/model/shared/Name.java
``` java
/**
 * Represents a Task's name in the user inbox.
 * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}
 */
public class Name {

    public static final String MESSAGE_NAME_CONSTRAINTS =
            "Task names should only contain alphanumeric characters and spaces, and it should not be blank";

    /*
     * The first character of the name must not be a whitespace,
     * otherwise " " (a blank string) becomes a valid input.
     */
    public static final String NAME_VALIDATION_REGEX = "[\\p{Alnum}][\\p{Alnum} ]*";

    public final String name;

    /**
     * Validates given name.
     *
     * @throws IllegalValueException if given name string is invalid.
     */
    public Name(String name) throws IllegalValueException {
        assert name != null;

        String trimmedName = name.trim();
        if (!isValidName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
        }
        this.name = trimmedName;
    }

    /**
     * Returns true if a given string is a valid task name.
     */
    public static boolean isValidName(String test) {
        return test.matches(NAME_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return name;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Name // instanceof handles nulls
                && this.name.equals(((Name) other).name)); // state check
    }

    @Override
    public int hashCode() {
        return name.hashCode();
    }

}
```
###### /java/project/taskcrusher/model/task/Deadline.java
``` java
/**
 * Represents a deadline for a task. Empty deadline means no deadline.
 */
public class Deadline {

    public static final String MESSAGE_DEADLINE_CONSTRAINTS = "Deadline provided must be a relative"
            + " or absolute date, and must not have passed";
    public static final String NO_DEADLINE = "";
    public static final boolean IS_LOADING_FROM_STORAGE = false;

    public final String deadline;

    /**
     * Creates a Deadline using the String passed
     *
     * @param deadline
     * @throws IllegalValueException
     */
    public Deadline(String deadline) throws IllegalValueException {
        assert deadline != null;

        if (deadline.equals(NO_DEADLINE)) {
            this.deadline = NO_DEADLINE;
        } else {
            this.deadline = DateUtilApache.dateAsStringForStorage(DateUtilApache.parseDate(deadline, true));
        }
    }

    /**
     * Creates a Deadline using the String passed. isNew means that this
     * Deadline object is added from user input as opposed to being loaded from
     * storage, and therefore the checking of whether the deadline date is in
     * the past should NOT be bypassed.
     *
     * @param deadline
     * @throws IllegalValueException
     */
    public Deadline(String deadline, boolean filterOverdue) throws IllegalValueException {
        assert deadline != null;

        if (deadline.equals(NO_DEADLINE)) {
            this.deadline = NO_DEADLINE;
        } else {
            this.deadline = DateUtilApache.dateAsStringForStorage(DateUtilApache.parseDate(deadline, filterOverdue));
        }

    }

    /**
     * Returns Deadline in the form of Optional<Date>
     *
     * @return Deadline in the form of Optional<Date>, empty Optional<Date> if
     *         no deadline
     * @throws IllegalValueException
     */
    public Optional<Date> getDate() {

        Optional<Date> deadlineAsDate = Optional.empty();

        if (this.hasDeadline()) {
            try {
                return Optional.of(DateUtilApache.parseDate(this.deadline, false));
            } catch (IllegalValueException e) {
                // TODO this should not occur by default, provided that this
                // object was instantiated successfully.
                e.printStackTrace();
                return deadlineAsDate;
            }
        } else {
            return deadlineAsDate;
        }
    }

    public boolean hasDeadline() {
        return !deadline.equals(NO_DEADLINE);
    }

    public boolean isWithin(Timeslot timeslot) {
        assert timeslot != null;
        if (!hasDeadline()) {
            return false;
        }

        Date deadlineInDate = getDate().get();

        if ((deadlineInDate.after(timeslot.start)) && (deadlineInDate.before(timeslot.end))) {
            return true;
        } else {
            return false;
        }
    }

    @Override
    public String toString() {
        if (this.hasDeadline()) {
            return DateUtilApache.dateAsStringForStorage(this.getDate().get());
        } else {
            return Deadline.NO_DEADLINE;
        }
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Deadline // instanceof handles nulls
                        && this.deadline.equals(((Deadline) other).deadline));
    }

}
```
###### /java/project/taskcrusher/logic/parser/ParserUtil.java
``` java
    /**
     * Parses a {@code Optional<String> deadline} into an
     * {@code Optional<Deadline>} if {@code deadline} is present.
     */
    public static Optional<List<Timeslot>> parseTimeslots(Optional<String> timeslots) throws IllegalValueException {
        assert timeslots != null;

        if (timeslots.isPresent()) {

            if (timeslots.get().equals(Timeslot.NO_TIMESLOT)) {
                throw new IllegalValueException(Timeslot.MESSAGE_TIMESLOT_DNE);
            }

            // TODO again, could refactor this somewhere
            String[] timeslotsAsStrings = timeslots.get().split("\\s+or\\s+");
            List<Timeslot> timeslotsParsed = new ArrayList<>();
            for (String t : timeslotsAsStrings) {
                String[] dates = t.split("\\s+to\\s+");
                if (dates.length != 2) {
                    throw new IllegalValueException(Timeslot.MESSAGE_TIMESLOT_PAIRS);
                }
                timeslotsParsed.add(new Timeslot(dates[0], dates[1]));
            }

            return Optional.of(timeslotsParsed);

        } else {
            return Optional.empty();
        }
    }

    /**
     *
     * @param argsTokenizer
     * @param prefix
     * @param defaultValue
     * @return
     */
    public static String setValue(ArgumentTokenizer argsTokenizer, ArgumentTokenizer.Prefix prefix,
            String defaultValue) {
        String value = defaultValue;
        Optional<String> rawValue = argsTokenizer.getValue(prefix);
        if (rawValue.isPresent()) {
            value = rawValue.get();
        }
        return value;
    }

    /**
     *
     * @param preamble
     * @param defaultValue
     * @return
     */
    public static String setValue(Optional<String> preamble, String defaultValue) {
        String value = defaultValue;
        if (preamble.isPresent()) {
            value = preamble.get();
        }
        return value;
    }

    /**
     *
     * @param datesToParse
     * @return
     * @throws IllegalValueException
     */
    public static List<Timeslot> parseAsTimeslots(String datesToParse) throws IllegalValueException {

        if (datesToParse.equals(Timeslot.NO_TIMESLOT)) {
            throw new IllegalValueException(Timeslot.MESSAGE_TIMESLOT_DNE);
        }
        String[] timeslotsAsStrings = datesToParse.split("\\s+or\\s+");
        List<Timeslot> timeslots = new ArrayList<>();
        for (String t : timeslotsAsStrings) {
            String[] dates = t.split("\\s+to\\s+");
            if (dates.length != 2) {
                throw new IllegalValueException(Timeslot.MESSAGE_TIMESLOT_PAIRS);
            }
            timeslots.add(new Timeslot(dates[0], dates[1]));
        }

        return timeslots;
    }

    /**
     *
     * @param datesToParse
     * @return
     * @throws IllegalValueException
     */
    public static List<Timeslot> parseForList(String datesToParse) throws IllegalValueException {

        if (datesToParse.equals(Timeslot.NO_TIMESLOT)) {
            throw new IllegalValueException(Timeslot.MESSAGE_TIMESLOT_DNE);
        }
        String[] timeslotsAsStrings = datesToParse.split("\\s+or\\s+");
        List<Timeslot> timeslots = new ArrayList<>();
        for (String t : timeslotsAsStrings) {
            String[] dates = t.split("\\s+to\\s+");
            if (dates.length == 1) {
                timeslots.add(Timeslot.constructTimeslotFromEndDate(dates[0]));
            } else if (dates.length != 2) {
                throw new IllegalValueException(Timeslot.MESSAGE_TIMESLOT_PAIRS);
            } else {
                timeslots.add(new Timeslot(dates[0], dates[1]));
            }
        }

        return timeslots;
    }

```
###### /java/project/taskcrusher/logic/parser/ConfirmCommandParser.java
``` java
public class ConfirmCommandParser {

    public static final String FLAG_EVENT_VALIDATION_REGEX = "[" + Event.EVENT_FLAG + "]";

    /**
     * Parses the given {@code String} of arguments in the context of the
     * DeleteCommand and returns an DeleteCommand object for execution.
     */
    public Command parse(String args) {

        String[] preamble = args.trim().split("\\s+");

        if (preamble.length != 3) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ConfirmCommand.MESSAGE_USAGE));
        } else if (!preamble[0].matches(ConfirmCommandParser.FLAG_EVENT_VALIDATION_REGEX)) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ConfirmCommand.MESSAGE_USAGE));
        } else if (!preamble[1].matches("\\d+") && !preamble[2].matches("\\d+")) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ConfirmCommand.MESSAGE_USAGE));
        }

        Optional<Integer> index = ParserUtil.parseIndex(preamble[1]);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ConfirmCommand.MESSAGE_USAGE));
        }

        Optional<Integer> slot = ParserUtil.parseIndex(preamble[2]);
        if (!slot.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ConfirmCommand.MESSAGE_USAGE));
        }

        return new ConfirmCommand(index.get(), slot.get());
    }

}
```
###### /java/project/taskcrusher/logic/parser/CliSyntax.java
``` java
/**
 * Contains Command Line Interface (CLI) syntax definitions common to multiple commands
 */
public class CliSyntax {

    /* Prefix definitions for tasks*/
    public static final Prefix PREFIX_PRIORITY = new Prefix("p/");

    /* Prefix definitions for events*/
    public static final Prefix PREFIX_LOCATION = new Prefix("l/");

    /* Prefix definitions for both tasks and events*/
    public static final Prefix PREFIX_DATE = new Prefix("d/");
    public static final Prefix PREFIX_TAG = new Prefix("t/");
    public static final Prefix PREFIX_DESCRIPTION = new Prefix("//");
    public static final Prefix PREFIX_OPTION = new Prefix("--");

    /* Patterns definitions */
    public static final Pattern KEYWORDS_ARGS_FORMAT =
            Pattern.compile("(?<keywords>\\S+(?:\\s+\\S+)*)"); // one or more keywords separated by whitespace

}
```
###### /java/project/taskcrusher/logic/parser/AddCommandParser.java
``` java
/**
 * Parses input arguments and creates a new AddCommand object
 */
public class AddCommandParser {

    private static final Pattern ADD_COMMAND_PREAMBLE_FORMAT = Pattern.compile("(?<flag>[te])(?<name>.+)");

    /**
     * Parses the given {@code String} of arguments in the context of the
     * AddCommand and returns an AddCommand object for execution.
     */
    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_DATE, PREFIX_TAG, PREFIX_PRIORITY,
                PREFIX_LOCATION, PREFIX_DESCRIPTION, PREFIX_OPTION);
        argsTokenizer.tokenize(args);

        // extract flag and name from preamble
        if (!argsTokenizer.getPreamble().isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }

        Matcher matcher = ADD_COMMAND_PREAMBLE_FORMAT.matcher(argsTokenizer.getPreamble().get());

        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }

        final String flag = matcher.group("flag");
        final String name = matcher.group("name");

        // set all remaining properties
        final String date = ParserUtil.setValue(argsTokenizer, PREFIX_DATE, Deadline.NO_DEADLINE);
        final String priority = ParserUtil.setValue(argsTokenizer, PREFIX_PRIORITY, Priority.NO_PRIORITY);
        final String location = ParserUtil.setValue(argsTokenizer, PREFIX_LOCATION, Location.NO_LOCATION);
        final String description = ParserUtil.setValue(argsTokenizer, PREFIX_DESCRIPTION, Description.NO_DESCRIPTION);
        final Set<String> tags = ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG));
        final String option = ParserUtil.setValue(argsTokenizer, PREFIX_OPTION, Parser.NO_OPTION);

        try {
            switch (flag) {
            case Event.EVENT_FLAG:
                List<Timeslot> timeslots = ParserUtil.parseAsTimeslots(date);
                AddCommand eventToAdd = new AddCommand(name, timeslots, priority, location, description, tags);
                if (option.equals(Parser.FORCE_OPTION)) {
                    eventToAdd.force = true;
                }
                return eventToAdd;
            case Task.TASK_FLAG:
                return new AddCommand(name, date, priority, description, tags);
            default:
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }

    }
}
```
###### /java/project/taskcrusher/logic/parser/SwitchCommandParser.java
``` java
public class SwitchCommandParser {

    public static final String FLAG_EVENT_VALIDATION_REGEX = "[" + Task.TASK_FLAG + Event.EVENT_FLAG + "]";

    /**
     * Parses the given {@code String} of arguments in the context of the
     * DeleteCommand and returns an DeleteCommand object for execution.
     */
    public Command parse(String args) {

        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_DATE);
        argsTokenizer.tokenize(args);

        if (!argsTokenizer.getPreamble().isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SwitchCommand.MESSAGE_USAGE));
        }

        String[] preamble = argsTokenizer.getPreamble().get().trim().split("\\s+");

        if (preamble.length != 2) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SwitchCommand.MESSAGE_USAGE));
        } else if (!preamble[0].matches(SwitchCommandParser.FLAG_EVENT_VALIDATION_REGEX)) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SwitchCommand.MESSAGE_USAGE));
        } else if (!preamble[1].matches("\\d+")) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SwitchCommand.MESSAGE_USAGE));
        }

        Optional<Integer> index = ParserUtil.parseIndex(preamble[1]);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SwitchCommand.MESSAGE_USAGE));
        }

        final String date = ParserUtil.setValue(argsTokenizer, PREFIX_DATE, Deadline.NO_DEADLINE);

        return new SwitchCommand(preamble[0], index.get(), date);
    }

}
```
###### /java/project/taskcrusher/logic/parser/ListCommandParser.java
``` java
/**
 * Parses input arguments and creates a new AddCommand object
 */
public class ListCommandParser {

    private final boolean showActiveOnly = true;
    private final boolean showCompleteOnly = true;

    /**
     * Parses the given {@code String} of arguments in the context of the
     * ListCommand and returns a ListCommand object for execution.
     */
    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_DATE);
        argsTokenizer.tokenize(args);

        String flag = ParserUtil.setValue(argsTokenizer.getPreamble(), ListCommand.NO_FLAG);
        String date = ParserUtil.setValue(argsTokenizer, PREFIX_DATE, Deadline.NO_DEADLINE);

        try {
            switch (flag) {
            case ListCommand.NO_FLAG:
                return new ListCommand(date, showActiveOnly, !showCompleteOnly);
            case ListCommand.ALL_FLAG:
                return new ListCommand(date, !showActiveOnly, !showCompleteOnly);
            case ListCommand.COMPLETE_FLAG:
                return new ListCommand(date, !showActiveOnly, showCompleteOnly);
            default:
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }

    }

}
```
###### /java/project/taskcrusher/logic/parser/EditCommandParser.java
``` java
/**
 * Parses input arguments and creates a new EditCommand object
 */
public class EditCommandParser {
    private static final Pattern EDIT_COMMAND_FORMAT = Pattern.compile("(?<flag>[te])(?<name>.+)");

    /**
     * Parses the given {@code String} of arguments in the context of the
     * EditCommand and returns an EditCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_PRIORITY, PREFIX_DATE, PREFIX_LOCATION,
                PREFIX_DESCRIPTION, PREFIX_TAG, PREFIX_OPTION);
        argsTokenizer.tokenize(args);
        final String option = ParserUtil.setValue(argsTokenizer, PREFIX_OPTION, Parser.NO_OPTION);

        List<Optional<String>> preambleFields = ParserUtil.splitPreamble(argsTokenizer.getPreamble().orElse(""), 3);

        try {
            if (preambleFields.get(0).get().equals(Task.TASK_FLAG)) {

                Optional<Integer> index = preambleFields.get(1).flatMap(ParserUtil::parseIndex);
                if (!index.isPresent()) {
                    return new IncorrectCommand(
                            String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
                }

                EditTaskDescriptor editTaskDescriptor = new EditTaskDescriptor();
                try {
                    editTaskDescriptor.setName(ParserUtil.parseName(preambleFields.get(2)));
                    editTaskDescriptor.setPriority(ParserUtil.parsePriority(argsTokenizer.getValue(PREFIX_PRIORITY)));
                    editTaskDescriptor.setDeadline(ParserUtil.parseDeadline(argsTokenizer.getValue(PREFIX_DATE)));
                    editTaskDescriptor
                            .setDescription(ParserUtil.parseDescription(argsTokenizer.getValue(PREFIX_DESCRIPTION)));
                    editTaskDescriptor
                            .setTags(parseTagsForEdit(ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG))));
                } catch (IllegalValueException ive) {
                    return new IncorrectCommand(ive.getMessage());
                }

                if (!editTaskDescriptor.isAnyFieldEdited()) {
                    return new IncorrectCommand(EditCommand.MESSAGE_NOT_EDITED);
                }

                return new EditCommand(index.get(), editTaskDescriptor);

            } else if (preambleFields.get(0).get().equals(Event.EVENT_FLAG)) {

                Optional<Integer> index = preambleFields.get(1).flatMap(ParserUtil::parseIndex);
                if (!index.isPresent()) {
                    return new IncorrectCommand(
                            String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
                }

                EditEventDescriptor editEventDescriptor = new EditEventDescriptor();
                try {
                    editEventDescriptor.setName(ParserUtil.parseName(preambleFields.get(2)));
                    editEventDescriptor.setLocation(ParserUtil.parseLocation(argsTokenizer.getValue(PREFIX_LOCATION)));
                    editEventDescriptor.setPriority(ParserUtil.parsePriority(argsTokenizer.getValue(PREFIX_PRIORITY)));
                    editEventDescriptor.setTimeslots(ParserUtil.parseTimeslots(argsTokenizer.getValue(PREFIX_DATE)));
                    editEventDescriptor
                            .setDescription(ParserUtil.parseDescription(argsTokenizer.getValue(PREFIX_DESCRIPTION)));
                    editEventDescriptor
                            .setTags(parseTagsForEdit(ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG))));
                } catch (IllegalValueException ive) {
                    return new IncorrectCommand(ive.getMessage());
                }

                if (!editEventDescriptor.isAnyFieldEdited()) {
                    return new IncorrectCommand(EditCommand.MESSAGE_NOT_EDITED);
                }

                EditEventCommand edited = new EditEventCommand(index.get(), editEventDescriptor);
                if (option.equals(Parser.FORCE_OPTION)) {
                    edited.force = true;
                }
                return edited;

            } else {
                throw new IllegalValueException(
                        String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

```
###### /java/project/taskcrusher/logic/parser/DeleteCommandParser.java
``` java
/**
 * Parses input arguments and creates a new DeleteCommand object
 */
public class DeleteCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the
     * DeleteCommand and returns an DeleteCommand object for execution.
     */
    public Command parse(String args) {

        String[] preamble = args.trim().split("\\s+");

        if (preamble.length != 2) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        } else if (!preamble[0].matches("[" + Task.TASK_FLAG + Event.EVENT_FLAG + "]")) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        } else if (!preamble[1].matches("\\d+")) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }

        Optional<Integer> index = ParserUtil.parseIndex(preamble[1]);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }

        return new DeleteCommand(preamble[0], index.get());
    }

}
```
###### /java/project/taskcrusher/logic/commands/ListCommand.java
``` java
/**
 * Lists all persons in the address book to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";
    public static final String COMPLETE_FLAG = "c";
    public static final String ALL_FLAG = "all";
    public static final String NO_FLAG = "";

    public static final String MESSAGE_MULTIPLE_DATERANGES = "Multiple date ranges supplied. Supply only one range.";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Lists tasks/events that satisfies the given qualifier "
            + "list: list command with no qualifier lists active todos only\n" + "list c: lists only complete events"
            + "list all: lists all events, active and complete"
            + "list d/DEADLINE: lists all todos whose set before now to DEADLINE"
            + "list d/TIMESLOT: lists all todos whose timeslot overlaps with TIMESLOT";

    // TODO fix this message eventually
    public static final String MESSAGE_SUCCESS = "Listed all relevant events/tasks";

    private Timeslot dateRange;
    private boolean showActiveOnly;
    private boolean showCompleteOnly;

    public ListCommand(String date, boolean showActiveOnly, boolean showCompleteOnly) throws IllegalValueException {
        if (date.equals(Deadline.NO_DEADLINE)) {
            this.dateRange = null;
        } else {
            this.dateRange = parseDateRange(date);
        }
        this.showActiveOnly = showActiveOnly;
        this.showCompleteOnly = showCompleteOnly;

        if (dateRange != null && (showCompleteOnly)) { // showActiveOnly allowed
                                                       // as default
            throw new IllegalValueException(MESSAGE_USAGE);
        }
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        assert !(showActiveOnly && showCompleteOnly);

        if (dateRange != null) {
            model.updateFilteredLists(dateRange);
        } else if (!showActiveOnly && !showCompleteOnly) {
            model.updateFilteredListsShowAll();
        } else if (showCompleteOnly) {
            model.updateFilteredListsToShowCompleteToDo();
        } else if (showActiveOnly) {
            model.updateFilteredListsToShowActiveToDo();
        } else if (dateRange != null) {
            model.updateFilteredLists(dateRange);
        }

        return new CommandResult(MESSAGE_SUCCESS);
    }

    /**
     *
     * @param date
     * @return
     * @throws IllegalValueException
     */
    private Timeslot parseDateRange(String date) throws IllegalValueException {
        Timeslot dateRange;

        List<Timeslot> timeslots = ParserUtil.parseForList(date);
        if (timeslots.size() > 1) {
            throw new IllegalValueException(MESSAGE_MULTIPLE_DATERANGES);
        }
        dateRange = timeslots.get(0);

        return dateRange;
    }

}
```
###### /java/project/taskcrusher/logic/commands/SwitchCommand.java
``` java
public class SwitchCommand extends Command {

    public static final String COMMAND_WORD = "switch";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Switches a task or event identified by"
            + "the index number used in the last event listing and number of the timeslot\n" + "to the opposite type\n"
            + "Parameters: FLAG (t or e) INDEX (must be positive integers) NEW TIMESLOT OR DEADLINE\n" + "Example: "
            + COMMAND_WORD + " e 1 d/tomorrow";

    public static final String MESSAGE_SWITCH_TASK_SUCCESS = "Switched the following task to event: %1$s";
    public static final String MESSAGE_SWITCH_EVENT_SUCCESS = "Switched the following event to task: %1$s";

    public final int targetIndex;
    public final String flag;
    public final String date;

    public SwitchCommand(String flag, int targetIndex, String date) {
        this.flag = flag;
        this.targetIndex = targetIndex;
        this.date = date;
    }

    @Override
    public CommandResult execute() throws CommandException {

        if (flag.equals(Task.TASK_FLAG)) {

            UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

            if (lastShownList.size() < targetIndex) {
                throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }

            ReadOnlyTask taskToSwitch = lastShownList.get(targetIndex - 1);

            try {
                List<Timeslot> timeslots = ParserUtil.parseAsTimeslots(date);
                model.switchTaskToEvent(taskToSwitch,
                        new Event(taskToSwitch.getName(), timeslots, taskToSwitch.getPriority(),
                                new Location(Location.NO_LOCATION), taskToSwitch.getDescription(),
                                taskToSwitch.getTags()));
            } catch (IllegalValueException ive) {
                throw new CommandException(ive.getMessage());
            } catch (TaskNotFoundException tnfe) {
                throw new CommandException(tnfe.getMessage());
            }

            return new CommandResult(String.format(MESSAGE_SWITCH_TASK_SUCCESS, taskToSwitch));

        } else {

            assert flag.equals(Event.EVENT_FLAG);

            UnmodifiableObservableList<ReadOnlyEvent> lastShownList = model.getFilteredEventList();

            if (lastShownList.size() < targetIndex) {
                throw new CommandException(Messages.MESSAGE_INVALID_EVENT_DISPLAYED_INDEX);
            }

            ReadOnlyEvent eventToSwitch = lastShownList.get(targetIndex - 1);

            try {
                model.switchEventToTask(eventToSwitch, new Task(eventToSwitch.getName(), new Deadline(date),
                       eventToSwitch.getPriority(), eventToSwitch.getDescription(), eventToSwitch.getTags()));
            } catch (IllegalValueException ive) {
                throw new CommandException(ive.getMessage());
            } catch (EventNotFoundException enfe) {
                throw new CommandException(enfe.getMessage());
            }

            return new CommandResult(String.format(MESSAGE_SWITCH_EVENT_SUCCESS, eventToSwitch));

        }

    }

}
```
###### /java/project/taskcrusher/logic/commands/DeleteCommand.java
``` java
/**
 * Deletes a person identified using it's last displayed index from the address
 * book.
 */
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = "delete";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the task/event identified by the index number used in the last task/event listing.\n"
            + "Parameters: FLAG INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " e 1";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted Task: %1$s";
    public static final String MESSAGE_DELETE_EVENT_SUCCESS = "Deleted Event: %1$s";

    public final int targetIndex;
    public final String flag;

    public DeleteCommand(String flag, int targetIndex) {
        this.flag = flag;
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() throws CommandException {

        assert (this.flag.equals(Event.EVENT_FLAG) || this.flag.equals(Task.TASK_FLAG));

        if (this.flag.equals(Task.TASK_FLAG)) {
            UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

            if (lastShownList.size() < targetIndex) {
                throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }

            ReadOnlyTask taskToDelete = lastShownList.get(targetIndex - 1);

            try {
                model.deleteTask(taskToDelete);
            } catch (TaskNotFoundException tnfe) {
                assert false : "The target task cannot be missing";
            }

            return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, taskToDelete));
        } else {
            UnmodifiableObservableList<ReadOnlyEvent> lastShownList = model.getFilteredEventList();

            if (lastShownList.size() < targetIndex) {
                throw new CommandException(Messages.MESSAGE_INVALID_EVENT_DISPLAYED_INDEX);
            }

            ReadOnlyEvent eventToDelete = lastShownList.get(targetIndex - 1);

            try {
                model.deleteEvent(eventToDelete);
            } catch (EventNotFoundException enfe) {
                assert false : "The target event cannot be missing";
            }

            return new CommandResult(String.format(MESSAGE_DELETE_EVENT_SUCCESS, eventToDelete));
        }

    }

}
```
###### /java/project/taskcrusher/logic/commands/AddCommand.java
``` java
/**
 * Adds a task to user inbox.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task or an event to the active list.\n "
            + "For events: " + COMMAND_WORD + " " + Event.EVENT_FLAG
            + " NAME d/START_DATE to END_DATE [l/LOCATION] [//DESCRIPTION] [t/TAG]\n" + " For tasks: " + COMMAND_WORD
            + " " + Task.TASK_FLAG + " NAME [d/DEADLINE] [p/PRIORITY] [//DESCRIPTION] [t/TAG]";

    public static final String MESSAGE_TASK_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_EVENT_SUCCESS = "New event added: %1$s";

    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the active list";
    public static final String MESSAGE_DUPLICATE_EVENT = "This event already exists in the active list";

    public static final String MESSAGE_EVENT_CLASHES = "This event clashes with a preexisting event";

    private final Task taskToAdd;
    private final Event eventToAdd;
    public boolean force = false;

    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException
     *             if any of the raw values are invalid
     */
    public AddCommand(String name, String deadline, String priority, String description, Set<String> tags)
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.taskToAdd = new Task(new Name(name), new Deadline(deadline), new Priority(priority),
                new Description(description), new UniqueTagList(tagSet));
        this.eventToAdd = null;
    }

    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException
     *             if any of the raw values are invalid
     */
    public AddCommand(String name, List<Timeslot> timeslots, String location, String description, Set<String> tags)
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.eventToAdd = new Event(new Name(name), new ArrayList<Timeslot>(timeslots), new Location(location),
                new Description(description), new UniqueTagList(tagSet));
        this.taskToAdd = null;
    }

    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException
     *             if any of the raw values are invalid
     */
    public AddCommand(String name, List<Timeslot> timeslots, String priority, String location, String description,
            Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.eventToAdd = new Event(new Name(name), new ArrayList<Timeslot>(timeslots), new Priority(priority),
                new Location(location), new Description(description), new UniqueTagList(tagSet));
        this.taskToAdd = null;
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        assert !(eventToAdd == null && taskToAdd == null);
        try {
            if (eventToAdd != null) {

                List<? extends ReadOnlyEvent> preexistingEvents = model.getUserInbox().getEventList();
                if (!force && eventToAdd.hasOverlappingEvent(preexistingEvents)) { // allow
                                                                                   // for
                                                                                   // force
                                                                                   // adding
                    throw new CommandException(MESSAGE_EVENT_CLASHES);
                }

                model.addEvent(eventToAdd);
                return new CommandResult(String.format(MESSAGE_EVENT_SUCCESS, eventToAdd));
            } else {
                model.addTask(taskToAdd);
                return new CommandResult(String.format(MESSAGE_TASK_SUCCESS, taskToAdd));
            }
        } catch (UniqueTaskList.DuplicateTaskException e) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        } catch (UniqueEventList.DuplicateEventException e) {
            throw new CommandException(MESSAGE_DUPLICATE_EVENT);
        }

    }

}
```
###### /java/project/taskcrusher/logic/commands/ConfirmCommand.java
``` java
public class ConfirmCommand extends Command {

    public static final String COMMAND_WORD = "confirm";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Confirms a timeslot of an event identified by "
            + "the index number used in the last event listing and number of the timeslot\n"
            + "Parameters: FLAG (must be e) INDEX SLOT (last 2 must be positive integers)\n" + "Example: "
            + COMMAND_WORD + " e 1 1";

    public static final String MESSAGE_CONFIRM_EVENT_SUCCESS = "Confirmed timeslot for: %1$s";

    public final int targetIndex;
    public final int targetSlot;

    public ConfirmCommand(int targetIndex, int targetSlot) {
        this.targetIndex = targetIndex;
        this.targetSlot = targetSlot;
    }

    @Override
    public CommandResult execute() throws CommandException {

        UnmodifiableObservableList<ReadOnlyEvent> lastShownList = model.getFilteredEventList();

        if (lastShownList.size() < targetIndex) {
            throw new CommandException(Messages.MESSAGE_INVALID_EVENT_DISPLAYED_INDEX);
        }

        ReadOnlyEvent eventToConfirm = lastShownList.get(targetIndex - 1);

        if (eventToConfirm.getTimeslots().size() < targetSlot) {
            throw new CommandException(Messages.MESSAGE_INVALID_EVENT_SLOT_DISPLAYED_INDEX);
        }

        model.confirmEventTime(targetIndex - 1, targetSlot - 1);

        return new CommandResult(String.format(MESSAGE_CONFIRM_EVENT_SUCCESS, eventToConfirm));

    }

}
```
