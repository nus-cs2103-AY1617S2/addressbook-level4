# A0131125Y
###### /java/seedu/toluist/commons/core/Config.java
``` java
package seedu.toluist.commons.core;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;

import seedu.toluist.commons.exceptions.DataConversionException;
import seedu.toluist.commons.util.JsonUtil;
import seedu.toluist.model.AliasTable;

/**
 * Config values used by the app
 * Since Config is largely a global state, singleton pattern can be largely applied here
 */
public class Config {
    private static final Logger logger = LogsCenter.getLogger(Config.class);
    public static final String DEFAULT_CONFIG_FILE_PATH = "data/config.json";
    public static final String DEFAULT_TODO_LIST_FILE_PATH = "data/todolist.json";
    public static final String APP_NAME = "ToLuist App";

    private static Config instance;
    private static String configFilePath = DEFAULT_CONFIG_FILE_PATH;

    // Config values customizable through config file
    private final String appTitle = APP_NAME;
    private Level logLevel = Level.INFO;
    private AliasTable aliasTable = new AliasTable();
    private String todoListFilePath = DEFAULT_TODO_LIST_FILE_PATH;
    private GuiSettings guiSettings = new GuiSettings();

    /**
     * Load config from disk
     * @return Config data
     */
    public static Config getInstance() {
        if (instance == null) {
            try {
                instance = JsonUtil.readJsonFile(configFilePath, Config.class).orElse(new Config());
            } catch (DataConversionException e) {
                instance = new Config();
            }
        }
        return instance;
    }

    /**
     * Save config to disk
     * @return true if successful, false otherwise
     */
    public boolean save() {
        try {
            JsonUtil.saveJsonFile(this, configFilePath);
            return true;
        } catch (IOException e) {
            logger.severe("Saving config failed");
            return false;
        }
    }

    public static void setConfigFilePath(String configFilePath) {
        Config.configFilePath = configFilePath;
    }

    public void setTodoListFilePath(String todoListFilePath) {
        this.todoListFilePath = todoListFilePath;
    }

    public void setLogLevel(Level logLevel) {
        this.logLevel = logLevel;
    }

    public void setGuiSettings(GuiSettings guiSettings) {
        this.guiSettings = guiSettings;
    }

    public String getTodoListFilePath() {
        return todoListFilePath;
    }

    public String getAppTitle() {
        return appTitle;
    }

    public Level getLogLevel() {
        return logLevel;
    }

    public AliasTable getAliasTable() {
        return aliasTable;
    }

    public GuiSettings getGuiSettings() {
        return guiSettings;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Config // instanceof handles nulls
                && appTitle.equals(((Config) other).appTitle)
                && logLevel.equals(((Config) other).logLevel)
                && todoListFilePath.equals(((Config) other).todoListFilePath)
                && aliasTable.equals(((Config) other).aliasTable)
                && guiSettings.equals(((Config) other).guiSettings));
    }
}
```
###### /java/seedu/toluist/commons/core/Messages.java
``` java
package seedu.toluist.commons.core;

/**
 * Container for user visible messages.
 */
public class Messages {
    public static final String MESSAGE_UNKNOWN_COMMAND = "Unknown command";
    public static final String MESSAGE_INVALID_TASK_INDEX = "A valid task index was not provided";
    public static final String MESSAGE_SAVING_FAILURE = "The data could not be saved";
    public static final String MESSAGE_STORAGE_SAME_LOCATION = "Current storage path is already set to %s.";
    public static final String MESSAGE_NO_STORAGE_PATH = "No storage path was provided.";
    public static final String MESSAGE_SET_STORAGE_FAILURE = "The storage path %s is invalid.";
    public static final String MESSAGE_SET_STORAGE_SUCCESS = "Data storage path was changed to %s.";
}
```
###### /java/seedu/toluist/commons/core/SwitchConfig.java
``` java
package seedu.toluist.commons.core;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Optional;

import seedu.toluist.model.TaskSwitchPredicate;

/**
 * Store the mapping for each tab & keyword
 */
public class SwitchConfig {
    private ArrayList<TaskSwitchPredicate> predicateArrayList = new ArrayList<>();
    private HashMap<String, TaskSwitchPredicate> keywordPredicateMapping = new HashMap<>();

    public static SwitchConfig getDefaultSwitchConfig() {
        SwitchConfig switchConfig = new SwitchConfig();
        switchConfig.setPredicate(TaskSwitchPredicate.SWITCH_PREDICATE_INCOMPLETE, "i", "1");
        switchConfig.setPredicate(TaskSwitchPredicate.SWITCH_PREDICATE_TODAY, "t", "2");
        switchConfig.setPredicate(TaskSwitchPredicate.SWITCH_PREDICATE_NEXT_7_DAYS, "n", "3");
        switchConfig.setPredicate(TaskSwitchPredicate.COMPLETED_SWITCH_PREDICATE, "c", "4");
        switchConfig.setPredicate(TaskSwitchPredicate.SWITCH_PREDICATE_ALL, "a", "5");
        return switchConfig;
    }

    /**
     * Add predicate to config with matching keywords
     * @param predicate the predicate
     * @param keywords varargs of keywords
     */
    public void setPredicate(TaskSwitchPredicate predicate, String... keywords) {
        if (!predicateArrayList.contains(predicate)) {
            predicateArrayList.add(predicate);
        }

        for (String keyword : keywords) {
            keywordPredicateMapping.put(keyword.toLowerCase(), predicate);
        }
    }

    /**
     * Return matching predicate for a keyword
     * @param keyword
     * @return a present optional of the predicate if there is a match, Optional.empty() otherwise
     */
    public Optional<TaskSwitchPredicate> getPredicate(String keyword) {
        String normalizedKeyword = keyword.toLowerCase();
        if (!keywordPredicateMapping.containsKey(normalizedKeyword)) {
            return Optional.empty();
        }
        return Optional.of(keywordPredicateMapping.get(normalizedKeyword));
    }

    /**
     * Return lists of predicates
     */
    public List<TaskSwitchPredicate> getAllPredicates() {
        return predicateArrayList;
    }
}
```
###### /java/seedu/toluist/commons/util/CollectionUtil.java
``` java
    /**
     * Returns true if the two collections holds exactly the same set of items, and have same sizes
     */
    public static <T> boolean elementsAreSimilar(Collection<T> items1, Collection<T> items2) {
        for (T item1 : items1) {
            if (!items2.contains(item1)) {
                return false;
            }
        }
        return items1.size() == items2.size();
    }

    /**
     * Convert items to string, using each item's default toString method
     */
    public static <T> String toString(String delimiter, Collection<T> items) {
        List<String> itemStringList = items.stream().map(T::toString).collect(Collectors.toList());
        return String.join(delimiter, itemStringList);
    }
}
```
###### /java/seedu/toluist/commons/util/DateTimeFormatterUtil.java
``` java
package seedu.toluist.commons.util;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import seedu.toluist.model.Task.RecurringFrequency;

/**
 * A class to assist in formatting date
 */
public class DateTimeFormatterUtil {
    public static final String EVERY = "Every";
    public static final String OF_THE = "of the";
    public static final String TO = "to";
    public static final String UNTIL = "until";
    public static final String TASK_DEADLINE = "by ";
    public static final String EVENT_TO = " to ";
    public static final String YESTERDAY = "yesterday";
    public static final String TODAY = "today";
    public static final String TOMORROW = "tomorrow";
    public static final String DAY = "day";
    public static final String WEEK = "week";
    public static final String MONTH = "month";
    public static final String YEAR = "year";
    public static final String FORMAT_DAY_OF_WEEK = "EEEE";
    public static final String FORMAT_DAY_OF_MONTH = "d";
    public static final String FORMAT_MONTH_OF_YEAR = "MMMM";
    public static final String FORMAT_DATE = "E, dd MMM yyy";
    public static final String FORMAT_TIME = "hh:mm a";
    public static final String DATE_TIME_SEPARATOR = ", ";
    public static final String RECURRING_DATE_SEPARATOR = " ";
    public static final String SUFFIX_FIRST = "st";
    public static final String SUFFIX_SECOND = "nd";
    public static final String SUFFIX_THIRD = "rd";
    public static final String SUFFIX_FOURTH_ONWARDS = "th";

    /**
     * Format task deadline
     */
    public static String formatTaskDeadline(LocalDateTime deadline) {
        return TASK_DEADLINE + formatDate(deadline) + DATE_TIME_SEPARATOR + formatTime(deadline);
    }

    /**
     * Format event range
     */
    public static String formatEventRange(LocalDateTime from, LocalDateTime to) {
        String dateFrom = formatDate(from);
        String dateTo = formatDate(to);
        String timeFrom = formatTime(from);
        String timeTo = formatTime(to);

        if (dateFrom.equals(dateTo)) {
            return dateFrom + DATE_TIME_SEPARATOR + timeFrom + EVENT_TO + timeTo;
        } else {
            return dateFrom + DATE_TIME_SEPARATOR + timeFrom + EVENT_TO + dateTo + DATE_TIME_SEPARATOR + timeTo;
        }
    }

```
###### /java/seedu/toluist/commons/util/DateTimeFormatterUtil.java
``` java
    public static String formatDateOfYear(LocalDateTime dateTime) {
        String formattedDay = formatDayOfMonth(dateTime);
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(FORMAT_MONTH_OF_YEAR);
        String formattedMonth = dateTime.format(formatter);
        return String.join(" ", formattedDay, formattedMonth);
    }

    public static String formatDate(LocalDateTime dateTime) {
        if (DateTimeUtil.isToday(dateTime)) {
            return TODAY;
        } else if (DateTimeUtil.isTomorrow(dateTime)) {
            return TOMORROW;
        } else if (DateTimeUtil.isYesterday(dateTime)) {
            return YESTERDAY;
        }
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(FORMAT_DATE);
        return dateTime.format(formatter);
    }


    public static String formatTime(LocalDateTime dateTime) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(FORMAT_TIME);
        return dateTime.format(formatter);
    }

```
###### /java/seedu/toluist/commons/util/DateTimeUtil.java
``` java
package seedu.toluist.commons.util;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Date;
import java.util.List;
import java.util.Objects;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

/**
 * Utility class for DateTime
 */
public class DateTimeUtil {
```
###### /java/seedu/toluist/commons/util/DateTimeUtil.java
``` java
    /**
     * Check if datetime is from today
     *
     * @param dateTime a datetime
     * @return true / false
     */
    public static boolean isToday(LocalDateTime dateTime) {
        LocalDate today = LocalDate.now();
        LocalDate date = dateTime.toLocalDate();
        return date.equals(today);
    }

    /**
     * Check if datetime is from yesterday
     *
     * @param dateTime a datetime
     * @return true / false
     */
    public static boolean isYesterday(LocalDateTime dateTime) {
        LocalDate yesterday = LocalDate.now().plusDays(-1);
        LocalDate date = dateTime.toLocalDate();
        return date.equals(yesterday);
    }

    /**
     * Check if datetime is from tomorrow
     *
     * @param dateTime a datetime
     * @return true / false
     */
    public static boolean isTomorrow(LocalDateTime dateTime) {
        LocalDate tomorrow = LocalDate.now().plusDays(1);
        LocalDate date = dateTime.toLocalDate();
        return date.equals(tomorrow);
    }

    /**
     * Check if a dateTime is before or equal to another datetime
     * null dateTime is considered to be after
     * @param dateTime1
     * @param dateTime2
     * @return true / false
     */
    public static boolean isBeforeOrEqual(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        if (Objects.equals(dateTime1, dateTime2)) {
            return true;
        }
        if (dateTime2 == null) {
            return true;
        }
        if (dateTime1 == null) {
            return false;
        }
        return dateTime1.isBefore(dateTime2);
    }
}
```
###### /java/seedu/toluist/commons/util/FileUtil.java
``` java
    /**
     * Remove a file
     *
     * @return true if file is removed, false otherwise
     */
    public static boolean removeFile(File file) {
        if (!file.exists()) {
            return true;
        }

        return file.delete();
    }

```
###### /java/seedu/toluist/commons/util/FileUtil.java
``` java
    /**
     * Converts a string to a platform-specific file path
     * @param pathWithForwardSlash A String representing a file path but using '/' as the separator
     * @return {@code pathWithForwardSlash} but '/' replaced with {@code File.separator}
     */
    public static String getPath(String pathWithForwardSlash) {
        assert pathWithForwardSlash != null;
        assert pathWithForwardSlash.contains("/");
        return pathWithForwardSlash.replace("/", File.separator);
    }

    /**
     * Converts a string to a file
     * @param path A String representing a file path
     * @return a new File
     */
    public static File getFile(String path) {
        String normalizedPath = path.replace("/", File.separator);
        return new File(normalizedPath);
    }

}
```
###### /java/seedu/toluist/commons/util/FxViewUtil.java
``` java
    /**
     * Apply anchor 0 to all 4 corners of a node, making it take the width of the parent
     * @param node a given node
     */
    public static void makeFullWidth(Node node) {
        applyAnchorBoundaryParameters(node, 0.0, 0.0, 0.0, 0.0);
    }

    /**
     * Add a style class to a node. Style class won't be re-added if the node already has it
     * @param node a given node
     * @param styleClass a given style class string
     */
    public static void addStyleClass(Node node, String styleClass) {
        if (!node.getStyleClass().contains(styleClass)) {
            node.getStyleClass().add(styleClass);
        }
    }

    /**
     * Remove a style class from a node
     * @param node a node
     * @param styleClass a style class string
     */
    public static void removeStyleClass(Node node, String styleClass) {
        node.getStyleClass().remove(styleClass);
    }

    /**
     * Sets the key combination on node.
     * @param keyCombination the KeyCombination value of the accelerator
     * @param handler the event handler
     */
    public static void setKeyCombination(Node node, KeyCombination keyCombination,
                                         EventHandler<ActionEvent> handler) {
        node.addEventFilter(KeyEvent.KEY_PRESSED, event -> {
            if (keyCombination.match(event)) {
                handler.handle(new ActionEvent());
                event.consume();
            }
        });
    }

}
```
###### /java/seedu/toluist/commons/util/StringUtil.java
``` java
    /**
     * Given a noun and a count, return the count followed by the noun in singular/plural form appropriately
     * E.g:
     * "word", 1 -> "1 word"
     * "cat", 2 -> "2 cats"
     * @param noun a noun
     * @param count the quantity
     * @return noun with count
     */
    public static String nounWithCount(String noun, int count) {
        return count + " " + English.plural(noun, count);
    }

```
###### /java/seedu/toluist/controller/AliasController.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.toluist.commons.core.Config;
import seedu.toluist.model.AliasTable;
import seedu.toluist.ui.commons.CommandResult;

/**
 * Alias Controller is responsible for handling alias requests
 */
public class AliasController extends Controller {
    public static final String PARAMETER_ALIAS = "alias";
    public static final String PARAMETER_COMMAND = "command";
    public static final String COMMAND_WORD = "alias";

    private static final String RESULT_MESSAGE_SUCCESS = "Alias %s for %s was added";
    private static final String RESULT_MESSAGE_FAILURE = "Alias %s for %s could not be added";
    public static final String RESULT_MESSAGE_RESERVED_WORD = "%s is a reserved word";
    private static final String COMMAND_TEMPLATE = "(?iu)\\s*alias\\s+(?<alias>\\S+)\\s+(?<command>.+)";

    private final AliasTable aliasConfig = Config.getInstance().getAliasTable();

    public void execute(String command) {
        HashMap<String, String> tokens = tokenize(command);
        String alias = tokens.get(PARAMETER_ALIAS);
        String commandPhrase = tokens.get(PARAMETER_COMMAND);

        if (aliasConfig.isReservedWord(alias)) {
            uiStore.setCommandResult(
                    new CommandResult(String.format(RESULT_MESSAGE_RESERVED_WORD, alias)));
            return;
        }

        if (aliasConfig.setAlias(alias, commandPhrase) && Config.getInstance().save()) {
            uiStore.setCommandResult(
                    new CommandResult(String.format(RESULT_MESSAGE_SUCCESS, alias, commandPhrase)));
        } else {
            uiStore.setCommandResult(
                    new CommandResult(String.format(RESULT_MESSAGE_FAILURE, alias, commandPhrase)));
        }
    }

    public HashMap<String, String> tokenize(String command) {
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put(PARAMETER_ALIAS, matcher.group(PARAMETER_ALIAS));
        tokens.put(PARAMETER_COMMAND, matcher.group(PARAMETER_COMMAND));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public static String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }
}
```
###### /java/seedu/toluist/controller/Controller.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;

import seedu.toluist.ui.UiStore;


/**
 * Abstract Controller class
 * Controllers are in charge of receiving the input from the UI,
 * modifies the models as appropriate, and render the updated UI subsequently
 */
public abstract class Controller {
    /**
     * UiStore to store data to be used by Ui
     */
    protected final UiStore uiStore = UiStore.getInstance();

    /**
     * Given a command string, execute the command
     * and modifies the data appropriately. Also optionally
     * update the UI
     * @param command
     */
    public abstract void execute(String command);

    /**
     * Given command string, tokenize the string into
     * a dictionary of tokens
     * @param command
     * @return
     */
    public abstract HashMap<String, String> tokenize(String command);

    /**
     * Check if Controller can handle this command
     * @param command
     * @return
     */
    public abstract boolean matchesCommand(String command);

    /**
     * Returns command word(s) used by controller
     */
    public static String[] getCommandWords() {
        return new String[] {};
    }
}
```
###### /java/seedu/toluist/controller/ExitController.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;

import seedu.toluist.commons.core.EventsCenter;
import seedu.toluist.commons.events.ui.ExitAppRequestEvent;

/**
 * Handle exit command
 */
public class ExitController extends Controller {
    public static final String COMMAND_WORD_EXIT = "exit";
    public static final String COMMAND_WORD_QUIT = "quit";
    private static final String COMMAND_TEMPLATE = "(?iu)^\\s*(exit|quit)\\s*";

    public void execute(String command) {
        EventsCenter.getInstance().post(new ExitAppRequestEvent());
    }

    public HashMap<String, String> tokenize(String command) {
        return null; // not used
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public static String[] getCommandWords() {
        return new String[] { COMMAND_WORD_EXIT, COMMAND_WORD_QUIT };
    }
}
```
###### /java/seedu/toluist/controller/LoadController.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.core.Messages;
import seedu.toluist.commons.exceptions.DataStorageException;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.UiStore;
import seedu.toluist.ui.commons.CommandResult;

/**
 * Responsible for loading-related task
 */
public class LoadController extends Controller {
    private static final Logger logger = LogsCenter.getLogger(LoadController.class);
    private static final String COMMAND_TEMPLATE = "(?iu)^\\s*load(\\s+(?<directory>\\S+))?\\s*";
    public static final String COMMAND_WORD = "load";
    public static final String PARAMETER_STORE_DIRECTORY = "directory";

    public void execute(String command) {
        logger.info(getClass() + "will handle command");
        HashMap<String, String> tokens = tokenize(command);
        String path = tokens.get(PARAMETER_STORE_DIRECTORY);

        if (path == null) {
            uiStore.setCommandResult(new CommandResult(Messages.MESSAGE_NO_STORAGE_PATH));
            return;
        }

        Config config = Config.getInstance();
        String oldStoragePath = config.getTodoListFilePath();
        if (oldStoragePath.equals(path)) {
            uiStore.setCommandResult(
                    new CommandResult(String.format(Messages.MESSAGE_STORAGE_SAME_LOCATION, path)));
            return;
        }

        try {
            TodoList todoList = TodoList.getInstance();
            todoList.load(path);
            UiStore.getInstance().setTasks(todoList.getTasks());
            uiStore.setCommandResult(
                    new CommandResult(String.format(Messages.MESSAGE_SET_STORAGE_SUCCESS, path)));
        } catch (DataStorageException e) {
            uiStore.setCommandResult(
                    new CommandResult(String.format(Messages.MESSAGE_SET_STORAGE_FAILURE, path)));
        }
    }

    public HashMap<String, String> tokenize(String command) {
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put(PARAMETER_STORE_DIRECTORY, matcher.group(PARAMETER_STORE_DIRECTORY));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public static String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }
}
```
###### /java/seedu/toluist/controller/MarkController.java
``` java
package seedu.toluist.controller;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.atteo.evo.inflector.English;

import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.core.Messages;
import seedu.toluist.commons.util.CollectionUtil;
import seedu.toluist.controller.commons.IndexParser;
import seedu.toluist.model.Task;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.UiStore;
import seedu.toluist.ui.commons.CommandResult;

/**
 * Mark Controller is responsible for marking task complete or incomplete
 */
public class MarkController extends Controller {
    private static final String RESULT_MESSAGE_COMPLETED_SUCCESS = "%s %s marked completed";
    private static final String RESULT_MESSAGE_INCOMPLETE_SUCCESS = "%s %s marked incomplete";
    private static final String COMMAND_TEMPLATE = "(?iu)^\\s*mark(\\s+(?<markType>(complete|incomplete)))" +
            "?(?<index>.*)?\\s*";
    private static final String COMMAND_WORD = "mark";

    private static final String PARAMETER_MARK = "markType";
    private static final String PARAMETER_INDEX = "index";
    private static final String PARAMETER_MARK_COMPLETE = "complete";
    private static final String PARAMETER_MARK_INCOMPLETE = "incomplete";
    private static final Logger logger = LogsCenter.getLogger(MarkController.class);

    public void execute(String command) {
        logger.info(getClass().toString() + " will handle command");

        HashMap<String, String> tokens = tokenize(command);
        String indexToken = tokens.get(PARAMETER_INDEX);
        String markTypeToken = tokens.get(PARAMETER_MARK);
        List<Integer> indexes = IndexParser.splitStringToIndexes(indexToken,
                UiStore.getInstance().getShownTasks().size());

        if (indexes.isEmpty()) {
            uiStore.setCommandResult(new CommandResult(Messages.MESSAGE_INVALID_TASK_INDEX));
            return;
        }

        CommandResult commandResult;
        if (Objects.equals(markTypeToken, PARAMETER_MARK_INCOMPLETE)) {
            commandResult = mark(indexes, false);
        } else {
            commandResult = mark(indexes, true);
        }

        TodoList todoList = TodoList.getInstance();
        if (!todoList.save()) {
            uiStore.setCommandResult(new CommandResult(Messages.MESSAGE_SAVING_FAILURE));
        }
        UiStore.getInstance().setTasks(todoList.getTasks());
        uiStore.setCommandResult(commandResult);
    }

    private CommandResult mark(List<Integer> taskIndexes, boolean isCompleted) {
        ArrayList<Task> tasks = UiStore.getInstance().getShownTasks(taskIndexes);
        for (Task task : tasks) {
            if (task.canUpdateToNextRecurringTask()) {
                task.updateToNextRecurringTask();
            } else {
                task.setCompleted(isCompleted);
            }
        }
        String indexString = CollectionUtil.toString(", ", taskIndexes);
        String messageTemplate = isCompleted
                ? RESULT_MESSAGE_COMPLETED_SUCCESS
                : RESULT_MESSAGE_INCOMPLETE_SUCCESS;
        return new CommandResult(String.format(messageTemplate,
                English.plural("Task", taskIndexes.size()), indexString));
    }

    public HashMap<String, String> tokenize(String command) {
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put(PARAMETER_MARK, matcher.group(PARAMETER_MARK));
        tokens.put(PARAMETER_INDEX, matcher.group(PARAMETER_INDEX));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public static String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }
}
```
###### /java/seedu/toluist/controller/RedoController.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javafx.util.Pair;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.commons.CommandResult;

/**
 * Responsible for redo-related task
 */
public class RedoController extends Controller {
    private static final String COMMAND_TEMPLATE = "(?iu)^\\s*redo(\\s+(?<number>\\d+))?\\s*";
    private static final String COMMAND_WORD = "redo";
    private static final String PARAMETER_REDO_TIMES = "number";
    private static final String RESULT_MESSAGE_TEMPLATE = "Your last undone %s %s re-applied.";

    private static final Logger logger = LogsCenter.getLogger(RedoController.class);

    public void execute(String command) {
        logger.info(getClass() + "will handle command");

        HashMap<String, String> tokens = tokenize(command);
        String redoTimesToken = tokens.get(PARAMETER_REDO_TIMES);
        int redoTimes = redoTimesToken != null ? Integer.parseInt(redoTimesToken) : 1;

        Pair<TodoList, Integer> redoResult = TodoList.getInstance().getStorage().redo(redoTimes);
        TodoList todoList = TodoList.getInstance();
        todoList.setTasks(redoResult.getKey().getTasks());
        int actualRedoTimes = redoResult.getValue();

        uiStore.setTasks(todoList.getTasks());

        uiStore.setCommandResult(new CommandResult(String.format(RESULT_MESSAGE_TEMPLATE,
                StringUtil.nounWithCount("change", actualRedoTimes),
                actualRedoTimes == 1 ? "was" : "were")));
    }

    public HashMap<String, String> tokenize(String command) {
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put(PARAMETER_REDO_TIMES, matcher.group(PARAMETER_REDO_TIMES));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public static String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }
}
```
###### /java/seedu/toluist/controller/StoreController.java
``` java
package seedu.toluist.controller;

import java.io.File;
import java.util.HashMap;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.core.Messages;
import seedu.toluist.commons.util.FileUtil;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.commons.CommandResult;

/**
 * Responsible for saving-related task
 */
public class StoreController extends Controller {
    private static final Logger logger = LogsCenter.getLogger(StoreController.class);
    private static final String COMMAND_TEMPLATE = "(?iu)^\\s*save(\\s+(?<directory>\\S+))?\\s*";
    public static final String COMMAND_WORD = "save";
    public static final String PARAMETER_STORE_DIRECTORY = "directory";

    public static final String RESULT_MESSAGE_WARNING_OVERWRITE = "A file exists at %s. This file will be overwritten.";

    public void execute(String command) {
        logger.info(getClass() + "will handle command");
        HashMap<String, String> tokens = tokenize(command);
        String path = tokens.get(PARAMETER_STORE_DIRECTORY);

        if (path == null) {
            uiStore.setCommandResult(new CommandResult(Messages.MESSAGE_NO_STORAGE_PATH));
            return;
        }

        Config config = Config.getInstance();
        if (config.getTodoListFilePath().equals(path)) {
            uiStore.setCommandResult(
                    new CommandResult(String.format(Messages.MESSAGE_STORAGE_SAME_LOCATION, path)));
            return;
        }

        String message = "";
        if (FileUtil.isFileExists(new File(path))) {
            message += String.format(RESULT_MESSAGE_WARNING_OVERWRITE, path) + "\n";
        }

        if (TodoList.getInstance().getStorage().move(path)) {
            message += String.format(Messages.MESSAGE_SET_STORAGE_SUCCESS, config.getTodoListFilePath());
            uiStore.setCommandResult(new CommandResult(message));
        } else {
            uiStore.setCommandResult(
                    new CommandResult(String.format(Messages.MESSAGE_SET_STORAGE_FAILURE, path)));
        }
    }

    public HashMap<String, String> tokenize(String command) {
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put(PARAMETER_STORE_DIRECTORY, matcher.group(PARAMETER_STORE_DIRECTORY));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public static String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }
}
```
###### /java/seedu/toluist/controller/SwitchController.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.toluist.commons.core.SwitchConfig;
import seedu.toluist.model.TaskSwitchPredicate;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.UiStore;
import seedu.toluist.ui.commons.CommandResult;

/**
 * Handle switch tab command
 */
public class SwitchController extends Controller {
    public static final String RESULT_MESSAGE_SWITCH_SUCCESS_FILTERED = "Switched to tab %s."
        + " Showing %d out of %d filtered tasks.";
    public static final String RESULT_MESSAGE_SWITCH_SUCCESS_ALL = "Switched to tab %s."
            + " Showing %d out of all %d existing tasks.";
    public static final String RESULT_MESSAGE_SWITCH_FAILURE = "%s is not a valid tab.";
    public static final String RESULT_MESSAGE_NO_TAB = "A tab to switch to was not provided";
    public static final String COMMAND_WORD = "switch";
    public static final String PARAMETER_TAB = "tab";
    private static final String COMMAND_TEMPLATE = "(?iu)^\\s*switch(\\s+(?<tab>\\S+))?\\s*";
    private SwitchConfig switchConfig = SwitchConfig.getDefaultSwitchConfig();

    public void execute(String command) {
        HashMap<String, String> tokens = tokenize(command);
        String keyword = tokens.get(PARAMETER_TAB);

        if (keyword == null) {
            uiStore.setCommandResult(new CommandResult(RESULT_MESSAGE_NO_TAB));
            return;
        }

        Optional<TaskSwitchPredicate> switchPredicateOptional = switchConfig.getPredicate(keyword);

        if (!switchPredicateOptional.isPresent()) {
            uiStore.setCommandResult(
                    new CommandResult(String.format(RESULT_MESSAGE_SWITCH_FAILURE, keyword)));
            return;
        }

        String messageTemplate = uiStore.getTasks().size() == TodoList.getInstance().getTasks().size()
                ? RESULT_MESSAGE_SWITCH_SUCCESS_ALL
                : RESULT_MESSAGE_SWITCH_SUCCESS_FILTERED;
        TaskSwitchPredicate switchPredicate = switchPredicateOptional.get();
        UiStore.getInstance().setObservableSwitchPredicate(switchPredicate);

        uiStore.setCommandResult(new CommandResult(String.format(
                messageTemplate,
                switchPredicate.getDisplayName(),
                UiStore.getInstance().getShownTasks().size(),
                UiStore.getInstance().getTasks().size())));
    }

    public HashMap<String, String> tokenize(String command) {
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put(PARAMETER_TAB, matcher.group(PARAMETER_TAB));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public static String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }
}
```
###### /java/seedu/toluist/controller/UnaliasController.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.toluist.commons.core.Config;
import seedu.toluist.model.AliasTable;
import seedu.toluist.ui.commons.CommandResult;

/**
 * Alias Controller is responsible for handling unalias requests
 */
public class UnaliasController extends Controller {
    private static final String RESULT_MESSAGE_SUCCESS = "Alias %s has been removed";
    private static final String RESULT_MESSAGE_FAILURE = "Alias %s cannot be removed";
    public static final String RESULT_MESSAGE_NOT_ALIAS = "%s is not an alias";
    private static final String COMMAND_TEMPLATE = "(?iu)^\\s*unalias\\s+(?<alias>\\S+)\\s*";
    private static final String COMMAND_WORD = "unalias";

    private static final String PARAMETER_ALIAS = "alias";

    private final AliasTable aliasConfig = Config.getInstance().getAliasTable();

    public void execute(String command) {
        HashMap<String, String> tokens = tokenize(command);
        String alias = tokens.get(PARAMETER_ALIAS);

        if (!aliasConfig.isAlias(alias)) {
            uiStore.setCommandResult(new CommandResult(String.format(RESULT_MESSAGE_NOT_ALIAS, alias)));
            return;
        }

        if (aliasConfig.removeAlias(alias) && Config.getInstance().save()) {
            uiStore.setCommandResult(new CommandResult(String.format(RESULT_MESSAGE_SUCCESS, alias)));
        } else {
            uiStore.setCommandResult(new CommandResult(String.format(RESULT_MESSAGE_FAILURE, alias)));
        }
    }

    public HashMap<String, String> tokenize(String command) {
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put(PARAMETER_ALIAS, matcher.group(PARAMETER_ALIAS));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public static String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }
}
```
###### /java/seedu/toluist/controller/UndoController.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javafx.util.Pair;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.commons.CommandResult;

/**
 * Responsible for storage-related task
 */
public class UndoController extends Controller {
    private static final String COMMAND_TEMPLATE = "(?iu)^\\s*undo(\\s+(?<number>\\d+))?\\s*";
    private static final String COMMAND_WORD = "undo";
    private static final String PARAMETER_UNDO_TIMES = "number";
    private static final String RESULT_MESSAGE_TEMPLATE = "Your last %s to the data %s undone.";

    private static final Logger logger = LogsCenter.getLogger(UndoController.class);

    public void execute(String command) {
        logger.info(getClass() + "will handle command");

        HashMap<String, String> tokens = tokenize(command);
        String undoTimesToken = tokens.get(PARAMETER_UNDO_TIMES);
        int undoTimes = undoTimesToken != null ? Integer.parseInt(undoTimesToken) : 1;

        Pair<TodoList, Integer> undoResult = TodoList.getInstance().getStorage().undo(undoTimes);
        TodoList todoList = TodoList.getInstance();
        todoList.setTasks(undoResult.getKey().getTasks());
        int actualUndoTimes =  undoResult.getValue();

        uiStore.setTasks(todoList.getTasks());

        uiStore.setCommandResult(new CommandResult(String.format(RESULT_MESSAGE_TEMPLATE,
                StringUtil.nounWithCount ("change", actualUndoTimes),
                actualUndoTimes == 1 ? "was" : "were")));
    }

    public HashMap<String, String> tokenize(String command) {
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put(PARAMETER_UNDO_TIMES, matcher.group(PARAMETER_UNDO_TIMES));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public static String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }
}
```
###### /java/seedu/toluist/controller/UnknownCommandController.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;

import seedu.toluist.commons.core.Messages;
import seedu.toluist.ui.commons.CommandResult;

/**
 * UnknownCommandController is responsible for rendering the initial UI
 */
public class UnknownCommandController extends Controller {

    public void execute(String command) {
        uiStore.setCommandResult(new CommandResult(Messages.MESSAGE_UNKNOWN_COMMAND));
    }

    public HashMap<String, String> tokenize(String command) {
        return null; // not used
    }

    public boolean matchesCommand(String command) {
        return true; // matches everything
    }
}
```
###### /java/seedu/toluist/controller/ViewAliasController.java
``` java
package seedu.toluist.controller;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.SortedSet;
import java.util.TreeSet;

import seedu.toluist.commons.core.Config;
import seedu.toluist.model.AliasTable;
import seedu.toluist.ui.commons.CommandResult;

/**
 * Alias Controller is responsible for handling viewalias requests
 */
public class ViewAliasController extends Controller {
    private static final String COMMAND_TEMPLATE = "(?iu)^\\s*viewalias\\s*";
    private static final String COMMAND_WORD = "viewalias";
    private static final String COMMAND_SEPARATOR_ALIAS = ":";
    private static final String NEW_LINE = "\n";
    public static final String RESULT_MESSAGE_NO_ALIAS = "No aliases found";

    private final AliasTable aliasConfig = Config.getInstance().getAliasTable();

    public void execute(String command) {
        Map<String, String> aliasMapping = aliasConfig.getAliasMapping();
        uiStore.setCommandResult(new CommandResult(getAliasCommandResult(aliasMapping)));
    }

    public HashMap<String, String> tokenize(String command) {
        return null; // not used
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public static String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }

    private String getAliasCommandResult(Map<String, String> aliasMapping) {
        ArrayList<String> lines = new ArrayList<>();

        SortedSet<String> aliases = new TreeSet<>(aliasMapping.keySet());
        for (String alias : aliases) {
            String line = alias + COMMAND_SEPARATOR_ALIAS + aliasMapping.get(alias);
            lines.add(line);
        }

        String result = String.join(NEW_LINE, lines);
        return result.isEmpty() ? RESULT_MESSAGE_NO_ALIAS : result;
    }
}
```
###### /java/seedu/toluist/dispatcher/CommandDispatcher.java
``` java
package seedu.toluist.dispatcher;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.logging.Logger;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.controller.AddTaskController;
import seedu.toluist.controller.AliasController;
import seedu.toluist.controller.ClearController;
import seedu.toluist.controller.Controller;
import seedu.toluist.controller.DeleteTaskController;
import seedu.toluist.controller.ExitController;
import seedu.toluist.controller.FindController;
import seedu.toluist.controller.HistoryController;
import seedu.toluist.controller.LoadController;
import seedu.toluist.controller.MarkController;
import seedu.toluist.controller.RedoController;
import seedu.toluist.controller.StoreController;
import seedu.toluist.controller.SwitchController;
import seedu.toluist.controller.TagController;
import seedu.toluist.controller.UnaliasController;
import seedu.toluist.controller.UndoController;
import seedu.toluist.controller.UnknownCommandController;
import seedu.toluist.controller.UntagController;
import seedu.toluist.controller.UpdateTaskController;
import seedu.toluist.controller.ViewAliasController;

public class CommandDispatcher extends Dispatcher {
    private static final Logger logger = LogsCenter.getLogger(CommandDispatcher.class);

```
###### /java/seedu/toluist/dispatcher/CommandDispatcher.java
``` java
    public CommandDispatcher() {
        super();
        aliasConfig.setReservedKeywords(getControllerKeywords());
        commandHistory = new ArrayList<>();
    }

    public void dispatchRecordingHistory(String command) {
        recordCommand(command);
        dispatch(command);
    }

    public void dispatch(String command) {
        String deAliasedCommand = getDealiasedCommand(command);
        logger.info("De-aliased command to be dispatched: " + deAliasedCommand + " original command " + command);

        Controller controller = getBestFitController(deAliasedCommand);
        logger.info("Controller class to be executed: " + controller.getClass());

        if (controller instanceof HistoryController) {
            ((HistoryController) controller).setCommandHistory(commandHistory);
        }
        controller.execute(deAliasedCommand);
    }

    public SortedSet<String> getPredictedCommands(String command) {
        SortedSet<String> predictedCommands = new TreeSet<>();

        if (!StringUtil.isPresent(command)) {
            return predictedCommands;
        }

        String firstWordOfCommand = command.trim().split("\\s+")[0];

        Map<String, String> aliasMapping = aliasConfig.getAliasMapping();
        for (String alias : aliasMapping.keySet()) {
            if (StringUtil.startsWithIgnoreCase(alias, firstWordOfCommand)) {
                String replacedCommand = command.replaceFirst(Pattern.quote(firstWordOfCommand), alias);
                predictedCommands.add(getDealiasedCommand(replacedCommand));
            }
        }

        for (String commandWord : getControllerKeywords()) {
            if (StringUtil.startsWithIgnoreCase(commandWord, firstWordOfCommand)) {
                predictedCommands.add(command.replaceFirst(Pattern.quote(firstWordOfCommand), commandWord));
            }
        }

        logger.info("Predicted commands: " + predictedCommands.toString());
        return predictedCommands;
    }

    private String getDealiasedCommand(String command) {
        String trimmedCommand = command.trim();
        return aliasConfig.dealias(trimmedCommand);
    }

    private void recordCommand(String command) {
        commandHistory.add(command);
        historyPointer = commandHistory.size();
    }

```
###### /java/seedu/toluist/dispatcher/CommandDispatcher.java
``` java
    private Controller getBestFitController(String command) {
        Collection<Controller> controllerCollection = getAllControllers();

        return controllerCollection
                .stream()
                .filter(controller -> controller.matchesCommand(command))
                .findFirst()
                .orElse(new UnknownCommandController()); // fail-safe
    }

    private Collection<Class <? extends Controller>> getAllControllerClasses() {
        return new ArrayList<>(Arrays.asList(
                AddTaskController.class,
                ClearController.class,
                UpdateTaskController.class,
                DeleteTaskController.class,
                StoreController.class,
                HistoryController.class,
                LoadController.class,
                UndoController.class,
                RedoController.class,
                ExitController.class,
                AliasController.class,
                UnaliasController.class,
                ViewAliasController.class,
                UntagController.class,
                FindController.class,
                TagController.class,
                MarkController.class,
                SwitchController.class,
                UnknownCommandController.class
        ));
    }

    private Collection<Controller> getAllControllers() {
        return getAllControllerClasses()
                .stream()
                .map((Class<? extends Controller> klass) -> {
                    try {
                        Constructor constructor = klass.getConstructor();
                        return (Controller) constructor.newInstance();
                    } catch (NoSuchMethodException | InstantiationException
                            | IllegalAccessException | InvocationTargetException e) {
                        // fail-safe. But should not actually reach here
                        return new UnknownCommandController();
                    }
                })
                .collect(Collectors.toList());
    }

    private Set<String> getControllerKeywords() {
        List<String> keywordList = getAllControllerClasses()
                .stream()
                .map((Class<? extends Controller> klass) -> {
                    try {
                        final String methodName = "getCommandWords";
                        Method method = klass.getMethod(methodName);
                        return Arrays.asList((String[]) method.invoke(null));
                    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
                        return new ArrayList<String>();
                    }
                })
                .flatMap(List::stream)
                .collect(Collectors.toList());
        return new HashSet<>(keywordList);
    }
}
```
###### /java/seedu/toluist/dispatcher/Dispatcher.java
``` java
package seedu.toluist.dispatcher;

import java.util.SortedSet;

import seedu.toluist.commons.core.Config;
import seedu.toluist.model.AliasTable;

/**
 * Dispatcher is the bridge between the UI input & Controller
 * It acts like a Router in a MVC. From the input, it deduces what is the appropriate
 * the controller to dispatch the command to
 */
public abstract class Dispatcher {

    /**
     * Default alias config
     */
    protected AliasTable aliasConfig = Config.getInstance().getAliasTable();

    /**
     * Dispatch a command from the Ui to a suitable Controller
     * The command will be saved in the dispatcher's command history
     * @param command
     */
    public abstract void dispatchRecordingHistory(String command);

    /**
     * Dispatch a command from the Ui to a suitable Controller.
     * @param command command to be executed
     */
    public abstract void dispatch(String command);

    /**
     * Returns set of possible command extensions from a command
     * @param command a command
     */
    public abstract SortedSet<String> getPredictedCommands(String command);

    /**
     * Setter DI to inject a alias config as a dependency
     * @param aliasConfig an alias config
     */
    public void setAliasConfig(AliasTable aliasConfig) {
        this.aliasConfig = aliasConfig;
    }
}
```
###### /java/seedu/toluist/MainApp.java
``` java
package seedu.toluist;

import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.stage.Stage;
import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.core.EventsCenter;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.core.Version;
import seedu.toluist.commons.events.ui.ExitAppRequestEvent;
import seedu.toluist.dispatcher.CommandDispatcher;
import seedu.toluist.dispatcher.Dispatcher;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.Ui;
import seedu.toluist.ui.UiManager;

/**
 * The main entry point to the application.
 */
public class MainApp extends Application {
    private static final Logger logger = LogsCenter.getLogger(MainApp.class);

    public static final Version VERSION = new Version(1, 0, 0, true);

    protected Ui ui;
    protected Dispatcher dispatcher;
    protected Config config = Config.getInstance();


    @Override
    public void init() throws Exception {
        logger.info("=============================[ Initializing ToLuist ]===========================");
        super.init();

        initLogging(config);

        // Configure dependencies
        dispatcher = new CommandDispatcher();
        ui = UiManager.getInstance();
        ui.init(dispatcher);
        TodoList.getInstance().load();

        initEventsCenter();
    }

    private void initLogging(Config config) {
        LogsCenter.init(config);
    }

    private void initEventsCenter() {
        EventsCenter.getInstance().registerHandler(this);
    }

    @Override
    public void start(Stage primaryStage) {
        logger.info("Starting ToLuist " + MainApp.VERSION);
        ui.start(primaryStage);
    }

    @Override
    public void stop() {
        logger.info("============================ [ Stopping ToLuist ] =============================");
        ui.stop();
        Platform.exit();
        System.exit(0);
    }

    @Subscribe
    public void handleExitAppRequestEvent(ExitAppRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        this.stop();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
```
###### /java/seedu/toluist/model/AliasTable.java
``` java
package seedu.toluist.model;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import seedu.toluist.commons.util.StringUtil;

/**
 * A model to manage alias
 */
public class AliasTable {
    private Map<String, String> aliasMapping = new HashMap<>();
    private Set<String> reservedKeywords = new HashSet<>();

    public Map<String, String> getAliasMapping() {
        return aliasMapping;
    }

    /**
     * Set alias for a command. Returns success status
     * @param alias
     * @param command
     * @return true / false
     */
    public boolean setAlias(String alias, String command) {
        if (isReservedWord(alias)) {
            return false;
        }

        aliasMapping.put(alias, command);
        return true;
    }

    /**
     * Remove an alias. Return sucess status
     * @param alias
     * @return true / false
     */
    public boolean removeAlias(String alias) {
        aliasMapping.remove(alias);
        return true;
    }

    /**
     * Remove all aliases.
     */
    public void clearAliases() {
        aliasMapping.clear();
    }

    /**
     * Set reserved keywords
     * @param reservedKeywords
     */
    public void setReservedKeywords(Set<String> reservedKeywords) {
        this.reservedKeywords = reservedKeywords;
    }

    /**
     * Check if the alias is a reserved word
     * @param alias
     * @return true/false
     */
    public boolean isReservedWord(String alias) {
        return reservedKeywords.contains(alias);
    }

    /**
     * Check if argument is an alias
     * @param alias
     * @return true / false
     */
    public boolean isAlias(String alias) {
        return aliasMapping.containsKey(alias);
    }

    /**
     * Convert a command that possibly contains an alias prefix to one without
     * Recursive unpacking of alias is not supported
     * e.g if a is an alias for b, and b is an alias a, dealias(a) will return b
     * @param command
     * @return converted command
     */
    public String dealias(String command) {
        String[] wordsInCommand = command.split("\\s+");
        if (wordsInCommand.length == 0) {
            return command;
        }

        String firstWord = wordsInCommand[0];

        for (String alias : aliasMapping.keySet()) {
            if (firstWord.equals(alias)) {
                return StringUtil.replaceFirstWord(command, aliasMapping.get(alias));
            }
        }
        return command;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof AliasTable // instanceof handles nulls
                && reservedKeywords.equals(((AliasTable) other).reservedKeywords)
                && aliasMapping.equals(((AliasTable) other).aliasMapping));
    }
}
```
###### /java/seedu/toluist/model/Tag.java
``` java
package seedu.toluist.model;

/**
 * Tag model
 */
public class Tag implements Comparable<Tag> {

    public String tagName;

    public Tag() {}

    /**
     * Validates given tag name.
     */
    public Tag(String name) {
        assert name != null;
        String trimmedName = name.trim();
        this.tagName = trimmedName;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Tag // instanceof handles nulls
                && this.tagName.equals(((Tag) other).tagName)); // state check
    }

    @Override
    public int hashCode() {
        return tagName.hashCode();
    }

    @Override
    public int compareTo(Tag other) {
        return tagName.compareTo(other.tagName);
    }
}
```
###### /java/seedu/toluist/model/Task.java
``` java
package seedu.toluist.model;

import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.Collection;
import java.util.Objects;
import java.util.TreeSet;

import seedu.toluist.commons.util.DateTimeUtil;

/**
 * Represents a Task
 */
public class Task implements Comparable<Task> {
    private static final String HIGH_PRIORITY_STRING = "high";
    private static final String LOW_PRIORITY_STRING = "low";
    private static final String ERROR_VALIDATION_EMPTY_DESCRIPTION = "Description must not be empty.";
    private static final String ERROR_VALIDATION_START_DATE_AFTER_END_DATE = "Start date must be before end date.";
    private static final String ERROR_VALIDATION_UNCLASSIFIED_TASK = "Task cannot contain only start date.";
    private static final String ERROR_INVALID_PRIORITY_LEVEL = "Priority level must be either 'low' or 'high'.";
    private static final String ERROR_INVALID_RECURRING_FREQUENCY = "Recurring frequency must be either 'daily',"
            + "'weekly', 'monthly' or 'yearly'.";
    private static final String ERROR_INVALID_RECURRING_END_DATE = "Non-recurring tasks cannot have end "
            + "date of recurrence,";

    // List of tags is unique
    private TreeSet<Tag> allTags = new TreeSet<>();
    private String description;
    private LocalDateTime startDateTime;
    private LocalDateTime endDateTime;
    private LocalDateTime completionDateTime;
    private LocalDateTime recurringEndDateTime;
    private RecurringFrequency recurringFrequency;
    private TaskPriority priority = TaskPriority.LOW;

    public enum TaskPriority {
        HIGH, LOW
    }

    public enum RecurringFrequency {
        DAILY, WEEKLY, MONTHLY, YEARLY
    }

    /**
     * To be used with json deserialisation
     */
    public Task() {}

    public Task(String description) {
        this(description, null, null);
    }

    public Task(String description, LocalDateTime endDateTime) {
        this(description, null, endDateTime);
    }

```
###### /java/seedu/toluist/model/Task.java
``` java
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Task // instanceof handles nulls
                && this.description.equals(((Task) other).description)) // state check
                && this.priority.equals(((Task) other).priority)
                && this.allTags.equals(((Task) other).allTags)
                && Objects.equals(this.recurringFrequency, ((Task) other).recurringFrequency) // handles null
                && Objects.equals(this.startDateTime, ((Task) other).startDateTime) // handles null
                && Objects.equals(this.endDateTime, ((Task) other).endDateTime) // handles null
                && Objects.equals(this.completionDateTime, ((Task) other).completionDateTime) // handles null
                && Objects.equals(this.recurringEndDateTime, ((Task) other).recurringEndDateTime); // handles null
    }

    /**
     * Set a task as completed or incomplete
     * @param isCompleted true/false
     */
    public void setCompleted(boolean isCompleted) {
        if (isCompleted) {
            completionDateTime = LocalDateTime.now();
        } else {
            completionDateTime = null;
        }
    }

    /**
     * Set a deadline for a task
     * @param deadLine a LocalDateTime object
     */
    public void setDeadLine(LocalDateTime deadLine) {
        setStartDateTime(null);
        setEndDateTime(deadLine);
    }

    /**
     * Set a from and to date for an event
     * from should be before to
     * @param from a LocalDateTime object
     * @param to a LocalDateTime object
     */
    public void setFromTo(LocalDateTime from, LocalDateTime to) {
        assert DateTimeUtil.isBeforeOrEqual(startDateTime, endDateTime);
        setStartDateTime(from);
        setEndDateTime(to);
    }

```
###### /java/seedu/toluist/model/Task.java
``` java

    /**
     * Replace the tags in the task with the given tags
     * @param tags a collection of tags
     */
    public void replaceTags(Collection<Tag> tags) {
        this.allTags = new TreeSet<>(tags);
    }

    public TreeSet<Tag> getAllTags() {
        return allTags;
    }

    public boolean isOverdue() {
        return !isCompleted() && endDateTime != null && DateTimeUtil.isBeforeOrEqual(endDateTime, LocalDateTime.now());
    }

    public boolean isHighPriority() {
        return priority == TaskPriority.HIGH;
    }

    public boolean isFloatingTask() {
        return startDateTime == null && endDateTime == null;
    }

    public boolean isTaskWithDeadline() {
        return startDateTime == null && endDateTime != null;
    }

    public boolean isEvent() {
        return startDateTime != null && endDateTime != null;
    }

    public boolean isCompleted() {
        return completionDateTime != null && DateTimeUtil.isBeforeOrEqual(completionDateTime, LocalDateTime.now());
    }

    public boolean isRecurring() {
        return recurringFrequency != null;
    }

```
###### /java/seedu/toluist/model/Task.java
``` java
    /**
     * Check if the task datetimes are within interval
     * @param from interval from
     * @param to interval to
     * @return true / false
     */
    public boolean isWithinInterval(LocalDateTime from, LocalDateTime to) {
        boolean startDateTimeWithinInterval = from == null
                || (startDateTime != null
                && DateTimeUtil.isBeforeOrEqual(from, startDateTime)
                && DateTimeUtil.isBeforeOrEqual(startDateTime, to));
        boolean endDateTimeWithinInterval = to == null
                || (endDateTime != null
                && DateTimeUtil.isBeforeOrEqual(from, endDateTime)
                && DateTimeUtil.isBeforeOrEqual(endDateTime, to));
        return startDateTimeWithinInterval || endDateTimeWithinInterval;
    }

    @Override
    /**
     * Compare by overdue first -> priority -> end date -> start date -> description
     * Floating tasks are put to the end
     */
    public int compareTo(Task comparison) {
        if (isOverdue() != comparison.isOverdue()) {
            return isOverdue() ? -1 : 1;
        } else if (priority.compareTo(comparison.priority) != 0) {
            return priority.compareTo(comparison.priority);
        } else if (!Objects.equals(endDateTime, comparison.endDateTime)) {
            return DateTimeUtil.isBeforeOrEqual(endDateTime, comparison.endDateTime) ? -1 : 1;
        } else if (!Objects.equals(startDateTime, comparison.startDateTime)) {
            return DateTimeUtil.isBeforeOrEqual(startDateTime, comparison.startDateTime) ? -1 : 1;
        } else {
            return this.description.compareToIgnoreCase(comparison.description);
        }
    }

```
###### /java/seedu/toluist/model/Task.java
``` java
    public TaskPriority getTaskPriority() {
        return priority;
    }

    public void setTaskPriority(TaskPriority priority) {
        this.priority = priority;
    }

    public void setTaskPriority(String priorityString) throws IllegalArgumentException {
        switch (priorityString.toLowerCase()) {
        case HIGH_PRIORITY_STRING:
            setTaskPriority(TaskPriority.HIGH);
            break;
        case LOW_PRIORITY_STRING:
            setTaskPriority(TaskPriority.LOW);
            break;
        default:
            throw new IllegalArgumentException(ERROR_INVALID_PRIORITY_LEVEL);
        }
    }

    public LocalDateTime getCompletionDateTime() {
        return completionDateTime;
    }

```
###### /java/seedu/toluist/model/TaskSwitchPredicate.java
``` java
package seedu.toluist.model;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.function.Predicate;

/**
 * Predicates to filter tasks on switching tab
 */
public class TaskSwitchPredicate {
    public static final Predicate<Task> PREDICATE_ALL = task -> true;
    public static final Predicate<Task> PREDICATE_INCOMPLETE = task -> !task.isCompleted();
    public static final Predicate<Task> PREDICATE_COMPLETED = task -> task.isCompleted();
    public static final Predicate<Task> PREDICATE_TODAY = task -> {
        ZonedDateTime startOfTodayDatetime = ZonedDateTime.now().toLocalDate()
                .atStartOfDay(ZoneId.systemDefault());
        LocalDateTime startOfToday =  LocalDateTime
                .ofInstant(startOfTodayDatetime.toInstant(), ZoneId.systemDefault());

        ZonedDateTime endOfTodayDatetime = ZonedDateTime.now().toLocalDate()
                .atStartOfDay(ZoneId.systemDefault())
                .plusDays(1).minusSeconds(1);
        LocalDateTime endOfToday =  LocalDateTime
                .ofInstant(endOfTodayDatetime.toInstant(), ZoneId.systemDefault());

        return task.isWithinInterval(startOfToday, endOfToday);
    };
    public static final Predicate<Task> PREDICATE_NEXT_7_DAYS = task -> {
        ZonedDateTime startOfTomorrowDatetime = ZonedDateTime.now().toLocalDate()
                .plusDays(1).atStartOfDay(ZoneId.systemDefault());
        LocalDateTime startOfTomorrow =  LocalDateTime
                .ofInstant(startOfTomorrowDatetime.toInstant(), ZoneId.systemDefault());

        ZonedDateTime endOf7DaysDatetime = ZonedDateTime.now().toLocalDate()
                .atStartOfDay(ZoneId.systemDefault())
                .plusDays(8).minusSeconds(1);
        LocalDateTime endOf7Days =  LocalDateTime
                .ofInstant(endOf7DaysDatetime.toInstant(), ZoneId.systemDefault());

        return task.isWithinInterval(startOfTomorrow, endOf7Days);
    };
    public static final TaskSwitchPredicate SWITCH_PREDICATE_ALL =
            new TaskSwitchPredicate(PREDICATE_ALL, "ALL");
    public static final TaskSwitchPredicate SWITCH_PREDICATE_INCOMPLETE =
            new TaskSwitchPredicate(PREDICATE_INCOMPLETE, "INCOMPLETE");
    public static final TaskSwitchPredicate COMPLETED_SWITCH_PREDICATE =
            new TaskSwitchPredicate(PREDICATE_COMPLETED, "COMPLETED");
    public static final TaskSwitchPredicate SWITCH_PREDICATE_TODAY =
            new TaskSwitchPredicate(PREDICATE_TODAY, "TODAY");
    public static final TaskSwitchPredicate SWITCH_PREDICATE_NEXT_7_DAYS =
            new TaskSwitchPredicate(PREDICATE_NEXT_7_DAYS, "NEXT 7 DAYS");

    private final Predicate<Task> predicate;
    private final String displayName;

    public TaskSwitchPredicate(Predicate<Task> predicate, String displayName) {
        this.predicate = predicate;
        this.displayName = displayName;
    }

    public Predicate<Task> getPredicate() {
        return predicate;
    }

    public String getDisplayName() {
        return displayName;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskSwitchPredicate // instanceof handles nulls
                && predicate.equals(((TaskSwitchPredicate) other).predicate)
                && displayName.equals(((TaskSwitchPredicate) other).displayName));
    }
}
```
###### /java/seedu/toluist/model/TodoList.java
``` java
package seedu.toluist.model;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import com.fasterxml.jackson.annotation.JsonIgnore;

import seedu.toluist.commons.exceptions.DataStorageException;
import seedu.toluist.storage.JsonStorage;
import seedu.toluist.storage.TodoListStorage;

/**
 * TodoList Model
 */
public class TodoList {
    private static TodoList instance;

    private ArrayList<Task> allTasks = new ArrayList<>();
    @JsonIgnore
    private TodoListStorage storage = new JsonStorage();

    public boolean equals(Object other) {
        return other == this // short circuit if same objectå
                || (other instanceof TodoList // instanceof handles nulls
                && allTasks.equals(((TodoList) other).getTasks()));
    }

    public ArrayList<Task> getTasks() {
        return allTasks;
    }

    public static TodoList getInstance() {
        // Initialize currentTodoList if not done
        if (instance == null) {
            instance = new TodoList();
        }

        return instance;
    }

    public void setStorage(TodoListStorage storage) {
        this.storage = storage;
    }

    public TodoListStorage getStorage() {
        return storage;
    }

    public void load() throws DataStorageException {
        TodoList loadedTodoList = storage.load();
        setTasks(loadedTodoList.getTasks());
    }

    public void load(String storagePath) throws DataStorageException {
        TodoList loadedTodoList = storage.load(storagePath);
        setTasks(loadedTodoList.getTasks());
    }

    /**
     * Save the todo list data to disk
     * @return true / false
     */
    public boolean save() {
        return storage.save(this);
    }

    /**
     * Add a task to todolist
     * @param task task to be added
     */
    public void add(Task task) {
        // Don't allow duplicate tasks
        if (allTasks.contains(task)) {
            return;
        }

        allTasks.add(task);
    }

    /**
     * Remove a task from todo list
     * @param task task to be removed
     */
    public void remove(Task task) {
        allTasks.remove(task);
    }

    /**
     * Returns list of tasks based on predicate
     * @param predicate a predicate
     * @return a list of task
     */
    public ArrayList<Task> getFilterTasks(Predicate<Task> predicate) {
        List<Task> taskList = getTasks().stream().filter(predicate).collect(Collectors.toList());
        return new ArrayList<>(taskList);
    }

```
###### /java/seedu/toluist/storage/JsonStorage.java
``` java
package seedu.toluist.storage;

import java.io.File;
import java.io.IOException;
import java.nio.file.InvalidPathException;
import java.util.ArrayDeque;
import java.util.Optional;

import com.fasterxml.jackson.core.JsonProcessingException;

import javafx.util.Pair;
import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.exceptions.DataStorageException;
import seedu.toluist.commons.util.FileUtil;
import seedu.toluist.commons.util.JsonUtil;
import seedu.toluist.model.TodoList;

/**
 * JsonStorage saves/loads TodoList object to/from json file.
 */
public class JsonStorage implements TodoListStorage {
    private Config config = Config.getInstance();
    private ArrayDeque<String> historyStack = new ArrayDeque<>();
    private ArrayDeque<String> redoHistoryStack = new ArrayDeque<>();

    public boolean save(TodoList todoList) {
        return save(todoList, Config.getInstance().getTodoListFilePath());
    }

    public boolean save(TodoList todoList, String storagePath) {
        if (!saveNotAffectingHistory(todoList, storagePath)) {
            return false;
        }
        addToHistory(todoList);
        redoHistoryStack.clear();

        Config.getInstance().setTodoListFilePath(storagePath);
        return true;
    }

    public TodoList load() throws DataStorageException {
        return load(Config.getInstance().getTodoListFilePath());
    }


    public TodoList load(String storagePath) throws DataStorageException {
        try {
            String jsonString = FileUtil.readFromFile(new File(storagePath));
            // push todo list json string into historyStack if the stack is empty
            if (historyStack.isEmpty()) {
                addToHistory(jsonString);
            }
            TodoList todoList = JsonUtil.fromJsonString(jsonString, TodoList.class);

            Config.getInstance().setTodoListFilePath(storagePath);
            return todoList;
        } catch (IOException | InvalidPathException e) {
            throw new DataStorageException(e.getMessage());
        }
    }

    public boolean move(String newStoragePath) {
        String oldStoragePath = config.getTodoListFilePath();

        TodoList todoList;
        try {
            todoList = load();
        } catch (DataStorageException e) {
            return false;
        }

        if (!saveNotAffectingHistory(todoList, newStoragePath)) {
            return false;
        }

        FileUtil.removeFile(FileUtil.getFile(oldStoragePath));

        config.setTodoListFilePath(newStoragePath);
        return config.save();
    }

    public Pair<TodoList, Integer> undo(int times) {
        assert historyStack.size() >= 1;
        int steps = times;
        while (steps > 0 && historyStack.size() > 1) {
            redoHistoryStack.addLast(historyStack.pollLast());
            steps -= 1;
        }
        TodoList todoList = todoListFromJson(historyStack.peekLast()).get();
        // So as to not clear the redo history
        saveNotAffectingHistory(todoList, config.getTodoListFilePath());
        return new Pair<>(todoList, times - steps);
    }

    public Pair<TodoList, Integer> redo(int times) {
        int steps = times;
        while (steps > 0 && redoHistoryStack.size() > 0) {
            historyStack.addLast(redoHistoryStack.pollLast());
            steps -= 1;
        }

        TodoList todoList = todoListFromJson(historyStack.peekLast()).get();
        // So as to not clear the redo history
        saveNotAffectingHistory(todoList, config.getTodoListFilePath());
        return new Pair<>(todoList, times - steps);
    }

    /**
     * Add todolist data to history, making sure that no identical todo list data appear consecutively
     * in history
     * @param todoList TodoList object
     */
    public void addToHistory(TodoList todoList) {
        try {
            addToHistory(JsonUtil.toJsonString(todoList));
        } catch (JsonProcessingException e) {
            // Should not reach here
            e.printStackTrace();
        }
    }

    /**
     * Add json representation of todolist data to history, making sure that no identical todo list data
     * appear consecutively in history
     * @param jsonString json representation of todolist data
     */
    public void addToHistory(String jsonString) {
        if (historyStack.isEmpty() || (!historyStack.getLast().equals(jsonString))) {
            historyStack.addLast(jsonString);
        }
    }

    /**
     * Save todo list to data file, but does not add it to the history stack
     * @param todoList todo list data
     * @param storagePath data file path
     * @return true if saving succeeds, otherwise false
     */
    private boolean saveNotAffectingHistory(TodoList todoList, String storagePath) {
        try {
            String jsonString = JsonUtil.toJsonString(todoList);
            FileUtil.writeToFile(FileUtil.getFile(storagePath), jsonString);
            return true;
        } catch (IOException e) {
            return false;
        }
    }

    /**
     * Get optional of TodoList from a json string
     * @param json json serialisation for todo list data
     * @return optional of todolist if the data can be deserialized successfully, otherwise Optional.empty()
     */
    private Optional<TodoList> todoListFromJson(String json) {
        try {
            TodoList todoList = JsonUtil.fromJsonString(json, TodoList.class);
            // Inject self as storage dependency
            todoList.setStorage(this);
            return Optional.of(todoList);
        } catch (IOException e) {
            return Optional.empty();
        }
    }
}
```
###### /java/seedu/toluist/storage/TodoListStorage.java
``` java
package seedu.toluist.storage;

import java.io.IOException;

import javafx.util.Pair;
import seedu.toluist.commons.exceptions.DataStorageException;
import seedu.toluist.model.TodoList;

/**
 * Interface for TodoListStorage that saves/loads TodoList data
 */
public interface TodoListStorage {
    /**
     * Serialize a todolist to the disk, using a default storage path
     * supplied by the singleton Config
     * @param todoList todolist to be saved
     * @return true if the saving was successful, false otherwise
     */
    boolean save(TodoList todoList);

    /**
     * Serialize a todolist to the disk at the specified storage path
     * If saving is successful, the todolist storage path in the config will be changed
     * accordingly
     * @param todoList todolist to be saved
     * @param todoListStoragePath storage path to save todo list data at
     * @return true if the saving was successful, false otherwise
     */
    boolean save(TodoList todoList, String todoListStoragePath);

    /**
     * Load todo list data from disk, using a default storage path
     * supplied by the singleton Config
     * @return todo list data
     * @throws DataStorageException if data cannot be loaded
     */
    TodoList load() throws DataStorageException;

    /**
     * Load todo list data from disk from the specified storage path
     * If loading is successful, the todolist storage path in the config will be changed
     * accordingly
     * @return todo list data
     * @param todoListStoragePath storage path to load todo list data from
     * @throws IOException if data cannot be loaded
     */
    TodoList load(String todoListStoragePath) throws DataStorageException;

    /**
     * Move the todo list data to somewhere else
     * If moving is successful, the todolist storage path in the config will be changed
     * accordingly
     * @param todoListStoragePath storage path to move todo list data to
     * @return true if the moving was successful, false otherwise
     */
    boolean move(String todoListStoragePath);

    /**
     * Undo the todolist by a number of times
     * @param times number of times to undo
     * @return Pair of todolist, the resulting todo list and an integer denoting the number of actual undo times
     */
    Pair<TodoList, Integer> undo(int times);

    /**
     * Redo the todolist by a number of times
     * @param times number of times to redo
     * @return Pair of todolist, the resulting todo list and an integer denoting the number of actual redo times
     */
    Pair<TodoList, Integer> redo(int times);
}
```
###### /java/seedu/toluist/ui/MainWindow.java
``` java
package seedu.toluist.ui;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.logging.Logger;

import javax.swing.ImageIcon;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.scene.Scene;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyCodeCombination;
import javafx.scene.input.KeyCombination;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Region;
import javafx.stage.Stage;

import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.core.GuiSettings;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.events.ui.ExitAppRequestEvent;
import seedu.toluist.commons.util.FxViewUtil;
import seedu.toluist.dispatcher.Dispatcher;
import seedu.toluist.ui.view.CommandAutoCompleteView;
import seedu.toluist.ui.view.CommandBox;
import seedu.toluist.ui.view.ResultView;
import seedu.toluist.ui.view.TabBarView;
import seedu.toluist.ui.view.TaskListUiView;

/**
 * The Main Window. Provides the basic application layout containing
 * a menu bar and space where other JavaFX elements can be placed.
 */
public class MainWindow extends UiPart<Region> {
    private static final Logger logger = LogsCenter.getLogger(MainWindow.class);
    private static final String IMAGE_PATH_LOGO = "/images/logo.png";
    private static final String FXML = "MainWindow.fxml";
    private static final int MIN_HEIGHT = 600;
    private static final int MIN_WIDTH = 800;

    private Stage primaryStage;
    private Dispatcher dispatcher;

    @FXML
    private AnchorPane commandBoxPlaceholder;
    @FXML
    private AnchorPane taskListPlaceholder;
    @FXML
    private AnchorPane resultDisplayPlaceholder;
    @FXML
    private AnchorPane tabPanePlaceholder;

    @FXML
    private AnchorPane commandAutoCompletePlaceholder;

    private CommandBox commandBox;
    private TaskListUiView taskListUiView;
    private ResultView resultView;
    private TabBarView tabBarView;
    private CommandAutoCompleteView commandAutoCompleteView;


    public MainWindow (Stage primaryStage, Dispatcher dispatcher) {
        super(FXML);

        // Set dependencies
        this.primaryStage = primaryStage;
        this.dispatcher = dispatcher;

        // Configure the UI
        setLogo();
        setWindowMinSize();
        setWindowDefaultSize();
        Scene scene = new Scene(getRoot());
        primaryStage.setScene(scene);
        configureKeyCombinations();
        configureChildrenViews();
    }

    public Stage getPrimaryStage() {
        return primaryStage;
    }

    public void render() {
        taskListUiView.render();
        commandBox.render();
        resultView.render();
        tabBarView.render();
        commandAutoCompleteView.render();
    }

    private void configureKeyCombinations() {
        configureSwitchTabKeyCombinations();
    }

    void hide() {
        primaryStage.hide();
    }

    private void configureSwitchTabKeyCombinations() {
        String[] tabNames = new String[] { "i", "t", "n", "c", "a" };
        Arrays.stream(tabNames).forEach(tabName -> {
            KeyCombination keyCombination = new KeyCodeCombination(getKeyCode(tabName),
                    KeyCombination.CONTROL_DOWN);
            String switchCommand = "switch " + tabName;
            EventHandler<ActionEvent> handler = event -> dispatcher.dispatch(switchCommand);
            FxViewUtil.setKeyCombination(getRoot(), keyCombination, handler);
        });
    }

    /**
     * Get matching key code for a string
     * @param s string
     * @returna key code
     */
    private KeyCode getKeyCode(String s) {
        switch (s) {
        case "i": return KeyCode.I;
        case "t": return KeyCode.T;
        case "n": return KeyCode.N;
        case "c": return KeyCode.C;
        case "a": return KeyCode.A;
        default: return KeyCode.ESCAPE;
        }
    }

    private AnchorPane getTaskListPlaceholder() {
        return taskListPlaceholder;
    }

    private AnchorPane getCommandBoxPlaceholder() {
        return commandBoxPlaceholder;
    }

    private AnchorPane getResultDisplayPlaceholder() {
        return resultDisplayPlaceholder;
    }

    private AnchorPane getTabPanePlaceholder() {
        return tabPanePlaceholder;
    }

    private AnchorPane getCommandAutoCompletePlaceholder() {
        return commandAutoCompletePlaceholder;
    }

    private void setWindowMinSize() {
        primaryStage.setMinHeight(MIN_HEIGHT);
        primaryStage.setMinWidth(MIN_WIDTH);
    }

    /**
     * Sets the logo for the app
     */
    private void setLogo() {
        FxViewUtil.setStageIcon(primaryStage, IMAGE_PATH_LOGO);
        // Only in macOS, you can try to use reflection to access this library
        // and use it to set a custom app icon
        try {
            Class applicationClass = Class.forName("com.apple.eawt.Application");
            Method getApplication = applicationClass.getMethod("getApplication");
            Object application = getApplication.invoke(applicationClass);
            Method setDockIconImage = applicationClass.getMethod("setDockIconImage", java.awt.Image.class);
            setDockIconImage.invoke(application,
                    new ImageIcon(MainWindow.class.getResource(IMAGE_PATH_LOGO)).getImage());
        } catch (NoSuchMethodException | IllegalAccessException
                | InvocationTargetException | ClassNotFoundException e) {
            logger.info("Not on macOS");
        }
    }

    /**
     * Sets the default size based on user config.
     */
    private void setWindowDefaultSize() {
        GuiSettings guiSettings = Config.getInstance().getGuiSettings();
        primaryStage.setHeight(guiSettings.getWindowHeight());
        primaryStage.setWidth(guiSettings.getWindowWidth());
        if (guiSettings.getWindowCoordinates() != null) {
            primaryStage.setX(guiSettings.getWindowCoordinates().getX());
            primaryStage.setY(guiSettings.getWindowCoordinates().getY());
        }
    }

    private void configureChildrenViews() {
        taskListUiView = new TaskListUiView();
        taskListUiView.setParent(getTaskListPlaceholder());

        commandBox = new CommandBox(dispatcher);
        commandBox.setParent(getCommandBoxPlaceholder());

        resultView = new ResultView();
        resultView.setParent(getResultDisplayPlaceholder());

        tabBarView = new TabBarView();
        tabBarView.setParent(getTabPanePlaceholder());

        commandAutoCompleteView = new CommandAutoCompleteView();
        commandAutoCompleteView.setParent(getCommandAutoCompletePlaceholder());
    }

    void show() {
        primaryStage.show();
    }

    /**
     * Returns the current size and the position of the main Window.
     */
    GuiSettings getCurrentGuiSetting() {
        return new GuiSettings(primaryStage.getWidth(), primaryStage.getHeight(),
                (int) primaryStage.getX(), (int) primaryStage.getY());
    }

    /** ================ ACTION HANDLERS ================== **/

    @FXML
    public void handleHelp() {
    }

    @FXML
    public void handleMenu() {
    }

    /**
     * Closes the application.
     */
    @FXML
    private void handleExit() {
        raise(new ExitAppRequestEvent());
    }
}
```
###### /java/seedu/toluist/ui/UiManager.java
``` java
package seedu.toluist.ui;

import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;

import javafx.application.Platform;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.stage.Stage;
import seedu.toluist.commons.core.ComponentManager;
import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.events.ui.ShowHelpRequestEvent;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.dispatcher.Dispatcher;

/**
 * The manager of the UI component. Singleton
 */
public class UiManager extends ComponentManager implements Ui {
    private static final Logger logger = LogsCenter.getLogger(UiManager.class);
    private static UiManager instance;

    private MainWindow mainWindow;
    private Dispatcher dispatcher;

    public static UiManager getInstance() {
        if (instance == null) {
            instance = new UiManager();
        }
        return instance;
    }

    private UiManager() {
        super();
    }

    @Override
    public void start(Stage primaryStage) {
        logger.info("Starting UI...");
        Config config = Config.getInstance();
        primaryStage.setTitle(config.getAppTitle());

        try {
            mainWindow = new MainWindow(primaryStage, dispatcher);
            mainWindow.render();
            mainWindow.show();
            // Re-render when data change is observed
            String listCommand = "list";
            dispatcher.dispatch(listCommand);
        } catch (Throwable e) {
            logger.severe(StringUtil.getDetails(e));
            showFatalErrorDialogAndShutdown("Fatal error during initializing", e);
        }
    }

    @Override
    public void stop() {
        // Save the last used gui settings
        Config.getInstance().setGuiSettings(mainWindow.getCurrentGuiSetting());
        Config.getInstance().save();
        mainWindow.hide();
    }

    public void init(Dispatcher dispatcher) {
        this.dispatcher = dispatcher;
    }

    void showAlertDialogAndWait(Alert.AlertType type, String title, String headerText, String contentText) {
        showAlertDialogAndWait(mainWindow.getPrimaryStage(), type, title, headerText, contentText);
    }

    private static void showAlertDialogAndWait(Stage owner, AlertType type, String title, String headerText,
                                               String contentText) {
        final Alert alert = new Alert(type);
        alert.getDialogPane().getStylesheets().add("stylesheet/DefaultTheme.css");
        alert.initOwner(owner);
        alert.setTitle(title);
        alert.setHeaderText(headerText);
        alert.setContentText(contentText);
        alert.showAndWait();
    }

    private void showFatalErrorDialogAndShutdown(String title, Throwable e) {
        logger.severe(title + " " + e.getMessage() + StringUtil.getDetails(e));
        showAlertDialogAndWait(Alert.AlertType.ERROR, title, e.getMessage(), e.toString());
        Platform.exit();
        System.exit(1);
    }

    //==================== Event Handling Code ===============================================================

    @Subscribe
    private void handleShowHelpEvent(ShowHelpRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
//        mainWindow.handleHelp();
    }
}
```
###### /java/seedu/toluist/ui/UiStore.java
``` java
package seedu.toluist.ui;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.ObservableIntegerValue;
import javafx.beans.value.ObservableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;

import seedu.toluist.model.Task;
import seedu.toluist.model.TaskSwitchPredicate;
import seedu.toluist.ui.commons.CommandInput;
import seedu.toluist.ui.commons.CommandResult;
import seedu.toluist.ui.view.UiView;

/**
 * UiStore acts like a "single source of truth" / view model for the Ui
 * Ui will observe for changes to `shownTasks` and re-render on state change
 */
public class UiStore {
    public static final int INDEX_INVALID_SUGGESTION = -1;

    private static UiStore instance;

    private ArrayList<Task> allTasks = new ArrayList<>();
    private ObjectProperty<TaskSwitchPredicate> observableSwitchPredicate =
            new SimpleObjectProperty<>(TaskSwitchPredicate.SWITCH_PREDICATE_INCOMPLETE);
    private ObservableList<Task> shownTasks = FXCollections.observableArrayList();
    private ObjectProperty<CommandResult> observableCommandResult =
            new SimpleObjectProperty<>(new CommandResult(""));
    private ObjectProperty<CommandInput> observableCommandInput =
            new SimpleObjectProperty<>(new CommandInput(""));
    private ObservableList<String> observableSuggestedCommands = FXCollections.observableArrayList();
    private SimpleIntegerProperty observableSuggestedCommandIndex =
            new SimpleIntegerProperty(INDEX_INVALID_SUGGESTION);

    public static UiStore getInstance() {
        if (instance == null) {
            instance = new UiStore();
        }
        return instance;
    }

    private UiStore() {}

    /**
     * Bind view to an observable list. View will re-render on list change
     * @param view a UiView
     * @param observableList an observable list
     */
    public void bind(UiView view, ObservableList<?> observableList) {
        WeakReference<UiView> weakView = new WeakReference<>(view);
        observableList.addListener((ListChangeListener) (c -> {
            if (weakView.get() != null) {
                weakView.get().render();
            }
        }));
    }

    /**
     * Bind view to an observable value. View will re-render on value change
     * @param view a UiView
     * @param observableValue an observable value
     */
    public void bind(UiView view, ObservableValue<?> observableValue) {
        WeakReference<UiView> weakView = new WeakReference<>(view);
        observableValue.addListener(c -> {
            if (weakView.get() != null) {
                weakView.get().render();
            }
        });
    }

    public void setObservableSwitchPredicate(TaskSwitchPredicate switchPredicate) {
        observableSwitchPredicate.setValue(switchPredicate);
        changeShownTasks();
    }

    public ObservableValue<TaskSwitchPredicate> getObservableSwitchPredicate() {
        return observableSwitchPredicate;
    }

    public void setCommandResult(CommandResult commandResult) {
        observableCommandResult.setValue(commandResult);
    }

    public void setSuggestedCommands(List<String> suggestedCommands) {
        observableSuggestedCommandIndex.set(INDEX_INVALID_SUGGESTION);
        observableSuggestedCommands.setAll(suggestedCommands);
    }

    public ObservableList<String> getObservableSuggestedCommands() {
        return observableSuggestedCommands;
    }

    public void setCommandInput(String command) {
        observableCommandInput.setValue(new CommandInput(command));
    }

    public ObservableValue<CommandInput> getObservableCommandInput() {
        return observableCommandInput;
    }

    public ObservableValue<CommandResult> getObservableCommandResult() {
        return observableCommandResult;
    }

    public void incrementSuggestedCommandIndex() {
        if (observableSuggestedCommands.isEmpty()) {
            return;
        }

        observableSuggestedCommandIndex.set((observableSuggestedCommandIndex.get() + 1) %
                observableSuggestedCommands.size());
    }

    public ObservableIntegerValue getObservableSuggestedCommandIndex() {
        return observableSuggestedCommandIndex;
    }

    public void setTasks(ArrayList<Task> tasks) {
        // Sorted by default
        Collections.sort(tasks);
        this.allTasks = tasks;
        changeShownTasks();
    }

    public ArrayList<Task> getTasks() {
        return allTasks;
    }

    /**
     * Returns list of tasks are currently shown on the Ui
     */
    public ArrayList<Task> getShownTasks() {
        return new ArrayList(Arrays.asList(shownTasks.toArray()));
    }

    public ArrayList<Task> getShownTasks(List<Integer> indexes) {
        List<Task> shownTasks = getShownTasks();
        ArrayList<Task> tasks = new ArrayList<>();
        for (int index : indexes) {
            if (index < 1 || index > shownTasks.size()) {
                continue;
            }
            tasks.add(shownTasks.get(index - 1));
        }
        return tasks;
    }

    public ObservableList<Task> getObservableTasks() {
        return shownTasks;
    }

    private void changeShownTasks() {
        shownTasks.setAll(allTasks.stream()
                .filter(observableSwitchPredicate.getValue().getPredicate()).collect(Collectors.toList()));
    }
}
```
###### /java/seedu/toluist/ui/view/CommandBox.java
``` java
package seedu.toluist.ui.view;

import java.util.ArrayList;
import java.util.List;

import javafx.fxml.FXML;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyCodeCombination;
import seedu.toluist.commons.util.FxViewUtil;
import seedu.toluist.dispatcher.Dispatcher;
import seedu.toluist.ui.UiStore;

public class CommandBox extends UiView {
    private static final String STYLE_CLASS_ERROR = "error";
    private static final String FXML = "CommandBox.fxml";
    private final Dispatcher dispatcher;

    @FXML
    private TextField commandTextField;

    public CommandBox(Dispatcher dispatcher) {
        super(FXML);
        this.dispatcher = dispatcher;
        configureBindings();
        configureKeyCombinations();
    }

    @Override
    protected void viewDidMount () {
        FxViewUtil.makeFullWidth(getRoot());
        FxViewUtil.makeFullWidth(commandTextField);
        UiStore store = UiStore.getInstance();
        setCommandTextFieldText(store.getObservableCommandInput().getValue().getCommand());
    }

    private void configureBindings() {
        UiStore store = UiStore.getInstance();
        store.bind(this, store.getObservableCommandInput());
        commandTextField.textProperty()
                .addListener((observable, oldValue, newValue) -> handleCommandInputChanged(newValue));
    }

    private void configureKeyCombinations() {
        FxViewUtil.setKeyCombination(commandTextField, new KeyCodeCombination(KeyCode.TAB),
            event -> handleCommandInputAutoComplete());
        FxViewUtil.setKeyCombination(commandTextField, new KeyCodeCombination(KeyCode.ENTER),
            event -> handleCommandInputSelectSuggestedCommand());
    }

    private void dispatchCommand() {
        dispatcher.dispatchRecordingHistory(commandTextField.getText());
        commandTextField.setText("");
    }

    private void handleCommandInputChanged(String newCommand) {
        List<String> suggestedCommands = new ArrayList(dispatcher.getPredictedCommands(newCommand));
        UiStore.getInstance().setSuggestedCommands(suggestedCommands);
        if (!newCommand.isEmpty() && suggestedCommands.isEmpty()) {
            FxViewUtil.addStyleClass(commandTextField, STYLE_CLASS_ERROR);
        } else {
            FxViewUtil.removeStyleClass(commandTextField, STYLE_CLASS_ERROR);
        }
    }

    private void handleCommandInputAutoComplete() {
        UiStore store = UiStore.getInstance();
        store.incrementSuggestedCommandIndex();

        List<String> suggestedCommands = store.getObservableSuggestedCommands();
        if (suggestedCommands.size() == 1) {
            setCommandTextFieldText(suggestedCommands.get(0));
        }
    }

    /**
     * Handle selection of suggested command
     * If current text matches suggested command, or if no suggested command selected, dispatch the command
     * Otherwise auto-complete it to match the command
     */
    private void handleCommandInputSelectSuggestedCommand() {
        UiStore store = UiStore.getInstance();
        List<String> suggestedCommands = store.getObservableSuggestedCommands();
        int index = store.getObservableSuggestedCommandIndex().get();

        if (suggestedCommands.isEmpty()
            || index == UiStore.INDEX_INVALID_SUGGESTION
            || suggestedCommands.get(index).equals(commandTextField.getText())) {
            dispatchCommand();
            return;
        }

        store.setCommandInput(suggestedCommands.get(index));
    }

    private void setCommandTextFieldText(String text) {
        commandTextField.setText(text);
        commandTextField.end();
    }
}
```
###### /java/seedu/toluist/ui/view/ResultView.java
``` java
package seedu.toluist.ui.view;

import javafx.fxml.FXML;
import javafx.scene.control.TextArea;
import javafx.scene.layout.AnchorPane;
import seedu.toluist.commons.util.FxViewUtil;
import seedu.toluist.ui.UiStore;

/**
 * A ui for the status bar that is displayed at the header of the application.
 */
public class ResultView extends UiView {

    private static final String FXML = "ResultView.fxml";

    @FXML
    private AnchorPane mainPane;

    @FXML
    private TextArea resultDisplay;

    public ResultView () {
        super(FXML);
        configureBindings();
    }

    private void configureBindings() {
        UiStore store = UiStore.getInstance();
        store.bind(this, store.getObservableCommandResult());
    }

    @Override
    protected void viewDidMount() {
        registerAsAnEventHandler(this);
        makeFullWidth();
        String result = UiStore.getInstance().getObservableCommandResult().getValue().getFeedbackToUser();
        resultDisplay.setText(result);
    }

    private void makeFullWidth() {
        FxViewUtil.makeFullWidth(getRoot());
        FxViewUtil.makeFullWidth(mainPane);
        FxViewUtil.makeFullWidth(resultDisplay);
    }
}
```
###### /java/seedu/toluist/ui/view/TabBarView.java
``` java
package seedu.toluist.ui.view;

import javafx.fxml.FXML;
import javafx.scene.layout.Pane;

import seedu.toluist.commons.core.SwitchConfig;
import seedu.toluist.commons.util.FxViewUtil;
import seedu.toluist.model.TaskSwitchPredicate;
import seedu.toluist.ui.UiStore;

/**
 * View to display the tab bar
 */
public class TabBarView extends UiView {

    private static final String FXML = "TabBarView.fxml";

    @FXML
    private Pane tabContainer;
    private SwitchConfig switchConfig = SwitchConfig.getDefaultSwitchConfig();

    public TabBarView() {
        super(FXML);
        configureBindings();
    }

    private void configureBindings() {
        UiStore store = UiStore.getInstance();
        store.bind(this, store.getObservableSwitchPredicate());
        store.bind(this, store.getObservableTasks());
    }

    @Override
    protected void viewDidMount() {
        FxViewUtil.makeFullWidth(getRoot());
        tabContainer.getChildren().clear();
        for (TaskSwitchPredicate switchPredicate : switchConfig.getAllPredicates()) {
            TabView tabView = new TabView(switchPredicate,
                    switchPredicate.equals(UiStore.getInstance().getObservableSwitchPredicate().getValue()));
            tabView.setParent(tabContainer);
            tabView.render();
        }
    }
}
```
###### /java/seedu/toluist/ui/view/TabView.java
``` java
package seedu.toluist.ui.view;

import java.util.stream.Collectors;

import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import seedu.toluist.commons.util.FxViewUtil;
import seedu.toluist.model.TaskSwitchPredicate;
import seedu.toluist.ui.UiStore;

/**
 * View to display the individual tab
 */
public class TabView extends UiView {
    private static final String STYLE_CLASS_SELECTED_TAB = "selected";
    private static final String FXML = "TabView.fxml";

    @FXML
    private HBox tabPane;
    @FXML
    private Label tabLabel;
    @FXML
    private Label tabShortcutLabel;
    private final TaskSwitchPredicate switchPredicate;
    private final boolean isSelected;

    public TabView(TaskSwitchPredicate switchPredicate, boolean isSelected) {
        super(FXML);
        this.switchPredicate = switchPredicate;
        this.isSelected = isSelected;
    }

    @Override
    protected void viewDidMount() {
        UiStore uiStore = UiStore.getInstance();
        String taskInfo = " ("
                + uiStore.getTasks().stream()
                         .filter(switchPredicate.getPredicate()).collect(Collectors.toList()).size()
                + "/" + uiStore.getTasks().size() + ")";
        tabShortcutLabel.setText(switchPredicate.getDisplayName().substring(0, 1));
        tabLabel.setText(switchPredicate.getDisplayName().substring(1) + taskInfo);
        if (isSelected) {
            FxViewUtil.addStyleClass(tabPane, STYLE_CLASS_SELECTED_TAB);
        }
    }
}
```
###### /java/seedu/toluist/ui/view/TaskListUiView.java
``` java
package seedu.toluist.ui.view;

import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import seedu.toluist.commons.util.FxViewUtil;
import seedu.toluist.model.Task;
import seedu.toluist.ui.UiStore;

/**
 * TaskListUiView to display the list of tasks
 */
public class TaskListUiView extends UiView {

    private static final String FXML = "TaskListView.fxml";

    @FXML
    private ListView<Task> taskListView;

    public TaskListUiView () {
        super(FXML);
    }

    @Override
    protected void viewDidMount () {
        UiStore store = UiStore.getInstance();
        ObservableList<Task> taskList = store.getObservableTasks();
        setConnections(taskList);
        FxViewUtil.makeFullWidth(getRoot());
    }

    private void setConnections(ObservableList<Task> taskList) {
        taskListView.setItems(taskList);
        taskListView.setCellFactory(listView -> new TaskListViewCell());
    }

    class TaskListViewCell extends ListCell<Task> {

        @Override
        protected void updateItem(Task task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                TaskUiView taskRow = new TaskUiView(task, getIndex() + 1);
                setGraphic(taskRow.getRoot());
                taskRow.render();
            }
        }
    }
}
```
###### /java/seedu/toluist/ui/view/TaskStatusView.java
``` java
package seedu.toluist.ui.view;

import javafx.fxml.FXML;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;

/**
 * View to display the task's status, e.g. high priority / overdue
 */
public class TaskStatusView extends UiView {
    private static final String FXML = "TaskStatusView.fxml";

    @FXML
    private ImageView imageView;
    private final Image image;

    public TaskStatusView(Image image) {
        super(FXML);
        this.image = image;
    }

    @Override
    protected void viewDidMount() {
        imageView.setImage(image);
    }
}
```
###### /java/seedu/toluist/ui/view/TaskTypeTagView.java
``` java
package seedu.toluist.ui.view;

import seedu.toluist.commons.util.FxViewUtil;

/**
 * View to display the task type
 */
public class TaskTypeTagView extends TagView {
    private static final String STYLE_CLASS_EVENT = "event-tag";
    private static final String STYLE_CLASS_TASK = "task-tag";
    private static final String DISPLAY_NAME_EVENT = "Event";
    private static final String DISPLAY_NAME_TASK = "Task";

    final boolean isTask;

    public TaskTypeTagView(boolean isTask) {
        super(isTask ? DISPLAY_NAME_TASK : DISPLAY_NAME_EVENT);
        this.isTask = isTask;
    }

    @Override
    protected void viewDidMount() {
        super.viewDidMount();
        if (isTask) {
            FxViewUtil.addStyleClass(tagLabel, STYLE_CLASS_TASK);
        } else {
            FxViewUtil.addStyleClass(tagLabel, STYLE_CLASS_EVENT);
        }
    }
}
```
###### /java/seedu/toluist/ui/view/UiView.java
``` java
package seedu.toluist.ui.view;

import javafx.scene.layout.Pane;
import seedu.toluist.ui.UiPart;

/**
 * UiView is basic building block for the Ui
 * To setup a UiView, {@link #render()} needs to be explicitly called
 * Also a parent node is required through {@link #setParent(Pane)}
 */
public class UiView extends UiPart<Pane> {
    private Pane parent;

    public UiView(String fxmlFileName) {
        super(fxmlFileName);
    }

    public void render() {
        viewDidMount();
    }

    public void setParent(Pane newParent) {
        if (parent == newParent) {
            return;
        }

        parent = newParent;
        newParent.getChildren().add(getRoot());
    }

    public Pane getParent() {
        return parent;
    }

    protected void viewDidMount() {} // do nothing by default
}
```
###### /resources/stylesheet/Colors.css
``` css
* {
    theme-primary: #00BCD4;
    theme-primary-dark: #0097A7;
    theme-primary-light: #B2EBF2;
    theme-accent: #FFC107;
    theme-primary-text: #212121;
    theme-secondary-text: #757575;
    theme-text: #FAFAFA;
    theme-background: #E5E5DB;
    theme-danger: #EF4A4F;
}
```
###### /resources/stylesheet/DefaultTheme.css
``` css
@import "Colors.css";
@import "Fonts.css";

/* DEFAULT STYLING */

.root {
    -fx-background-color: theme-background;
    -fx-control-inner-background: theme-background;
    -fx-font-family: "Roboto";
}

.scroll-bar .thumb {
    -fx-background-color: theme-primary-text;
    -fx-background-insets: 3;
}

.scroll-bar .increment-button, .scroll-bar .decrement-button {
    -fx-background-color: transparent;
    -fx-padding: 0 0 0 0;
}

.scroll-bar .increment-arrow, .scroll-bar .decrement-arrow {
    -fx-shape: " ";
}

.scroll-bar:vertical .increment-arrow, .scroll-bar:vertical .decrement-arrow {
    -fx-padding: 1 8 1 8;
}

.scroll-bar:horizontal .increment-arrow, .scroll-bar:horizontal .decrement-arrow {
    -fx-padding: 8 1 8 1;
}

.list-view {
    -fx-background-color: transparent;
}

.list-cell {
    -fx-background-color: transparent;
}

.text-field {
    -fx-background-color: transparent;
    -fx-padding: 0.5em 0.5em 0.5em 0.1em;
    -fx-border-color: theme-primary;
    -fx-border-width: 0 0 2 0;
    -fx-prompt-text-fill: theme-secondary-text;
    -fx-highlight-fill: theme-primary-text;
    -fx-font-family: "Roboto Bold";
}

.text-field:focused {
    -fx-border-color: theme-primary-dark;
}

.text-field.error {
    -fx-border-color: theme-danger;
}

.text-area {
    -fx-background-radius: 0;
}

.text-area .content {
    -fx-background-radius: 0;
    -fx-padding: 10;
}

.label {
    -fx-font-size: 11pt;
    -fx-text-fill: theme-primary-text;
}

/* COMMON CLASSES */

.dark {
    -fx-background-color: theme-primary-text;
    -fx-control-inner-background: theme-primary-text;
    -fx-highlight-fill: theme-text;
    -fx-text-fill: theme-text;
}

.meta-text {
    -fx-text-fill: derive(theme-primary-text, 35%);
    -fx-font-style: italic;
}

.bold-text {
    -fx-font-family: "Roboto Bold";
}

/* TAB PANE */

.tabs {
    -fx-background-color: theme-primary-dark;
    -fx-padding: 0 10 0 10;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.8), 10, 0, 0, 0);
}

.tabs .tab .label {
    -fx-text-fill: theme-primary-light;
}

.tabs .tab .label.initial {
    -fx-border-color: theme-primary-light;
    -fx-border-width: 0 0 1 0;
    -fx-border-insets: -1;
}

.tabs .tab.selected {
    -fx-border-width: 0 0 2 0;
    -fx-border-color: theme-accent;
}

.tabs .tab.selected .label {
    -fx-text-fill: theme-text;
}

.tabs .tab.selected .label.initial {
    -fx-border-color: theme-text;
}

/* TASK */

.tasks .task {
    -fx-border-color: theme-secondary-text;
    -fx-border-width: 0 0 1 0;
}

.tasks .task.completed .status-text .text {
    -fx-strikethrough: true;
}

.tasks .task.overdue .status-text.label {
    -fx-text-fill: theme-danger;
}

/* TAG */

.tag {
    -fx-padding: 5 10 5 10;
    -fx-background-radius: 5;
    -fx-font-size: 11;
}

.tag.event-tag {
    -fx-font-size: 12;
    -fx-background-color: theme-primary-dark;
}

.tag.task-tag {
    -fx-font-size: 12;
    -fx-background-color: derive(theme-accent, -10%);
}

/* COMMAND SUGGESTION */

.command-suggestions {
    -fx-background-color: theme-background;
    -fx-background-radius: 5;
}

.command-suggestions .command-suggestion.selected {
    -fx-text-fill: theme-primary-dark;
}

/* COMMAND INPUT */
```
###### /resources/stylesheet/Fonts.css
``` css
@font-face {
    font-family: "Roboto";
    font-style: normal;
    font-weight: 400;
    src: url('../fonts/Roboto-Regular.ttf');
}

@font-face {
    font-family: "Roboto Medium";
    font-style: normal;
    font-weight: 500;
    src: url('../fonts/Roboto-Medium.ttf');
}

@font-face {
    font-family: "Roboto Bold";
    font-style: normal;
    font-weight: 600;
    src: url('../fonts/Roboto-Bold.ttf');
}

@font-face {
    font-family: "Roboto Light";
    text-style: normal;
    font-weight: 300;
    src: url('../fonts/Roboto-Light.ttf');
}

@font-face {
    font-family: "Roboto";
    text-style: italic;
    font-weight: 400;
    src: url('../fonts/Roboto-Italic.ttf');
}

@font-face {
    font-family: "Roboto Medium";
    text-style: italic;
    font-weight: 500;
    src: url('../fonts/Roboto-MediumItalic.ttf');
}

@font-face {
    font-family: "Roboto Mono";
    font-style: normal;
    font-weight: 400;
    src: url('../fonts/RobotoMono-Regular.ttf');
}

@font-face {
    font-family: "Roboto Mono Medium";
    font-style: normal;
    font-weight: 500;
    src: url('../fonts/RobotoMono-Medium.ttf');
}
```
###### /resources/view/CommandBox.fxml
``` fxml

<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.AnchorPane?>

<AnchorPane styleClass="command-input-pane" stylesheets="@../stylesheet/DefaultTheme.css" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <TextField fx:id="commandTextField" alignment="CENTER" promptText="Enter command here..." styleClass="command-input" />
</AnchorPane>
```
###### /resources/view/MainWindow.fxml
``` fxml

<?import javafx.geometry.Insets?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.StackPane?>
<?import javafx.scene.layout.VBox?>

<VBox stylesheets="@../stylesheet/DefaultTheme.css" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <StackPane alignment="BOTTOM_CENTER" VBox.vgrow="ALWAYS">
         <children>
            <VBox>
               <children>
                  <AnchorPane fx:id="tabPanePlaceholder" prefHeight="0.0" prefWidth="200.0" />
                  <AnchorPane fx:id="taskListPlaceholder" VBox.vgrow="ALWAYS" />
                  <AnchorPane fx:id="resultDisplayPlaceholder" VBox.vgrow="NEVER" />
               </children>
            </VBox>
            <AnchorPane fx:id="commandAutoCompletePlaceholder" />
         </children>
      </StackPane>
      <AnchorPane fx:id="commandBoxPlaceholder" styleClass="command-input-placeholder" VBox.vgrow="NEVER">
         <padding>
            <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
         </padding>
      </AnchorPane>
   </children>
</VBox>
```
###### /resources/view/ResultView.fxml
``` fxml
<?import javafx.scene.control.TextArea?>
<?import javafx.scene.layout.AnchorPane?>

<AnchorPane fx:id="mainPane" stylesheets="@../stylesheet/DefaultTheme.css" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
     <TextArea fx:id="resultDisplay" editable="false" prefHeight="115.0" prefWidth="320.0" promptText="The result of your command will be shown here." styleClass="dark" wrapText="true" />
</AnchorPane>
```
###### /resources/view/TabBarView.fxml
``` fxml
<?import javafx.scene.layout.FlowPane?>


<FlowPane fx:id="tabContainer" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" minHeight="-Infinity" minWidth="-Infinity" prefHeight="40.0" prefWidth="600.0" styleClass="tabs" stylesheets="@../stylesheet/DefaultTheme.css" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1" />
```
###### /resources/view/TabView.fxml
``` fxml

<?import java.lang.String?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.text.Font?>

<HBox fx:id="tabPane" alignment="CENTER" prefHeight="35.0" prefWidth="149.0" styleClass="tab" stylesheets="@../stylesheet/DefaultTheme.css" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <Label fx:id="tabShortcutLabel" text="Label">
         <font>
            <Font name="System Bold" size="13.0" />
         </font>
         <styleClass>
            <String fx:value="initial" />
            <String fx:value="bold-text" />
         </styleClass></Label>
      <Label fx:id="tabLabel" styleClass="bold-text" text="Label" />
   </children>
</HBox>
```
###### /resources/view/TaskListView.fxml
``` fxml
<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.*?>
<?import java.net.URL?>
<?import javafx.scene.control.ListView?>

<VBox xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
    <stylesheets>
        <URL value="@../stylesheet/DefaultTheme.css" />
    </stylesheets>
    <children>
        <ListView fx:id="taskListView" styleClass="tasks" VBox.vgrow="ALWAYS" />
    </children>
</VBox>
```
###### /resources/view/TaskStatusView.fxml
``` fxml
<?import javafx.scene.image.ImageView?>


<ImageView fx:id="imageView" fitHeight="40.0" fitWidth="40.0" pickOnBounds="true" preserveRatio="true" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1" />
```
