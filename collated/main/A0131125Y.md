# A0131125Y
###### /java/seedu/toluist/commons/core/Config.java
``` java
package seedu.toluist.commons.core;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;

import seedu.toluist.commons.exceptions.DataConversionException;
import seedu.toluist.commons.util.JsonUtil;
import seedu.toluist.model.AliasTable;

/**
 * Config values used by the app
 * Since Config is largely a global state, singleton pattern can be largely applied here
 */
public class Config {
    private static final Logger logger = LogsCenter.getLogger(Config.class);
    public static final String DEFAULT_CONFIG_FILE_PATH = "data/config.json";
    public static final String DEFAULT_TODO_LIST_FILE_PATH = "data/todolist.json";
    public static final String APP_NAME = "ToLuist App";
    public static final String LOG_MESSAGE_SAVE_CONFIG_FAILURE = "Saving config failed";

    private static Config instance;
    private static String configFilePath = DEFAULT_CONFIG_FILE_PATH;

    // Config values customizable through config file
    private final String appTitle = APP_NAME;
    private Level logLevel = Level.INFO;
    private AliasTable aliasTable = new AliasTable();
    private String todoListFilePath = DEFAULT_TODO_LIST_FILE_PATH;
    private GuiSettings guiSettings = new GuiSettings();

    /**
     * Load config from disk
     * @return Config data
     */
    public static Config getInstance() {
        if (instance == null) {
            try {
                instance = JsonUtil.readJsonFile(configFilePath, Config.class).orElse(new Config());
            } catch (DataConversionException e) {
                instance = new Config();
            }
        }
        return instance;
    }

    /**
     * Save config to disk
     * @return true if successful, false otherwise
     */
    public boolean save() {
        try {
            JsonUtil.saveJsonFile(this, configFilePath);
            return true;
        } catch (IOException e) {
            logger.severe(LOG_MESSAGE_SAVE_CONFIG_FAILURE);
            return false;
        }
    }

    public static void setConfigFilePath(String configFilePath) {
        Config.configFilePath = configFilePath;
    }

    public void setTodoListFilePath(String todoListFilePath) {
        this.todoListFilePath = todoListFilePath;
    }

    public void setLogLevel(Level logLevel) {
        this.logLevel = logLevel;
    }

    public void setGuiSettings(GuiSettings guiSettings) {
        this.guiSettings = guiSettings;
    }

    public String getTodoListFilePath() {
        return todoListFilePath;
    }

    public String getAppTitle() {
        return appTitle;
    }

    public Level getLogLevel() {
        return logLevel;
    }

    public AliasTable getAliasTable() {
        return aliasTable;
    }

    public GuiSettings getGuiSettings() {
        return guiSettings;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Config // instanceof handles nulls
                && appTitle.equals(((Config) other).appTitle)
                && logLevel.equals(((Config) other).logLevel)
                && todoListFilePath.equals(((Config) other).todoListFilePath)
                && aliasTable.equals(((Config) other).aliasTable)
                && guiSettings.equals(((Config) other).guiSettings));
    }
}
```
###### /java/seedu/toluist/commons/core/Messages.java
``` java
package seedu.toluist.commons.core;

/**
 * Container for user visible messages.
 */
public class Messages {
    public static final String MESSAGE_UNKNOWN_COMMAND = "Unknown command. Please type `help` for available commands.";
    public static final String MESSAGE_INVALID_TASK_INDEX = "A valid task index was not provided";
    public static final String MESSAGE_SAVING_FAILURE = "The data could not be saved";
    public static final String MESSAGE_STORAGE_SAME_LOCATION = "Current storage path is already set to %s.";
    public static final String MESSAGE_NO_STORAGE_PATH = "No storage path was provided.";
    public static final String MESSAGE_SET_STORAGE_FAILURE = "The storage path %s is invalid.";
    public static final String MESSAGE_SET_STORAGE_SUCCESS = "Data storage path was changed to %s.";
    public static final String MESSAGE_INVALID_COMMAND_FORMAT = "Invalid command format. "
            + "Please type `help %s` for assistance.";
}
```
###### /java/seedu/toluist/commons/core/SwitchConfig.java
``` java
package seedu.toluist.commons.core;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Optional;
import java.util.Set;

import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.model.TaskSwitchPredicate;

/**
 * Store the mapping for each tab & keyword
 */
public class SwitchConfig {
    private ArrayList<TaskSwitchPredicate> predicateArrayList = new ArrayList<>();
    private HashMap<String, TaskSwitchPredicate> keywordPredicateMapping = new HashMap<>();
    private static final String[] KEYWORDS_INCOMPLETE = new String[] { "incomplete", "1" };
    private static final String[] KEYWORDS_COMPLETE = new String[] { "completed", "4" };
    private static final String[] KEYWORDS_TODAY = new String[] { "today", "2" };
    private static final String[] KEYWORDS_NEXT_7_DAYS = new String[] { "next7days", "3" };
    private static final String[] KEYWORDS_ALL = new String[] { "all", "5" };

    public static SwitchConfig getDefaultSwitchConfig() {
        SwitchConfig switchConfig = new SwitchConfig();
        switchConfig.setPredicate(TaskSwitchPredicate.SWITCH_PREDICATE_INCOMPLETE, KEYWORDS_INCOMPLETE);
        switchConfig.setPredicate(TaskSwitchPredicate.SWITCH_PREDICATE_TODAY, KEYWORDS_TODAY);
        switchConfig.setPredicate(TaskSwitchPredicate.SWITCH_PREDICATE_NEXT_7_DAYS, KEYWORDS_NEXT_7_DAYS);
        switchConfig.setPredicate(TaskSwitchPredicate.COMPLETED_SWITCH_PREDICATE, KEYWORDS_COMPLETE);
        switchConfig.setPredicate(TaskSwitchPredicate.SWITCH_PREDICATE_ALL, KEYWORDS_ALL);
        return switchConfig;
    }

    /**
     * Add predicate to config with matching keywords
     * The assumption is that keywords which are prefixes of each others won't be added
     * @param predicate the predicate
     * @param keywords varargs of keywords
     */
    public void setPredicate(TaskSwitchPredicate predicate, String... keywords) {
        if (!predicateArrayList.contains(predicate)) {
            predicateArrayList.add(predicate);
        }

        for (String keyword : keywords) {
            keywordPredicateMapping.put(keyword.toLowerCase(), predicate);
        }
    }

    /**
     * Return matching predicate for a keyword
     * @param keyword
     * @return a present optional of the predicate if there is a match, Optional.empty() otherwise
     */
    public Optional<TaskSwitchPredicate> getPredicate(String keyword) {
        Optional<String> matchingKey = keywordPredicateMapping.keySet().stream()
                .filter(key -> StringUtil.startsWithIgnoreCase(key, keyword))
                .findFirst();
        if (!matchingKey.isPresent()) {
            return Optional.empty();
        }
        return Optional.of(keywordPredicateMapping.get(matchingKey.get()));
    }

    /**
     * Return lists of predicates
     */
    public List<TaskSwitchPredicate> getAllPredicates() {
        return predicateArrayList;
    }

    /**
     * Return set of keys
     */
    public Set<String> getAllKeys() {
        return keywordPredicateMapping.keySet();
    }
}
```
###### /java/seedu/toluist/commons/exceptions/InvalidCommandException.java
``` java
package seedu.toluist.commons.exceptions;

/**
 * Signals that some given command does not fulfill some constraints.
 */
public class InvalidCommandException extends Exception {
    /**
     * @param message should contain relevant information on the failed constraint(s)
     */
    public InvalidCommandException(String message) {
        super(message);
    }
}
```
###### /java/seedu/toluist/commons/util/CollectionUtil.java
``` java
    /**
     * Returns true if the two collections holds exactly the same set of items, and have same sizes
     */
    public static <T> boolean elementsAreSimilar(Collection<T> items1, Collection<T> items2) {
        for (T item1 : items1) {
            if (!items2.contains(item1)) {
                return false;
            }
        }
        return items1.size() == items2.size();
    }

    /**
     * Convert items to string, using each item's default toString method
     */
    public static <T> String getStringRepresentation(String delimiter, Collection<T> items) {
        List<String> itemStringList = items.stream().map(T::toString).collect(Collectors.toList());
        return String.join(delimiter, itemStringList);
    }
}
```
###### /java/seedu/toluist/commons/util/DateTimeFormatterUtil.java
``` java
package seedu.toluist.commons.util;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import seedu.toluist.model.Task.RecurringFrequency;

/**
 * A class to assist in formatting date
 */
public class DateTimeFormatterUtil {
    public static final String EVERY = "Every";
    public static final String OF_THE = "of the";
    public static final String TO = "to";
    public static final String UNTIL = "until";
    public static final String TASK_DEADLINE = "by ";
    public static final String EVENT_TO = " to ";
    public static final String YESTERDAY = "yesterday";
    public static final String TODAY = "today";
    public static final String TOMORROW = "tomorrow";
    public static final String DAY = "day";
    public static final String WEEK = "week";
    public static final String MONTH = "month";
    public static final String YEAR = "year";
    public static final String FORMAT_DAY_OF_WEEK = "EEEE";
    public static final String FORMAT_DAY_OF_MONTH = "d";
    public static final String FORMAT_MONTH_OF_YEAR = "MMMM";
    public static final String FORMAT_DATE = "E, dd MMM yyy";
    public static final String FORMAT_TIME = "hh:mm a";
    public static final String DATE_TIME_SEPARATOR = ", ";
    public static final String RECURRING_DATE_SEPARATOR = StringUtil.SINGLE_SPACE;
    public static final String SUFFIX_FIRST = "st";
    public static final String SUFFIX_SECOND = "nd";
    public static final String SUFFIX_THIRD = "rd";
    public static final String SUFFIX_FOURTH_ONWARDS = "th";

    /**
     * Format task deadline
     */
    public static String formatTaskDeadline(LocalDateTime deadline) {
        return TASK_DEADLINE + formatDate(deadline) + DATE_TIME_SEPARATOR + formatTime(deadline);
    }

    /**
     * Format event range
     */
    public static String formatEventRange(LocalDateTime from, LocalDateTime to) {
        String dateFrom = formatDate(from);
        String dateTo = formatDate(to);
        String timeFrom = formatTime(from);
        String timeTo = formatTime(to);

        if (dateFrom.equals(dateTo)) {
            return dateFrom + DATE_TIME_SEPARATOR + timeFrom + EVENT_TO + timeTo;
        } else {
            return dateFrom + DATE_TIME_SEPARATOR + timeFrom + EVENT_TO + dateTo + DATE_TIME_SEPARATOR + timeTo;
        }
    }

```
###### /java/seedu/toluist/commons/util/DateTimeFormatterUtil.java
``` java
    public static String formatDateOfYear(LocalDateTime dateTime) {
        String formattedDay = formatDayOfMonth(dateTime);
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(FORMAT_MONTH_OF_YEAR);
        String formattedMonth = dateTime.format(formatter);
        return String.join(StringUtil.SINGLE_SPACE, formattedDay, formattedMonth);
    }

    public static String formatDate(LocalDateTime dateTime) {
        if (DateTimeUtil.isToday(dateTime)) {
            return TODAY;
        } else if (DateTimeUtil.isTomorrow(dateTime)) {
            return TOMORROW;
        } else if (DateTimeUtil.isYesterday(dateTime)) {
            return YESTERDAY;
        }
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(FORMAT_DATE);
        return dateTime.format(formatter);
    }


    public static String formatTime(LocalDateTime dateTime) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(FORMAT_TIME);
        return dateTime.format(formatter);
    }

```
###### /java/seedu/toluist/commons/util/DateTimeUtil.java
``` java
package seedu.toluist.commons.util;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Date;
import java.util.List;
import java.util.Objects;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

/**
 * Utility class for DateTime
 */
public class DateTimeUtil {
```
###### /java/seedu/toluist/commons/util/DateTimeUtil.java
``` java
    /**
     * Check if datetime is from today
     *
     * @param dateTime a datetime
     * @return true / false
     */
    public static boolean isToday(LocalDateTime dateTime) {
        LocalDate today = LocalDate.now();
        LocalDate date = dateTime.toLocalDate();
        return date.equals(today);
    }

    /**
     * Check if datetime is from yesterday
     *
     * @param dateTime a datetime
     * @return true / false
     */
    public static boolean isYesterday(LocalDateTime dateTime) {
        LocalDate yesterday = LocalDate.now().plusDays(-1);
        LocalDate date = dateTime.toLocalDate();
        return date.equals(yesterday);
    }

    /**
     * Check if datetime is from tomorrow
     *
     * @param dateTime a datetime
     * @return true / false
     */
    public static boolean isTomorrow(LocalDateTime dateTime) {
        LocalDate tomorrow = LocalDate.now().plusDays(1);
        LocalDate date = dateTime.toLocalDate();
        return date.equals(tomorrow);
    }

    /**
     * Check if a dateTime is before or equal to another datetime
     * null dateTime is considered to be after
     * @param dateTime1
     * @param dateTime2
     * @return true / false
     */
    public static boolean isBeforeOrEqual(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        if (Objects.equals(dateTime1, dateTime2)) {
            return true;
        }
        return isBefore(dateTime1, dateTime2);
    }

    /**
     * Check if a dateTime is before another datetime
     * null dateTime is considered to be after
     * @param dateTime1
     * @param dateTime2
     * @return true / false
     */
    public static boolean isBefore(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        if (dateTime2 == null) {
            return true;
        }
        if (dateTime1 == null) {
            return false;
        }
        return dateTime1.isBefore(dateTime2);
    }
}
```
###### /java/seedu/toluist/commons/util/FileUtil.java
``` java
    /**
     * Remove a file
     *
     * @return true if file is removed, false otherwise
     */
    public static boolean removeFile(File file) {
        if (!file.exists()) {
            return true;
        }

        return file.delete();
    }

```
###### /java/seedu/toluist/commons/util/FileUtil.java
``` java
    /**
     * Converts a string to a platform-specific file path
     * @param pathWithForwardSlash A String representing a file path but using '/' as the separator
     * @return {@code pathWithForwardSlash} but '/' replaced with {@code File.separator}
     */
    public static String getPath(String pathWithForwardSlash) {
        assert pathWithForwardSlash != null;
        assert pathWithForwardSlash.contains(StringUtil.FORWARD_SLASH);
        return pathWithForwardSlash.replace(StringUtil.FORWARD_SLASH, File.separator);
    }

    /**
     * Converts a string to a file
     * @param path A String representing a file path
     * @return a new File
     */
    public static File getFile(String path) {
        String normalizedPath = path.replace(StringUtil.FORWARD_SLASH, File.separator);
        return new File(normalizedPath);
    }

}
```
###### /java/seedu/toluist/commons/util/FxViewUtil.java
``` java
    /**
     * Apply anchor 0 to all 4 corners of a node, making it take the width of the parent
     * @param node a given node
     */
    public static void makeFullWidth(Node node) {
        applyAnchorBoundaryParameters(node, 0.0, 0.0, 0.0, 0.0);
    }

    /**
     * Add a style class to a node. Style class won't be re-added if the node already has it
     * @param node a given node
     * @param styleClass a given style class string
     */
    public static void addStyleClass(Node node, String styleClass) {
        if (!node.getStyleClass().contains(styleClass)) {
            node.getStyleClass().add(styleClass);
        }
    }

    /**
     * Remove a style class from a node
     * @param node a node
     * @param styleClass a style class string
     */
    public static void removeStyleClass(Node node, String styleClass) {
        node.getStyleClass().remove(styleClass);
    }

    /**
     * Sets the key combination on node.
     * @param keyCombination the KeyCombination value of the accelerator
     * @param handler the event handler
     */
    public static void setKeyCombination(Node node, KeyCombination keyCombination,
                                         EventHandler<ActionEvent> handler) {
        node.addEventFilter(KeyEvent.KEY_PRESSED, event -> {
            if (keyCombination.match(event)) {
                handler.handle(new ActionEvent());
                event.consume();
            }
        });
    }

```
###### /java/seedu/toluist/commons/util/StringUtil.java
``` java
    /**
     * Given a noun and a count, return the count followed by the noun in singular/plural form appropriately
     * E.g:
     * "word", 1 -> "1 word"
     * "cat", 2 -> "2 cats"
     * @param noun a noun
     * @param count the quantity
     * @return noun with count
     */
    public static String nounWithCount(String noun, int count) {
        return count + StringUtil.SINGLE_SPACE + English.plural(noun, count);
    }

```
###### /java/seedu/toluist/controller/AliasController.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.model.AliasTable;
import seedu.toluist.ui.UiStore;
import seedu.toluist.ui.commons.CommandResult;

/**
 * Alias Controller is responsible for handling alias requests
 */
public class AliasController extends Controller {
    public static final String PARAMETER_ALIAS = "alias";
    public static final String PARAMETER_COMMAND = "command";
    public static final String COMMAND_WORD = "alias";

    private static final String MESSAGE_RESULT_SUCCESS = "Alias %s for %s was added";
    private static final String MESSAGE_RESULT_FAILURE = "Alias %s for %s could not be added";
    public static final String MESSAGE_RESULT_RESERVED_WORD = "%s is a reserved word";
    private static final String COMMAND_TEMPLATE = "(?iu)\\s*alias\\s+(?<alias>\\S+)\\s+(?<command>.+)";

```
###### /java/seedu/toluist/controller/AliasController.java
``` java
    private final AliasTable aliasConfig = Config.getInstance().getAliasTable();

    public void execute(Map<String, String> tokens) throws InvalidCommandException {
        String alias = tokens.get(PARAMETER_ALIAS);
        String commandPhrase = tokens.get(PARAMETER_COMMAND);

        validateReservedWord(alias);
        setAlias(alias, commandPhrase);
    }

    private void setAlias(String alias, String commandPhrase) throws InvalidCommandException {
        UiStore uiStore = UiStore.getInstance();
        if (aliasConfig.setAlias(alias, commandPhrase) && Config.getInstance().save()) {
            uiStore.setCommandResult(
                    new CommandResult(String.format(MESSAGE_RESULT_SUCCESS, alias, commandPhrase)));
        } else {
            throw new InvalidCommandException((String.format(MESSAGE_RESULT_FAILURE, alias, commandPhrase)));
        }
    }

    private void validateReservedWord(String alias) throws InvalidCommandException {
        if (aliasConfig.isReservedWord(alias)) {
            throw new InvalidCommandException(String.format(MESSAGE_RESULT_RESERVED_WORD, alias));
        }
    }

    public Map<String, String> tokenize(String command) {
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put(PARAMETER_ALIAS, matcher.group(PARAMETER_ALIAS));
        tokens.put(PARAMETER_COMMAND, matcher.group(PARAMETER_COMMAND));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }

```
###### /java/seedu/toluist/controller/Controller.java
``` java
package seedu.toluist.controller;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import javafx.util.Pair;
import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.controller.commons.KeywordTokenizer;

/**
 * Abstract Controller class
 * Controllers are in charge of receiving the input from the UI,
 * modifies the models as appropriate, and render the updated UI subsequently
 */
public abstract class Controller {
    public static final String DEFAULT_DESCRIPTION_KEYWORD = "command_description";

    /**
     * Given a command string, execute the command
     * and modifies the data appropriately. Also optionally
     * update the UI
     * @param tokens dictionary of tokens
     * @throws InvalidCommandException if some constraints fail
     */
    public abstract void execute(Map<String, String> tokens) throws InvalidCommandException;

    /**
     * Given command string, tokenize the string into
     * a dictionary of tokens
     * The default implementation uses keywordize to tokenize,
     * so controllers without keywords can override this to have their own tokenization logic
     * @param command
     * @return dictionary of tokens with value
     */
    public Map<String, String> tokenize(String command) {
        HashMap<String, String> tokens = new HashMap<>();
        for (Pair<String, String> tokenPair : keywordize(command)) {
            tokens.put(tokenPair.getKey(), tokenPair.getValue());
        }
        return tokens;
    }

    /**
     * Given command string, make that into a list of keywords,
     * in order of appearance in the commands
     * @param command
     * @return list of keywords and associated value
     */
    public List<Pair<String, String>> keywordize(String command) {
        if (!StringUtil.isPresent(command)) {
            return new ArrayList<>();
        }
        String commandWithoutCommandWord = StringUtil.replaceFirstWord(command, StringUtil.EMPTY_STRING);
        return KeywordTokenizer.tokenizeInOrder(commandWithoutCommandWord, DEFAULT_DESCRIPTION_KEYWORD,
                getCommandKeywordMap().keySet().toArray(new String[0]));
    }

    /**
     * Check if Controller can handle this command
     * @param command
     * @return true / false
     */
    public abstract boolean matchesCommand(String command);

    /**
     * Returns command word(s) used by controller
     */
    public String[] getCommandWords() {
        return new String[0];
    }

    /**
     * Returns mapping of keywords with possible values used by controller
     */
    public Map<String, String[]> getCommandKeywordMap() {
        return new HashMap<>();
    }

    /**
     * Returns array of groups of keywords that should not appear together
     * E.g /by & /from in add controller
     */
    public String[][][] getConflictingKeywordsList() {
        return new String[0][0][0];
    }

    /**
     * Return the set of all keywords that conflict with the current keyword
     * @param keyword a keyword
     * @return set of conflicting keywords
     */
    public final Set<String> getConflictingKeywords(String keyword) {
        return Arrays.stream(getConflictingKeywordsList())
                .filter(conflictingRule -> Arrays.stream(conflictingRule)
                        .flatMap(Arrays::stream)
                        .collect(Collectors.toList())
                        .contains(keyword))
                .map(conflictingRule -> Arrays.stream(conflictingRule)
                        .filter(group -> !Arrays.asList(group).contains(keyword))
                        .flatMap(Arrays::stream)
                        .collect(Collectors.toSet()))
                .flatMap(Set::stream)
                .collect(Collectors.toSet());
    }

```
###### /java/seedu/toluist/controller/ControllerLibrary.java
``` java
package seedu.toluist.controller;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Controller Library is responsible for querying the list of controllers
 */
public class ControllerLibrary {
    /**
     * Returns a collection of Controllers associated with specific commands
     */
    public Collection<Controller> getCommandControllers() {
        return new ArrayList(Arrays.asList(
                new AddTaskController(),
                new ClearController(),
                new UpdateTaskController(),
                new DeleteTaskController(),
                new StoreController(),
                new SortController(),
                new HistoryController(),
                new LoadController(),
                new UndoController(),
                new HelpController(),
                new RedoController(),
                new ExitController(),
                new AliasController(),
                new UnaliasController(),
                new ViewAliasController(),
                new UntagController(),
                new FindController(),
                new AddTagController(),
                new MarkController(),
                new SwitchController()
        ));
    }

    /**
     * Returns a collection of Controllers not associated with specific commands
     */
    public Collection<Controller> getNonCommandControllers() {
        return new ArrayList(Arrays.asList(
                new NavigateHistoryController(),
                new UnknownCommandController()
        ));
    }

    /**
     * Returns a collection of all Controllers
     */
    public Collection<Controller> getAllControllers() {
        Collection<Controller> controllers = new ArrayList<>();
        controllers.addAll(getCommandControllers());
        controllers.addAll(getNonCommandControllers());
        return controllers;
    }

    /**
     * Returns set of command words for all command controllers
     * @return set of controller command words
     */
    public Set<String> getCommandControllerCommandWords() {
        List<String> keywordList = getCommandControllers().stream()
                .map(controller -> Arrays.asList(controller.getCommandWords()))
                .flatMap(List::stream)
                .collect(Collectors.toList());
        return new HashSet<>(keywordList);
    }

```
###### /java/seedu/toluist/controller/ExitController.java
``` java
package seedu.toluist.controller;

import java.util.Map;

import seedu.toluist.commons.core.EventsCenter;
import seedu.toluist.commons.events.ui.ExitAppRequestEvent;
import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.StringUtil;

/**
 * Handle exit command
 */
public class ExitController extends Controller {
    public static final String COMMAND_WORD_EXIT = "exit";
    public static final String COMMAND_WORD_QUIT = "quit";
    private static final String COMMAND_TEMPLATE = "(?iu)^\\s*(exit|quit)\\s*";

    private static final String HELP_DETAILS = "Exits the program.";
    private static final String HELP_FORMAT = "exit/quit";
    private static final String[] HELP_COMMENTS = { "Your data will save automatically.",
                                                    "You can re-open the program by clicking on the .jar file." };

    public void execute(Map<String, String> tokens) throws InvalidCommandException {
        EventsCenter.getInstance().post(new ExitAppRequestEvent());
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public String[] getCommandWords() {
        return new String[] { COMMAND_WORD_EXIT, COMMAND_WORD_QUIT };
    }

```
###### /java/seedu/toluist/controller/LoadController.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.core.Messages;
import seedu.toluist.commons.exceptions.DataStorageException;
import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.UiStore;
import seedu.toluist.ui.commons.CommandResult;

/**
 * Responsible for loading-related task
 */
public class LoadController extends Controller {
    private static final Logger logger = LogsCenter.getLogger(LoadController.class);
    private static final String COMMAND_TEMPLATE = "(?iu)^\\s*load(\\s+(?<directory>\\S+))?\\s*";
    public static final String COMMAND_WORD = "load";
    public static final String PARAMETER_STORE_DIRECTORY = "directory";

```
###### /java/seedu/toluist/controller/LoadController.java
``` java
    public void execute(Map<String, String> tokens) throws InvalidCommandException {
        logger.info(getClass() + "will handle command");
        String path = tokens.get(PARAMETER_STORE_DIRECTORY);

        validateNoStoragePath(path);
        validateSameStorageLocation(path);
        load(path);
    }

    private void load(String path) throws InvalidCommandException {
        try {
            TodoList todoList = TodoList.getInstance();
            UiStore uiStore = UiStore.getInstance();
            todoList.load(path);
            UiStore.getInstance().setTasks(todoList.getTasks());
            uiStore.setCommandResult(
                    new CommandResult(String.format(Messages.MESSAGE_SET_STORAGE_SUCCESS, path)));
            uiStore.setStoragePath(path);
        } catch (DataStorageException e) {
            throw new InvalidCommandException(String.format(Messages.MESSAGE_SET_STORAGE_FAILURE, path));
        }
    }

    private void validateSameStorageLocation(String path) throws InvalidCommandException {
        Config config = Config.getInstance();
        String oldStoragePath = config.getTodoListFilePath();
        if (oldStoragePath.equals(path)) {
            throw new InvalidCommandException(String.format(Messages.MESSAGE_STORAGE_SAME_LOCATION, path));
        }
    }

    private void validateNoStoragePath(String path) throws InvalidCommandException {
        if (path == null) {
            throw new InvalidCommandException(Messages.MESSAGE_NO_STORAGE_PATH);
        }
    }

    public Map<String, String> tokenize(String command) {
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put(PARAMETER_STORE_DIRECTORY, matcher.group(PARAMETER_STORE_DIRECTORY));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }

```
###### /java/seedu/toluist/controller/MarkController.java
``` java
package seedu.toluist.controller;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.atteo.evo.inflector.English;

import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.core.Messages;
import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.CollectionUtil;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.controller.commons.IndexParser;
import seedu.toluist.model.Task;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.UiStore;
import seedu.toluist.ui.commons.CommandResult;

/**
 * Mark Controller is responsible for marking task complete or incomplete
 */
public class MarkController extends Controller {
    private static final String MESSAGE_RESULT_COMPLETED_SUCCESS = "%s %s marked completed";
    private static final String MESSAGE_RESULT_INCOMPLETE_SUCCESS = "%s %s marked incomplete";
    private static final String COMMAND_TEMPLATE = "(?iu)^\\s*mark(\\s+(complete|incomplete))?"
            + "(\\s+(?<index>.*))?(\\s+(complete|incomplete))?.*";
    private static final String COMMAND_WORD = "mark";

    private static final String PARAMETER_INDEX = "index";
    private static final String PARAMETER_MARK_COMPLETE = "complete";
    private static final String PARAMETER_MARK_INCOMPLETE = "incomplete";
    private static final Logger logger = LogsCenter.getLogger(MarkController.class);

```
###### /java/seedu/toluist/controller/MarkController.java
``` java
    public void execute(Map<String, String> tokens) throws InvalidCommandException {
        logger.info(getClass().toString() + " will handle command");
        String indexToken = tokens.get(PARAMETER_INDEX);
        UiStore uiStore = UiStore.getInstance();
        boolean isMarkComplete = !tokens.keySet().contains(PARAMETER_MARK_INCOMPLETE);
        List<Integer> indexes = IndexParser.splitStringToIndexes(indexToken, uiStore.getShownTasks().size());

        validateInvalidIndexes(indexes);
        mark(isMarkComplete, indexes);
    }

    private void validateInvalidIndexes(List<Integer> indexes) throws InvalidCommandException {
        if (indexes.isEmpty()) {
            throw new InvalidCommandException(Messages.MESSAGE_INVALID_TASK_INDEX);
        }
    }

    private void mark(boolean isMarkComplete, List<Integer> indexes) throws InvalidCommandException {
        CommandResult commandResult = mark(indexes, isMarkComplete);

        TodoList todoList = TodoList.getInstance();
        UiStore uiStore = UiStore.getInstance();
        if (!todoList.save()) {
            throw new InvalidCommandException(Messages.MESSAGE_SAVING_FAILURE);
        }
        uiStore.setTasks(todoList.getTasks());
        uiStore.setCommandResult(commandResult);
    }

    private CommandResult mark(List<Integer> taskIndexes, boolean isCompleted) {
        UiStore uiStore = UiStore.getInstance();
        ArrayList<Task> tasks = uiStore.getShownTasks(taskIndexes);
        for (Task task : tasks) {
            if (task.canUpdateToNextRecurringTask()) {
                task.updateToNextRecurringTask();
            } else {
                task.setCompleted(isCompleted);
            }
        }
        String indexString = CollectionUtil.getStringRepresentation(StringUtil.COMMA_DELIMITER, taskIndexes);
        String messageTemplate = isCompleted
                ? MESSAGE_RESULT_COMPLETED_SUCCESS
                : MESSAGE_RESULT_INCOMPLETE_SUCCESS;
        return new CommandResult(String.format(messageTemplate,
                English.plural(StringUtil.capitalize(StringUtil.WORD_TASK), taskIndexes.size()), indexString));
    }

    public Map<String, String> tokenize(String command) {
        Map<String, String> tokens = super.tokenize(command);
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        tokens.put(PARAMETER_INDEX, matcher.group(PARAMETER_INDEX));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }

    public Map<String, String[]> getCommandKeywordMap() {
        String[] keywords = new String[] { PARAMETER_MARK_COMPLETE, PARAMETER_MARK_INCOMPLETE };
        HashMap<String, String[]> keywordMap = new HashMap<>();
        for (String keyword : keywords) {
            keywordMap.put(keyword, new String[0]);
        }
        return keywordMap;
    }

    public String[][][] getConflictingKeywordsList() {
        return new String[][][] { new String[][] {
            new String[] { PARAMETER_MARK_INCOMPLETE },
            new String[] { PARAMETER_MARK_COMPLETE }
        }};
    }

```
###### /java/seedu/toluist/controller/RedoController.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javafx.util.Pair;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.UiStore;
import seedu.toluist.ui.commons.CommandResult;

/**
 * Responsible for redo-related task
 */
public class RedoController extends Controller {
    private static final String COMMAND_TEMPLATE = "(?iu)^\\s*redo(\\s+(?<number>\\d+))?\\s*";
    private static final String COMMAND_WORD = "redo";
    private static final String PARAMETER_REDO_TIMES = "number";
    private static final String MESSAGE_RESULT_TEMPLATE = "Your last %s %s re-applied.";
    private static final int SINGLE_REDO = 1;

```
###### /java/seedu/toluist/controller/RedoController.java
``` java
    private static final Logger logger = LogsCenter.getLogger(RedoController.class);

    public void execute(Map<String, String> tokens) throws InvalidCommandException {
        logger.info(getClass() + "will handle command");
        String redoTimesToken = tokens.get(PARAMETER_REDO_TIMES);
        int redoTimes = redoTimesToken != null ? Integer.parseInt(redoTimesToken) : SINGLE_REDO;
        redo(redoTimes);
    }

    private void redo(int redoTimes) {
        Pair<TodoList, Integer> redoResult = TodoList.getInstance().getStorage().redo(redoTimes);
        TodoList todoList = TodoList.getInstance();
        UiStore uiStore = UiStore.getInstance();
        todoList.setTasks(redoResult.getKey().getTasks());
        int actualRedoTimes = redoResult.getValue();

        uiStore.setTasks(todoList.getTasks());
        uiStore.setCommandResult(new CommandResult(String.format(MESSAGE_RESULT_TEMPLATE,
                StringUtil.nounWithCount(StringUtil.WORD_CHANGE, actualRedoTimes),
                actualRedoTimes == SINGLE_REDO ? StringUtil.WORD_WAS : StringUtil.WORD_WERE)));
    }

    public Map<String, String> tokenize(String command) {
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put(PARAMETER_REDO_TIMES, matcher.group(PARAMETER_REDO_TIMES));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }

```
###### /java/seedu/toluist/controller/StoreController.java
``` java
package seedu.toluist.controller;

import java.io.File;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.core.Messages;
import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.FileUtil;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.UiStore;
import seedu.toluist.ui.commons.CommandResult;

/**
 * Responsible for saving-related task
 */
public class StoreController extends Controller {
    private static final Logger logger = LogsCenter.getLogger(StoreController.class);
    private static final String COMMAND_TEMPLATE = "(?iu)^\\s*save(\\s+(?<directory>\\S+))?\\s*";
    public static final String COMMAND_WORD = "save";
    public static final String PARAMETER_STORE_DIRECTORY = "directory";

    public static final String MESSAGE_RESULT_WARNING_OVERWRITE = "A file exists at %s. This file will be overwritten.";

```
###### /java/seedu/toluist/controller/StoreController.java
``` java
    public void execute(Map<String, String> tokens) throws InvalidCommandException {
        logger.info(getClass() + "will handle command");
        String path = tokens.get(PARAMETER_STORE_DIRECTORY);

        validateNoStoragePath(path);
        validateSameStorageLocationPath(path);

        save(path);
    }

    private void save(String path) throws InvalidCommandException {
        String message = StringUtil.EMPTY_STRING;
        UiStore uiStore = UiStore.getInstance();
        if (FileUtil.isFileExists(new File(path))) {
            message += String.format(MESSAGE_RESULT_WARNING_OVERWRITE, path) + StringUtil.NEW_LINE;
        }

        if (TodoList.getInstance().getStorage().move(path)) {
            message += String.format(Messages.MESSAGE_SET_STORAGE_SUCCESS,
                    Config.getInstance().getTodoListFilePath());
            uiStore.setCommandResult(new CommandResult(message));
            uiStore.setStoragePath(path);
        } else {
            throw new InvalidCommandException(String.format(Messages.MESSAGE_SET_STORAGE_FAILURE, path));
        }
    }

    private void validateSameStorageLocationPath(String path) throws InvalidCommandException {
        if (Config.getInstance().getTodoListFilePath().equals(path)) {
            throw new InvalidCommandException(String.format(Messages.MESSAGE_STORAGE_SAME_LOCATION, path));
        }
    }

    private void validateNoStoragePath(String path) throws InvalidCommandException {
        if (path == null) {
            throw new InvalidCommandException(Messages.MESSAGE_NO_STORAGE_PATH);
        }
    }

    public Map<String, String> tokenize(String command) {
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put(PARAMETER_STORE_DIRECTORY, matcher.group(PARAMETER_STORE_DIRECTORY));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }

```
###### /java/seedu/toluist/controller/SwitchController.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.toluist.commons.core.SwitchConfig;
import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.model.TaskSwitchPredicate;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.UiStore;
import seedu.toluist.ui.commons.CommandResult;

/**
 * Handle switch tab command
 */
public class SwitchController extends Controller {
    public static final String MESSAGE_RESULT_SWITCH_SUCCESS_FILTERED = "Switched to tab %s."
        + " Showing %d out of %d filtered tasks.";
    public static final String MESSAGE_RESULT_SWITCH_SUCCESS_ALL = "Switched to tab %s."
            + " Showing %d out of all %d existing tasks.";
    public static final String MESSAGE_RESULT_SWITCH_FAILURE = "%s is not a valid tab.";
    public static final String MESSAGE_RESULT_NO_TAB = "A tab to switch to was not provided";
    public static final String COMMAND_WORD = "switch";
    public static final String PARAMETER_TAB = "tab";
    private static final String COMMAND_TEMPLATE = "(?iu)^\\s*switch(\\s+(?<tab>\\S+))?\\s*";
    private SwitchConfig switchConfig = SwitchConfig.getDefaultSwitchConfig();

```
###### /java/seedu/toluist/controller/SwitchController.java
``` java
    public void execute(Map<String, String> tokens) throws InvalidCommandException {
        String keyword = tokens.get(PARAMETER_TAB);

        validateNoTab(keyword);
        validateInvalidTab(keyword);

        switchTab(keyword);
    }

    private void switchTab(String keyword) {
        UiStore uiStore = UiStore.getInstance();
        TaskSwitchPredicate switchPredicate = switchConfig.getPredicate(keyword).get();
        String messageTemplate = uiStore.getTasks().size() == TodoList.getInstance().getTasks().size()
                ? MESSAGE_RESULT_SWITCH_SUCCESS_ALL
                : MESSAGE_RESULT_SWITCH_SUCCESS_FILTERED;
        UiStore.getInstance().setObservableSwitchPredicate(switchPredicate);

        uiStore.setCommandResult(new CommandResult(String.format(
                messageTemplate,
                switchPredicate.getDisplayName(),
                UiStore.getInstance().getShownTasks().size(),
                UiStore.getInstance().getTasks().size())));
    }

    private void validateInvalidTab(String keyword) throws InvalidCommandException {
        Optional<TaskSwitchPredicate> switchPredicateOptional = switchConfig.getPredicate(keyword);

        if (!switchPredicateOptional.isPresent()) {
            throw new InvalidCommandException(String.format(MESSAGE_RESULT_SWITCH_FAILURE, keyword));
        }
    }

    private void validateNoTab(String keyword) throws InvalidCommandException {
        if (keyword == null) {
            throw new InvalidCommandException(MESSAGE_RESULT_NO_TAB);
        }
    }

    public Map<String, String> tokenize(String command) {
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put(PARAMETER_TAB, matcher.group(PARAMETER_TAB));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }

    public Map<String, String[]> getCommandKeywordMap() {
        Map<String, String[]> keywords = new HashMap<>();
        for (String tab : switchConfig.getAllKeys()) {
            keywords.put(tab, new String[0]);
        }
        return keywords;
    }

    public String[][][] getConflictingKeywordsList() {
        return new String[][][] { StringUtil.collectionToArrayOfArrays(switchConfig.getAllKeys()) };
    }

```
###### /java/seedu/toluist/controller/UnaliasController.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.model.AliasTable;
import seedu.toluist.ui.UiStore;
import seedu.toluist.ui.commons.CommandResult;

/**
 * Alias Controller is responsible for handling unalias requests
 */
public class UnaliasController extends Controller {
    private static final String MESSAGE_RESULT_SUCCESS = "Alias %s has been removed";
    private static final String MESSAGE_RESULT_FAILURE = "Alias %s cannot be removed";
    public static final String MESSAGE_RESULT_NOT_ALIAS = "%s is not an alias";
    private static final String COMMAND_TEMPLATE = "(?iu)^\\s*unalias\\s+(?<alias>\\S+)\\s*";
    private static final String COMMAND_WORD = "unalias";

    private static final String PARAMETER_ALIAS = "alias";

```
###### /java/seedu/toluist/controller/UnaliasController.java
``` java
    private final AliasTable aliasConfig = Config.getInstance().getAliasTable();

    public void execute(Map<String, String> tokens) throws InvalidCommandException {
        String alias = tokens.get(PARAMETER_ALIAS);

        validateNoAlias(alias);

        unalias(alias);
    }

    private void unalias(String alias) throws InvalidCommandException {
        UiStore uiStore = UiStore.getInstance();
        if (aliasConfig.removeAlias(alias) && Config.getInstance().save()) {
            uiStore.setCommandResult(new CommandResult(String.format(MESSAGE_RESULT_SUCCESS, alias)));
        } else {
            throw new InvalidCommandException(String.format(MESSAGE_RESULT_FAILURE, alias));
        }
    }

    private void validateNoAlias(String alias) throws InvalidCommandException {
        if (!aliasConfig.isAlias(alias)) {
            throw new InvalidCommandException(String.format(MESSAGE_RESULT_NOT_ALIAS, alias));
        }
    }

    public Map<String, String> tokenize(String command) {
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put(PARAMETER_ALIAS, matcher.group(PARAMETER_ALIAS));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }

```
###### /java/seedu/toluist/controller/UndoController.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javafx.util.Pair;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.UiStore;
import seedu.toluist.ui.commons.CommandResult;

/**
 * Responsible for storage-related task
 */
public class UndoController extends Controller {
    private static final String COMMAND_TEMPLATE = "(?iu)^\\s*undo(\\s+(?<number>\\d+))?\\s*";
    private static final String COMMAND_WORD = "undo";
    private static final String PARAMETER_UNDO_TIMES = "number";
    private static final String MESSAGE_RESULT_TEMPLATE = "Your last %s to the data %s undone.";
    private static final int SINGLE_UNDO = 1;

```
###### /java/seedu/toluist/controller/UndoController.java
``` java
    private static final Logger logger = LogsCenter.getLogger(UndoController.class);

    public void execute(Map<String, String> tokens) throws InvalidCommandException {
        logger.info(getClass() + "will handle command");

        String undoTimesToken = tokens.get(PARAMETER_UNDO_TIMES);
        int undoTimes = undoTimesToken != null ? Integer.parseInt(undoTimesToken) : SINGLE_UNDO;

        undo(undoTimes);
    }

    private void undo(int undoTimes) {
        UiStore uiStore = UiStore.getInstance();
        Pair<TodoList, Integer> undoResult = TodoList.getInstance().getStorage().undo(undoTimes);
        TodoList todoList = TodoList.getInstance();
        todoList.setTasks(undoResult.getKey().getTasks());
        int actualUndoTimes =  undoResult.getValue();

        uiStore.setTasks(todoList.getTasks());

        uiStore.setCommandResult(new CommandResult(String.format(MESSAGE_RESULT_TEMPLATE,
                StringUtil.nounWithCount (StringUtil.WORD_CHANGE, actualUndoTimes),
                actualUndoTimes == SINGLE_UNDO ? StringUtil.WORD_WAS : StringUtil.WORD_WERE)));
    }

    public Map<String, String> tokenize(String command) {
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put(PARAMETER_UNDO_TIMES, matcher.group(PARAMETER_UNDO_TIMES));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }

```
###### /java/seedu/toluist/controller/UnknownCommandController.java
``` java
package seedu.toluist.controller;

import java.util.Map;

import seedu.toluist.commons.core.Messages;
import seedu.toluist.commons.exceptions.InvalidCommandException;

/**
 * UnknownCommandController is responsible for rendering the initial UI
 */
public class UnknownCommandController extends Controller {

    public void execute(Map<String, String> tokens) throws InvalidCommandException {
        throw new InvalidCommandException(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    public Map<String, String> tokenize(String command) {
        return null; // not used
    }

    public boolean matchesCommand(String command) {
        return true; // matches everything
    }
}
```
###### /java/seedu/toluist/controller/ViewAliasController.java
``` java
package seedu.toluist.controller;

import java.util.ArrayList;
import java.util.Map;
import java.util.SortedSet;
import java.util.TreeSet;

import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.model.AliasTable;
import seedu.toluist.ui.UiStore;
import seedu.toluist.ui.commons.CommandResult;

/**
 * Alias Controller is responsible for handling viewalias requests
 */
public class ViewAliasController extends Controller {
    private static final String COMMAND_TEMPLATE = "(?iu)^\\s*viewalias\\s*";
    private static final String COMMAND_WORD = "viewalias";
    private static final String COMMAND_SEPARATOR_ALIAS = ":";
    public static final String MESSAGE_RESULT_NO_ALIAS = "No aliases found";

```
###### /java/seedu/toluist/controller/ViewAliasController.java
``` java
    private static final String HELP_DETAILS = "Views aliases in the system.";
    private static final String HELP_FORMAT = "viewalias";
    private static final String[] HELP_COMMENTS = { "Related commands: `alias`, `unalias`",
                                                    "Lists aliases in the format `ALIAS:PHRASE`" };

```
###### /java/seedu/toluist/controller/ViewAliasController.java
``` java
    private final AliasTable aliasConfig = Config.getInstance().getAliasTable();

    public void execute(Map<String, String> tokens) throws InvalidCommandException {
        UiStore uiStore = UiStore.getInstance();
        Map<String, String> aliasMapping = aliasConfig.getAliasMapping();
        uiStore.setCommandResult(new CommandResult(getAliasCommandResult(aliasMapping)));
    }

    public Map<String, String> tokenize(String command) {
        return null; // not used
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }

    private String getAliasCommandResult(Map<String, String> aliasMapping) {
        ArrayList<String> lines = new ArrayList<>();

        SortedSet<String> aliases = new TreeSet<>(aliasMapping.keySet());
        for (String alias : aliases) {
            String line = alias + COMMAND_SEPARATOR_ALIAS + aliasMapping.get(alias);
            lines.add(line);
        }

        String result = String.join(StringUtil.NEW_LINE, lines);
        return result.isEmpty() ? MESSAGE_RESULT_NO_ALIAS : result;
    }

```
###### /java/seedu/toluist/dispatcher/CommandDispatcher.java
``` java
package seedu.toluist.dispatcher;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.function.Function;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import edu.emory.mathcs.backport.java.util.Collections;
import javafx.util.Pair;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.controller.Controller;
import seedu.toluist.controller.ControllerLibrary;
import seedu.toluist.controller.FindController;
import seedu.toluist.controller.HistoryController;
import seedu.toluist.controller.NavigateHistoryController;
import seedu.toluist.controller.UnknownCommandController;
import seedu.toluist.ui.UiStore;
import seedu.toluist.ui.commons.CommandResult;

public class CommandDispatcher extends Dispatcher {
    private static final Logger logger = LogsCenter.getLogger(CommandDispatcher.class);
    private static final int SUGGESTION_LIMIT = 7;
    private static final int KEYWORD_CHECK_SIZE = 2;

```
###### /java/seedu/toluist/dispatcher/CommandDispatcher.java
``` java
    public CommandDispatcher() {
        super();
        aliasConfig.setReservedKeywords(controllerLibrary.getCommandControllerCommandWords());
    }

    public void dispatchRecordingHistory(String command) {
        dispatch(command);
        commandHistory.recordCommand(command);
    }

    public void dispatch(String command) {
        String processedCommand = getDealiasedCommand(command).trim();
        logger.info("De-aliased command to be dispatched: " + processedCommand + " original command " + command);
        Controller controller = getBestFitController(processedCommand);
        logger.info("Controller class to be executed: " + controller.getClass());
        handleHistoryController(controller);
        handleNavigateHistoryController(controller);
        execute(processedCommand, controller);
    }

    /**
     * Execute command using controller
     * @param command a command that is already de-aliased
     * @param controller controller to handle the command
     */
    private void execute(String command, Controller controller) {
        Map<String, String> tokens = controller.tokenize(command);
        tokenHistoryList.recordTokens(controller.getClass(), tokens);
        try {
            controller.execute(tokens);
        } catch (InvalidCommandException e) {
            UiStore.getInstance().setCommandResult(
                    new CommandResult(e.getMessage(), CommandResult.CommandResultType.FAILURE));
        }
    }

```
###### /java/seedu/toluist/dispatcher/CommandDispatcher.java
``` java
    /**
     * Get set of suggestions for a command based on, in order:
     * - Command word / Replacement for alias suggestion
     * - Search keywords
     * - Arguments for general keywords
     * - General keywords
     */
    public SortedSet<String> getSuggestions(String command) {
        if (!StringUtil.isPresent(command)) {
            return new TreeSet<>();
        }

        List<Function<String, SortedSet<String>>> getSuggestionMethods = Arrays.asList(
                this::getCommandWordAndAliasSuggestions,
                this::getSearchSuggestions,
                this::getKeywordArgumentSuggestions,
                this::getKeywordSuggestions
        );

        SortedSet<String> suggestions = getSuggestionMethods.stream()
                .reduce(new TreeSet<String>(),
                    (accumulator, next) -> {
                        if (!accumulator.isEmpty()) {
                            return accumulator;
                        }
                        return next.apply(command).stream()
                                .limit(SUGGESTION_LIMIT)
                                .collect(Collectors.toCollection(TreeSet::new));
                    },
                    (set1, set2) -> set1); // This line will not be actually be run
        logger.info("Suggestions for command " + command +  " " + suggestions.toString());
        return suggestions;
    }

    /**
     * Return suggestions for command words, or possible alias expansion
     * @param command command string
     * @return sorted set of suggestions
     */
    private SortedSet<String> getCommandWordAndAliasSuggestions(String command) {
        SortedSet<String> suggestions = new TreeSet<>();
        String[] words = command.trim().split(StringUtil.WHITE_SPACE);

        if (command.substring(command.length() - 1).equals(StringUtil.SINGLE_SPACE) || words.length > 1) {
            return suggestions;
        }
        String firstWordOfCommand = words[0];

        Map<String, String> aliasMapping = aliasConfig.getAliasMapping();
        for (String alias : aliasMapping.keySet()) {
            if (StringUtil.startsWithIgnoreCase(alias, firstWordOfCommand)) {
                suggestions.add(aliasMapping.get(alias));
            }
        }

        for (String commandWord : controllerLibrary.getCommandControllerCommandWords()) {
            if (StringUtil.startsWithIgnoreCase(commandWord, firstWordOfCommand)) {
                suggestions.add(commandWord);
            }
        }

        suggestions.remove(firstWordOfCommand);

        return suggestions;
    }

    /**
     * Return suggestions for command keywords, not including those already used in the command
     * Works for aliased command too
     * @param command command string
     * @return sorted set of suggestions
     */
    private SortedSet<String> getKeywordSuggestions(String command) {
        String deAliasedCommand = getDealiasedCommand(command);
        String lastComponentOfCommand = StringUtil.getLastComponent(deAliasedCommand);
        Controller bestFitController = getBestFitController(deAliasedCommand);
        Map<String, String[]> keywordMap = bestFitController.getCommandKeywordMap();
        Set<String> existingKeywords = bestFitController.keywordize(deAliasedCommand).stream()
                .map(keywordValuePair -> keywordValuePair.getKey())
                .collect(Collectors.toSet());
        return keywordMap.keySet().stream()
                // do not repeat keywords
                .filter(keyword -> !existingKeywords.contains(keyword))
                // do not suggest keywords that conflict with existing keywords
                .filter(keyword -> Collections.disjoint(bestFitController.getConflictingKeywords(keyword),
                        existingKeywords))
                .filter(keyword -> StringUtil.startsWithIgnoreCase(keyword, lastComponentOfCommand))
                .collect(Collectors.toCollection(TreeSet::new));
    }

    /**
     * Return suggestions for argument for command keywords
     * Works for aliased command too
     * @param command command string
     * @return sorted set of suggestions
     */
    private SortedSet<String> getKeywordArgumentSuggestions(String command) {
        String deAliasedCommand = getDealiasedCommand(command);
        String lastComponentOfCommand = StringUtil.getLastComponent(deAliasedCommand);
        Controller bestFitController = getBestFitController(deAliasedCommand);
        Map<String, String[]> keywordMap = bestFitController.getCommandKeywordMap();
        List<Pair<String, String>> keywordValuePairs = bestFitController.keywordize(deAliasedCommand);
        if (keywordValuePairs.size() < KEYWORD_CHECK_SIZE) {
            return new TreeSet<>();
        }

        keywordValuePairs.remove(0);

        Pair<String, String> lastKeywordTokenPair = keywordValuePairs.get(keywordValuePairs.size() - 1);

        // Do not suggests arguments if something is already there
        if (!StringUtil.isPresent(lastComponentOfCommand)
            && StringUtil.isPresent(lastKeywordTokenPair.getValue())) {
            return new TreeSet<>();
        }

        return Arrays.stream(keywordMap.get(lastKeywordTokenPair.getKey()))
                .filter(value -> StringUtil.startsWithIgnoreCase(value, lastComponentOfCommand))
                .collect(Collectors.toCollection(TreeSet::new));
    }

    /**
     * Return suggestions for find/search command
     * Works for aliased command too
     * @param command command string
     * @return sorted set of suggestions
     */
    private SortedSet<String> getSearchSuggestions(String command) {
        String deAliasedCommand = getDealiasedCommand(command);
        Controller bestFitController = getBestFitController(deAliasedCommand);
        if (!(bestFitController instanceof FindController)) {
            return new TreeSet<>();
        }

        Set<String> existingKeywords = new HashSet(Arrays.asList(bestFitController.tokenize(deAliasedCommand)
                .get(FindController.PARAMETER_KEYWORDS).split(StringUtil.WHITE_SPACE)));

        String lastComponentOfCommand = StringUtil.getLastComponent(deAliasedCommand);
        return tokenHistoryList.retrieveTokens(bestFitController.getClass(), FindController.PARAMETER_KEYWORDS)
                .stream()
                .map(keywords -> keywords.split(StringUtil.WHITE_SPACE))
                .flatMap(Arrays::stream)
                .filter(value -> !existingKeywords.contains(value))
                .filter(value -> StringUtil.startsWithIgnoreCase(value, lastComponentOfCommand))
                .collect(Collectors.toCollection(TreeSet::new));
    }


    /**
     * Returns de-aliased version of a command
     * @param command a command string
     * @return the converted command
     */
    private String getDealiasedCommand(String command) {
        return aliasConfig.dealias(command);
    }

    /**
     * Retrieve the controller that can best handle a command
     * @param command command string, should have already been de-aliased but not necessarily trimmed
     * @return Controller object
     */
    private Controller getBestFitController(String command) {
        Collection<Controller> controllerCollection = controllerLibrary.getAllControllers();

        return controllerCollection
                .stream()
                .filter(controller -> controller.matchesCommand(command.trim()))
                .findFirst()
                .orElse(new UnknownCommandController()); // fail-safe
    }
}
```
###### /java/seedu/toluist/dispatcher/Dispatcher.java
``` java
package seedu.toluist.dispatcher;

import java.util.SortedSet;

import seedu.toluist.commons.core.Config;
import seedu.toluist.model.AliasTable;

/**
 * Dispatcher is the bridge between the UI input & Controller
 * It acts like a Router in a MVC. From the input, it deduces what is the appropriate
 * the controller to dispatch the command to
 */
public abstract class Dispatcher {

    /**
     * Default alias config
     */
    protected AliasTable aliasConfig = Config.getInstance().getAliasTable();

    /**
     * Dispatch a command from the Ui to a suitable Controller
     * The command will be saved in the dispatcher's command history
     * @param command
     */
    public abstract void dispatchRecordingHistory(String command);

    /**
     * Dispatch a command from the Ui to a suitable Controller.
     * @param command command to be executed
     */
    public abstract void dispatch(String command);

    /**
     * Returns set of possible command extensions from a command
     * @param command a command
     */
    public abstract SortedSet<String> getSuggestions(String command);

    /**
     * Setter DI to inject a alias config as a dependency
     * @param aliasConfig an alias config
     */
    public void setAliasConfig(AliasTable aliasConfig) {
        this.aliasConfig = aliasConfig;
    }
}
```
###### /java/seedu/toluist/dispatcher/TokenHistoryList.java
``` java
package seedu.toluist.dispatcher;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * TokenHistoryList records the list of tokens and values used in the current session
 * Sort like a cookie
 */
public class TokenHistoryList {
    private HashMap<String, HashMap<String, Set<String>>> tokenHistory = new HashMap<>();

    /**
     * Record token map for a particular controller
     * @param controllerClass a controller class
     * @param tokens dictionary of tokens
     */
    public void recordTokens(Class controllerClass, Map<String, String> tokens) {
        if (tokens == null) {
            return;
        }

        String controllerKey = controllerClass.getName();
        if (tokenHistory.get(controllerKey) == null) {
            tokenHistory.put(controllerKey, new HashMap());
        }
        HashMap<String, Set<String>> tokenHistoryForController = tokenHistory.get(controllerKey);
        for (String token : tokens.keySet()) {
            if (tokenHistoryForController.get(token) == null) {
                tokenHistoryForController.put(token, new HashSet());
            }
            tokenHistoryForController.get(token).add(tokens.get(token));
        }
    }

    /**
     * Retrieve past values for a token in the current session for a particular controller
     * @param controllerClass a controller class
     * @param tokenName token value
     * @return
     */
    public Set<String> retrieveTokens(Class controllerClass, String tokenName) {
        String controllerKey = controllerClass.getName();
        if (tokenHistory.get(controllerKey) == null
            || tokenHistory.get(controllerKey).get(tokenName) == null) {
            return new HashSet<>();
        }

        return tokenHistory.get(controllerKey).get(tokenName);
    }
}
```
###### /java/seedu/toluist/MainApp.java
``` java
package seedu.toluist;

import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.stage.Stage;
import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.core.EventsCenter;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.core.Version;
import seedu.toluist.commons.events.ui.ExitAppRequestEvent;
import seedu.toluist.commons.exceptions.DataStorageException;
import seedu.toluist.dispatcher.CommandDispatcher;
import seedu.toluist.dispatcher.Dispatcher;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.Ui;
import seedu.toluist.ui.UiManager;

/**
 * The main entry point to the application.
 */
public class MainApp extends Application {
    private static final Logger logger = LogsCenter.getLogger(MainApp.class);

    public static final Version VERSION = new Version(1, 0, 0, true);

    protected Ui ui;
    protected Dispatcher dispatcher;
    protected Config config = Config.getInstance();


    @Override
    public void init() throws Exception {
        logger.info("=============================[ Initializing ToLuist ]===========================");
        super.init();

        initLogging(config);
        initDispatcher();
        initDispatcher();
        initUi();
        initModel();
        initEventsCenter();
    }

    private void initDispatcher() {
        dispatcher = new CommandDispatcher();
    }

    private void initUi() {
        ui = UiManager.getInstance();
        ui.init(dispatcher);
    }

    private void initModel() {
        try {
            TodoList.getInstance().load();
        } catch (DataStorageException e) {
            logger.info("No existing data file found");
        }
    }

    private void initLogging(Config config) {
        LogsCenter.init(config);
    }

    private void initEventsCenter() {
        EventsCenter.getInstance().registerHandler(this);
    }

    @Override
    public void start(Stage primaryStage) {
        logger.info("Starting ToLuist " + MainApp.VERSION);
        ui.start(primaryStage);
    }

    @Override
    public void stop() {
        logger.info("============================ [ Stopping ToLuist ] =============================");
        ui.stop();
        Platform.exit();
        System.exit(0);
    }

    @Subscribe
    public void handleExitAppRequestEvent(ExitAppRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        this.stop();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
```
###### /java/seedu/toluist/model/AliasTable.java
``` java
package seedu.toluist.model;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import seedu.toluist.commons.util.StringUtil;

/**
 * A model to manage alias
 */
public class AliasTable {
    private Map<String, String> aliasMapping = new HashMap<>();
    private Set<String> reservedKeywords = new HashSet<>();

    public Map<String, String> getAliasMapping() {
        return aliasMapping;
    }

    /**
     * Set alias for a command. Returns success status
     * @param alias
     * @param command
     * @return true / false
     */
    public boolean setAlias(String alias, String command) {
        if (isReservedWord(alias)) {
            return false;
        }

        aliasMapping.put(alias, command);
        return true;
    }

    /**
     * Remove an alias. Return sucess status
     * @param alias
     * @return true / false
     */
    public boolean removeAlias(String alias) {
        aliasMapping.remove(alias);
        return true;
    }

    /**
     * Remove all aliases.
     */
    public void clearAliases() {
        aliasMapping.clear();
    }

    /**
     * Set reserved keywords
     * @param reservedKeywords
     */
    public void setReservedKeywords(Set<String> reservedKeywords) {
        this.reservedKeywords = reservedKeywords;
    }

    /**
     * Check if the alias is a reserved word
     * @param alias
     * @return true/false
     */
    public boolean isReservedWord(String alias) {
        return reservedKeywords.contains(alias);
    }

    /**
     * Check if argument is an alias
     * @param alias
     * @return true / false
     */
    public boolean isAlias(String alias) {
        return aliasMapping.containsKey(alias);
    }

    /**
     * Convert a command that possibly contains an alias prefix to one without
     * Recursive unpacking of alias is not supported
     * e.g if a is an alias for b, and b is an alias a, dealias(a) will return b
     * @param command
     * @return converted command
     */
    public String dealias(String command) {
        String[] wordsInCommand = command.split(StringUtil.WHITE_SPACE);
        if (wordsInCommand.length == 0) {
            return command;
        }

        String firstWord = wordsInCommand[0];

        for (String alias : getAliasMapping().keySet()) {
            if (firstWord.equals(alias)) {
                return StringUtil.replaceFirstWord(command, getAliasMapping().get(alias));
            }
        }
        return command;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof AliasTable // instanceof handles nulls
                && reservedKeywords.equals(((AliasTable) other).reservedKeywords)
                && aliasMapping.equals(((AliasTable) other).aliasMapping));
    }
}
```
###### /java/seedu/toluist/model/Tag.java
``` java
package seedu.toluist.model;

/**
 * Tag model
 */
public class Tag implements Comparable<Tag> {

    private String tagName;

    public Tag() {}

    /**
     * Validates given tag name.
     */
    public Tag(String name) {
        assert name != null;
        String trimmedName = name.trim();
        this.tagName = trimmedName;
    }

    public String getTagName() {
        return tagName;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Tag // instanceof handles nulls
                && this.tagName.equals(((Tag) other).tagName)); // state check
    }

    @Override
    public int hashCode() {
        return tagName.hashCode();
    }

    @Override
    public int compareTo(Tag other) {
        return tagName.compareTo(other.tagName);
    }
}
```
###### /java/seedu/toluist/model/Task.java
``` java
package seedu.toluist.model;

import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.Collection;
import java.util.LinkedList;
import java.util.Objects;
import java.util.TreeSet;

import edu.emory.mathcs.backport.java.util.Arrays;
import seedu.toluist.commons.util.DateTimeUtil;
import seedu.toluist.commons.util.StringUtil;

/**
 * Represents a Task
 */
public class Task implements Comparable<Task>, Cloneable {
    public static final String HIGH_PRIORITY_STRING = "high";
    public static final String LOW_PRIORITY_STRING = "low";
    private static final String ERROR_VALIDATION_EMPTY_DESCRIPTION = "Description must not be empty.";
    private static final String ERROR_VALIDATION_START_DATE_AFTER_END_DATE = "Start date must be before end date.";
    private static final String ERROR_VALIDATION_UNCLASSIFIED_TASK = "Task cannot contain only start date.";
    private static final String ERROR_INVALID_PRIORITY_LEVEL = "Priority level must be either 'low' or 'high'.";
    private static final String ERROR_INVALID_RECURRING_FREQUENCY = "Recurring frequency must be either 'daily',"
            + "'weekly', 'monthly' or 'yearly'.";
    private static final String ERROR_INVALID_RECURRING_END_DATE = "Non-recurring tasks cannot have end "
            + "date of recurrence,";

```
###### /java/seedu/toluist/model/Task.java
``` java
    // List of tags is unique
    private TreeSet<Tag> allTags = new TreeSet<>();
    private String description;
    private LocalDateTime startDateTime;
    private LocalDateTime endDateTime;
    private LocalDateTime completionDateTime;
    private LocalDateTime recurringEndDateTime;
    private RecurringFrequency recurringFrequency;
    private TaskPriority priority = TaskPriority.LOW;

    public enum TaskType {
        TASK, DEADLINE, EVENT
    }

    public enum TaskPriority {
        HIGH, LOW
    }

    public enum RecurringFrequency {
        DAILY, WEEKLY, MONTHLY, YEARLY
    }

    /**
     * To be used with json deserialisation
     */
    public Task() {}

    public Task(String description) {
        this(description, null, null);
    }

    public Task(String description, LocalDateTime endDateTime) {
        this(description, null, endDateTime);
    }

```
###### /java/seedu/toluist/model/Task.java
``` java
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Task // instanceof handles nulls
                && this.description.equals(((Task) other).description)) // state check
                && this.priority.equals(((Task) other).priority)
                && this.allTags.equals(((Task) other).allTags)
                && Objects.equals(this.recurringFrequency, ((Task) other).recurringFrequency) // handles null
                && Objects.equals(this.startDateTime, ((Task) other).startDateTime) // handles null
                && Objects.equals(this.endDateTime, ((Task) other).endDateTime) // handles null
                && Objects.equals(this.completionDateTime, ((Task) other).completionDateTime) // handles null
                && Objects.equals(this.recurringEndDateTime, ((Task) other).recurringEndDateTime); // handles null
    }

    /**
     * Set a task as completed or incomplete
     * @param isCompleted true/false
     */
    public void setCompleted(boolean isCompleted) {
        if (isCompleted) {
            completionDateTime = LocalDateTime.now();
        } else {
            completionDateTime = null;
        }
    }

    /**
     * Set a deadline for a task
     * @param deadLine a LocalDateTime object
     */
    public void setDeadLine(LocalDateTime deadLine) {
        setStartDateTime(null);
        setEndDateTime(deadLine);
    }

    /**
     * Set a from and to date for an event
     * from should be before to
     * @param from a LocalDateTime object
     * @param to a LocalDateTime object
     */
    public void setFromTo(LocalDateTime from, LocalDateTime to) {
        assert DateTimeUtil.isBeforeOrEqual(startDateTime, endDateTime);
        setStartDateTime(from);
        setEndDateTime(to);
    }

```
###### /java/seedu/toluist/model/Task.java
``` java

    /**
     * Replace the tags in the task with the given tags
     * @param tags a collection of tags
     */
    public void replaceTags(Collection<Tag> tags) {
        this.allTags = new TreeSet<>(tags);
    }

    public TreeSet<Tag> getAllTags() {
        return allTags;
    }

    public boolean isOverdue() {
        return !isCompleted() && endDateTime != null && DateTimeUtil.isBeforeOrEqual(endDateTime, LocalDateTime.now());
    }

    public boolean isHighPriority() {
        return priority == TaskPriority.HIGH;
    }

    public boolean isFloatingTask() {
        return startDateTime == null && endDateTime == null;
    }

    public boolean isTaskWithDeadline() {
        return startDateTime == null && endDateTime != null;
    }

    public boolean isEvent() {
        return startDateTime != null && endDateTime != null;
    }

    public boolean isCompleted() {
        return completionDateTime != null && DateTimeUtil.isBeforeOrEqual(completionDateTime, LocalDateTime.now());
    }

    public boolean isRecurring() {
        return recurringFrequency != null;
    }

```
###### /java/seedu/toluist/model/Task.java
``` java
    /**
     * Check if the task datetimes are within interval
     * @param from interval from
     * @param to interval to
     * @return true / false
     */
    public boolean isWithinInterval(LocalDateTime from, LocalDateTime to) {
        boolean startDateTimeWithinInterval = from == null
                || (startDateTime != null
                && DateTimeUtil.isBeforeOrEqual(from, startDateTime)
                && DateTimeUtil.isBeforeOrEqual(startDateTime, to));
        boolean endDateTimeWithinInterval = to == null
                || (endDateTime != null
                && DateTimeUtil.isBeforeOrEqual(from, endDateTime)
                && DateTimeUtil.isBeforeOrEqual(endDateTime, to));
        return startDateTimeWithinInterval || endDateTimeWithinInterval;
    }

```
###### /java/seedu/toluist/model/Task.java
``` java
    public TaskPriority getTaskPriority() {
        return priority;
    }

    public void setTaskPriority(TaskPriority priority) {
        this.priority = priority;
    }

    public void setTaskPriority(String priorityString) throws IllegalArgumentException {
        switch (priorityString.toLowerCase()) {
        case HIGH_PRIORITY_STRING:
            setTaskPriority(TaskPriority.HIGH);
            break;
        case LOW_PRIORITY_STRING:
            setTaskPriority(TaskPriority.LOW);
            break;
        default:
            throw new IllegalArgumentException(ERROR_INVALID_PRIORITY_LEVEL);
        }
    }

    public LocalDateTime getCompletionDateTime() {
        return completionDateTime;
    }

```
###### /java/seedu/toluist/model/TaskSwitchPredicate.java
``` java
package seedu.toluist.model;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.function.Predicate;

/**
 * Predicates to filter tasks on switching tab
 */
public class TaskSwitchPredicate {
    public static final Predicate<Task> PREDICATE_ALL = task -> true;
    public static final Predicate<Task> PREDICATE_INCOMPLETE = task -> !task.isCompleted();
    public static final Predicate<Task> PREDICATE_COMPLETED = task -> task.isCompleted();
    public static final Predicate<Task> PREDICATE_TODAY = task -> {
        ZonedDateTime startOfTodayDatetime = ZonedDateTime.now().toLocalDate()
                .atStartOfDay(ZoneId.systemDefault());
        LocalDateTime startOfToday =  LocalDateTime
                .ofInstant(startOfTodayDatetime.toInstant(), ZoneId.systemDefault());

        ZonedDateTime endOfTodayDatetime = ZonedDateTime.now().toLocalDate()
                .atStartOfDay(ZoneId.systemDefault())
                .plusDays(1).minusSeconds(1);
        LocalDateTime endOfToday =  LocalDateTime
                .ofInstant(endOfTodayDatetime.toInstant(), ZoneId.systemDefault());

        return task.isWithinInterval(startOfToday, endOfToday);
    };
    public static final Predicate<Task> PREDICATE_NEXT_7_DAYS = task -> {
        ZonedDateTime startOfTomorrowDatetime = ZonedDateTime.now().toLocalDate()
                .plusDays(1).atStartOfDay(ZoneId.systemDefault());
        LocalDateTime startOfTomorrow =  LocalDateTime
                .ofInstant(startOfTomorrowDatetime.toInstant(), ZoneId.systemDefault());

        ZonedDateTime endOf7DaysDatetime = ZonedDateTime.now().toLocalDate()
                .atStartOfDay(ZoneId.systemDefault())
                .plusDays(8).minusSeconds(1);
        LocalDateTime endOf7Days =  LocalDateTime
                .ofInstant(endOf7DaysDatetime.toInstant(), ZoneId.systemDefault());

        return task.isWithinInterval(startOfTomorrow, endOf7Days);
    };
    public static final TaskSwitchPredicate SWITCH_PREDICATE_ALL =
            new TaskSwitchPredicate(PREDICATE_ALL, "ALL");
    public static final TaskSwitchPredicate SWITCH_PREDICATE_INCOMPLETE =
            new TaskSwitchPredicate(PREDICATE_INCOMPLETE, "INCOMPLETE");
    public static final TaskSwitchPredicate COMPLETED_SWITCH_PREDICATE =
            new TaskSwitchPredicate(PREDICATE_COMPLETED, "COMPLETED");
    public static final TaskSwitchPredicate SWITCH_PREDICATE_TODAY =
            new TaskSwitchPredicate(PREDICATE_TODAY, "TODAY");
    public static final TaskSwitchPredicate SWITCH_PREDICATE_NEXT_7_DAYS =
            new TaskSwitchPredicate(PREDICATE_NEXT_7_DAYS, "NEXT 7 DAYS");

    private final Predicate<Task> predicate;
    private final String displayName;

    public TaskSwitchPredicate(Predicate<Task> predicate, String displayName) {
        this.predicate = predicate;
        this.displayName = displayName;
    }

    public Predicate<Task> getPredicate() {
        return predicate;
    }

    public String getDisplayName() {
        return displayName;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskSwitchPredicate // instanceof handles nulls
                && predicate.equals(((TaskSwitchPredicate) other).predicate)
                && displayName.equals(((TaskSwitchPredicate) other).displayName));
    }
}
```
###### /java/seedu/toluist/model/TodoList.java
``` java
package seedu.toluist.model;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import com.fasterxml.jackson.annotation.JsonIgnore;

import seedu.toluist.commons.exceptions.DataStorageException;
import seedu.toluist.storage.JsonStorage;
import seedu.toluist.storage.TodoListStorage;

/**
 * TodoList Model
 */
public class TodoList {
    private static TodoList instance;

    private ArrayList<Task> allTasks = new ArrayList<>();
    @JsonIgnore
    private TodoListStorage storage = new JsonStorage();

    public boolean equals(Object other) {
        return other == this // short circuit if same objectå
                || (other instanceof TodoList // instanceof handles nulls
                && allTasks.equals(((TodoList) other).getTasks()));
    }

    public ArrayList<Task> getTasks() {
        return allTasks;
    }

    public static TodoList getInstance() {
        // Initialize currentTodoList if not done
        if (instance == null) {
            instance = new TodoList();
        }

        return instance;
    }

    public void setStorage(TodoListStorage storage) {
        this.storage = storage;
    }

    public TodoListStorage getStorage() {
        return storage;
    }

    public void load() throws DataStorageException {
        TodoList loadedTodoList = storage.load();
        setTasks(loadedTodoList.getTasks());
    }

    public void load(String storagePath) throws DataStorageException {
        TodoList loadedTodoList = storage.load(storagePath);
        setTasks(loadedTodoList.getTasks());
    }

    /**
     * Save the todo list data to disk
     * @return true / false
     */
    public boolean save() {
        return storage.save(this);
    }

    /**
     * Add a task to todolist
     * @param task task to be added
     */
    public void add(Task task) {
        // Don't allow duplicate tasks
        if (allTasks.contains(task)) {
            return;
        }

        allTasks.add(task);
    }

    /**
     * Remove a task from todo list
     * @param task task to be removed
     */
    public void remove(Task task) {
        allTasks.remove(task);
    }

    /**
     * Returns list of tasks based on predicate
     * @param predicate a predicate
     * @return a list of task
     */
    public ArrayList<Task> getFilterTasks(Predicate<Task> predicate) {
        List<Task> taskList = getTasks().stream().filter(predicate).collect(Collectors.toList());
        return new ArrayList<>(taskList);
    }

```
###### /java/seedu/toluist/storage/JsonStorage.java
``` java
package seedu.toluist.storage;

import java.io.File;
import java.io.IOException;
import java.nio.file.InvalidPathException;
import java.util.ArrayDeque;
import java.util.Optional;

import com.fasterxml.jackson.core.JsonProcessingException;

import javafx.util.Pair;
import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.exceptions.DataStorageException;
import seedu.toluist.commons.util.FileUtil;
import seedu.toluist.commons.util.JsonUtil;
import seedu.toluist.model.TodoList;

/**
 * JsonStorage saves/loads TodoList object to/from json file.
 */
public class JsonStorage implements TodoListStorage {
    private Config config = Config.getInstance();
    private ArrayDeque<String> undoHistoryStack = new ArrayDeque<>();
    private ArrayDeque<String> redoHistoryStack = new ArrayDeque<>();

    public boolean save(TodoList todoList) {
        return save(todoList, Config.getInstance().getTodoListFilePath());
    }

    public boolean save(TodoList todoList, String storagePath) {
        if (!saveNotAffectingHistory(todoList, storagePath)) {
            return false;
        }
        addToHistory(todoList);
        redoHistoryStack.clear();

        Config.getInstance().setTodoListFilePath(storagePath);
        return true;
    }

    public TodoList load() throws DataStorageException {
        return load(Config.getInstance().getTodoListFilePath());
    }


    public TodoList load(String storagePath) throws DataStorageException {
        try {
            String jsonString = FileUtil.readFromFile(new File(storagePath));
            // push todo list json string into undoHistoryStack if the stack is empty
            if (undoHistoryStack.isEmpty()) {
                addToHistory(jsonString);
            }
            TodoList todoList = JsonUtil.fromJsonString(jsonString, TodoList.class);

            Config.getInstance().setTodoListFilePath(storagePath);
            return todoList;
        } catch (IOException | InvalidPathException e) {
            throw new DataStorageException(e.getMessage());
        }
    }

    public boolean move(String newStoragePath) {
        String oldStoragePath = config.getTodoListFilePath();

        TodoList todoList;
        try {
            todoList = load();
        } catch (DataStorageException e) {
            return false;
        }

        if (!saveNotAffectingHistory(todoList, newStoragePath)) {
            return false;
        }

        FileUtil.removeFile(FileUtil.getFile(oldStoragePath));

        config.setTodoListFilePath(newStoragePath);
        return config.save();
    }

    public Pair<TodoList, Integer> undo(int times) {
        assert undoHistoryStack.size() >= 1;
        int steps = times;
        while (steps > 0 && undoHistoryStack.size() > 1) {
            redoHistoryStack.addLast(undoHistoryStack.pollLast());
            steps -= 1;
        }
        TodoList todoList = todoListFromJson(undoHistoryStack.peekLast()).get();
        // So as to not clear the redo history
        saveNotAffectingHistory(todoList, config.getTodoListFilePath());
        return new Pair<>(todoList, times - steps);
    }

    public Pair<TodoList, Integer> redo(int times) {
        int steps = times;
        while (steps > 0 && redoHistoryStack.size() > 0) {
            undoHistoryStack.addLast(redoHistoryStack.pollLast());
            steps -= 1;
        }

        TodoList todoList = todoListFromJson(undoHistoryStack.peekLast()).get();
        // So as to not clear the redo history
        saveNotAffectingHistory(todoList, config.getTodoListFilePath());
        return new Pair<>(todoList, times - steps);
    }

    /**
     * Add todolist data to history, making sure that no identical todo list data appear consecutively
     * in history
     * @param todoList TodoList object
     */
    public void addToHistory(TodoList todoList) {
        try {
            addToHistory(JsonUtil.toJsonString(todoList));
        } catch (JsonProcessingException e) {
            // Should not reach here
            e.printStackTrace();
        }
    }

    /**
     * Add json representation of todolist data to history, making sure that no identical todo list data
     * appear consecutively in history
     * @param jsonString json representation of todolist data
     */
    public void addToHistory(String jsonString) {
        if (undoHistoryStack.isEmpty() || (!undoHistoryStack.getLast().equals(jsonString))) {
            undoHistoryStack.addLast(jsonString);
        }
    }

    /**
     * Save todo list to data file, but does not add it to the history stack
     * @param todoList todo list data
     * @param storagePath data file path
     * @return true if saving succeeds, otherwise false
     */
    private boolean saveNotAffectingHistory(TodoList todoList, String storagePath) {
        try {
            String jsonString = JsonUtil.toJsonString(todoList);
            FileUtil.writeToFile(FileUtil.getFile(storagePath), jsonString);
            return true;
        } catch (IOException e) {
            return false;
        }
    }

    /**
     * Get optional of TodoList from a json string
     * @param json json serialisation for todo list data
     * @return optional of todolist if the data can be deserialized successfully, otherwise Optional.empty()
     */
    private Optional<TodoList> todoListFromJson(String json) {
        try {
            TodoList todoList = JsonUtil.fromJsonString(json, TodoList.class);
            // Inject self as storage dependency
            todoList.setStorage(this);
            return Optional.of(todoList);
        } catch (IOException e) {
            return Optional.empty();
        }
    }
}
```
###### /java/seedu/toluist/storage/TodoListStorage.java
``` java
package seedu.toluist.storage;

import java.io.IOException;

import javafx.util.Pair;
import seedu.toluist.commons.exceptions.DataStorageException;
import seedu.toluist.model.TodoList;

/**
 * Interface for TodoListStorage that saves/loads TodoList data
 */
public interface TodoListStorage {
    /**
     * Serialize a todolist to the disk, using a default storage path
     * supplied by the singleton Config
     * @param todoList todolist to be saved
     * @return true if the saving was successful, false otherwise
     */
    boolean save(TodoList todoList);

    /**
     * Serialize a todolist to the disk at the specified storage path
     * If saving is successful, the todolist storage path in the config will be changed
     * accordingly
     * @param todoList todolist to be saved
     * @param todoListStoragePath storage path to save todo list data at
     * @return true if the saving was successful, false otherwise
     */
    boolean save(TodoList todoList, String todoListStoragePath);

    /**
     * Load todo list data from disk, using a default storage path
     * supplied by the singleton Config
     * @return todo list data
     * @throws DataStorageException if data cannot be loaded
     */
    TodoList load() throws DataStorageException;

    /**
     * Load todo list data from disk from the specified storage path
     * If loading is successful, the todolist storage path in the config will be changed
     * accordingly
     * @return todo list data
     * @param todoListStoragePath storage path to load todo list data from
     * @throws IOException if data cannot be loaded
     */
    TodoList load(String todoListStoragePath) throws DataStorageException;

    /**
     * Move the todo list data to somewhere else
     * If moving is successful, the todolist storage path in the config will be changed
     * accordingly
     * @param todoListStoragePath storage path to move todo list data to
     * @return true if the moving was successful, false otherwise
     */
    boolean move(String todoListStoragePath);

    /**
     * Undo the todolist by a number of times
     * @param times number of times to undo
     * @return Pair of todolist, the resulting todo list and an integer denoting the number of actual undo times
     */
    Pair<TodoList, Integer> undo(int times);

    /**
     * Redo the todolist by a number of times
     * @param times number of times to redo
     * @return Pair of todolist, the resulting todo list and an integer denoting the number of actual redo times
     */
    Pair<TodoList, Integer> redo(int times);
}
```
###### /java/seedu/toluist/ui/MainWindow.java
``` java
package seedu.toluist.ui;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.logging.Logger;

import javax.swing.ImageIcon;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.scene.Scene;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyCodeCombination;
import javafx.scene.input.KeyCombination;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Region;
import javafx.stage.Stage;

import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.core.GuiSettings;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.util.FxViewUtil;
import seedu.toluist.dispatcher.Dispatcher;
import seedu.toluist.ui.view.CommandAutoCompleteView;
import seedu.toluist.ui.view.CommandBox;
import seedu.toluist.ui.view.HelpListView;
import seedu.toluist.ui.view.ResultView;
import seedu.toluist.ui.view.StatusBar;
import seedu.toluist.ui.view.TabBarView;
import seedu.toluist.ui.view.TaskListView;

/**
 * The Main Window. Provides the basic application layout containing
 * a menu bar and space where other JavaFX elements can be placed.
 */
public class MainWindow extends UiPart<Region> {
    private static final Logger logger = LogsCenter.getLogger(MainWindow.class);
    private static final String IMAGE_PATH_LOGO = "/images/logo.png";
    private static final String FXML = "MainWindow.fxml";
    private static final int MIN_HEIGHT = 600;
    private static final int MIN_WIDTH = 800;

    private static final String COMMAND_UNDO = "undo";
    private static final String COMMAND_REDO = "redo";
    private static final String COMMAND_SWITCH = "switch ";
    private static final String COMMAND_NAVIGATEHISTORY = "navigatehistory ";
    private static final String[] KEYCODES_NAVIGATEHISTORY = new String[] { "up", "down" };
    private static final String[] KEYCODES_SWITCH = new String[] { "1", "2", "3", "4", "5" };

    private static final String APPLICATION_CLASS = "com.apple.eawt.Application";
    private static final String METHOD_GET_APPLICATION = "getApplication";
    private static final String METHOD_SET_DOCK_ICON = "setDockIconImage";

    private Stage primaryStage;
    private Dispatcher dispatcher;

    @FXML
    private AnchorPane commandBoxPlaceholder;
    @FXML
    private AnchorPane taskListPlaceholder;
    @FXML
    private AnchorPane resultDisplayPlaceholder;
    @FXML
    private AnchorPane tabPanePlaceholder;
    @FXML
    private HBox commandAutoCompletePlaceholder;
    @FXML
    private BorderPane commandAutoCompleteContainer;
    @FXML
    private AnchorPane helpPlaceholder;
    @FXML
    private AnchorPane statusBarPlaceholder;

    private CommandBox commandBox;
    private TaskListView taskListUiView;
    private ResultView resultView;
    private TabBarView tabBarView;
    private CommandAutoCompleteView commandAutoCompleteView;
    private HelpListView helpListView;
    private StatusBar statusBar;


    public MainWindow (Stage primaryStage, Dispatcher dispatcher) {
        super(FXML);

        // Set dependencies
        this.primaryStage = primaryStage;
        this.dispatcher = dispatcher;

        // Configure the UI
        setLogo();
        setWindowMinSize();
        setWindowDefaultSize();
        Scene scene = new Scene(getRoot());
        primaryStage.setScene(scene);
        configureChildrenViews();
        configureKeyCombinations();
    }

    public Stage getPrimaryStage() {
        return primaryStage;
    }

    public void render() {
        taskListUiView.render();
        commandBox.render();
        resultView.render();
        tabBarView.render();
        commandAutoCompleteView.render();
        helpListView.render();
        statusBar.render();
    }

    private void configureKeyCombinations() {
        configureSwitchTabKeyCombinations();
        configureUndoKeyCombination();
        configureRedoKeyCombination();
        configureHistoryNavigationKeyPresses();
        configureExitHelpKeyPress();
    }

    void hide() {
        primaryStage.hide();
    }

    /**
     * Configure switch tab hotkey, using underlined letters
     */
    private void configureSwitchTabKeyCombinations() {
        Arrays.stream(KEYCODES_SWITCH).forEach(tabName -> {
            KeyCombination keyCombination = new KeyCodeCombination(getKeyCode(tabName),
                    KeyCombination.CONTROL_DOWN);
            String switchCommand = COMMAND_SWITCH + tabName;
            EventHandler<ActionEvent> handler = event -> dispatcher.dispatch(switchCommand);
            FxViewUtil.setKeyCombination(getRoot(), keyCombination, handler);
        });
    }

    /**
     * Configure CTRL+Z for quick undo
     */
    private void configureUndoKeyCombination() {
        KeyCombination keyCombination = new KeyCodeCombination(KeyCode.Z, KeyCombination.CONTROL_DOWN);
        String undoCommand = COMMAND_UNDO;
        EventHandler<ActionEvent> handler = event -> dispatcher.dispatch(undoCommand);
        FxViewUtil.setKeyCombination(getRoot(), keyCombination, handler);
    }

    /**
     * Configure CTRL+Y for quick redo
     */
    private void configureRedoKeyCombination() {
        KeyCombination keyCombination = new KeyCodeCombination(KeyCode.Y, KeyCombination.CONTROL_DOWN);
        String redoCommand = COMMAND_REDO;
        EventHandler<ActionEvent> handler = event -> dispatcher.dispatch(redoCommand);
        FxViewUtil.setKeyCombination(getRoot(), keyCombination, handler);
    }

```
###### /java/seedu/toluist/ui/MainWindow.java
``` java
    /**
     * Configure keys for exitting help
     */
    private void configureExitHelpKeyPress() {
        getRoot().addEventFilter(KeyEvent.KEY_PRESSED, event -> {
            UiStore store = UiStore.getInstance();
            store.setHelp(null, new ArrayList<>());
        });
    }

```
###### /java/seedu/toluist/ui/MainWindow.java
``` java
    private AnchorPane getTaskListPlaceholder() {
        return taskListPlaceholder;
    }

    private AnchorPane getCommandBoxPlaceholder() {
        return commandBoxPlaceholder;
    }

    private AnchorPane getResultDisplayPlaceholder() {
        return resultDisplayPlaceholder;
    }

    private AnchorPane getTabPanePlaceholder() {
        return tabPanePlaceholder;
    }

    private HBox getCommandAutoCompletePlaceholder() {
        return commandAutoCompletePlaceholder;
    }

    private AnchorPane getStatusBarPlaceholder() {
        return statusBarPlaceholder;
    }

    /**
     * Set min size for window
     */
    private void setWindowMinSize() {
        primaryStage.setMinHeight(MIN_HEIGHT);
        primaryStage.setMinWidth(MIN_WIDTH);
    }

    /**
     * Sets the logo for the app
     */
    private void setLogo() {
        FxViewUtil.setStageIcon(primaryStage, IMAGE_PATH_LOGO);
        // Only in macOS, you can try to use reflection to access this library
        // and use it to set a custom app icon
        try {
            Class applicationClass = Class.forName(APPLICATION_CLASS);
            Method getApplication = applicationClass.getMethod(METHOD_GET_APPLICATION);
            Object application = getApplication.invoke(applicationClass);
            Method setDockIconImage = applicationClass.getMethod(METHOD_SET_DOCK_ICON, java.awt.Image.class);
            setDockIconImage.invoke(application,
                    new ImageIcon(MainWindow.class.getResource(IMAGE_PATH_LOGO)).getImage());
        } catch (NoSuchMethodException | IllegalAccessException
                | InvocationTargetException | ClassNotFoundException e) {
            logger.info(e.getMessage());
        }
    }

    /**
     * Sets the default size based on user config.
     */
    private void setWindowDefaultSize() {
        GuiSettings guiSettings = Config.getInstance().getGuiSettings();
        primaryStage.setHeight(guiSettings.getWindowHeight());
        primaryStage.setWidth(guiSettings.getWindowWidth());
        if (guiSettings.getWindowCoordinates() != null) {
            primaryStage.setX(guiSettings.getWindowCoordinates().getX());
            primaryStage.setY(guiSettings.getWindowCoordinates().getY());
        }
    }

    private void configureChildrenViews() {
        taskListUiView = new TaskListView();
        taskListUiView.setParent(getTaskListPlaceholder());

        commandBox = new CommandBox(dispatcher);
        commandBox.setParent(getCommandBoxPlaceholder());

        resultView = new ResultView();
        resultView.setParent(getResultDisplayPlaceholder());

        tabBarView = new TabBarView();
        tabBarView.setParent(getTabPanePlaceholder());

        commandAutoCompleteContainer.setPickOnBounds(false);
        commandAutoCompleteView = new CommandAutoCompleteView();
        commandAutoCompleteView.setParent(getCommandAutoCompletePlaceholder());

        FxViewUtil.makeFullWidth(helpPlaceholder);
        helpListView = new HelpListView();
        helpListView.setParent(helpPlaceholder);

        statusBar = new StatusBar();
        statusBar.setParent(getStatusBarPlaceholder());
    }

    void show() {
        primaryStage.show();
    }

    /**
     * Returns the current size and the position of the main Window.
     */
    GuiSettings getCurrentGuiSetting() {
        return new GuiSettings(primaryStage.getWidth(), primaryStage.getHeight(),
                (int) primaryStage.getX(), (int) primaryStage.getY());
    }
}
```
###### /java/seedu/toluist/ui/UiManager.java
``` java
package seedu.toluist.ui;

import java.util.logging.Logger;

import javafx.application.Platform;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.stage.Stage;
import seedu.toluist.commons.core.ComponentManager;
import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.dispatcher.Dispatcher;

/**
 * The manager of the UI component. Singleton
 */
public class UiManager extends ComponentManager implements Ui {
    private static final Logger logger = LogsCenter.getLogger(UiManager.class);
    private static final String BOOTSTRAP_COMMAND = "list";
    private static final String STYLESHEET_PATH = "stylesheet/DefaultTheme.css";
    private static UiManager instance;

    private MainWindow mainWindow;
    private Dispatcher dispatcher;

    public static UiManager getInstance() {
        if (instance == null) {
            instance = new UiManager();
        }
        return instance;
    }

    private UiManager() {
        super();
    }

    @Override
    public void start(Stage primaryStage) {
        logger.info("Starting UI...");
        Config config = Config.getInstance();
        primaryStage.setTitle(config.getAppTitle());

        try {
            mainWindow = new MainWindow(primaryStage, dispatcher);
            mainWindow.render();
            mainWindow.show();
            // Initial dispatch call
            dispatcher.dispatch(BOOTSTRAP_COMMAND);
        } catch (Throwable e) {
            logger.severe(StringUtil.getDetails(e));
            showFatalErrorDialogAndShutdown("Fatal error during initializing", e);
        }
    }

    @Override
    public void stop() {
        // Save the last used gui settings
        Config.getInstance().setGuiSettings(mainWindow.getCurrentGuiSetting());
        Config.getInstance().save();
        mainWindow.hide();
    }

    public void init(Dispatcher dispatcher) {
        this.dispatcher = dispatcher;
    }

    void showAlertDialogAndWait(Alert.AlertType type, String title, String headerText, String contentText) {
        showAlertDialogAndWait(mainWindow.getPrimaryStage(), type, title, headerText, contentText);
    }

    private static void showAlertDialogAndWait(Stage owner, AlertType type, String title, String headerText,
                                               String contentText) {
        final Alert alert = new Alert(type);
        alert.getDialogPane().getStylesheets().add(STYLESHEET_PATH);
        alert.initOwner(owner);
        alert.setTitle(title);
        alert.setHeaderText(headerText);
        alert.setContentText(contentText);
        alert.showAndWait();
    }

    private void showFatalErrorDialogAndShutdown(String title, Throwable e) {
        logger.severe(title + StringUtil.SINGLE_SPACE + e.getMessage() + StringUtil.getDetails(e));
        showAlertDialogAndWait(Alert.AlertType.ERROR, title, e.getMessage(), e.toString());
        Platform.exit();
        System.exit(1);
    }
}
```
###### /java/seedu/toluist/ui/UiStore.java
``` java
package seedu.toluist.ui;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import javafx.application.Platform;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.beans.value.ObservableIntegerValue;
import javafx.beans.value.ObservableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;

import javafx.util.Pair;
import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.model.Task;
import seedu.toluist.model.TaskSwitchPredicate;
import seedu.toluist.ui.commons.CommandResult;
import seedu.toluist.ui.view.UiView;

/**
 * UiStore acts like a "single source of truth" / view model for the Ui
 * Ui will observe for changes to `shownTasks` and re-render on state change
 */
public class UiStore {
    public static final int INDEX_INVALID_SUGGESTION = -1;

    private static UiStore instance;

    private ObjectProperty<TaskSwitchPredicate> observableSwitchPredicate =
            new SimpleObjectProperty<>(TaskSwitchPredicate.SWITCH_PREDICATE_INCOMPLETE);
    private ObservableList<Task> observableTasks = FXCollections.observableArrayList();
    private ObjectProperty<Pair<String, List<String>>> observableHelp =
            new SimpleObjectProperty<>(new Pair(null, new ArrayList()));
    private ObjectProperty<CommandResult> observableCommandResult =
            new SimpleObjectProperty<>(new CommandResult(StringUtil.EMPTY_STRING));
    private StringProperty commandInputProperty = new SimpleStringProperty(StringUtil.EMPTY_STRING);
    private StringProperty observableStoragePath =
            new SimpleStringProperty(Config.getInstance().getTodoListFilePath());
    private ObservableList<String> observableSuggestedCommands = FXCollections.observableArrayList();
    private SimpleIntegerProperty observableSuggestedCommandIndex =
            new SimpleIntegerProperty(INDEX_INVALID_SUGGESTION);
    private SimpleDoubleProperty observableCommandTextWidth = new SimpleDoubleProperty(0);
    private Task lastEditedTask;

    public static UiStore getInstance() {
        if (instance == null) {
            instance = new UiStore();
        }
        return instance;
    }

    private UiStore() {}

    /**
     * Bind view to an observable list. View will re-render on list change
     * @param view a UiView
     * @param observableList an observable list
     */
    public void bind(UiView view, ObservableList<?> observableList) {
        WeakReference<UiView> weakView = new WeakReference<>(view);
        observableList.addListener((ListChangeListener) (c -> {
            Platform.runLater(() -> {
                if (weakView.get() != null) {
                    weakView.get().render();
                }
            });
        }));
    }

    /**
     * Bind view to an observable value. View will re-render on value change
     * @param view a UiView
     * @param observableValue an observable value
     */
    public void bind(UiView view, ObservableValue<?> observableValue) {
        WeakReference<UiView> weakView = new WeakReference<>(view);
        observableValue.addListener(c -> {
            Platform.runLater(() -> {
                if (weakView.get() != null) {
                    weakView.get().render();
                }
            });
        });
    }

    public void setObservableSwitchPredicate(TaskSwitchPredicate switchPredicate) {
        observableSwitchPredicate.setValue(switchPredicate);
    }

    public ObservableValue<TaskSwitchPredicate> getObservableSwitchPredicate() {
        return observableSwitchPredicate;
    }

    public void setCommandResult(CommandResult commandResult) {
        observableCommandResult.setValue(commandResult);
    }

    public void setSuggestedCommands(List<String> suggestedCommands) {
        observableSuggestedCommandIndex.set(INDEX_INVALID_SUGGESTION);
        observableSuggestedCommands.setAll(suggestedCommands);
    }

    public void setStoragePath(String storagePath) {
        observableStoragePath.setValue(storagePath);
    }

    public ObservableValue<String> getObservableStoragePath() {
        return observableStoragePath;
    }

    public ObservableList<String> getObservableSuggestedCommands() {
        return observableSuggestedCommands;
    }

    public void setCommandInput(String commandInput) {
        commandInputProperty.setValue(commandInput);
    }

    public StringProperty getCommandInputProperty() {
        return commandInputProperty;
    }

    public ObservableValue<CommandResult> getObservableCommandResult() {
        return observableCommandResult;
    }

    public void incrementSuggestedCommandIndex() {
        if (observableSuggestedCommands.isEmpty()) {
            return;
        }

        observableSuggestedCommandIndex.set((observableSuggestedCommandIndex.get() + 1) %
                observableSuggestedCommands.size());
    }

    public ObservableIntegerValue getObservableSuggestedCommandIndex() {
        return observableSuggestedCommandIndex;
    }

    public void setCommandTextWidth(double width) {
        observableCommandTextWidth.setValue(width);
    }

    public DoubleProperty getObservableCommandTextWidth() {
        return observableCommandTextWidth;
    }

    public void setTasks(ArrayList<Task> tasks) {
        setTasks(tasks, null);
    }

    /**
     * Overloaded method to setTasks and last editted task at the same time
     * @params tasks tasks to replace current task
     * @param lastEditedTask last editted task
     */
    public void setTasks(ArrayList<Task> tasks, Task lastEditedTask) {
        // Sorted by default
        Collections.sort(tasks);
        this.lastEditedTask = lastEditedTask;
        observableTasks.clear();
        observableTasks.setAll(tasks);
    }

    public ArrayList<Task> getTasks() {
        return observableTasks.stream().collect(Collectors.toCollection(ArrayList::new));
    }

    public Task getLastEditedTask() {
        return lastEditedTask;
    }

    /**
     * Returns list of tasks are currently shown on the Ui
     */
    public ArrayList<Task> getShownTasks() {
        return getTasks().stream().filter(observableSwitchPredicate.get()
                .getPredicate()).collect(Collectors.toCollection(ArrayList::new));
    }

    public ArrayList<Task> getShownTasks(List<Integer> indexes) {
        List<Task> shownTasks = getShownTasks();
        ArrayList<Task> tasks = new ArrayList<>();
        for (int index : indexes) {
            if (index < 1 || index > shownTasks.size()) {
                continue;
            }
            tasks.add(shownTasks.get(index - 1));
        }
        return tasks;
    }

    public ObservableList<Task> getObservableTasks() {
        return observableTasks;
    }

    /**
     * Find the index of the task in shownTasks
     * @param task
     * @return the index if it is found, else -1
     */
    public int getTaskIndex(Task task) {
        return getShownTasks().indexOf(task);
    }

```
###### /java/seedu/toluist/ui/view/CommandBox.java
``` java
package seedu.toluist.ui.view;

import java.util.ArrayList;
import java.util.List;

import javafx.fxml.FXML;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyCodeCombination;
import javafx.scene.text.Text;
import seedu.toluist.commons.util.FxViewUtil;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.dispatcher.Dispatcher;
import seedu.toluist.ui.UiStore;
import seedu.toluist.ui.commons.CommandResult;

public class CommandBox extends UiView {
    private static final String STYLE_CLASS_ERROR = "error";
    private static final String FXML = "CommandBox.fxml";
    private final Dispatcher dispatcher;

    @FXML
    private TextField commandTextField;

    public CommandBox(Dispatcher dispatcher) {
        super(FXML);
        this.dispatcher = dispatcher;
        configureBindings();
        configureKeyCombinations();
    }

    @Override
    protected void viewDidMount () {
        FxViewUtil.makeFullWidth(getRoot());
        FxViewUtil.makeFullWidth(commandTextField);
        CommandResult commandResult = UiStore.getInstance().getObservableCommandResult().getValue();
        if (commandResult.getCommandResultType() == CommandResult.CommandResultType.FAILURE) {
            FxViewUtil.addStyleClass(commandTextField, STYLE_CLASS_ERROR);
        }
    }

    private void configureBindings() {
        UiStore store = UiStore.getInstance();
        commandTextField.textProperty().bindBidirectional(store.getCommandInputProperty());
        commandTextField.textProperty()
            .addListener(((observable, oldValue, newValue) -> handleCommandInputChanged(newValue)));
        store.bind(this, store.getObservableCommandResult());
    }

    private void configureKeyCombinations() {
        FxViewUtil.setKeyCombination(commandTextField, new KeyCodeCombination(KeyCode.TAB),
            event -> handleCommandInputAutoComplete());
        FxViewUtil.setKeyCombination(commandTextField, new KeyCodeCombination(KeyCode.ENTER),
            event -> handleCommandInputSelectSuggestedCommand());
    }

    /**
     * Dispatch the command text to the Dispatcher
     */
    private void dispatchCommand() {
        dispatcher.dispatchRecordingHistory(commandTextField.getText());
        UiStore.getInstance().setCommandInput(StringUtil.EMPTY_STRING);
    }

    /**
     * Handler for command text change
     * @param newCommand the new command text
     */
    private void handleCommandInputChanged(String newCommand) {
        List<String> suggestedCommands = new ArrayList(dispatcher.getSuggestions(newCommand));
        UiStore uiStore = UiStore.getInstance();
        uiStore.setSuggestedCommands(suggestedCommands);
        uiStore.setCommandTextWidth(getTextWidth(newCommand));
        FxViewUtil.removeStyleClass(commandTextField, STYLE_CLASS_ERROR);
    }

    /**
     * Handle command auto complete on TAB
     */
    private void handleCommandInputAutoComplete() {
        UiStore store = UiStore.getInstance();
        store.incrementSuggestedCommandIndex();

        List<String> suggestedCommands = store.getObservableSuggestedCommands();
        if (suggestedCommands.size() == 1) {
            setCommandTextField(
                    StringUtil.replaceLastComponent(commandTextField.getText(), suggestedCommands.get(0)));
        }
    }

    /**
     * Handle selection of suggested command
     * If no suggestions are selected dispatch the command
     * Otherwise auto-complete it to match the command
     */
    private void handleCommandInputSelectSuggestedCommand() {
        UiStore store = UiStore.getInstance();
        List<String> suggestedCommands = store.getObservableSuggestedCommands();
        int index = store.getObservableSuggestedCommandIndex().get();
        String commandText = commandTextField.getText();

        if (index == UiStore.INDEX_INVALID_SUGGESTION) {
            dispatchCommand();
            return;
        }

        setCommandTextField(StringUtil.replaceLastComponent(commandText, suggestedCommands.get(index)));
    }

    /**
     * Set command text to text field. Also move the caret to the end
     * @param command command string
     */
    private void setCommandTextField(String command) {
        commandTextField.setText(command);
        commandTextField.end();
    }

    /**
     * Estimate the width of certain command text
     * @param text the text string
     * @return width in double
     */
    private double getTextWidth(String text) {
        Text dummyText = new Text(text);
        return dummyText.getBoundsInLocal().getWidth();
    }
}
```
###### /java/seedu/toluist/ui/view/ResultView.java
``` java
package seedu.toluist.ui.view;

import javafx.fxml.FXML;
import javafx.scene.control.TextArea;
import javafx.scene.layout.AnchorPane;
import seedu.toluist.commons.util.FxViewUtil;
import seedu.toluist.ui.UiStore;

/**
 * A ui for the status bar that is displayed at the header of the application.
 */
public class ResultView extends UiView {

    private static final String FXML = "ResultView.fxml";

    @FXML
    private AnchorPane mainPane;

    @FXML
    private TextArea resultDisplay;

    public ResultView() {
        super(FXML);
        makeFullWidth();
        configureBindings();
    }

    private void configureBindings() {
        UiStore store = UiStore.getInstance();
        store.bind(this, store.getObservableCommandResult());
    }

    @Override
    protected void viewDidMount() {
        registerAsAnEventHandler(this);
        String result = UiStore.getInstance().getObservableCommandResult().getValue().getFeedbackToUser();
        resultDisplay.setText(result);
    }

    private void makeFullWidth() {
        FxViewUtil.makeFullWidth(getRoot());
        FxViewUtil.makeFullWidth(mainPane);
        FxViewUtil.makeFullWidth(resultDisplay);
    }
}
```
###### /java/seedu/toluist/ui/view/TabBarView.java
``` java
package seedu.toluist.ui.view;

import javafx.fxml.FXML;
import javafx.scene.layout.Pane;

import seedu.toluist.commons.core.SwitchConfig;
import seedu.toluist.commons.util.FxViewUtil;
import seedu.toluist.model.TaskSwitchPredicate;
import seedu.toluist.ui.UiStore;

/**
 * View to display the tab bar
 */
public class TabBarView extends UiView {

    private static final String FXML = "TabBarView.fxml";

    @FXML
    private Pane tabContainer;
    private SwitchConfig switchConfig = SwitchConfig.getDefaultSwitchConfig();

    public TabBarView() {
        super(FXML);
        configureBindings();
    }

    private void configureBindings() {
        UiStore store = UiStore.getInstance();
        store.bind(this, store.getObservableSwitchPredicate());
        store.bind(this, store.getObservableTasks());
    }

    @Override
    protected void viewDidMount() {
        FxViewUtil.makeFullWidth(getRoot());
        tabContainer.getChildren().clear();
        for (TaskSwitchPredicate switchPredicate : switchConfig.getAllPredicates()) {
            TabView tabView = new TabView(switchPredicate,
                    switchPredicate.equals(UiStore.getInstance().getObservableSwitchPredicate().getValue()));
            tabView.setParent(tabContainer);
            tabView.render();
        }
    }
}
```
###### /java/seedu/toluist/ui/view/TabView.java
``` java
package seedu.toluist.ui.view;

import java.util.stream.Collectors;

import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import seedu.toluist.commons.util.FxViewUtil;
import seedu.toluist.model.TaskSwitchPredicate;
import seedu.toluist.ui.UiStore;

/**
 * View to display the individual tab
 */
public class TabView extends UiView {
    private static final String STYLE_CLASS_SELECTED_TAB = "selected";
    private static final String FXML = "TabView.fxml";
    private static final String TAB_LABEL_TEMPLATE = "%s (%d/%d)";

    @FXML
    private HBox tabPane;
    @FXML
    private Label tabLabel;
    private final TaskSwitchPredicate switchPredicate;
    private final boolean isSelected;

    public TabView(TaskSwitchPredicate switchPredicate, boolean isSelected) {
        super(FXML);
        this.switchPredicate = switchPredicate;
        this.isSelected = isSelected;
    }

    @Override
    protected void viewDidMount() {
        UiStore uiStore = UiStore.getInstance();
        int numberOfShownTasks = uiStore.getTasks().stream()
                .filter(switchPredicate.getPredicate()).collect(Collectors.toList()).size();
        int numberOfTotalTasks = uiStore.getTasks().size();
        tabLabel.setText(String.format(TAB_LABEL_TEMPLATE, switchPredicate.getDisplayName(),
                numberOfShownTasks, numberOfTotalTasks));
        if (isSelected) {
            FxViewUtil.addStyleClass(tabPane, STYLE_CLASS_SELECTED_TAB);
        }
    }
}
```
###### /java/seedu/toluist/ui/view/TaskListView.java
``` java
package seedu.toluist.ui.view;

import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import seedu.toluist.commons.util.FxViewUtil;
import seedu.toluist.model.Task;
import seedu.toluist.ui.UiStore;

/**
 * TaskListView to display the list of tasks
 */
public class TaskListView extends UiView {

    private static final String FXML = "TaskListView.fxml";

    @FXML
    private ListView<Task> taskListView;

    public TaskListView() {
        super(FXML);
        FxViewUtil.makeFullWidth(getRoot());
        taskListView.setCellFactory(listView -> new TaskListViewCell());
        configureBindings();
    }

    @Override
    protected void viewDidMount () {
        UiStore store = UiStore.getInstance();
        taskListView.setItems(FXCollections.observableArrayList());
        taskListView.setItems(FXCollections.observableArrayList(store.getShownTasks()));
        int scrollIndex = Math.max(store.getShownTasks().indexOf(store.getLastEditedTask()) - 1, 0);
        Platform.runLater(() -> taskListView.scrollTo(scrollIndex));
    }

    private void configureBindings() {
        UiStore store = UiStore.getInstance();
        ObservableList<Task> taskList = store.getObservableTasks();
        store.bind(this, taskList);
        store.bind(this, store.getObservableSwitchPredicate());
    }

    class TaskListViewCell extends ListCell<Task> {

        @Override
        protected void updateItem(Task task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                TaskView taskRow = new TaskView(task, getIndex() + 1);
                setGraphic(taskRow.getRoot());
                taskRow.render();
            }
        }
    }
}
```
###### /java/seedu/toluist/ui/view/TaskStatusView.java
``` java
package seedu.toluist.ui.view;

import javafx.fxml.FXML;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;

/**
 * View to display the task's status, e.g. high priority / overdue
 */
public class TaskStatusView extends UiView {
    private static final String FXML = "TaskStatusView.fxml";

    @FXML
    private ImageView imageView;
    private final Image image;

    public TaskStatusView(Image image) {
        super(FXML);
        this.image = image;
    }

    @Override
    protected void viewDidMount() {
        imageView.setImage(image);
    }
}
```
###### /java/seedu/toluist/ui/view/TaskTypeTagView.java
``` java
package seedu.toluist.ui.view;

import seedu.toluist.commons.util.FxViewUtil;

/**
 * View to display the task type
 */
public class TaskTypeTagView extends TagView {
    private static final String STYLE_CLASS_EVENT = "event-tag";
    private static final String STYLE_CLASS_TASK = "task-tag";
    private static final String DISPLAY_NAME_EVENT = "Event";
    private static final String DISPLAY_NAME_TASK = "Task";

    final boolean isTask;

    public TaskTypeTagView(boolean isTask) {
        super(isTask ? DISPLAY_NAME_TASK : DISPLAY_NAME_EVENT);
        this.isTask = isTask;
    }

    @Override
    protected void viewDidMount() {
        super.viewDidMount();
        if (isTask) {
            FxViewUtil.addStyleClass(tagLabel, STYLE_CLASS_TASK);
        } else {
            FxViewUtil.addStyleClass(tagLabel, STYLE_CLASS_EVENT);
        }
    }
}
```
###### /java/seedu/toluist/ui/view/UiView.java
``` java
package seedu.toluist.ui.view;

import javafx.scene.layout.Pane;
import seedu.toluist.ui.UiPart;

/**
 * UiView is basic building block for the Ui
 * To setup a UiView, {@link #render()} needs to be explicitly called
 * Also a parent node is required through {@link #setParent(Pane)}
 */
public class UiView extends UiPart<Pane> {
    private Pane parent;

    public UiView(String fxmlFileName) {
        super(fxmlFileName);
    }

    public void render() {
        viewDidMount();
    }

    public void setParent(Pane newParent) {
        if (parent == newParent) {
            return;
        }

        parent = newParent;
        newParent.getChildren().add(getRoot());
    }

    public Pane getParent() {
        return parent;
    }

    protected void viewDidMount() {} // do nothing by default
}
```
###### /resources/stylesheet/Colors.css
``` css
* {
    theme-primary: #00BCD4;
    theme-primary-dark: #0097A7;
    theme-primary-light: #B2EBF2;
    theme-accent: #FFC107;
    theme-primary-text: #212121;
    theme-secondary-text: #757575;
    theme-text: #FAFAFA;
    theme-background: #E5E5DB;
    theme-danger: #EF4A4F;
}
```
###### /resources/stylesheet/DefaultTheme.css
``` css
@import "Colors.css";
@import "Fonts.css";

/* DEFAULT STYLING */

.root {
    -fx-background-color: theme-background;
    -fx-control-inner-background: theme-background;
    -fx-font-family: "Roboto Medium";
}

.scroll-bar .thumb {
    -fx-background-color: theme-primary-text;
    -fx-background-insets: 3;
}

.scroll-bar .increment-button, .scroll-bar .decrement-button {
    -fx-background-color: transparent;
    -fx-padding: 0 0 0 0;
}

.scroll-bar .increment-arrow, .scroll-bar .decrement-arrow {
    -fx-shape: " ";
}

.scroll-bar:vertical .increment-arrow, .scroll-bar:vertical .decrement-arrow {
    -fx-padding: 1 8 1 8;
}

.scroll-bar:horizontal .increment-arrow, .scroll-bar:horizontal .decrement-arrow {
    -fx-padding: 8 1 8 1;
}

.list-view {
    -fx-background-color: transparent;
}

.list-cell {
    -fx-background-color: transparent;
    -fx-border-color: theme-secondary-text;
    -fx-border-width: 0 0 1 0;
}

.list-cell:empty {
    visibility: hidden;
    -fx-border-width: 0;
}

.text-field {
    -fx-background-color: transparent;
    -fx-padding: 0.5em 0.5em 0.5em 0.1em;
    -fx-border-color: theme-primary;
    -fx-border-width: 0 0 2 0;
    -fx-prompt-text-fill: theme-secondary-text;
    -fx-highlight-fill: theme-primary-text;
    -fx-font-family: "Roboto Bold";
}

.text-field:focused {
    -fx-border-color: theme-primary-dark;
}

.text-field.error {
    -fx-border-color: theme-danger;
}

.text-area {
    -fx-background-radius: 0;
}

.text-area .content {
    -fx-background-radius: 0;
    -fx-padding: 10;
}

.label {
    -fx-font-size: 11pt;
    -fx-text-fill: theme-primary-text;
}

/* COMMON CLASSES */

.dark {
    -fx-background-color: theme-primary-text;
    -fx-control-inner-background: theme-primary-text;
    -fx-highlight-fill: theme-text;
    -fx-text-fill: theme-text;
}

.meta-text {
    -fx-text-fill: derive(theme-primary-text, 35%);
    -fx-font-style: italic;
}

.bold-text {
    -fx-font-family: "Roboto Bold";
}

.header {
    -fx-background-color: theme-primary-dark;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.8), 10, 0, 0, 0);
}

/* TAB PANE */

.tabs {
    -fx-padding: 0 10 0 10;
}

.tabs .tab .label {
    -fx-text-fill: theme-primary-light;
}

.tabs .tab .label.initial {
    -fx-border-color: theme-primary-light;
    -fx-border-width: 0 0 1 0;
    -fx-border-insets: -1;
}

.tabs .tab.selected {
    -fx-border-width: 0 0 2 0;
    -fx-border-color: theme-accent;
}

.tabs .tab.selected .label {
    -fx-text-fill: theme-text;
}

.tabs .tab.selected .label.initial {
    -fx-border-color: theme-text;
}

/* TASK */

.tasks .task.completed .status-text .text {
    -fx-strikethrough: true;
}

.tasks .task.overdue .status-text.label {
    -fx-text-fill: theme-danger;
}

.tasks .task.new .status-text.label {
    -fx-text-fill: theme-primary;
}

/* TAG */

.tag {
    -fx-padding: 5 10 5 10;
    -fx-background-radius: 5;
    -fx-font-size: 11;
}

.tag.event-tag {
    -fx-font-size: 12;
    -fx-background-color: theme-primary-dark;
}

.tag.task-tag {
    -fx-font-size: 12;
    -fx-background-color: derive(theme-accent, -10%);
}

/* COMMAND SUGGESTION */

.command-suggestions {
    -fx-background-color: theme-background;
    -fx-background-radius: 5;
    -fx-border-radius: 5;
    -fx-border-width: 2;
    -fx-border-color: theme-primary;
}

.command-suggestions .command-suggestion.selected {
    -fx-text-fill: theme-primary-dark;
}

/* HELP */

.help-container {
    -fx-background-color: theme-background;
    -fx-border-width: 0 0 2 0;
    -fx-border-color: theme-primary-text;
}

.help-container .help-header {
    -fx-padding: 10;
    -fx-text-fill: theme-text;
}

/* STATUS BAR */

.status-bar {
    -fx-background-color: theme-primary-text;
    -fx-padding: 5;
}

.status-bar .label {
    -fx-text-fill: theme-text;
    -fx-font-size: 9;
}
```
###### /resources/stylesheet/Fonts.css
``` css
@font-face {
    font-family: "Roboto";
    font-style: normal;
    font-weight: 400;
    src: url('../fonts/Roboto-Regular.ttf');
}

@font-face {
    font-family: "Roboto Medium";
    font-style: normal;
    font-weight: 500;
    src: url('../fonts/Roboto-Medium.ttf');
}

@font-face {
    font-family: "Roboto Bold";
    font-style: normal;
    font-weight: 600;
    src: url('../fonts/Roboto-Bold.ttf');
}

@font-face {
    font-family: "Roboto Light";
    text-style: normal;
    font-weight: 300;
    src: url('../fonts/Roboto-Light.ttf');
}

@font-face {
    font-family: "Roboto";
    text-style: italic;
    font-weight: 400;
    src: url('../fonts/Roboto-Italic.ttf');
}

@font-face {
    font-family: "Roboto Medium";
    text-style: italic;
    font-weight: 500;
    src: url('../fonts/Roboto-MediumItalic.ttf');
}

@font-face {
    font-family: "Roboto Mono";
    font-style: normal;
    font-weight: 400;
    src: url('../fonts/RobotoMono-Regular.ttf');
}

@font-face {
    font-family: "Roboto Mono Medium";
    font-style: normal;
    font-weight: 500;
    src: url('../fonts/RobotoMono-Medium.ttf');
}
```
###### /resources/view/CommandBox.fxml
``` fxml

<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.AnchorPane?>

<AnchorPane styleClass="command-input-pane" stylesheets="@../stylesheet/DefaultTheme.css" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <TextField fx:id="commandTextField" alignment="CENTER" promptText="Enter command here..." styleClass="command-input" />
</AnchorPane>
```
###### /resources/view/MainWindow.fxml
``` fxml

<?import javafx.geometry.Insets?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.StackPane?>
<?import javafx.scene.layout.VBox?>

<VBox maxHeight="Infinity" maxWidth="Infinity" minHeight="-Infinity" minWidth="-Infinity" spacing="8.0" stylesheets="@../stylesheet/DefaultTheme.css" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <children>
       <StackPane alignment="BOTTOM_CENTER" VBox.vgrow="ALWAYS">
         <children>
            <VBox>
               <children>
                  <AnchorPane fx:id="tabPanePlaceholder" prefWidth="200.0" />
                  <AnchorPane fx:id="taskListPlaceholder" VBox.vgrow="ALWAYS" />
                  <AnchorPane fx:id="resultDisplayPlaceholder" VBox.vgrow="NEVER" />
               </children>
            </VBox>
            <BorderPane fx:id="commandAutoCompleteContainer" StackPane.alignment="CENTER">
               <bottom>
                  <HBox fx:id="commandAutoCompletePlaceholder" alignment="CENTER" BorderPane.alignment="CENTER">
                     <BorderPane.margin>
                        <Insets bottom="8.0" />
                     </BorderPane.margin>
                  </HBox>
               </bottom>
            </BorderPane>
            <AnchorPane fx:id="helpPlaceholder" prefHeight="200.0" prefWidth="200.0" styleClass="help-container" />
         </children>
      </StackPane>
      <AnchorPane fx:id="commandBoxPlaceholder" styleClass="command-input-placeholder" VBox.vgrow="NEVER">
         <padding>
            <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
         </padding>
      </AnchorPane>
      <AnchorPane fx:id="statusBarPlaceholder" styleClass="dark" />
   </children>
</VBox>
```
###### /resources/view/ResultView.fxml
``` fxml
<?import javafx.scene.control.TextArea?>
<?import javafx.scene.layout.AnchorPane?>

<AnchorPane fx:id="mainPane" stylesheets="@../stylesheet/DefaultTheme.css" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
     <TextArea fx:id="resultDisplay" editable="false" prefHeight="115.0" prefWidth="320.0" promptText="The result of your command will be shown here." styleClass="dark" wrapText="true" />
</AnchorPane>
```
###### /resources/view/TabBarView.fxml
``` fxml

<?import java.lang.String?>
<?import javafx.scene.layout.FlowPane?>

<FlowPane fx:id="tabContainer" hgap="10.0" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" minHeight="-Infinity" minWidth="-Infinity" prefHeight="40.0" prefWidth="600.0" stylesheets="@../stylesheet/DefaultTheme.css" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <styleClass>
      <String fx:value="tabs" />
      <String fx:value="header" />
   </styleClass>
</FlowPane>
```
###### /resources/view/TabView.fxml
``` fxml

<?import java.lang.String?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.text.Font?>

<HBox fx:id="tabPane" alignment="CENTER" styleClass="tab" stylesheets="@../stylesheet/DefaultTheme.css" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <Label fx:id="tabShortcutLabel" alignment="CENTER" text="">
         <font>
            <Font name="System Bold" size="13.0" />
         </font>
         <styleClass>
            <String fx:value="initial" />
            <String fx:value="bold-text" />
         </styleClass></Label>
      <Label fx:id="tabLabel" alignment="CENTER" styleClass="bold-text" text="Label" />
   </children>
   <padding>
      <Insets bottom="5.0" left="5.0" right="5.0" top="5.0" />
   </padding>
</HBox>
```
###### /resources/view/TaskListView.fxml
``` fxml
<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.*?>
<?import java.net.URL?>
<?import javafx.scene.control.ListView?>

<VBox xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
    <stylesheets>
        <URL value="@../stylesheet/DefaultTheme.css" />
    </stylesheets>
    <children>
        <ListView fx:id="taskListView" styleClass="tasks" VBox.vgrow="ALWAYS" />
    </children>
</VBox>
```
###### /resources/view/TaskStatusView.fxml
``` fxml
<?import javafx.scene.image.ImageView?>


<ImageView fx:id="imageView" fitHeight="40.0" fitWidth="40.0" pickOnBounds="true" preserveRatio="true" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1" />
```
