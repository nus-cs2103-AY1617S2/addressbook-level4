# A0131125Y
###### /java/seedu/toluist/commons/core/Config.java
``` java
package seedu.toluist.commons.core;

import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;

import seedu.toluist.commons.exceptions.DataConversionException;
import seedu.toluist.commons.util.JsonUtil;
import seedu.toluist.model.AliasTable;

/**
 * Config values used by the app
 * Since Config is largely a global state, singleton pattern can be largely applied here
 */
public class Config {
    private static final Logger logger = LogsCenter.getLogger(Config.class);
    public static final String DEFAULT_CONFIG_FILE_PATH = "data/config.json";
    public static final String DEFAULT_TODO_LIST_FILE_PATH = "data/todolist.json";
    public static final String APP_NAME = "ToLuist App";

    private static Config instance;
    private static String configFilePath = DEFAULT_CONFIG_FILE_PATH;

    // Config values customizable through config file
    private final String appTitle = APP_NAME;
    private Level logLevel = Level.INFO;
    private AliasTable aliasTable = new AliasTable();
    private String todoListFilePath = DEFAULT_TODO_LIST_FILE_PATH;
    private GuiSettings guiSettings = new GuiSettings();

    /**
     * Load config from disk
     * @return Config data
     */
    public static Config getInstance() {
        if (instance == null) {
            try {
                instance = JsonUtil.readJsonFile(configFilePath, Config.class).orElse(new Config());
            } catch (DataConversionException e) {
                instance = new Config();
            }
        }
        return instance;
    }

    /**
     * Save config to disk
     * @return true if successful, false otherwise
     */
    public boolean save() {
        try {
            JsonUtil.saveJsonFile(this, configFilePath);
            return true;
        } catch (IOException e) {
            logger.severe("Saving config failed");
            return false;
        }
    }

    public static void setConfigFilePath(String configFilePath) {
        Config.configFilePath = configFilePath;
    }

    public void setTodoListFilePath(String todoListFilePath) {
        this.todoListFilePath = todoListFilePath;
    }

    public void setLogLevel(Level logLevel) {
        this.logLevel = logLevel;
    }

    public void setGuiSettings(GuiSettings guiSettings) {
        this.guiSettings = guiSettings;
    }

    public String getTodoListFilePath() {
        return todoListFilePath;
    }

    public String getAppTitle() {
        return appTitle;
    }

    public Level getLogLevel() {
        return logLevel;
    }

    public AliasTable getAliasTable() {
        return aliasTable;
    }

    public GuiSettings getGuiSettings() {
        return guiSettings;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Config // instanceof handles nulls
                && appTitle.equals(((Config) other).appTitle)
                && logLevel.equals(((Config) other).logLevel)
                && todoListFilePath.equals(((Config) other).todoListFilePath)
                && aliasTable.equals(((Config) other).aliasTable)
                && guiSettings.equals(((Config) other).guiSettings));
    }
}
```
###### /java/seedu/toluist/commons/core/Messages.java
``` java
package seedu.toluist.commons.core;

/**
 * Container for user visible messages.
 */
public class Messages {
    public static final String MESSAGE_UNKNOWN_COMMAND = "Unknown command";
    public static final String MESSAGE_INVALID_TASK_INDEX = "A valid task index was not provided";
    public static final String MESSAGE_SAVING_FAILURE = "The data could not be saved";
    public static final String MESSAGE_STORAGE_SAME_LOCATION = "Current storage path is already set to %s.";
    public static final String MESSAGE_NO_STORAGE_PATH = "No storage path was provided.";
    public static final String MESSAGE_SET_STORAGE_FAILURE = "The storage path %s is invalid.";
    public static final String MESSAGE_SET_STORAGE_SUCCESS = "Data storage path was changed to %s.";
}
```
###### /java/seedu/toluist/commons/core/SwitchConfig.java
``` java
package seedu.toluist.commons.core;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Optional;

import seedu.toluist.model.TaskSwitchPredicate;

/**
 * Store the mapping for each tab & keyword
 */
public class SwitchConfig {
    private ArrayList<TaskSwitchPredicate> predicateArrayList = new ArrayList<>();
    private HashMap<String, TaskSwitchPredicate> keywordPredicateMapping = new HashMap<>();

    public static SwitchConfig getDefaultSwitchConfig() {
        SwitchConfig switchConfig = new SwitchConfig();
        switchConfig.setPredicate(TaskSwitchPredicate.INCOMPLETE_SWITCH_PREDICATE, "i", "1");
        switchConfig.setPredicate(TaskSwitchPredicate.TODAY_SWITCH_PREDICATE, "t", "2");
        switchConfig.setPredicate(TaskSwitchPredicate.NEXT_7_DAYS_SWITCH_PREDICATE, "n", "3");
        switchConfig.setPredicate(TaskSwitchPredicate.COMPLETED_SWITCH_PREDICATE, "c", "4");
        switchConfig.setPredicate(TaskSwitchPredicate.ALL_SWITCH_PREDICATE, "a", "5");
        return switchConfig;
    }

    /**
     * Add predicate to config with matching keywords
     * @param predicate the predicate
     * @param keywords varargs of keywords
     */
    public void setPredicate(TaskSwitchPredicate predicate, String... keywords) {
        if (!predicateArrayList.contains(predicate)) {
            predicateArrayList.add(predicate);
        }

        for (String keyword : keywords) {
            keywordPredicateMapping.put(keyword.toLowerCase(), predicate);
        }
    }

    /**
     * Return matching predicate for a keyword
     * @param keyword
     * @return a present optional of the predicate if there is a match, Optional.empty() otherwise
     */
    public Optional<TaskSwitchPredicate> getPredicate(String keyword) {
        String normalizedKeyword = keyword.toLowerCase();
        if (!keywordPredicateMapping.containsKey(normalizedKeyword)) {
            return Optional.empty();
        }
        return Optional.of(keywordPredicateMapping.get(normalizedKeyword));
    }

    /**
     * Return lists of predicates
     */
    public List<TaskSwitchPredicate> getAllPredicates() {
        return predicateArrayList;
    }
}
```
###### /java/seedu/toluist/commons/util/CollectionUtil.java
``` java
    /**
     * Returns true if the two collections holds exactly the same set of items, and have same sizes
     */
    public static <T> boolean elementsAreSimilar(Collection<T> items1, Collection<T> items2) {
        for (T item1 : items1) {
            if (!items2.contains(item1)) {
                return false;
            }
        }
        return items1.size() == items2.size();
    }

    /**
     * Convert items to string, using each item's default toString method
     */
    public static <T> String toString(String delimiter, Collection<T> items) {
        List<String> itemStringList = items.stream().map(T::toString).collect(Collectors.toList());
        return String.join(delimiter, itemStringList);
    }
}
```
###### /java/seedu/toluist/commons/util/DateTimeFormatterUtil.java
``` java
package seedu.toluist.commons.util;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * A class to assist in formatting date
 */
public class DateTimeFormatterUtil {
    public static final String TASK_DEADLINE = "by ";
    public static final String EVENT_TO = " to ";
    public static final String YESTERDAY = "yesterday";
    public static final String TODAY = "today";
    public static final String TOMORROW = "tomorrow";
    public static final String FORMAT_DATE = "E, dd MMM yyy";
    public static final String FORMAT_TIME = "hh:mm a";
    public static final String DATE_TIME_SEPARATOR = ", ";

    /**
     * Format task deadline
     */
    public static String formatTaskDeadline(LocalDateTime deadline) {
        return TASK_DEADLINE + formatDate(deadline) + DATE_TIME_SEPARATOR + formatTime(deadline);
    }

    /**
     * Format event range
     */
    public static String formatEventRange(LocalDateTime from, LocalDateTime to) {
        String dateFrom = formatDate(from);
        String dateTo = formatDate(to);
        String timeFrom = formatTime(from);
        String timeTo = formatTime(to);

        if (dateFrom.equals(dateTo)) {
            return dateFrom + DATE_TIME_SEPARATOR + timeFrom + EVENT_TO + timeTo;
        } else {
            return dateFrom + DATE_TIME_SEPARATOR + timeFrom + EVENT_TO + dateTo + DATE_TIME_SEPARATOR + timeTo;
        }
    }

    public static String formatDate(LocalDateTime dateTime) {
        if (DateTimeUtil.isToday(dateTime)) {
            return TODAY;
        } else if (DateTimeUtil.isTomorrow(dateTime)) {
            return TOMORROW;
        } else if (DateTimeUtil.isYesterday(dateTime)) {
            return YESTERDAY;
        }
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(FORMAT_DATE);
        return dateTime.format(formatter);
    }


    public static String formatTime(LocalDateTime dateTime) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(FORMAT_TIME);
        return dateTime.format(formatter);
    }
}
```
###### /java/seedu/toluist/commons/util/DateTimeUtil.java
``` java
package seedu.toluist.commons.util;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Date;
import java.util.List;
import java.util.Objects;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

/**
 * Utility class for DateTime
 */
public class DateTimeUtil {
```
###### /java/seedu/toluist/commons/util/DateTimeUtil.java
``` java
    /**
     * Check if datetime is from today
     *
     * @param dateTime a datetime
     * @return true / false
     */
    public static boolean isToday(LocalDateTime dateTime) {
        LocalDate today = LocalDate.now();
        LocalDate date = dateTime.toLocalDate();
        return date.equals(today);
    }

    /**
     * Check if datetime is from yesterday
     *
     * @param dateTime a datetime
     * @return true / false
     */
    public static boolean isYesterday(LocalDateTime dateTime) {
        LocalDate yesterday = LocalDate.now().plusDays(-1);
        LocalDate date = dateTime.toLocalDate();
        return date.equals(yesterday);
    }

    /**
     * Check if datetime is from tomorrow
     *
     * @param dateTime a datetime
     * @return true / false
     */
    public static boolean isTomorrow(LocalDateTime dateTime) {
        LocalDate tomorrow = LocalDate.now().plusDays(1);
        LocalDate date = dateTime.toLocalDate();
        return date.equals(tomorrow);
    }

    /**
     * Check if a dateTime is before or equal to another datetime
     * null dateTime is considered to be after
     * @param dateTime1
     * @param dateTime2
     * @return true / false
     */
    public static boolean isBeforeOrEqual(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        if (Objects.equals(dateTime1, dateTime2)) {
            return true;
        }
        if (dateTime2 == null) {
            return true;
        }
        if (dateTime1 == null) {
            return false;
        }
        return dateTime1.isBefore(dateTime2);
    }
}
```
###### /java/seedu/toluist/commons/util/FileUtil.java
``` java
    /**
     * Remove a file
     *
     * @return true if file is removed, false otherwise
     */
    public static boolean removeFile(File file) {
        if (!file.exists()) {
            return true;
        }

        return file.delete();
    }

```
###### /java/seedu/toluist/commons/util/FileUtil.java
``` java
    /**
     * Converts a string to a platform-specific file path
     * @param pathWithForwardSlash A String representing a file path but using '/' as the separator
     * @return {@code pathWithForwardSlash} but '/' replaced with {@code File.separator}
     */
    public static String getPath(String pathWithForwardSlash) {
        assert pathWithForwardSlash != null;
        assert pathWithForwardSlash.contains("/");
        return pathWithForwardSlash.replace("/", File.separator);
    }

    /**
     * Converts a string to a file
     * @param path A String representing a file path
     * @return a new File
     */
    public static File getFile(String path) {
        String normalizedPath = path.replace("/", File.separator);
        return new File(normalizedPath);
    }

}
```
###### /java/seedu/toluist/commons/util/FxViewUtil.java
``` java
    /**
     * Apply anchor 0 to all 4 corners of a node, making it take the width of the parent
     * @param node a given node
     */
    public static void makeFullWidth(Node node) {
        applyAnchorBoundaryParameters(node, 0.0, 0.0, 0.0, 0.0);
    }

    /**
     * Add a style class to a node. Style class won't be re-added if the node already has it
     * @param node a given node
     * @param styleClass a given style class string
     */
    public static void addStyleClass(Node node, String styleClass) {
        if (!node.getStyleClass().contains(styleClass)) {
            node.getStyleClass().add(styleClass);
        }
    }
}
```
###### /java/seedu/toluist/commons/util/StringUtil.java
``` java
    /**
     * Given a noun and a count, return the count followed by the noun in singular/plural form appropriately
     * E.g:
     * "word", 1 -> "1 word"
     * "cat", 2 -> "2 cats"
     * @param noun a noun
     * @param count the quantity
     * @return noun with count
     */
    public static String nounWithCount(String noun, int count) {
        return count + " " + English.plural(noun, count);
    }

```
###### /java/seedu/toluist/controller/AliasController.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.toluist.commons.core.Config;
import seedu.toluist.dispatcher.CommandResult;
import seedu.toluist.model.AliasTable;

/**
 * Alias Controller is responsible for handling alias requests
 */
public class AliasController extends Controller {
    public static final String ALIAS_TERM = "alias";
    public static final String COMMAND_TERM = "command";
    public static final String COMMAND_WORD = "alias";

    private static final String RESULT_MESSAGE_SUCCESS = "Alias %s for %s was added";
    private static final String RESULT_MESSAGE_FAILURE = "Alias %s for %s could not be added";
    public static final String RESULT_MESSAGE_RESERVED_WORD = "%s is a reserved word";
    private static final String COMMAND_TEMPLATE = "alias\\s+(?<alias>\\S+)\\s+(?<command>.+)";

    private final AliasTable aliasConfig = Config.getInstance().getAliasTable();

    public CommandResult execute(String command) {
        HashMap<String, String> tokens = tokenize(command);
        String alias = tokens.get(ALIAS_TERM);
        String commandPhrase = tokens.get(COMMAND_TERM);

        if (aliasConfig.isReservedWord(alias)) {
            return new CommandResult(String.format(RESULT_MESSAGE_RESERVED_WORD, alias));
        }

        if (aliasConfig.setAlias(alias, commandPhrase) && Config.getInstance().save()) {
            return new CommandResult(String.format(RESULT_MESSAGE_SUCCESS, alias, commandPhrase));
        } else {
            return new CommandResult(String.format(RESULT_MESSAGE_FAILURE, alias, commandPhrase));
        }
    }

    public HashMap<String, String> tokenize(String command) {
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put(ALIAS_TERM, matcher.group(ALIAS_TERM));
        tokens.put(COMMAND_TERM, matcher.group(COMMAND_TERM));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public static String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }
}
```
###### /java/seedu/toluist/controller/Controller.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;

import seedu.toluist.dispatcher.CommandResult;
import seedu.toluist.ui.UiStore;


/**
 * Abstract Controller class
 * Controllers are in charge of receiving the input from the UI,
 * modifies the models as appropriate, and render the updated UI subsequently
 */
public abstract class Controller {
    /**
     * UiStore to store data to be used by Ui
     */
    protected final UiStore uiStore = UiStore.getInstance();

    /**
     * Given a command string, execute the command
     * and modifies the data appropriately. Also optionally
     * update the UI
     * @param command
     * @return
     */
    public abstract CommandResult execute(String command);

    /**
     * Given command string, tokenize the string into
     * a dictionary of tokens
     * @param command
     * @return
     */
    public abstract HashMap<String, String> tokenize(String command);

    /**
     * Check if Controller can handle this command
     * @param command
     * @return
     */
    public abstract boolean matchesCommand(String command);

    /**
     * Returns command word(s) used by controller
     */
    public static String[] getCommandWords() {
        return new String[] {};
    }
}
```
###### /java/seedu/toluist/controller/ExitController.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;

import seedu.toluist.commons.core.EventsCenter;
import seedu.toluist.commons.events.ui.ExitAppRequestEvent;
import seedu.toluist.dispatcher.CommandResult;

/**
 * Handle exit command
 */
public class ExitController extends Controller {
    public static final String COMMAND_WORD_EXIT = "exit";
    public static final String COMMAND_WORD_QUIT = "quit";
    private static final String COMMAND_TEMPLATE = "^(exit|quit)\\s*";

    public CommandResult execute(String command) {
        EventsCenter.getInstance().post(new ExitAppRequestEvent());
        // This result won't be displayed
        return new CommandResult("");
    }

    public HashMap<String, String> tokenize(String command) {
        return null; // not used
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public static String[] getCommandWords() {
        return new String[] { COMMAND_WORD_EXIT, COMMAND_WORD_QUIT };
    }
}
```
###### /java/seedu/toluist/controller/LoadController.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.core.Messages;
import seedu.toluist.commons.exceptions.DataStorageException;
import seedu.toluist.dispatcher.CommandResult;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.UiStore;

/**
 * Responsible for loading-related task
 */
public class LoadController extends Controller {
    private static final Logger logger = LogsCenter.getLogger(LoadController.class);
    private static final String COMMAND_TEMPLATE = "^load(\\s+(?<directory>\\S+))?\\s*";
    public static final String COMMAND_WORD = "load";
    public static final String STORE_DIRECTORY = "directory";

    public CommandResult execute(String command) {
        logger.info(getClass() + "will handle command");
        HashMap<String, String> tokens = tokenize(command);
        String path = tokens.get(STORE_DIRECTORY);

        if (path == null) {
            return new CommandResult(Messages.MESSAGE_NO_STORAGE_PATH);
        }

        Config config = Config.getInstance();
        String oldStoragePath = config.getTodoListFilePath();
        if (oldStoragePath.equals(path)) {
            return new CommandResult(String.format(Messages.MESSAGE_STORAGE_SAME_LOCATION, path));
        }

        // Attemp to load from new storage
        try {
            TodoList newTodoList = TodoList.load().getStorage().load(path);
            newTodoList.save();
            UiStore.getInstance().setTasks(newTodoList.getTasks());
            return new CommandResult(String.format(Messages.MESSAGE_SET_STORAGE_SUCCESS, path));
        } catch (DataStorageException e) {
            return new CommandResult(String.format(Messages.MESSAGE_SET_STORAGE_FAILURE, path));
        }
    }

    public HashMap<String, String> tokenize(String command) {
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put(STORE_DIRECTORY, matcher.group(STORE_DIRECTORY));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public static String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }
}
```
###### /java/seedu/toluist/controller/MarkController.java
``` java
package seedu.toluist.controller;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.atteo.evo.inflector.English;

import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.core.Messages;
import seedu.toluist.commons.util.CollectionUtil;
import seedu.toluist.controller.commons.IndexParser;
import seedu.toluist.dispatcher.CommandResult;
import seedu.toluist.model.Task;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.UiStore;

/**
 * Mark Controller is responsible for marking task complete or incomplete
 */
public class MarkController extends Controller {
    private static final String RESULT_MESSAGE_COMPLETED_SUCCESS = "%s %s marked completed";
    private static final String RESULT_MESSAGE_INCOMPLETE_SUCCESS = "%s %s marked incomplete";
    private static final String COMMAND_TEMPLATE = "mark(\\s+(?<markType>(complete|incomplete)))?(?<index>.*)?\\s*";
    private static final String COMMAND_WORD = "mark";

    private static final String MARK_TERM = "markType";
    private static final String INDEX_TERM = "index";
    private static final String MARK_COMPLETE = "complete";
    private static final String MARK_INCOMPLETE = "incomplete";
    private static final Logger logger = LogsCenter.getLogger(MarkController.class);

    public CommandResult execute(String command) {
        logger.info(getClass().toString() + " will handle command");

        HashMap<String, String> tokens = tokenize(command);
        String indexToken = tokens.get(INDEX_TERM);
        String markTypeToken = tokens.get(MARK_TERM);
        List<Integer> indexes = IndexParser.splitStringToIndexes(indexToken,
                UiStore.getInstance().getShownTasks().size());

        if (indexes.isEmpty()) {
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_INDEX);
        }

        CommandResult commandResult;
        if (Objects.equals(markTypeToken, MARK_INCOMPLETE)) {
            commandResult = mark(indexes, false);
        } else {
            commandResult = mark(indexes, true);
        }

        TodoList todoList = TodoList.load();
        if (!todoList.save()) {
            return new CommandResult(Messages.MESSAGE_SAVING_FAILURE);
        }
        UiStore.getInstance().setTasks(todoList.getTasks());
        return commandResult;
    }

    private CommandResult mark(List<Integer> taskIndexes, boolean isCompleted) {
        ArrayList<Task> tasks = UiStore.getInstance().getShownTasks(taskIndexes);
        for (Task task : tasks) {
            task.setCompleted(isCompleted);
        }
        String indexString = CollectionUtil.toString(", ", taskIndexes);
        String messageTemplate = isCompleted
                ? RESULT_MESSAGE_COMPLETED_SUCCESS
                : RESULT_MESSAGE_INCOMPLETE_SUCCESS;
        return new CommandResult(String.format(messageTemplate,
                English.plural("Task", taskIndexes.size()), indexString));
    }

    public HashMap<String, String> tokenize(String command) {
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put(MARK_TERM, matcher.group(MARK_TERM));
        tokens.put(INDEX_TERM, matcher.group(INDEX_TERM));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public static String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }
}
```
###### /java/seedu/toluist/controller/RedoController.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javafx.util.Pair;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.dispatcher.CommandResult;
import seedu.toluist.model.TodoList;

/**
 * Responsible for redo-related task
 */
public class RedoController extends Controller {
    private static final String COMMAND_TEMPLATE = "^redo(\\s+(?<number>\\d+))?\\s*";
    private static final String COMMAND_WORD = "redo";
    private static final String REDO_TIMES = "number";
    private static final String RESULT_MESSAGE_TEMPLATE = "Your last undone %s %s re-applied.";

    private static final Logger logger = LogsCenter.getLogger(RedoController.class);

    public CommandResult execute(String command) {
        logger.info(getClass() + "will handle command");

        HashMap<String, String> tokens = tokenize(command);
        String redoTimesToken = tokens.get(REDO_TIMES);
        int redoTimes = redoTimesToken != null ? Integer.parseInt(redoTimesToken) : 1;

        Pair<TodoList, Integer> redoResult = TodoList.load().getStorage().redo(redoTimes);
        TodoList todoList = redoResult.getKey();
        int actualRedoTimes = redoResult.getValue();

        uiStore.setTasks(todoList.getTasks());

        return new CommandResult(String.format(RESULT_MESSAGE_TEMPLATE,
                StringUtil.nounWithCount("change", actualRedoTimes),
                actualRedoTimes == 1 ? "was" : "were"));
    }

    public HashMap<String, String> tokenize(String command) {
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put(REDO_TIMES, matcher.group(REDO_TIMES));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public static String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }
}
```
###### /java/seedu/toluist/controller/StoreController.java
``` java
package seedu.toluist.controller;

import java.io.File;
import java.util.HashMap;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.core.Messages;
import seedu.toluist.commons.util.FileUtil;
import seedu.toluist.dispatcher.CommandResult;
import seedu.toluist.model.TodoList;

/**
 * Responsible for saving-related task
 */
public class StoreController extends Controller {
    private static final Logger logger = LogsCenter.getLogger(StoreController.class);
    private static final String COMMAND_TEMPLATE = "^save(\\s+(?<directory>\\S+))?\\s*";
    public static final String COMMAND_WORD = "save";
    public static final String STORE_DIRECTORY = "directory";

    public static final String RESULT_MESSAGE_WARNING_OVERWRITE = "A file exists at %s. This file will be overwritten.";

    public CommandResult execute(String command) {
        logger.info(getClass() + "will handle command");
        HashMap<String, String> tokens = tokenize(command);
        String path = tokens.get(STORE_DIRECTORY);

        if (path == null) {
            return new CommandResult(Messages.MESSAGE_NO_STORAGE_PATH);
        }

        Config config = Config.getInstance();
        if (config.getTodoListFilePath().equals(path)) {
            return new CommandResult(String.format(Messages.MESSAGE_STORAGE_SAME_LOCATION, path));
        }

        String message = "";
        if (FileUtil.isFileExists(new File(path))) {
            message += String.format(RESULT_MESSAGE_WARNING_OVERWRITE, path) + "\n";
        }

        if (TodoList.load().getStorage().move(path)) {
            message += String.format(Messages.MESSAGE_SET_STORAGE_SUCCESS, config.getTodoListFilePath());
            return new CommandResult(message);
        } else {
            return new CommandResult(String.format(Messages.MESSAGE_SET_STORAGE_FAILURE, path));
        }
    }

    public HashMap<String, String> tokenize(String command) {
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put(STORE_DIRECTORY, matcher.group(STORE_DIRECTORY));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public static String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }
}
```
###### /java/seedu/toluist/controller/SwitchController.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.toluist.commons.core.SwitchConfig;
import seedu.toluist.dispatcher.CommandResult;
import seedu.toluist.model.TaskSwitchPredicate;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.UiStore;

/**
 * Handle switch tab command
 */
public class SwitchController extends Controller {
    public static final String RESULT_MESSAGE_SWITCH_SUCCESS_FILTERED = "Switched to tab %s."
        + " Showing %d out of %d filtered tasks.";
    public static final String RESULT_MESSAGE_SWITCH_SUCCESS_ALL = "Switched to tab %s."
            + " Showing %d out of all %d existing tasks.";
    public static final String RESULT_MESSAGE_SWITCH_FAILURE = "%s is not a valid tab.";
    public static final String RESULT_MESSAGE_NO_TAB = "A tab to switch to was not provided";
    public static final String COMMAND_WORD = "switch";
    public static final String TAB = "tab";
    private static final String COMMAND_TEMPLATE = "switch(\\s+(?<tab>\\S+))?\\s*";
    private SwitchConfig switchConfig = SwitchConfig.getDefaultSwitchConfig();

    public CommandResult execute(String command) {
        HashMap<String, String> tokens = tokenize(command);
        String keyword = tokens.get(TAB);

        if (keyword == null) {
            return new CommandResult(RESULT_MESSAGE_NO_TAB);
        }

        Optional<TaskSwitchPredicate> switchPredicateOptional = switchConfig.getPredicate(keyword);

        if (!switchPredicateOptional.isPresent()) {
            return new CommandResult(String.format(RESULT_MESSAGE_SWITCH_FAILURE, keyword));
        }

        String messageTemplate = uiStore.getTasks().size() == TodoList.load().getTasks().size()
                ? RESULT_MESSAGE_SWITCH_SUCCESS_ALL
                : RESULT_MESSAGE_SWITCH_SUCCESS_FILTERED;
        TaskSwitchPredicate switchPredicate = switchPredicateOptional.get();
        UiStore.getInstance().setSwitchPredicate(switchPredicate);

        return new CommandResult(String.format(
                messageTemplate,
                switchPredicate.getDisplayName(),
                UiStore.getInstance().getShownTasks().size(),
                UiStore.getInstance().getTasks().size()));
    }

    public HashMap<String, String> tokenize(String command) {
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put(TAB, matcher.group(TAB));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public static String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }
}
```
###### /java/seedu/toluist/controller/UnaliasController.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import seedu.toluist.commons.core.Config;
import seedu.toluist.dispatcher.CommandResult;
import seedu.toluist.model.AliasTable;

/**
 * Alias Controller is responsible for handling unalias requests
 */
public class UnaliasController extends Controller {
    private static final String RESULT_MESSAGE_SUCCESS = "Alias %s has been removed";
    private static final String RESULT_MESSAGE_FAILURE = "Alias %s cannot be removed";
    public static final String RESULT_MESSAGE_NOT_ALIAS = "%s is not an alias";
    private static final String COMMAND_TEMPLATE = "unalias\\s+(?<alias>\\S+)\\s*";
    private static final String COMMAND_WORD = "unalias";

    private static final String ALIAS_TERM = "alias";

    private final AliasTable aliasConfig = Config.getInstance().getAliasTable();

    public CommandResult execute(String command) {
        HashMap<String, String> tokens = tokenize(command);
        String alias = tokens.get(ALIAS_TERM);

        if (!aliasConfig.isAlias(alias)) {
            return new CommandResult(String.format(RESULT_MESSAGE_NOT_ALIAS, alias));
        }

        if (aliasConfig.removeAlias(alias) && Config.getInstance().save()) {
            return new CommandResult(String.format(RESULT_MESSAGE_SUCCESS, alias));
        } else {
            return new CommandResult(String.format(RESULT_MESSAGE_FAILURE, alias));
        }
    }

    public HashMap<String, String> tokenize(String command) {
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put(ALIAS_TERM, matcher.group(ALIAS_TERM));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public static String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }
}
```
###### /java/seedu/toluist/controller/UndoController.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javafx.util.Pair;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.dispatcher.CommandResult;
import seedu.toluist.model.TodoList;

/**
 * Responsible for storage-related task
 */
public class UndoController extends Controller {
    private static final String COMMAND_TEMPLATE = "^undo(\\s+(?<number>\\d+))?\\s*";
    private static final String COMMAND_WORD = "undo";
    private static final String UNDO_TIMES = "number";
    private static final String RESULT_MESSAGE_TEMPLATE = "Your last %s to the data %s undone.";

    private static final Logger logger = LogsCenter.getLogger(UndoController.class);

    public CommandResult execute(String command) {
        logger.info(getClass() + "will handle command");

        HashMap<String, String> tokens = tokenize(command);
        String undoTimesToken = tokens.get(UNDO_TIMES);
        int undoTimes = undoTimesToken != null ? Integer.parseInt(undoTimesToken) : 1;

        Pair<TodoList, Integer> undoResult = TodoList.load().getStorage().undo(undoTimes);
        TodoList todoList = undoResult.getKey();
        int actualUndoTimes =  undoResult.getValue();

        uiStore.setTasks(todoList.getTasks());

        return new CommandResult(String.format(RESULT_MESSAGE_TEMPLATE,
                StringUtil.nounWithCount ("change", actualUndoTimes),
                actualUndoTimes == 1 ? "was" : "were"));
    }

    public HashMap<String, String> tokenize(String command) {
        Pattern pattern = Pattern.compile(COMMAND_TEMPLATE);
        Matcher matcher = pattern.matcher(command.trim());
        matcher.find();
        HashMap<String, String> tokens = new HashMap<>();
        tokens.put(UNDO_TIMES, matcher.group(UNDO_TIMES));
        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public static String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }
}
```
###### /java/seedu/toluist/controller/UnknownCommandController.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;

import seedu.toluist.commons.core.Messages;
import seedu.toluist.dispatcher.CommandResult;

/**
 * UnknownCommandController is responsible for rendering the initial UI
 */
public class UnknownCommandController extends Controller {

    public CommandResult execute(String command) {
        return new CommandResult(Messages.MESSAGE_UNKNOWN_COMMAND);
    }

    public HashMap<String, String> tokenize(String command) {
        return null; // not used
    }

    public boolean matchesCommand(String command) {
        return true; // matches everything
    }
}
```
###### /java/seedu/toluist/controller/ViewAliasController.java
``` java
package seedu.toluist.controller;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.SortedSet;
import java.util.TreeSet;

import seedu.toluist.commons.core.Config;
import seedu.toluist.dispatcher.CommandResult;
import seedu.toluist.model.AliasTable;

/**
 * Alias Controller is responsible for handling viewalias requests
 */
public class ViewAliasController extends Controller {
    private static final String COMMAND_TEMPLATE = "viewalias\\s*";
    private static final String COMMAND_WORD = "viewalias";
    private static final String ALIAS_COMMAND_SEPARATOR = ":";
    private static final String NEW_LINE = "\n";
    public static final String NO_ALIAS_MESSAGE = "No aliases found";

    private final AliasTable aliasConfig = Config.getInstance().getAliasTable();

    public CommandResult execute(String command) {
        Map<String, String> aliasMapping = aliasConfig.getAliasMapping();
        return new CommandResult(getAliasCommandResult(aliasMapping));
    }

    public HashMap<String, String> tokenize(String command) {
        return null; // not used
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public static String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }

    private String getAliasCommandResult(Map<String, String> aliasMapping) {
        ArrayList<String> lines = new ArrayList<>();

        SortedSet<String> aliases = new TreeSet<>(aliasMapping.keySet());
        for (String alias : aliases) {
            String line = alias + ALIAS_COMMAND_SEPARATOR + aliasMapping.get(alias);
            lines.add(line);
        }

        String result = String.join(NEW_LINE, lines);
        return result.isEmpty() ? NO_ALIAS_MESSAGE : result;
    }
}
```
###### /java/seedu/toluist/dispatcher/CommandDispatcher.java
``` java
package seedu.toluist.dispatcher;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.core.EventsCenter;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.events.ui.NewResultAvailableEvent;
import seedu.toluist.controller.AddTaskController;
import seedu.toluist.controller.AliasController;
import seedu.toluist.controller.ClearController;
import seedu.toluist.controller.Controller;
import seedu.toluist.controller.DeleteTaskController;
import seedu.toluist.controller.ExitController;
import seedu.toluist.controller.FindController;
import seedu.toluist.controller.HistoryController;
import seedu.toluist.controller.LoadController;
import seedu.toluist.controller.MarkController;
import seedu.toluist.controller.RedoController;
import seedu.toluist.controller.StoreController;
import seedu.toluist.controller.SwitchController;
import seedu.toluist.controller.TagController;
import seedu.toluist.controller.UnaliasController;
import seedu.toluist.controller.UndoController;
import seedu.toluist.controller.UnknownCommandController;
import seedu.toluist.controller.UntagController;
import seedu.toluist.controller.UpdateTaskController;
import seedu.toluist.controller.ViewAliasController;
import seedu.toluist.model.AliasTable;

public class CommandDispatcher extends Dispatcher {
    private static final Logger logger = LogsCenter.getLogger(CommandDispatcher.class);
    private final EventsCenter eventsCenter = EventsCenter.getInstance();
    private final AliasTable aliasConfig = Config.getInstance().getAliasTable();

```
###### /java/seedu/toluist/dispatcher/CommandDispatcher.java
``` java
    public CommandDispatcher() {
        super();
        aliasConfig.setReservedKeywords(getControllerKeywords());
        commandHistory = new ArrayList<>();
    }

    public void dispatchRecordingHistory(String command) {
        recordCommand(command);
        dispatch(command);
    }

    public void dispatch(String command) {
        String deAliasedCommand = aliasConfig.dealias(command);
        logger.info("De-aliased command to be dispatched: " + deAliasedCommand + " original command " + command);

        Controller controller = getBestFitController(deAliasedCommand);
        logger.info("Controller class to be executed: " + controller.getClass());

        CommandResult feedbackToUser;
        if (controller instanceof HistoryController) {
            ((HistoryController) controller).setCommandHistory(commandHistory);
        }

        feedbackToUser = controller.execute(deAliasedCommand);

        eventsCenter.post(new NewResultAvailableEvent(feedbackToUser.getFeedbackToUser()));
    }

    private void recordCommand(String command) {
        commandHistory.add(command);
        historyPointer = commandHistory.size();
    }

    private Controller getBestFitController(String command) {
        Collection<Controller> controllerCollection = getAllControllers();

        return controllerCollection
                .stream()
                .filter(controller -> controller.matchesCommand(command))
                .findFirst()
                .orElse(new UnknownCommandController()); // fail-safe
    }

    private Collection<Class <? extends Controller>> getAllControllerClasses() {
        return new ArrayList<>(Arrays.asList(
                AddTaskController.class,
                ClearController.class,
                UpdateTaskController.class,
                DeleteTaskController.class,
                StoreController.class,
                HistoryController.class,
                LoadController.class,
                UndoController.class,
                RedoController.class,
                ExitController.class,
                AliasController.class,
                UnaliasController.class,
                ViewAliasController.class,
                UntagController.class,
                FindController.class,
                TagController.class,
                MarkController.class,
                SwitchController.class,
                UnknownCommandController.class
        ));
    }

    private Collection<Controller> getAllControllers() {
        return getAllControllerClasses()
                .stream()
                .map((Class<? extends Controller> klass) -> {
                    try {
                        Constructor constructor = klass.getConstructor();
                        return (Controller) constructor.newInstance();
                    } catch (NoSuchMethodException | InstantiationException
                            | IllegalAccessException | InvocationTargetException e) {
                        // fail-safe. But should not actually reach here
                        return new UnknownCommandController();
                    }
                })
                .collect(Collectors.toList());
    }

    private Set<String> getControllerKeywords() {
        List<String> keywordList = getAllControllerClasses()
                .stream()
                .map((Class<? extends Controller> klass) -> {
                    try {
                        final String methodName = "getCommandWords";
                        Method method = klass.getMethod(methodName);
                        return Arrays.asList((String[]) method.invoke(null));
                    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
                        return new ArrayList<String>();
                    }
                })
                .flatMap(List::stream)
                .collect(Collectors.toList());
        return new HashSet<>(keywordList);
    }
}
```
###### /java/seedu/toluist/dispatcher/Dispatcher.java
``` java
package seedu.toluist.dispatcher;

/**
 * Dispatcher is the bridge between the UI input & Controller
 * It acts like a Router in a MVC. From the input, it deduces what is the appropriate
 * the controller to dispatch the command to
 */
public abstract class Dispatcher {

    /**
     * Dispatch a command from the Ui to a suitable Controller
     * The command will be saved in the dispatcher's command history
     * @param command
     */
    public abstract void dispatchRecordingHistory(String command);

    /**
     * Dispatch a command from the Ui to a suitable Controller.
     * @param command command to be executed
     */
    public abstract void dispatch(String command);
}
```
###### /java/seedu/toluist/MainApp.java
``` java
package seedu.toluist;

import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;

import javafx.application.Application;
import javafx.application.Platform;
import javafx.stage.Stage;
import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.core.EventsCenter;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.core.Version;
import seedu.toluist.commons.events.ui.ExitAppRequestEvent;
import seedu.toluist.dispatcher.CommandDispatcher;
import seedu.toluist.dispatcher.Dispatcher;
import seedu.toluist.ui.Ui;
import seedu.toluist.ui.UiManager;

/**
 * The main entry point to the application.
 */
public class MainApp extends Application {
    private static final Logger logger = LogsCenter.getLogger(MainApp.class);

    public static final Version VERSION = new Version(1, 0, 0, true);

    protected Ui ui;
    protected Dispatcher dispatcher;
    protected Config config = Config.getInstance();


    @Override
    public void init() throws Exception {
        logger.info("=============================[ Initializing ToLuist ]===========================");
        super.init();

        initLogging(config);

        // Configure dependencies
        dispatcher = new CommandDispatcher();
        ui = UiManager.getInstance();
        ui.init(dispatcher);

        initEventsCenter();
    }

    private void initLogging(Config config) {
        LogsCenter.init(config);
    }

    private void initEventsCenter() {
        EventsCenter.getInstance().registerHandler(this);
    }

    @Override
    public void start(Stage primaryStage) {
        logger.info("Starting ToLuist " + MainApp.VERSION);
        ui.start(primaryStage);
    }

    @Override
    public void stop() {
        logger.info("============================ [ Stopping ToLuist ] =============================");
        ui.stop();
        Platform.exit();
        System.exit(0);
    }

    @Subscribe
    public void handleExitAppRequestEvent(ExitAppRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        this.stop();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
```
###### /java/seedu/toluist/model/AliasTable.java
``` java
package seedu.toluist.model;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * A model to manage alias
 */
public class AliasTable {
    private Map<String, String> aliasMapping = new HashMap<>();
    private Set<String> reservedKeywords = new HashSet<>();

    public Map<String, String> getAliasMapping() {
        return aliasMapping;
    }

    /**
     * Set alias for a command. Returns success status
     * @param alias
     * @param command
     * @return true / false
     */
    public boolean setAlias(String alias, String command) {
        if (isReservedWord(alias)) {
            return false;
        }

        aliasMapping.put(alias, command);
        return true;
    }

    /**
     * Remove an alias. Return sucess status
     * @param alias
     * @return true / false
     */
    public boolean removeAlias(String alias) {
        aliasMapping.remove(alias);
        return true;
    }

    /**
     * Remove all aliases.
     */
    public void clearAliases() {
        aliasMapping.clear();
    }

    /**
     * Set reserved keywords
     * @param reservedKeywords
     */
    public void setReservedKeywords(Set<String> reservedKeywords) {
        this.reservedKeywords = reservedKeywords;
    }

    /**
     * Check if the alias is a reserved word
     * @param alias
     * @return true/false
     */
    public boolean isReservedWord(String alias) {
        return reservedKeywords.contains(alias);
    }

    /**
     * Check if argument is an alias
     * @param alias
     * @return true / false
     */
    public boolean isAlias(String alias) {
        return aliasMapping.containsKey(alias);
    }

    /**
     * Convert a command that possibly contains an alias prefix to one without
     * Recursive unpacking of alias is not supported
     * e.g if a is an alias for b, and b is an alias a, dealias(a) will return b
     * @param command
     * @return converted command
     */
    public String dealias(String command) {
        String[] wordsInCommand = command.split("\\s+");
        if (wordsInCommand.length == 0) {
            return command;
        }

        String firstWord = wordsInCommand[0];

        for (String alias : aliasMapping.keySet()) {
            if (firstWord.equals(alias)) {
                wordsInCommand[0] = aliasMapping.get(alias);
                return String.join(" ", wordsInCommand);
            }
        }
        return command;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof AliasTable // instanceof handles nulls
                && reservedKeywords.equals(((AliasTable) other).reservedKeywords)
                && aliasMapping.equals(((AliasTable) other).aliasMapping));
    }
}
```
###### /java/seedu/toluist/model/Tag.java
``` java
package seedu.toluist.model;

/**
 * Tag model
 */
public class Tag implements Comparable<Tag> {

    public String tagName;

    public Tag() {}

    /**
     * Validates given tag name.
     */
    public Tag(String name) {
        assert name != null;
        String trimmedName = name.trim();
        this.tagName = trimmedName;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Tag // instanceof handles nulls
                && this.tagName.equals(((Tag) other).tagName)); // state check
    }

    @Override
    public int hashCode() {
        return tagName.hashCode();
    }

    @Override
    public int compareTo(Tag other) {
        return tagName.compareTo(other.tagName);
    }
}
```
###### /java/seedu/toluist/model/Task.java
``` java
package seedu.toluist.model;

import java.time.LocalDateTime;
import java.util.Collection;
import java.util.Objects;
import java.util.TreeSet;

import seedu.toluist.commons.util.DateTimeUtil;

/**
 * Represents a Task
 */
public class Task implements Comparable<Task> {

    // List of tags is unique
    private TreeSet<Tag> allTags = new TreeSet<>();
    private String description;
    private LocalDateTime startDateTime;
    private LocalDateTime endDateTime;
    private LocalDateTime completionDateTime;
    private TaskPriority priority = TaskPriority.LOW;

    public enum TaskPriority {
        HIGH, LOW
    }

    /**
     * To be used with json deserialisation
     */
    public Task() {}

    public Task(String description) {
        this(description, null, null);
    }

    public Task(String description, LocalDateTime endDateTime) {
        this(description, null, endDateTime);
    }

```
###### /java/seedu/toluist/model/Task.java
``` java
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Task // instanceof handles nulls
                && this.description.equals(((Task) other).description)) // state check
                && this.priority.equals(((Task) other).priority)
                && this.allTags.equals(((Task) other).allTags)
                && Objects.equals(this.startDateTime, ((Task) other).startDateTime) // handles null
                && Objects.equals(this.endDateTime, ((Task) other).endDateTime) // handles null
                && Objects.equals(this.completionDateTime, ((Task) other).completionDateTime); // handles null
    }

    /**
     * Set a task as completed or incomplete
     * @param isCompleted true/false
     */
    public void setCompleted(boolean isCompleted) {
        if (isCompleted) {
            completionDateTime = LocalDateTime.now();
        } else {
            completionDateTime = null;
        }
    }

    /**
     * Set a deadline for a task
     * @param deadLine a LocalDateTime object
     */
    public void setDeadLine(LocalDateTime deadLine) {
        setStartDateTime(null);
        setEndDateTime(deadLine);
    }

    /**
     * Set a from and to date for an event
     * from should be before to
     * @param from a LocalDateTime object
     * @param to a LocalDateTime object
     */
    public void setFromTo(LocalDateTime from, LocalDateTime to) {
        assert DateTimeUtil.isBeforeOrEqual(startDateTime, endDateTime);
        setStartDateTime(from);
        setEndDateTime(to);
    }

```
###### /java/seedu/toluist/model/Task.java
``` java

    /**
     * Replace the tags in the task with the given tags
     * @param tags a collection of tags
     */
    public void replaceTags(Collection<Tag> tags) {
        this.allTags = new TreeSet<>(tags);
    }

    public TreeSet<Tag> getAllTags() {
        return allTags;
    }

    public boolean isOverdue() {
        return !isCompleted() && endDateTime != null && DateTimeUtil.isBeforeOrEqual(endDateTime, LocalDateTime.now());
    }

    public boolean isFloatingTask() {
        return startDateTime == null && endDateTime == null;
    }

    public boolean isTaskWithDeadline() {
        return startDateTime == null && endDateTime != null;
    }

    public boolean isEvent() {
        return startDateTime != null && endDateTime != null;
    }

    public boolean isCompleted() {
        return completionDateTime != null && DateTimeUtil.isBeforeOrEqual(completionDateTime, LocalDateTime.now());
    }

```
###### /java/seedu/toluist/model/Task.java
``` java
    /**
     * Check if the task datetimes are within interval
     * @param from interval from
     * @param to interval to
     * @return true / false
     */
    public boolean isWithinInterval(LocalDateTime from, LocalDateTime to) {
        boolean startDateTimeWithinInterval = from == null
                || (startDateTime != null
                && DateTimeUtil.isBeforeOrEqual(from, startDateTime)
                && DateTimeUtil.isBeforeOrEqual(startDateTime, to));
        boolean endDateTimeWithinInterval = to == null
                || (endDateTime != null
                && DateTimeUtil.isBeforeOrEqual(from, endDateTime)
                && DateTimeUtil.isBeforeOrEqual(endDateTime, to));
        return startDateTimeWithinInterval || endDateTimeWithinInterval;
    }

    @Override
    /**
     * Compare by overdue first -> priority -> end date -> start date -> description
     * Floating tasks are put to the end
     */
    public int compareTo(Task comparison) {
        if (isOverdue() != comparison.isOverdue()) {
            return isOverdue() ? -1 : 1;
        } else if (priority.compareTo(comparison.priority) != 0) {
            return priority.compareTo(comparison.priority);
        } else if (!Objects.equals(endDateTime, comparison.endDateTime)) {
            return DateTimeUtil.isBeforeOrEqual(endDateTime, comparison.endDateTime) ? -1 : 1;
        } else if (!Objects.equals(startDateTime, comparison.startDateTime)) {
            return DateTimeUtil.isBeforeOrEqual(startDateTime, comparison.startDateTime) ? -1 : 1;
        } else {
            return this.description.compareToIgnoreCase(comparison.description);
        }
    }

```
###### /java/seedu/toluist/model/Task.java
``` java
    public TaskPriority getTaskPriority() {
        return priority;
    }

    public void setTaskPriority(TaskPriority priority) {
        this.priority = priority;
    }

    public LocalDateTime getCompletionDateTime() {
        return completionDateTime;
    }
}
```
###### /java/seedu/toluist/model/TaskSwitchPredicate.java
``` java
package seedu.toluist.model;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.function.Predicate;

/**
 * Predicates to filter tasks on switching tab
 */
public class TaskSwitchPredicate {
    public static final Predicate<Task> ALL_PREDICATE = task -> true;
    public static final Predicate<Task> INCOMPLETE_PREDICATE = task -> !task.isCompleted();
    public static final Predicate<Task> COMPLETED_PREDICATE = task -> task.isCompleted();
    public static final Predicate<Task> TODAY_PREDICATE = task -> {
        ZonedDateTime startOfTodayDatetime = ZonedDateTime.now().toLocalDate().atStartOfDay(ZoneId.systemDefault());
        LocalDateTime startOfToday =  LocalDateTime.ofInstant(startOfTodayDatetime.toInstant(), ZoneId.systemDefault());

        ZonedDateTime endOfTodayDatetime = ZonedDateTime.now().toLocalDate()
                .atStartOfDay(ZoneId.systemDefault())
                .plusDays(1).minusSeconds(1);
        LocalDateTime endOfToday =  LocalDateTime.ofInstant(endOfTodayDatetime.toInstant(), ZoneId.systemDefault());

        return task.isWithinInterval(startOfToday, endOfToday);
    };
    public static final Predicate<Task> NEXT_7_DAYS_PREDICATE = task -> {
        ZonedDateTime startOfTomorrowDatetime = ZonedDateTime.now().toLocalDate()
                .plusDays(1).atStartOfDay(ZoneId.systemDefault());
        LocalDateTime startOfTomorrow =  LocalDateTime
                .ofInstant(startOfTomorrowDatetime.toInstant(), ZoneId.systemDefault());

        ZonedDateTime endOf7DaysDatetime = ZonedDateTime.now().toLocalDate()
                .atStartOfDay(ZoneId.systemDefault())
                .plusDays(8).minusSeconds(1);
        LocalDateTime endOf7Days =  LocalDateTime.ofInstant(endOf7DaysDatetime.toInstant(), ZoneId.systemDefault());

        return task.isWithinInterval(startOfTomorrow, endOf7Days);
    };
    public static final TaskSwitchPredicate ALL_SWITCH_PREDICATE =
            new TaskSwitchPredicate(ALL_PREDICATE, "ALL");
    public static final TaskSwitchPredicate INCOMPLETE_SWITCH_PREDICATE =
            new TaskSwitchPredicate(INCOMPLETE_PREDICATE, "INCOMPLETE");
    public static final TaskSwitchPredicate COMPLETED_SWITCH_PREDICATE =
            new TaskSwitchPredicate(COMPLETED_PREDICATE, "COMPLETED");
    public static final TaskSwitchPredicate TODAY_SWITCH_PREDICATE =
            new TaskSwitchPredicate(TODAY_PREDICATE, "TODAY");
    public static final TaskSwitchPredicate NEXT_7_DAYS_SWITCH_PREDICATE =
            new TaskSwitchPredicate(NEXT_7_DAYS_PREDICATE, "NEXT 7 DAYS");

    private final Predicate<Task> predicate;
    private final String displayName;

    public TaskSwitchPredicate(Predicate<Task> predicate, String displayName) {
        this.predicate = predicate;
        this.displayName = displayName;
    }

    public Predicate<Task> getPredicate() {
        return predicate;
    }

    public String getDisplayName() {
        return displayName;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskSwitchPredicate // instanceof handles nulls
                && predicate.equals(((TaskSwitchPredicate) other).predicate)
                && displayName.equals(((TaskSwitchPredicate) other).displayName));
    }
}
```
###### /java/seedu/toluist/model/TodoList.java
``` java
package seedu.toluist.model;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import com.fasterxml.jackson.annotation.JsonIgnore;

import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.exceptions.DataStorageException;
import seedu.toluist.storage.JsonStorage;
import seedu.toluist.storage.TodoListStorage;

/**
 * TodoList Model
 */
public class TodoList {
    private static final Logger logger = LogsCenter.getLogger(TodoList.class);
    public static final TodoListStorage DEFAULT_STORAGE = new JsonStorage();
    private static TodoList currentTodoList;

    private ArrayList<Task> allTasks = new ArrayList<>();
    @JsonIgnore
    private TodoListStorage storage = new JsonStorage();

    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TodoList // instanceof handles nulls
                && allTasks.equals(((TodoList) other).getTasks()));
    }

    public ArrayList<Task> getTasks() {
        return allTasks;
    }

    /**
     * Load the todo list data using the default storage if currentTodoList is null
     * Otherwise returns the current in-memory todo list
     */
    public static TodoList load() {
        // Initialize currentTodoList if not done
        if (currentTodoList == null) {
            currentTodoList = new TodoList(DEFAULT_STORAGE);
        }

        return currentTodoList;
    }

    /**
     * Construct a todo list. Use the tasks saved in the storage
     * Replaces the static currentTodoList
     * @param storage a todo list storage
     */
    public TodoList(TodoListStorage storage) {
        currentTodoList = this;
        this.storage = storage;
        try {
            TodoList todoList = storage.load();
            allTasks = todoList.getTasks();
        } catch (DataStorageException e) {
            logger.severe("Data cannot be loaded");
        }
    }

    /**
     * Construct a todo list. use the default storage
     */
    public TodoList() {
        currentTodoList = this;
        this.storage = DEFAULT_STORAGE;
    }

    public void setStorage(TodoListStorage storage) {
        this.storage = storage;
    }

    public TodoListStorage getStorage() {
        return storage;
    }

    /**
     * Save the todo list data to disk
     * @return true / false
     */
    public boolean save() {
        currentTodoList = this;
        return storage.save(this);
    }

    /**
     * Add a task to todolist
     * @param task task to be added
     */
    public void add(Task task) {
        // Don't allow duplicate tasks
        if (allTasks.indexOf(task) > -1) {
            return;
        }

        allTasks.add(task);
    }

    /**
     * Remove a task from todo list
     * @param task task to be removed
     */
    public void remove(Task task) {
        allTasks.remove(task);
    }

    /**
     * Returns list of tasks based on predicate
     * @param predicate a predicate
     * @return a list of task
     */
    public ArrayList<Task> getFilterTasks(Predicate<Task> predicate) {
        List<Task> taskList = getTasks().stream().filter(predicate).collect(Collectors.toList());
        return new ArrayList<>(taskList);
    }

    public void setTasks(ArrayList<Task> newTaskList) {
        allTasks = newTaskList;
    }
}
```
###### /java/seedu/toluist/storage/JsonStorage.java
``` java
package seedu.toluist.storage;

import java.io.File;
import java.io.IOException;
import java.nio.file.InvalidPathException;
import java.util.ArrayDeque;
import java.util.Optional;

import com.fasterxml.jackson.core.JsonProcessingException;

import javafx.util.Pair;
import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.exceptions.DataStorageException;
import seedu.toluist.commons.util.FileUtil;
import seedu.toluist.commons.util.JsonUtil;
import seedu.toluist.model.TodoList;

/**
 * JsonStorage saves/loads TodoList object to/from json file.
 */
public class JsonStorage implements TodoListStorage {
    private Config config = Config.getInstance();
    private ArrayDeque<String> historyStack = new ArrayDeque<>();
    private ArrayDeque<String> redoHistoryStack = new ArrayDeque<>();

    public JsonStorage() {}

    public boolean save(TodoList todoList) {
        return save(todoList, Config.getInstance().getTodoListFilePath());
    }

    public boolean save(TodoList todoList, String storagePath) {
        if (!saveNotAffectingHistory(todoList, storagePath)) {
            return false;
        }
        // push current todo list json string into historyStack if the stack is empty

        try {
            historyStack.addLast(JsonUtil.toJsonString(todoList));
        } catch (JsonProcessingException e) {
            // Should not reach here
            e.printStackTrace();
        }
        redoHistoryStack.clear();

        Config.getInstance().setTodoListFilePath(storagePath);
        return true;
    }

    public TodoList load() throws DataStorageException {
        return load(Config.getInstance().getTodoListFilePath());
    }


    public TodoList load(String storagePath) throws DataStorageException {
        try {
            String jsonString = FileUtil.readFromFile(new File(storagePath));
            // push todo list json string into historyStack if the stack is empty
            if (historyStack.isEmpty()) {
                historyStack.addLast(jsonString);
            }
            TodoList todoList = JsonUtil.fromJsonString(jsonString, TodoList.class);

            Config.getInstance().setTodoListFilePath(storagePath);
            return todoList;
        } catch (IOException | InvalidPathException e) {
            throw new DataStorageException(e.getMessage());
        }
    }

    public boolean move(String newStoragePath) {
        String oldStoragePath = config.getTodoListFilePath();

        TodoList todoList;
        try {
            todoList = load();
        } catch (DataStorageException e) {
            return false;
        }

        if (!saveNotAffectingHistory(todoList, newStoragePath)) {
            return false;
        }

        FileUtil.removeFile(FileUtil.getFile(oldStoragePath));

        config.setTodoListFilePath(newStoragePath);
        return config.save();
    }

    public Pair<TodoList, Integer> undo(int times) {
        assert historyStack.size() >= 1;
        int steps = times;
        while (steps > 0 && historyStack.size() > 1) {
            redoHistoryStack.addLast(historyStack.pollLast());
            steps -= 1;
        }
        TodoList todoList = todoListFromJson(historyStack.peekLast()).get();
        // So as to not clear the redo history
        saveNotAffectingHistory(todoList, config.getTodoListFilePath());
        return new Pair<>(todoList, times - steps);
    }

    public Pair<TodoList, Integer> redo(int times) {
        int steps = times;
        while (steps > 0 && redoHistoryStack.size() > 0) {
            historyStack.addLast(redoHistoryStack.pollLast());
            steps -= 1;
        }

        TodoList todoList = todoListFromJson(historyStack.peekLast()).get();
        // So as to not clear the redo history
        saveNotAffectingHistory(todoList, config.getTodoListFilePath());
        return new Pair<>(todoList, times - steps);
    }

    private boolean saveNotAffectingHistory(TodoList todoList, String storagePath) {
        try {
            String jsonString = JsonUtil.toJsonString(todoList);
            FileUtil.writeToFile(FileUtil.getFile(storagePath), jsonString);
            return true;
        } catch (IOException e) {
            return false;
        }
    }

    private Optional<TodoList> todoListFromJson(String json) {
        try {
            TodoList todoList = JsonUtil.fromJsonString(json, TodoList.class);
            // Inject self as storage dependency
            todoList.setStorage(this);
            return Optional.of(todoList);
        } catch (IOException e) {
            return Optional.empty();
        }
    }
}
```
###### /java/seedu/toluist/storage/TodoListStorage.java
``` java
package seedu.toluist.storage;

import java.io.IOException;

import javafx.util.Pair;
import seedu.toluist.commons.exceptions.DataStorageException;
import seedu.toluist.model.TodoList;

/**
 * Interface for TodoListStorage that saves/loads TodoList data
 */
public interface TodoListStorage {
    /**
     * Serialize a todolist to the disk, using a default storage path
     * supplied by the singleton Config
     * @param todoList todolist to be saved
     * @return true if the saving was successful, false otherwise
     */
    boolean save(TodoList todoList);

    /**
     * Serialize a todolist to the disk at the specified storage path
     * If saving is successful, the todolist storage path in the config will be changed
     * accordingly
     * @param todoList todolist to be saved
     * @param todoListStoragePath storage path to save todo list data at
     * @return true if the saving was successful, false otherwise
     */
    boolean save(TodoList todoList, String todoListStoragePath);

    /**
     * Load todo list data from disk, using a default storage path
     * supplied by the singleton Config
     * @return todo list data
     * @throws DataStorageException if data cannot be loaded
     */
    TodoList load() throws DataStorageException;

    /**
     * Load todo list data from disk from the specified storage path
     * If loading is successful, the todolist storage path in the config will be changed
     * accordingly
     * @return todo list data
     * @param todoListStoragePath storage path to load todo list data from
     * @throws IOException if data cannot be loaded
     */
    TodoList load(String todoListStoragePath) throws DataStorageException;

    /**
     * Move the todo list data to somewhere else
     * If moving is successful, the todolist storage path in the config will be changed
     * accordingly
     * @param todoListStoragePath storage path to move todo list data to
     * @return true if the moving was successful, false otherwise
     */
    boolean move(String todoListStoragePath);

    /**
     * Undo the todolist by a number of times
     * @param times number of times to undo
     * @return Pair of todolist, the resulting todo list and an integer denoting the number of actual undo times
     */
    Pair<TodoList, Integer> undo(int times);

    /**
     * Redo the todolist by a number of times
     * @param times number of times to redo
     * @return Pair of todolist, the resulting todo list and an integer denoting the number of actual redo times
     */
    Pair<TodoList, Integer> redo(int times);
}
```
###### /java/seedu/toluist/ui/MainWindow.java
``` java
package seedu.toluist.ui;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.logging.Logger;

import javax.swing.ImageIcon;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.scene.Scene;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyCodeCombination;
import javafx.scene.input.KeyCombination;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Region;
import javafx.stage.Stage;

import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.core.GuiSettings;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.events.ui.ExitAppRequestEvent;
import seedu.toluist.commons.util.FxViewUtil;
import seedu.toluist.dispatcher.Dispatcher;
import seedu.toluist.ui.view.CommandBox;
import seedu.toluist.ui.view.ResultView;
import seedu.toluist.ui.view.TabBarView;
import seedu.toluist.ui.view.TaskListUiView;

/**
 * The Main Window. Provides the basic application layout containing
 * a menu bar and space where other JavaFX elements can be placed.
 */
public class MainWindow extends UiPart<Region> {
    private static final Logger logger = LogsCenter.getLogger(MainWindow.class);
    private static final String LOGO_IMAGE_PATH = "/images/logo.png";
    private static final String FXML = "MainWindow.fxml";
    private static final int MIN_HEIGHT = 600;
    private static final int MIN_WIDTH = 800;

    private Stage primaryStage;
    private Dispatcher dispatcher;

    @FXML
    private AnchorPane commandBoxPlaceholder;

    @FXML
    private AnchorPane taskListPlaceholder;

    @FXML
    private AnchorPane resultDisplayPlaceholder;

    @FXML
    private AnchorPane tabPanePlaceholder;

    private CommandBox commandBox;
    private TaskListUiView taskListUiView;
    private ResultView resultView;
    private TabBarView tabBarView;


    public MainWindow (Stage primaryStage, Dispatcher dispatcher) {
        super(FXML);

        // Set dependencies
        this.primaryStage = primaryStage;
        this.dispatcher = dispatcher;

        // Configure the UI
        setLogo();
        setWindowMinSize();
        setWindowDefaultSize();
        Scene scene = new Scene(getRoot());
        primaryStage.setScene(scene);
        configureKeyCombinations();
        configureChildrenViews();
    }

    public Stage getPrimaryStage() {
        return primaryStage;
    }

    public void render() {
        taskListUiView.render();
        commandBox.render();
        resultView.render();
        tabBarView.render();
    }

    private void configureKeyCombinations() {
        configureSwitchTabKeyCombinations();
    }

    /**
     * Sets the key combination on root.
     * @param keyCombination the KeyCombination value of the accelerator
     * @param handler the event handler
     */
    private void setKeyCombination(KeyCombination keyCombination, EventHandler<ActionEvent> handler) {
        /*
         * TODO: the code below can be removed once the bug reported here
         * https://bugs.openjdk.java.net/browse/JDK-8131666
         * is fixed in later version of SDK.
         *
         * According to the bug report, TextInputControl (TextField, TextArea) will
         * consume function-key events. Because CommandBox contains a TextField, and
         * ResultView contains a TextArea, thus some accelerators (e.g F1) will
         * not work when the focus is in them because the key event is consumed by
         * the TextInputControl(s).
         *
         * For now, we add following event filter to capture such key events and open
         * help window purposely so to support accelerators even when focus is
         * in CommandBox or ResultView.
         */
        getRoot().addEventFilter(KeyEvent.KEY_PRESSED, event -> {
            if (keyCombination.match(event)) {
                handler.handle(new ActionEvent());
                event.consume();
            }
        });
    }

    void hide() {
        primaryStage.hide();
    }

    private void configureSwitchTabKeyCombinations() {
        String[] tabNames = new String[] { "i", "t", "n", "c", "a" };
        Arrays.stream(tabNames).forEach(tabName -> {
            KeyCombination keyCombination = new KeyCodeCombination(getKeyCode(tabName), KeyCombination.CONTROL_DOWN);
            String switchCommand = "switch " + tabName;
            EventHandler<ActionEvent> handler = event -> dispatcher.dispatch(switchCommand);
            setKeyCombination(keyCombination, handler);
        });
    }

    /**
     * Get matching key code for a string
     * @param s string
     * @returna key code
     */
    private KeyCode getKeyCode(String s) {
        switch (s) {
        case "i": return KeyCode.I;
        case "t": return KeyCode.T;
        case "n": return KeyCode.N;
        case "c": return KeyCode.C;
        case "a": return KeyCode.A;
        default: return KeyCode.ESCAPE;
        }
    }

    private AnchorPane getTaskListPlaceholder() {
        return taskListPlaceholder;
    }

    private AnchorPane getCommandBoxPlaceholder() {
        return commandBoxPlaceholder;
    }

    private AnchorPane getResultDisplayPlaceholder() {
        return resultDisplayPlaceholder;
    }

    private AnchorPane getTabPanePlaceholder() {
        return tabPanePlaceholder;
    }

    private void setWindowMinSize() {
        primaryStage.setMinHeight(MIN_HEIGHT);
        primaryStage.setMinWidth(MIN_WIDTH);
    }

    /**
     * Sets the logo for the app
     */
    private void setLogo() {
        FxViewUtil.setStageIcon(primaryStage, LOGO_IMAGE_PATH);
        // Only in macOS, you can try to use reflection to access this library
        // and use it to set a custom app icon
        try {
            Class applicationClass = Class.forName("com.apple.eawt.Application");
            Method getApplication = applicationClass.getMethod("getApplication");
            Object application = getApplication.invoke(applicationClass);
            Method setDockIconImage = applicationClass.getMethod("setDockIconImage", java.awt.Image.class);
            setDockIconImage.invoke(application,
                    new ImageIcon(MainWindow.class.getResource(LOGO_IMAGE_PATH)).getImage());
        } catch (NoSuchMethodException | IllegalAccessException
                | InvocationTargetException | ClassNotFoundException e) {
            logger.info("Not on macOS");
        }
    }

    /**
     * Sets the default size based on user config.
     */
    private void setWindowDefaultSize() {
        GuiSettings guiSettings = Config.getInstance().getGuiSettings();
        primaryStage.setHeight(guiSettings.getWindowHeight());
        primaryStage.setWidth(guiSettings.getWindowWidth());
        if (guiSettings.getWindowCoordinates() != null) {
            primaryStage.setX(guiSettings.getWindowCoordinates().getX());
            primaryStage.setY(guiSettings.getWindowCoordinates().getY());
        }
    }

    private void configureChildrenViews() {
        taskListUiView = new TaskListUiView();
        taskListUiView.setParent(getTaskListPlaceholder());

        commandBox = new CommandBox(dispatcher);
        commandBox.setParent(getCommandBoxPlaceholder());

        resultView = new ResultView();
        resultView.setParent(getResultDisplayPlaceholder());

        tabBarView = new TabBarView();
        tabBarView.setParent(getTabPanePlaceholder());
    }

    void show() {
        primaryStage.show();
    }

    /**
     * Returns the current size and the position of the main Window.
     */
    GuiSettings getCurrentGuiSetting() {
        return new GuiSettings(primaryStage.getWidth(), primaryStage.getHeight(),
                (int) primaryStage.getX(), (int) primaryStage.getY());
    }

    /** ================ ACTION HANDLERS ================== **/

    @FXML
    public void handleHelp() {
    }

    @FXML
    public void handleMenu() {
    }

    /**
     * Closes the application.
     */
    @FXML
    private void handleExit() {
        raise(new ExitAppRequestEvent());
    }
}
```
###### /java/seedu/toluist/ui/Ui.java
``` java
package seedu.toluist.ui;

import javafx.stage.Stage;
import seedu.toluist.dispatcher.Dispatcher;

/**
 * API of UI component
 */
public interface Ui {

    /** Starts the UI (and the App).  */
    void start(Stage primaryStage);

    /** Stops the UI. */
    void stop();

    void init(Dispatcher dispatcher);

    void render();

}
```
###### /java/seedu/toluist/ui/UiManager.java
``` java
package seedu.toluist.ui;

import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;

import javafx.application.Platform;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.stage.Stage;
import seedu.toluist.commons.core.ComponentManager;
import seedu.toluist.commons.core.Config;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.events.ui.ShowHelpRequestEvent;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.dispatcher.Dispatcher;

/**
 * The manager of the UI component. Singleton
 */
public class UiManager extends ComponentManager implements Ui {
    private static final Logger logger = LogsCenter.getLogger(UiManager.class);
    private static UiManager instance;

    private MainWindow mainWindow;
    private Dispatcher dispatcher;

    public static UiManager getInstance() {
        if (instance == null) {
            instance = new UiManager();
        }
        return instance;
    }

    private UiManager() {
        super();
    }

    @Override
    public void start(Stage primaryStage) {
        logger.info("Starting UI...");
        Config config = Config.getInstance();
        primaryStage.setTitle(config.getAppTitle());

        try {
            mainWindow = new MainWindow(primaryStage, dispatcher);
            mainWindow.render();
            mainWindow.show();
            // Re-render when data change is observed
            UiStore.getInstance().bind(this);
            String listCommand = "list";
            dispatcher.dispatch(listCommand);
        } catch (Throwable e) {
            logger.severe(StringUtil.getDetails(e));
            showFatalErrorDialogAndShutdown("Fatal error during initializing", e);
        }
    }

    @Override
    public void stop() {
        // Save the last used gui settings
        Config.getInstance().setGuiSettings(mainWindow.getCurrentGuiSetting());
        Config.getInstance().save();
        mainWindow.hide();
    }

    public void init(Dispatcher dispatcher) {
        this.dispatcher = dispatcher;
    }

    public void render() {
        assert dispatcher != null;
        mainWindow.render();
    }

    void showAlertDialogAndWait(Alert.AlertType type, String title, String headerText, String contentText) {
        showAlertDialogAndWait(mainWindow.getPrimaryStage(), type, title, headerText, contentText);
    }

    private static void showAlertDialogAndWait(Stage owner, AlertType type, String title, String headerText,
                                               String contentText) {
        final Alert alert = new Alert(type);
        alert.getDialogPane().getStylesheets().add("stylesheet/DefaultTheme.css");
        alert.initOwner(owner);
        alert.setTitle(title);
        alert.setHeaderText(headerText);
        alert.setContentText(contentText);
        alert.showAndWait();
    }

    private void showFatalErrorDialogAndShutdown(String title, Throwable e) {
        logger.severe(title + " " + e.getMessage() + StringUtil.getDetails(e));
        showAlertDialogAndWait(Alert.AlertType.ERROR, title, e.getMessage(), e.toString());
        Platform.exit();
        System.exit(1);
    }

    //==================== Event Handling Code ===============================================================

    @Subscribe
    private void handleShowHelpEvent(ShowHelpRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
//        mainWindow.handleHelp();
    }
}
```
###### /java/seedu/toluist/ui/UiStore.java
``` java
package seedu.toluist.ui;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import javafx.beans.property.ObjectProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.ObservableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.ObservableList;

import seedu.toluist.model.Task;
import seedu.toluist.model.TaskSwitchPredicate;

/**
 * UiStore acts like a "single source of truth" / view model for the Ui
 * Ui will observe for changes to `shownTasks` and re-render on state change
 */
public class UiStore {
    private static UiStore instance;

    private ArrayList<Task> allTasks = new ArrayList<>();
    private ObjectProperty<TaskSwitchPredicate> switchPredicate =
            new SimpleObjectProperty<>(TaskSwitchPredicate.INCOMPLETE_SWITCH_PREDICATE);
    private ObservableList<Task> shownTasks = FXCollections.observableArrayList();

    public static UiStore getInstance() {
        if (instance == null) {
            instance = new UiStore();
        }
        return instance;
    }

    private UiStore() {}

    public void bind(Ui renderer) {
        shownTasks.addListener((ListChangeListener.Change<? extends Task> c) -> renderer.render());
        switchPredicate.addListener(observable -> renderer.render());
    }

    public void setSwitchPredicate(TaskSwitchPredicate switchPredicate) {
        this.switchPredicate.setValue(switchPredicate);
        changeShownTasks();
    }

    public ObservableValue<TaskSwitchPredicate> getSwitchPredicate() {
        return switchPredicate;
    }

    public void setTasks(ArrayList<Task> tasks) {
        // Sorted by default
        Collections.sort(tasks);
        this.allTasks = tasks;
        changeShownTasks();
    }

    public ArrayList<Task> getTasks() {
        return allTasks;
    }

    /**
     * Returns list of tasks are currently shown on the Ui
     */
    public ArrayList<Task> getShownTasks() {
        return new ArrayList(Arrays.asList(shownTasks.toArray()));
    }

    public ArrayList<Task> getShownTasks(List<Integer> indexes) {
        List<Task> shownTasks = getShownTasks();
        ArrayList<Task> tasks = new ArrayList<>();
        for (int index : indexes) {
            if (index < 1 || index > shownTasks.size()) {
                continue;
            }
            tasks.add(shownTasks.get(index - 1));
        }
        return tasks;
    }

    public ObservableList<Task> getObservableTasks() {
        return shownTasks;
    }

    private void changeShownTasks() {
        shownTasks.setAll(allTasks.stream()
                .filter(switchPredicate.getValue().getPredicate()).collect(Collectors.toList()));
    }
}
```
###### /java/seedu/toluist/ui/view/CommandBox.java
``` java
package seedu.toluist.ui.view;

import java.util.logging.Logger;

import javafx.fxml.FXML;
import javafx.scene.control.TextField;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.util.FxViewUtil;
import seedu.toluist.dispatcher.Dispatcher;

public class CommandBox extends UiView {
    private final Logger logger = LogsCenter.getLogger(CommandBox.class);
    private static final String FXML = "CommandBox.fxml";
    private final Dispatcher dispatcher;

    @FXML
    private TextField commandTextField;

    public CommandBox(Dispatcher dispatcher) {
        super(FXML);
        this.dispatcher = dispatcher;
    }

    @Override
    protected void viewDidMount () {
        FxViewUtil.makeFullWidth(getRoot());
        FxViewUtil.makeFullWidth(commandTextField);
    }

    @FXML
    private void handleCommandInputChanged() {
        dispatcher.dispatchRecordingHistory(commandTextField.getText());
        commandTextField.setText("");
    }
}
```
###### /java/seedu/toluist/ui/view/ResultView.java
``` java
package seedu.toluist.ui.view;

import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;

import javafx.beans.property.SimpleStringProperty;
import javafx.beans.property.StringProperty;
import javafx.fxml.FXML;
import javafx.scene.control.TextArea;
import javafx.scene.layout.AnchorPane;
import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.events.ui.NewResultAvailableEvent;
import seedu.toluist.commons.util.FxViewUtil;

/**
 * A ui for the status bar that is displayed at the header of the application.
 */
public class ResultView extends UiView {

    private static final Logger logger = LogsCenter.getLogger(ResultView.class);
    private static final String FXML = "ResultView.fxml";

    private final StringProperty displayed = new SimpleStringProperty("");

    @FXML
    private AnchorPane mainPane;

    @FXML
    private TextArea resultDisplay;

    public ResultView () {
        super(FXML);
    }

    @Override
    protected void viewDidMount() {
        resultDisplay.textProperty().bind(displayed);
        registerAsAnEventHandler(this);
        makeFullWidth();
    }

    private void makeFullWidth() {
        FxViewUtil.makeFullWidth(getRoot());
        FxViewUtil.makeFullWidth(mainPane);
        FxViewUtil.makeFullWidth(resultDisplay);
    }

    @Subscribe
    private void handleNewResultAvailableEvent(NewResultAvailableEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        displayed.setValue(event.message);
    }
}
```
###### /java/seedu/toluist/ui/view/TabBarView.java
``` java
package seedu.toluist.ui.view;

import javafx.fxml.FXML;
import javafx.scene.layout.Pane;

import seedu.toluist.commons.core.SwitchConfig;
import seedu.toluist.commons.util.FxViewUtil;
import seedu.toluist.model.TaskSwitchPredicate;
import seedu.toluist.ui.UiStore;

/**
 * View to display the tab bar
 */
public class TabBarView extends UiView {

    private static final String FXML = "TabBarView.fxml";

    @FXML
    private Pane tabContainer;
    private SwitchConfig switchConfig = SwitchConfig.getDefaultSwitchConfig();

    public TabBarView() {
        super(FXML);
    }

    @Override
    protected void viewDidMount() {
        FxViewUtil.makeFullWidth(getRoot());
        tabContainer.getChildren().clear();
        for (TaskSwitchPredicate switchPredicate : switchConfig.getAllPredicates()) {
            TabView tabView = new TabView(switchPredicate,
                                          switchPredicate.equals(UiStore.getInstance()
                                                                        .getSwitchPredicate().getValue()));
            tabView.setParent(tabContainer);
            tabView.render();
        }
    }
}
```
###### /java/seedu/toluist/ui/view/TabView.java
``` java
package seedu.toluist.ui.view;

import java.util.stream.Collectors;

import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import seedu.toluist.commons.util.FxViewUtil;
import seedu.toluist.model.TaskSwitchPredicate;
import seedu.toluist.ui.UiStore;

/**
 * View to display the individual tab
 */
public class TabView extends UiView {
    private static final String SELECTED_TAB_CLASS = "selected";
    private static final String FXML = "TabView.fxml";

    @FXML
    private HBox tabPane;
    @FXML
    private Label tabLabel;
    @FXML
    private Label tabShortcutLabel;
    private final TaskSwitchPredicate switchPredicate;
    private final boolean isSelected;

    public TabView(TaskSwitchPredicate switchPredicate, boolean isSelected) {
        super(FXML);
        this.switchPredicate = switchPredicate;
        this.isSelected = isSelected;
    }

    @Override
    protected void viewDidMount() {
        UiStore uiStore = UiStore.getInstance();
        String taskInfo = " ("
                + uiStore.getTasks().stream()
                         .filter(switchPredicate.getPredicate()).collect(Collectors.toList()).size()
                + "/" + uiStore.getTasks().size() + ")";
        tabShortcutLabel.setText(switchPredicate.getDisplayName().substring(0, 1));
        tabLabel.setText(switchPredicate.getDisplayName().substring(1) + taskInfo);
        if (isSelected) {
            FxViewUtil.addStyleClass(tabPane, SELECTED_TAB_CLASS);
        }
    }
}
```
###### /java/seedu/toluist/ui/view/TagView.java
``` java
package seedu.toluist.ui.view;

import javafx.fxml.FXML;
import javafx.scene.control.Label;

/**
 * View to display the indiviual tag
 */
public class TagView extends UiView {
    private static final String FXML = "TagView.fxml";

    @FXML
    protected Label tagLabel;
    private final String tagName;

    public TagView(String tagName) {
        super(FXML);
        this.tagName = tagName;
    }

    @Override
    protected void viewDidMount() {
        tagLabel.setText(tagName);
    }
}
```
###### /java/seedu/toluist/ui/view/TaskListUiView.java
``` java
package seedu.toluist.ui.view;

import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import seedu.toluist.commons.util.FxViewUtil;
import seedu.toluist.model.Task;
import seedu.toluist.ui.UiStore;

/**
 * TaskListUiView to display the list of tasks
 */
public class TaskListUiView extends UiView {

    private static final String FXML = "TaskListView.fxml";

    @FXML
    private ListView<Task> taskListView;

    public TaskListUiView () {
        super(FXML);
    }

    @Override
    protected void viewDidMount () {
        UiStore store = UiStore.getInstance();
        ObservableList<Task> taskList = store.getObservableTasks();
        setConnections(taskList);
        FxViewUtil.makeFullWidth(getRoot());
    }

    private void setConnections(ObservableList<Task> taskList) {
        taskListView.setItems(taskList);
        taskListView.setCellFactory(listView -> new TaskListViewCell());
    }

    class TaskListViewCell extends ListCell<Task> {

        @Override
        protected void updateItem(Task task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                TaskUiView taskRow = new TaskUiView(task, getIndex() + 1);
                setGraphic(taskRow.getRoot());
                taskRow.render();
            }
        }
    }
}
```
###### /java/seedu/toluist/ui/view/TaskStatusView.java
``` java
package seedu.toluist.ui.view;

import javafx.fxml.FXML;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;

/**
 * View to display the task's status, e.g. high priority / overdue
 */
public class TaskStatusView extends UiView {
    private static final String FXML = "TaskStatusView.fxml";

    @FXML
    private ImageView imageView;
    private final Image image;

    public TaskStatusView(Image image) {
        super(FXML);
        this.image = image;
    }

    @Override
    protected void viewDidMount() {
        imageView.setImage(image);
    }
}
```
###### /java/seedu/toluist/ui/view/TaskTypeTagView.java
``` java
package seedu.toluist.ui.view;

import seedu.toluist.commons.util.FxViewUtil;

/**
 * View to display the task type
 */
public class TaskTypeTagView extends TagView {
    private static final String EVENT_STYLE_CLASS = "event-tag";
    private static final String TASK_STYLE_CLASS = "task-tag";
    private static final String EVENT_DISPLAY_NAME = "Event";
    private static final String TASK_DISPLAY_NAME = "Task";

    final boolean isTask;

    public TaskTypeTagView(boolean isTask) {
        super(isTask ? TASK_DISPLAY_NAME : EVENT_DISPLAY_NAME);
        this.isTask = isTask;
    }

    @Override
    protected void viewDidMount() {
        super.viewDidMount();
        if (isTask) {
            FxViewUtil.addStyleClass(tagLabel, TASK_STYLE_CLASS);
        } else {
            FxViewUtil.addStyleClass(tagLabel, EVENT_STYLE_CLASS);
        }
    }
}
```
###### /java/seedu/toluist/ui/view/TaskUiView.java
``` java
package seedu.toluist.ui.view;

import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.image.ImageView;
import javafx.scene.layout.FlowPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import seedu.toluist.commons.util.AppUtil;
import seedu.toluist.commons.util.DateTimeFormatterUtil;
import seedu.toluist.commons.util.FxViewUtil;
import seedu.toluist.model.Tag;
import seedu.toluist.model.Task;

/**
 * View to display task row
 */
public class TaskUiView extends UiView {

    private static final String FXML = "TaskView.fxml";
    private static final String CLOCK_ICON_IMAGE_PATH = "/images/clock.png";
    private static final String OVERDUE_ICON_IMAGE_PATH = "/images/warning.png";
    private static final String COMPLETED_STYLE_CLASS = "completed";
    private static final String OVERDUE_STYLE_CLASS = "overdue";

    @FXML
    private Pane taskPane;
    @FXML
    private FlowPane tagsPane;
    @FXML
    private Label name;
    @FXML
    private Label id;
    @FXML
    private Label date;
    @FXML
    private HBox statusBox;
    @FXML
    private ImageView clockIcon;

    private Task task;
    private int displayedIndex;


    public TaskUiView (Task task, int displayedIndex) {
        super(FXML);
        this.task = task;
        this.displayedIndex = displayedIndex;
    }

    @Override
    protected void viewDidMount() {
        boolean isFloatingTask = task.isFloatingTask();
        boolean isTaskWithDeadline = task.isTaskWithDeadline();
        boolean isTask = isFloatingTask || isTaskWithDeadline;
        boolean isEvent = task.isEvent();

        tagsPane.getChildren().clear();

        TaskTypeTagView taskTypeTagView = new TaskTypeTagView(isTask);
        taskTypeTagView.setParent(tagsPane);
        taskTypeTagView.render();

        for (Tag tag : task.getAllTags()) {
            TagView tagView = new TagView(tag.tagName);
            tagView.setParent(tagsPane);
            tagView.render();
        }

        statusBox.getChildren().clear();
        if (task.isOverdue()) {
            TaskStatusView statusView = new TaskStatusView(AppUtil.getImage(OVERDUE_ICON_IMAGE_PATH));
            statusView.setParent(statusBox);
            statusView.render();
            FxViewUtil.addStyleClass(taskPane, OVERDUE_STYLE_CLASS);
        }

        name.setText(task.getDescription());
        id.setText(displayedIndex + ". ");
        if (isTaskWithDeadline) {
            date.setText(DateTimeFormatterUtil.formatTaskDeadline(task.getEndDateTime()));
        } else if (isEvent) {
            date.setText(DateTimeFormatterUtil.formatEventRange(task.getStartDateTime(), task.getEndDateTime()));
        }
        if (isTaskWithDeadline || task.isEvent()) {
            clockIcon.setImage(AppUtil.getImage(CLOCK_ICON_IMAGE_PATH));
        }
        if (task.isCompleted()) {
            FxViewUtil.addStyleClass(taskPane, COMPLETED_STYLE_CLASS);
        }
    }
}
```
###### /java/seedu/toluist/ui/view/UiView.java
``` java
package seedu.toluist.ui.view;

import javafx.scene.layout.Pane;
import seedu.toluist.ui.UiPart;

/**
 * UiView is basic building block for the Ui
 * To show a UiView, {@link #render()} needs to be explicitly called
 * Also a parent node is required through {@link #setParent(Pane)}
 */
abstract class UiView extends UiPart<Pane> {
    private Pane parent;

    public UiView(String fxmlFileName) {
        super(fxmlFileName);
    }

    public void render() {
        viewDidMount();
    }

    public void setParent(Pane newParent) {
        if (parent == newParent) {
            return;
        }

        parent = newParent;
        newParent.getChildren().add(getRoot());
    }

    public Pane getParent() {
        return parent;
    }

    protected void viewDidMount() {} // do nothing by default
}
```
###### /resources/stylesheet/Colors.css
``` css
* {
    theme-primary: #00BCD4;
    theme-primary-dark: #0097A7;
    theme-primary-light: #B2EBF2;
    theme-accent: #FFC107;
    theme-primary-text: #212121;
    theme-secondary-text: #757575;
    theme-text: #FAFAFA;
    theme-background: #E5E5DB;
    theme-danger: #EF4A4F;
}
```
###### /resources/stylesheet/DefaultTheme.css
``` css
@import "Colors.css";
@import "Fonts.css";

/* DEFAULT STYLING */

.root {
    -fx-background-color: theme-background;
    -fx-control-inner-background: theme-background;
    -fx-font-family: "Roboto";
}

.scroll-bar .thumb {
    -fx-background-color: theme-primary-text;
    -fx-background-insets: 3;
}

.scroll-bar .increment-button, .scroll-bar .decrement-button {
    -fx-background-color: transparent;
    -fx-padding: 0 0 0 0;
}

.scroll-bar .increment-arrow, .scroll-bar .decrement-arrow {
    -fx-shape: " ";
}

.scroll-bar:vertical .increment-arrow, .scroll-bar:vertical .decrement-arrow {
    -fx-padding: 1 8 1 8;
}

.scroll-bar:horizontal .increment-arrow, .scroll-bar:horizontal .decrement-arrow {
    -fx-padding: 8 1 8 1;
}

.list-cell {
    -fx-background-color: transparent;
}

.text-field {
    -fx-background-color: transparent;
    -fx-padding: 0.5em 0.5em 0.5em 0.1em;
    -fx-border-color: theme-primary;
    -fx-border-width: 0 0 2 0;
    -fx-prompt-text-fill: theme-secondary-text;
    -fx-highlight-fill: theme-primary-text;
    -fx-font-family: "Roboto Bold";
}

.text-field:focused {
    -fx-border-color: theme-primary-dark;
}

.text-area {
    -fx-background-radius: 0;
}

.text-area .content {
    -fx-background-radius: 0;
    -fx-padding: 10;
}

.label {
    -fx-font-size: 11pt;
    -fx-text-fill: theme-primary-text;
}

/* COMMON CLASSES */

.dark {
    -fx-background-color: theme-primary-text;
    -fx-control-inner-background: theme-primary-text;
    -fx-highlight-fill: theme-text;
    -fx-text-fill: theme-text;
}

/* TAB PANE */

.tabs {
    -fx-background-color: theme-primary-dark;
    -fx-padding: 0 10 0 10;
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.8), 10, 0, 0, 0);
}

.tabs .tab .label {
    -fx-text-fill: theme-primary-light;
    -fx-font-family: "Roboto Bold";
}

.tabs .tab.selected {
    -fx-border-width: 0 0 2 0;
    -fx-border-color: theme-accent;
}

.tabs .tab.selected .label {
    -fx-text-fill: theme-text;
}

/* TASK */

.task {
    -fx-border-color: theme-secondary-text;
    -fx-border-width: 0 0 1 0;
}

.task.completed .status-text .text {
    -fx-strikethrough: true;
}

.task.overdue .status-text.label {
    -fx-text-fill: theme-danger;
}

/* TAG */

.tag {
    -fx-font-family: "Roboto Bold";
    -fx-padding: 5 10 5 10;
    -fx-font-size: 11;
    -fx-background-radius: 5;
}

.tag.event-tag {
    -fx-font-size: 12;
    -fx-background-color: theme-primary-dark;
}

.tag.task-tag {
    -fx-font-size: 12;
    -fx-background-color: derive(theme-accent, -10%);
}

```
###### /resources/stylesheet/Fonts.css
``` css
@font-face {
    font-family: "Roboto";
    font-style: normal;
    font-weight: 400;
    src: url('../fonts/Roboto-Regular.ttf');
}

@font-face {
    font-family: "Roboto Medium";
    font-style: normal;
    font-weight: 500;
    src: url('../fonts/Roboto-Medium.ttf');
}

@font-face {
    font-family: "Roboto Bold";
    font-style: normal;
    font-weight: 600;
    src: url('../fonts/Roboto-Bold.ttf');
}

@font-face {
    font-family: "Roboto Light";
    text-style: normal;
    font-weight: 300;
    src: url('../fonts/Roboto-Light.ttf');
}

@font-face {
    font-family: "Roboto";
    text-style: italic;
    font-weight: 400;
    src: url('../fonts/Roboto-Italic.ttf');
}

@font-face {
    font-family: "Roboto Medium";
    text-style: italic;
    font-weight: 500;
    src: url('../fonts/Roboto-MediumItalic.ttf');
}

@font-face {
    font-family: "Roboto Mono";
    font-style: normal;
    font-weight: 400;
    src: url('../fonts/RobotoMono-Regular.ttf');
}

@font-face {
    font-family: "Roboto Mono Medium";
    font-style: normal;
    font-weight: 500;
    src: url('../fonts/RobotoMono-Medium.ttf');
}
```
###### /resources/view/CommandBox.fxml
``` fxml

<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.AnchorPane?>

<AnchorPane stylesheets="@../stylesheet/DefaultTheme.css" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <TextField fx:id="commandTextField" alignment="CENTER" onAction="#handleCommandInputChanged" promptText="Enter command here..." styleClass="command-input" />
</AnchorPane>
```
###### /resources/view/MainWindow.fxml
``` fxml
<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <stylesheets>
      <URL value="@../stylesheet/DefaultTheme.css" />
   </stylesheets>
   <children>
      <AnchorPane fx:id="tabPanePlaceholder" prefHeight="0.0" prefWidth="200.0" />
      <AnchorPane fx:id="taskListPlaceholder" VBox.vgrow="ALWAYS" />
      <AnchorPane fx:id="resultDisplayPlaceholder" VBox.vgrow="NEVER" />
      <AnchorPane fx:id="commandBoxPlaceholder" VBox.vgrow="NEVER">
         <padding>
            <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
         </padding>
      </AnchorPane>
   </children>
</VBox>
```
###### /resources/view/ResultView.fxml
``` fxml
<?import javafx.scene.control.TextArea?>
<?import javafx.scene.layout.AnchorPane?>

<AnchorPane fx:id="mainPane" stylesheets="@../stylesheet/DefaultTheme.css" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
     <TextArea fx:id="resultDisplay" editable="false" prefHeight="115.0" prefWidth="320.0" promptText="The result of your command will be shown here." styleClass="dark" wrapText="true" />
</AnchorPane>
```
###### /resources/view/TabBarView.fxml
``` fxml
<?import javafx.scene.layout.FlowPane?>


<FlowPane fx:id="tabContainer" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" minHeight="-Infinity" minWidth="-Infinity" prefHeight="40.0" prefWidth="600.0" styleClass="tabs" stylesheets="@../stylesheet/DefaultTheme.css" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1" />
```
###### /resources/view/TabView.fxml
``` fxml
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.text.Font?>

<HBox fx:id="tabPane" alignment="CENTER" prefHeight="35.0" prefWidth="149.0" styleClass="tab" stylesheets="@../stylesheet/DefaultTheme.css" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <Label fx:id="tabShortcutLabel" styleClass="tab-lbl" text="Label" underline="true">
         <font>
            <Font name="System Bold" size="13.0" />
         </font></Label>
      <Label fx:id="tabLabel" text="Label" />
   </children>
</HBox>
```
###### /resources/view/TagView.fxml
``` fxml
<?import java.lang.String?>
<?import javafx.scene.control.Label?>


<Label fx:id="tagLabel" stylesheets="@../stylesheet/DefaultTheme.css" text="Label" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <styleClass>
      <String fx:value="dark" />
      <String fx:value="tag" />
   </styleClass>
</Label>
```
###### /resources/view/TaskListView.fxml
``` fxml
<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.*?>
<?import java.net.URL?>
<VBox xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
    <stylesheets>
        <URL value="@../stylesheet/DefaultTheme.css" />
    </stylesheets>
    <children>
        <ListView fx:id="taskListView" VBox.vgrow="ALWAYS" />
    </children>
</VBox>
```
###### /resources/view/TaskStatusView.fxml
``` fxml
<?import javafx.scene.image.ImageView?>


<ImageView fx:id="imageView" fitHeight="40.0" fitWidth="40.0" pickOnBounds="true" preserveRatio="true" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1" />
```
###### /resources/view/TaskView.fxml
``` fxml
<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.layout.BorderPane?>
<?import javafx.scene.layout.FlowPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.text.Font?>


<BorderPane fx:id="taskPane" styleClass="task" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <right>
      <HBox fx:id="statusBox" alignment="CENTER" BorderPane.alignment="CENTER" />
   </right>
   <center>
      <VBox alignment="CENTER_LEFT" BorderPane.alignment="CENTER">
         <stylesheets>
            <URL value="@../stylesheet/DefaultTheme.css" />
         </stylesheets>
         <children>
            <FlowPane fx:id="primaryTaskPane" alignment="CENTER_LEFT">
               <children>
                  <Label fx:id="id" text="Label">
                     <FlowPane.margin>
                        <Insets />
                     </FlowPane.margin>
                     <font>
                        <Font size="20.0" />
                     </font>
                  </Label>
                  <Label fx:id="name" styleClass="status-text" text="Label" wrapText="true">
                     <FlowPane.margin>
                        <Insets left="5.0" />
                     </FlowPane.margin>
                     <font>
                        <Font size="20.0" />
                     </font>
                  </Label>
                  <FlowPane fx:id="tagsPane" alignment="CENTER_LEFT" columnHalignment="CENTER" hgap="5.0" vgap="5.0">
                     <FlowPane.margin>
                        <Insets left="5.0" />
                     </FlowPane.margin>
                  </FlowPane>
               </children>
            </FlowPane>
            <HBox alignment="CENTER_LEFT" maxHeight="1.7976931348623157E308" maxWidth="1.7976931348623157E308" minHeight="-Infinity" minWidth="-Infinity">
               <children>
                  <ImageView fx:id="clockIcon" fitHeight="15.0" fitWidth="15.0" pickOnBounds="true" preserveRatio="true" />
                  <Label fx:id="date" styleClass="status-text">
                     <font>
                        <Font size="15.0" />
                     </font>
                     <HBox.margin>
                        <Insets left="5.0" />
                     </HBox.margin>
                  </Label>
               </children>
            </HBox>
         </children>
         <padding>
            <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
         </padding>
      </VBox>
   </center>
</BorderPane>
```
