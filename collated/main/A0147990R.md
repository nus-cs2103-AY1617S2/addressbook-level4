# A0147990R
###### /java/seedu/taskboss/logic/commands/ClearByCategoryCommand.java
``` java
public class ClearByCategoryCommand extends Command {

    public static final String COMMAND_WORD = "clear";
    public static final String COMMAND_WORD_SHORT = "c";

    public static final String MESSAGE_USAGE = COMMAND_WORD + " OR c c/"
            + ": Clears all tasks with the specified "
            + "category name (case-sensitive) as a list with index numbers.\n"
            + "Parameters: c/CATEGORYNAME\n"
            + "Example: " + COMMAND_WORD + " c/project" + " || " + "c c/project";

    public static final String MESSAGE_CLEAR_TASK_SUCCESS = "Clear all tasks under the category";
    public static final String MESSAGE_CATEGORY_NOT_FOUND = "The category does not exist";

    private final Category category;

    public ClearByCategoryCommand(Category category) {
        this.category = category;
    }

    @Override
    public CommandResult execute() throws IllegalValueException {
        model.updateFilteredTaskListByCategory(category);

        if (!model.hasCategory(category)) {
            model.updateFilteredListToShowAll();
            return new CommandResult(String.format(MESSAGE_CATEGORY_NOT_FOUND));
        }
        model.clearTasksByCategory(category);
        return new CommandResult(String.format(MESSAGE_CLEAR_TASK_SUCCESS));
    }

}
```
###### /java/seedu/taskboss/logic/commands/FindCommand.java
``` java
    public FindCommand(String type, String keywords) {
        this.type = type;
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() {
        if (type.equals(TYPE_KEYWORDS)) {
            String[] keywordsList = keywords.split(ALL_WHITESPACE);
            final Set<String> keywordSet = new HashSet<String>(Arrays.asList(keywordsList));
            model.updateFilteredTaskListByKeywords(keywordSet);
            return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
        } else if (type.equals(TYPE_START_DATE)) {
            model.updateFilteredTaskListByStartDateTime(keywords);
            return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
        } else { //find by end date time
            model.updateFilteredTaskListByEndDateTime(keywords);
            return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
        }
    }

}
```
###### /java/seedu/taskboss/logic/commands/ListByCategoryCommand.java
``` java
/**
 * Lists tasks under the specified category in TaskBoss to the user.
 */
public class ListByCategoryCommand extends Command {

    public static final String COMMAND_WORD = "list";

    public static final String MESSAGE_USAGE = COMMAND_WORD + " OR l c/"
            + ": Lists all tasks with the specified "
            + "category name (case-sensitive) as a list with index numbers.\n"
            + "Parameters: c/CATEGORYNAME\n"
            + "Example: " + COMMAND_WORD + " c/project" + " || " + "l c/project";

    private final Category category;

    public ListByCategoryCommand(Category category) {
        this.category = category;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskListByCategory(category);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

}
```
###### /java/seedu/taskboss/logic/parser/AddCommandParser.java
``` java
    private String checkEmpty(Optional<String> test) throws IllegalValueException {
        try {
            return test.get();
        } catch (NoSuchElementException nsee) {
            return EMPTY_STRING;
        }
    }
}
```
###### /java/seedu/taskboss/logic/parser/ClearCommandParser.java
``` java
/**
 * Parses input arguments and creates a new ClearCommand
 */
public class ClearCommandParser {

    private static final String EMPTY_STRING = "";

    /**
     * Parses the given {@code String} of arguments in the context of the ClearCommand
     * and returns an ClearCommand object for execution.
     */
    public Command parse(String args) {

        String categoryName;
        if (EMPTY_STRING.equals(args)) {
            return new ClearCommand();
        }

        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_CATEGORY);
        argsTokenizer.tokenize(args);

        try {
            categoryName = argsTokenizer.getValue(PREFIX_CATEGORY).get();
            Category category = new Category(categoryName);
            return new ClearByCategoryCommand(category);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        } catch (NoSuchElementException e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    ClearByCategoryCommand.MESSAGE_USAGE));
        }

    }

}
```
###### /java/seedu/taskboss/logic/parser/FindCommandParser.java
``` java
    /**
     * Parses the given {@code String} of arguments in the context of the FindCommand
     * and returns an FindCommand object for execution.
     * @throws IllegalValueException
     */
    public Command parse(String args) throws IllegalValueException {

        String findType = parseType(args);

        initOneWordDay();

        if (findType.equals(EMPTY_STRING)) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    FindCommand.MESSAGE_USAGE));
        }

        Prefix inputPrefix;

        if (findType.equals(TYPE_START_DATE)) {
            inputPrefix = PREFIX_START_DATE;
        } else {
            inputPrefix = PREFIX_END_DATE;
        }

        try {
            ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(inputPrefix);
            argsTokenizer.tokenize(args);
            String keywords;
            String updatedKeywords;

            if (findType.equals(TYPE_KEYWORDS)) {
                keywords = argsTokenizer.getPreamble().get();
            } else {
                keywords = argsTokenizer.getValue(inputPrefix).get();
            }

            // only parse if input is (not only integers and not a single word) or (contains time)
            // so that user can also search for numeral day_of_month/year
            if ((findType.equals(TYPE_START_DATE) || findType.equals(TYPE_END_DATE)) &&
                    (keywords.replaceAll(DIGITS, EMPTY_STRING).length() > 0 || hasAmOrPm(keywords))) {
                updatedKeywords = parseFindDates(keywords);
            } else {
                updatedKeywords = keywords;
            }

            final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(updatedKeywords.trim());
            if (!matcher.matches()) {
                return new IncorrectCommand(
                        String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
            }
            return new FindCommand(findType, updatedKeywords);

        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    FindCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }

    }

```
###### /java/seedu/taskboss/logic/parser/FindCommandParser.java
``` java
    /**
     * Get the find type of user input
     */
    private String parseType(String args) {
        String input = args.trim();
        if (input.equals(EMPTY_STRING)) {
            return EMPTY_STRING;
        } else if (input.length() >= 3 &&
                input.substring(0, 3).equals("sd/")) {
            return TYPE_START_DATE;
        } else if (input.length() >= 3 &&
                input.substring(0, 3).equals("ed/")) {
            return TYPE_END_DATE;
        } else {
            return TYPE_KEYWORDS;
        }
    }

}
```
###### /java/seedu/taskboss/logic/parser/ListCommandParser.java
``` java
    /**
     * Returns a ListCommand if there is no argument.
     * Otherwise parses the given {@code String} of arguments in the context of the ListByCategoryCommand
     * and returns an ListByCategoryCommand object for execution.
     */
    public Command parse(String args) {
        if (EMPTY_STRING.equals(args)) {
            return new ListCommand();
        }

        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_CATEGORY);
        argsTokenizer.tokenize(args);

        try {
            String categoryName = argsTokenizer.getValue(PREFIX_CATEGORY).get();
            Category category = new Category(categoryName);
            return new ListByCategoryCommand(category);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        } catch (NoSuchElementException e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    ListByCategoryCommand.MESSAGE_USAGE));
        }

    }

}
```
###### /java/seedu/taskboss/model/category/Category.java
``` java
    private String formatName(String name) {
        if (name.length() <= 1) {
            return name.toUpperCase();
        } else {
            String first = name.substring(0, 1).toUpperCase();
            String rest = name.substring(1).toLowerCase();
            return first + rest;
        }
    }

}
```
###### /java/seedu/taskboss/model/category/UniqueCategoryList.java
``` java
    /**
     * Removes a Category to the list.
     *
     */
    public void remove(Category toRemove) {
        assert toRemove != null;
        if (contains(toRemove)) {
            internalList.remove(toRemove);
        }
    }

```
###### /java/seedu/taskboss/model/ModelManager.java
``` java
    @Override
    public void updateFilteredTaskListByStartDateTime(String keywords) {
        updateFilteredTaskList(new PredicateExpression(new StartDatetimeQualifier(keywords)));
    }

    @Override
    public void updateFilteredTaskListByEndDateTime(String keywords) {
        updateFilteredTaskList(new PredicateExpression(new EndDatetimeQualifier(keywords)));
    }

    @Override
    public void updateFilteredTaskListByCategory(Category category) {
        updateFilteredTaskList(new PredicateExpression(new CategoryQualifier(category)));
    }

```
###### /java/seedu/taskboss/model/ModelManager.java
``` java
    @Override
    public void clearTasksByCategory(Category category) throws IllegalValueException {
        taskbossHistory.push(new TaskBoss(this.taskBoss));
        FilteredList<ReadOnlyTask> taskListWithCategory = filteredTasks;
        int listSize = taskListWithCategory.size();
        int i;
        for (i = 0; i < listSize; i++) {
            ReadOnlyTask target = taskListWithCategory.get(0);
            try {
                taskBoss.removeTask(target);
            } catch (TaskNotFoundException pnfe) {
                assert false : "The target task cannot be missing";
            }
        }
        updateFilteredListToShowAll();
        removeCategoryFromTaskboss(category);
        indicateTaskBossChanged();
    }

    /**
     * Removes the category from the UniqueCategoryList of Taskboss
     * if the category is not a build-in category
     **/
    public void removeCategoryFromTaskboss(Category category) {
        try {
            if (!category.equals(new Category(CATEGORY_ALL_TASKS)) &&
                    !category.equals(new Category(CATEGORY_DONE))) {
                taskBoss.removeCategory(category);
            }
        } catch (IllegalValueException ive) {
            //this exception should never be caught as CATEGORY_ALL_TASKS and CATEGORY_DONE
            // are always valid
        }
    }

    @Override
    /**
     * Check whether task boss contains the specified category
     **/
    public boolean hasCategory(Category t) {
        return taskBoss.hasCategory(t);
    }
    //========== Inner classes/interfaces used for filtering =================================================
```
###### /java/seedu/taskboss/model/ModelManager.java
``` java
    private class StartDatetimeQualifier implements Qualifier {
        private String startDateKeyWords;

        StartDatetimeQualifier(String startDateKeyWords) {
            this.startDateKeyWords = startDateKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return task.getStartDateTime().toString().contains(startDateKeyWords) ||
                    task.getStartDateTime().toString().toLowerCase().contains(startDateKeyWords);
        }

        @Override
        public String toString() {
            return "startDateTime=" + startDateKeyWords;
        }
    }

    private class EndDatetimeQualifier implements Qualifier {
        private String endDateKeyWords;

        EndDatetimeQualifier(String endDateKeyWords) {
            this.endDateKeyWords = endDateKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return task.getEndDateTime().toString().contains(endDateKeyWords) ||
                    task.getEndDateTime().toString().toLowerCase().contains(endDateKeyWords);
        }

        @Override
        public String toString() {
            return "endDateTime=" + endDateKeyWords;
        }
    }

    private class CategoryQualifier implements Qualifier {
        private Category categoryKeyWords;

        CategoryQualifier(Category categoryKeyWords) {
            this.categoryKeyWords = categoryKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return task.getCategories().contains(categoryKeyWords);
        }

        @Override
        public String toString() {
            return "category=" + categoryKeyWords.categoryName;
        }
    }
}
```
###### /java/seedu/taskboss/model/task/Name.java
``` java
    public static boolean isValidName(String test) {
        return (!test.equals(EMPTY_STRING)) && test.length() <= MAX_LENGTH;
    }

```
###### /java/seedu/taskboss/model/TaskBoss.java
``` java
    public void removeCategory(Category t) {
        categories.remove(t);
    }

    public boolean hasCategory(Category t) {
        return categories.contains(t);
    }

    //@@authour A0143157J
    /**
     * Renames a category in TaskBoss.
     * @throws IllegalValueException
     * @throws CommandException
     */
    public void renameCategory(Category newCategory, Category oldCategory) throws IllegalValueException,
        CommandException {
        categories.replace(newCategory, oldCategory);
        tasks.renameCategory(oldCategory, newCategory);
    }

//// util methods

```
