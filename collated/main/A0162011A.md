# A0162011A
###### /java/seedu/toluist/commons/util/FxViewUtil.java
``` java
    /**
     * Sets the key event on node.
     * @param node the fx object which the handler will be placed on
     * @param keycode the Keycode value of the accelerator
     * @param handler the event handler
     */
    public static void setKeyCode(Node node, KeyCode keycode,
                                  EventHandler<ActionEvent> handler) {
        node.addEventFilter(KeyEvent.KEY_PRESSED, event -> {
            if (keycode.equals(event.getCode())) {
                handler.handle(new ActionEvent());
                event.consume();
            }
        });
    }
}
```
###### /java/seedu/toluist/commons/util/StringUtil.java
``` java
    /**
     * Returns an array containing each word in the string.
     * @param keywords
     */
    public static String[] convertToArray(String keywords) {
        if (keywords == null || keywords.trim().isEmpty()) {
            return new String[] { EMPTY_STRING };
        }

        String trimmedKeywords = keywords.trim();
        String[] keywordList = trimmedKeywords.split(WHITE_SPACE);
        ArrayList<String> replacementList = new ArrayList<>();
        for (String keyword : keywordList) {
            if (!keyword.equals(EMPTY_STRING)) {
                replacementList.add(keyword);
            }
        }
        return replacementList.toArray(new String[0]);
    }

    /**
     * Return a transformed string of an original string, with the last component replaced
     * @param originalString the original string
     * @param newLastWord the string to replace the last word
     * @return the transformed string
     */
    public static String replaceLastComponent(String originalString, String newLastWord) {
        if (newLastWord == null || !StringUtil.isPresent(originalString)) {
            return originalString;
        }

        ArrayList<String> words = new ArrayList(Arrays.asList(originalString.split(WHITE_SPACE)));

        if (getLastComponent(originalString).equals(EMPTY_STRING)) {
            words.add(EMPTY_STRING);
        }

        if (words.isEmpty()) {
            return originalString;
        }

        words.set(words.size() - 1, newLastWord);
        return String.join(SINGLE_SPACE, words);
    }

    /**
     * Return a transformed string of an original string, with the first word replaced
     * @param originalString the original string
     * @param newFirstWord the string to replace the first word
     * @return the transformed string
     */
    public static String replaceFirstWord(String originalString, String newFirstWord) {
        if (newFirstWord == null || !StringUtil.isPresent(originalString)) {
            return originalString;
        }

        return originalString.replaceFirst(NONE_WHITE_SPACE, newFirstWord);
    }

    /**
     * Get last word of a string
     * @param originalString a string
     * @return last word of the string
     */
    public static String getLastWord(String originalString) {
        String[] words = originalString.trim().split(WHITE_SPACE);
        return words[words.length - 1];
    }

    /**
     * Get last component of a string
     * By component, it means the method will return the last word if the string ends with a word,
     * or "" or the string end with whitespaces
     * @param originalString a string
     * @return last component of the string
     */
    public static String getLastComponent(String originalString) {
        assert originalString != null;
        assert !originalString.equals(EMPTY_STRING);

        if (originalString.substring(originalString.length() - 1).matches(WHITE_SPACE)) {
            return EMPTY_STRING;
        }
        return getLastWord(originalString);
    }

    /**
     * Check if a string starts with another phrase, case-ignored
     * @param originalString a string
     * @param checkPhrase a phrase to compare with
     * @return true / false
     */
    public static boolean startsWithIgnoreCase(String originalString, String checkPhrase) {
        if (originalString == null || checkPhrase == null) {
            return false;
        }
        return originalString.toLowerCase().startsWith(checkPhrase.toLowerCase());
    }


    /**
     * Converts collection of strings to array of arrays of strings
     */
    public static String[][] collectionToArrayOfArrays(Collection<String> strings) {
        return strings.stream().map(string -> new String[] { string })
                .collect(Collectors.toList())
                .toArray(new String[0][0]);
    }
}
```
###### /java/seedu/toluist/controller/AddTagController.java
``` java
package seedu.toluist.controller;

import java.util.ArrayList;
import java.util.Map;
import java.util.logging.Logger;
import java.util.regex.Pattern;

import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.core.Messages;
import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.model.Tag;
import seedu.toluist.model.Task;
import seedu.toluist.ui.commons.CommandResult;

/**
 * Searches the task list for matches in the parameters, and displays the results received
 */
public class AddTagController extends TagController {
    private static final String COMMAND_TAG_WORD = "tag";

    private static final String MESSAGE_TEMPLATE_SUCCESS = "Successfully added \"%s\".\n";
    private static final String MESSAGE_TEMPLATE_FAIL = "Failed to add \"%s\".\n";
    private static final String MESSAGE_TEMPLATE_RESULT = "%s%s successfully added.";

    private static final String HELP_DETAILS = "Adds a tag(s) to an existing task.";
    private static final String HELP_FORMAT = "tag INDEX TAG(S)";
    private static final String[] HELP_COMMENTS = { "Related commands: `untag`",
                                                    "All tags are one word long.",
                                                    "Each word entered after the index will be its own tag.", };
    private static final String[] HELP_EXAMPLES = { "`tag 1 schoolwork`\n"
                                                        + "Adds the tag `schoolwork` to the task at index 1.",
                                                    "`tag 1 housework groceries`\nAdds the tags "
                                                        + "`housework` and `groceries` to the task at index 1." };


    private static final Logger logger = LogsCenter.getLogger(AddTagController.class);

    public void execute(Map<String, String> tokens) throws InvalidCommandException {
        logger.info(getClass() + "will handle command");

        super.execute(tokens);
    }

    public boolean matchesCommand(String command) {
        String trimmedAndLowercasedCommand = command.trim().toLowerCase();
        return trimmedAndLowercasedCommand.startsWith(COMMAND_TAG_WORD.toLowerCase());
    }

    protected String[] extractCommandWords(String command) {
        String replacedCommand = Pattern.compile(COMMAND_TAG_WORD, Pattern.CASE_INSENSITIVE).matcher(command)
            .replaceFirst(StringUtil.EMPTY_STRING).trim();
        return super.extractCommandWords(replacedCommand);
    }

    public String[] getCommandWords() {
        return new String[] { COMMAND_TAG_WORD };
    }

    public String[] getBasicHelp() {
        return new String[] { String.join(StringUtil.FORWARD_SLASH, getCommandWords()), HELP_FORMAT,
            HELP_DETAILS };
    }

    public String[][] getDetailedHelp() {
        return new String[][] { getBasicHelp(), HELP_COMMENTS, HELP_EXAMPLES };
    }

    protected void modifyTagsForTask(ArrayList<String> successfulList,
            ArrayList<String> failedList, Task task, String keywords) {
        String[] keywordList = StringUtil.convertToArray(keywords);
        for (String keyword : keywordList) {
            if (task.addTag(new Tag(keyword))) {
                successfulList.add(keyword);
            } else {
                failedList.add(keyword);
            }
        }
    }

    protected CommandResult formatDisplay(String[] successfulList, String[] failedList, int successCount) {
        String successWords = String.join(StringUtil.QUOTE_DELIMITER, successfulList);
        String failWords = String.join(StringUtil.QUOTE_DELIMITER, failedList);
        String resultMessage = StringUtil.EMPTY_STRING;

        if (successfulList.length > 0) {
            resultMessage += String.format(MESSAGE_TEMPLATE_SUCCESS, successWords);
        }
        if (failedList.length > 0) {
            resultMessage += String.format(MESSAGE_TEMPLATE_FAIL, failWords);
        }

        return new CommandResult(String.format(MESSAGE_TEMPLATE_RESULT, resultMessage,
                StringUtil.nounWithCount(StringUtil.WORD_TAG, successCount)));
    }

    protected void showInvalidFormatMessage() throws InvalidCommandException {
        throw new InvalidCommandException(
                String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, COMMAND_TAG_WORD));
    }
}
```
###### /java/seedu/toluist/controller/AddTaskController.java
``` java
    private static final String HELP_DETAILS = "Adds a task to the todo list.";
    private static final String HELP_FORMAT = "add NAME [from/STARTDATE to/ENDDATE] "
                                                  + "[by/ENDDATE] [repeat/PERIOD"
                                                    + "(daily/weekly/monthly/yearly)] "
                                                  + "[priority/PRIORITY(high/low)] [tags/TAGS]";
    private static final String[] HELP_COMMENTS = { "Related commands: `delete`, `update`",
                                                    "Only fields entered will be used.",
                                                    "Events can be created by entering a value for `by/`",
                                                    "Deadlines can be created by "
                                                        + "entering a value for `from/` and `to/`" };
    private static final String[] HELP_EXAMPLES = { "`add new floating task`\nAdds a new floating task.",
                                                    "`add new deadline by/friday`\n"
                                                        + "Adds a new deadline, with deadline friday.",
                                                    "`add new event from/tuesday to/thursday`\nAdds a new event, "
                                                        + "with start date tuesday and end date thursday.",
                                                    "`add new recurring task by/10pm repeat/daily`\n"
                                                        + "Adds a new recurring task, with deadline 10pm.",
                                                    "`add new tagged task tags/newtag`\n"
                                                        + "Adds a new task, with the tag `newtag`.",
                                                    "`add new priority task priority/high`\n"
                                                        + "Adds a new task, with high priority." };

```
###### /java/seedu/toluist/controller/AddTaskController.java
``` java
    public String[] getBasicHelp() {
        return new String[] { String.join(StringUtil.FORWARD_SLASH, getCommandWords()), HELP_FORMAT,
            HELP_DETAILS };
    }

    public String[][] getDetailedHelp() {
        return new String[][] { getBasicHelp(), HELP_COMMENTS, HELP_EXAMPLES };
    }
}
```
###### /java/seedu/toluist/controller/AliasController.java
``` java
    private static final String HELP_DETAILS = "Adds an alias for a phrase. "
                                                   + "The alias can be used to represent that phrase for commands.";
    private static final String HELP_FORMAT = "alias ALIAS PHRASE";
    private static final String[] HELP_COMMENTS = { "Related commands: `unalias`, `viewalias`",
                                                    "Once added, the alias can be used instead "
                                                        + "of the phrase to perform commands.",
                                                    "The phrase can be multiple words long." };
    private static final String[] HELP_EXAMPLES = { "`alias a add`\nAdds `a` as an alias for the word `add`.",
                                                    "`alias 1 mark complete 1`\n"
                                                        + "Adds `1` as an alias for the phrase `mark complete 1`.",
                                                    "`alias a alias`\nUpdates `a` "
                                                        + "to be an alias for the word `alias` instead of `add`." };

```
###### /java/seedu/toluist/controller/AliasController.java
``` java
    public String[] getBasicHelp() {
        return new String[] { String.join(StringUtil.FORWARD_SLASH, getCommandWords()), HELP_FORMAT,
            HELP_DETAILS };
    }

    public String[][] getDetailedHelp() {
        return new String[][] { getBasicHelp(), HELP_COMMENTS, HELP_EXAMPLES };
    }
}
```
###### /java/seedu/toluist/controller/ClearController.java
``` java
package seedu.toluist.controller;

import java.util.ArrayList;
import java.util.Map;
import java.util.logging.Logger;

import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.UiStore;
import seedu.toluist.ui.commons.CommandResult;

/**
 * UnknownCommandController is responsible for rendering the initial UI
 */
public class ClearController extends Controller {
    private static final Logger logger = LogsCenter.getLogger(ClearController.class);
    private static final String MESSAGE_RESULT = "All tasks cleared.";
    private static final String COMMAND_WORD = "clear";
    private static final String COMMAND_REGEX = "(?iu)^\\s*clear\\s*";

    private static final String HELP_DETAILS = "Clears all entries from the todo list.";
    private static final String HELP_FORMAT = "clear";
    private static final String[] HELP_COMMENTS = { "All entries from every list is affected, "
                                                        + "not just on the current task window.",
                                                    "The `undo` command can undo this action." };

    public void execute(Map<String, String> tokens) throws InvalidCommandException {
        logger.info(getClass().getName() + " will handle command");

        TodoList todoList = TodoList.getInstance();
        UiStore uiStore = UiStore.getInstance();
        todoList.setTasks(new ArrayList<>());
        todoList.save();

        uiStore.setTasks(todoList.getTasks());
        uiStore.setCommandResult(new CommandResult(MESSAGE_RESULT));
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_REGEX);
    }

    public String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }

    public String[] getBasicHelp() {
        return new String[] { String.join(StringUtil.FORWARD_SLASH, getCommandWords()), HELP_FORMAT,
            HELP_DETAILS };
    }

    public String[][] getDetailedHelp() {
        return new String[][] { getBasicHelp(), HELP_COMMENTS, null };
    }
}
```
###### /java/seedu/toluist/controller/Controller.java
``` java
    /**
     * Returns basic help command(s) used by help controller
     * Format is String[CommandWords, Format, Details]
     */
    public String[] getBasicHelp() {
        return new String[0];
    }

    /**
     * Returns detailed help command(s) used by help controller
     * Format is String[String[BasicHelp], String[Comments], String[Examples]]
     * Comments and Examples can be null, but at least one should be there to make this not pointless
     */
    public String[][] getDetailedHelp() {
        return new String[0][0];
    }
}
```
###### /java/seedu/toluist/controller/ControllerLibrary.java
``` java
    /**
     * Returns list of list basic help strings for all command controllers
     * @return list of list of help strings
     */
    public List<List<String>> getCommandControllerBasicHelps() {
        return getCommandControllers().stream()
                .map(controller -> Arrays.asList(controller.getBasicHelp()))
                .collect(Collectors.toList());
    }
}
```
###### /java/seedu/toluist/controller/DeleteTaskController.java
``` java
    private static final String HELP_DETAILS = "Deletes the specified task from the todo list.";
    private static final String HELP_FORMAT = "delete INDEX(ES)";
    private static final String[] HELP_COMMENTS = { "Related commands: `add`, `update`",
                                                    "Supports deletion of multiple indexes in a single command.",
                                                    "The `undo` command can undo this action." };
    private static final String[] HELP_EXAMPLES = { "`delete 1`\nDeletes the task at index 1.",
                                                    "`delete -2`\nDeletes the tasks up to index 2.",
                                                    "`delete 3-`\nDeletes the tasks starting from index 3.",
                                                    "`delete 1, 4`\nDeletes the tasks at index 1 and 4." };

```
###### /java/seedu/toluist/controller/DeleteTaskController.java
``` java
    public String[] getBasicHelp() {
        return new String[] { String.join(StringUtil.FORWARD_SLASH, getCommandWords()), HELP_FORMAT,
            HELP_DETAILS };
    }

    public String[][] getDetailedHelp() {
        return new String[][] { getBasicHelp(), HELP_COMMENTS, HELP_EXAMPLES };
    }
}
```
###### /java/seedu/toluist/controller/ExitController.java
``` java
    public String[] getBasicHelp() {
        return new String[] { String.join(StringUtil.FORWARD_SLASH, getCommandWords()), HELP_FORMAT,
            HELP_DETAILS };
    }

    public String[][] getDetailedHelp() {
        return new String[][] { getBasicHelp(), HELP_COMMENTS, null };
    }
}
```
###### /java/seedu/toluist/controller/FindController.java
``` java
package seedu.toluist.controller;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Predicate;
import java.util.logging.Logger;
import java.util.regex.Pattern;

import seedu.toluist.commons.core.LogsCenter;

import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.model.Task;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.UiStore;
import seedu.toluist.ui.commons.CommandResult;

/**
 * Searches the task list for matches in the parameters, and displays the results received
 */
public class FindController extends Controller {
    private static final String COMMAND_WORD_FIND = "find";
    private static final String COMMAND_WORD_FILTER = "filter";
    private static final String COMMAND_WORD_LIST = "list";

    private static final String PARAMETER_TAG = "/tag";
    private static final String PARAMETER_NAME = "/name";
    private static final String PARAMETER_NULL = StringUtil.EMPTY_STRING;
    public static final String PARAMETER_KEYWORDS = "keywords";

    private static final int NUMBER_OF_SPLITS_FOR_COMMAND_PARSE = 2;
    private static final String COMMAND_SPLITTER_REGEX = StringUtil.SINGLE_SPACE;
    private static final int SECTION_PARAMETER = 1;

    private static final String MESSAGE_RESULT_TEMPLATE_FIND = "Searching for \"%s\" by %s.\n%s found";
    private static final String MESSAGE_RESULT_TEMPLATE_LIST = "Listing all %s";
    private static final String MESSAGE_RESULT_TEMPLATE_TAB = ", %s of which are shown in the current tab.";
    private static final String MESSAGE_NAME = "name";
    private static final String MESSAGE_TAG = "tag";
    private static final String MESSAGE_NAME_AND_TAG = "name and tag";
    private static final String MESSAGE_STRING_JOINING = "\", \"";

    private static final String HELP_DETAILS = "Finds tasks whose names contain any of the given keywords.";
    private static final String HELP_FORMAT = "filter/list/find [KEYWORDS] [tag/] [name/]";
    private static final String[] HELP_COMMENTS = { "By default the name and tag is searched.",
                                                    "Using `tag/` will only search by tag",
                                                    "Using `name/` will only search by name.",
                                                    "Case insensitive. `find a` and `find A` are the same.",
                                                    "If no keyword is entered, the list of all tasks is displayed." };
    private static final String[] HELP_EXAMPLES = { "`find a`\nFinds tasks with `a` in the name or tag.",
                                                    "`filter b tag/ name/`\nFinds tasks with `b` in the name or tag.",
                                                    "`list c name/`\nFinds tasks with `c` in the name.",
                                                    "`find d tag/`\nFinds tasks with `d` in the tag.",
                                                    "`filter\nLists all tasks." };

    private static final Logger logger = LogsCenter.getLogger(FindController.class);

    public void execute(Map<String, String> tokens) throws InvalidCommandException {
        logger.info(getClass() + "will handle command");
        UiStore uiStore = UiStore.getInstance();

        // initialize keywords and variables for searching
        boolean isSearchByTag = tokens.get(PARAMETER_NAME) == null;
        boolean isSearchByName = tokens.get(PARAMETER_TAG) == null;
        String[] keywordList = StringUtil.convertToArray(tokens.get(PARAMETER_KEYWORDS));

        Predicate<Task> taskPredicate = task ->
                (isSearchByTag && task.isAnyKeywordsContainedInAnyTagIgnoreCase(keywordList)
                || (isSearchByName && task.isAnyKeywordsContainedInDescriptionIgnoreCase(keywordList)));


        ArrayList<Task> foundTasksList = TodoList.getInstance().getFilterTasks(taskPredicate);
        uiStore.setTasks(foundTasksList);

        // display formatting
        uiStore.setCommandResult(
                formatDisplay(isSearchByTag, isSearchByName, keywordList, foundTasksList.size()));
    }

    private CommandResult formatDisplay(boolean isSearchByTag, boolean isSearchByName,
                                        String[] keywordList, int foundCount) {
        UiStore uiStore = UiStore.getInstance();
        if (keywordList[0].equals(PARAMETER_NULL)) {
            return new CommandResult(String.format(MESSAGE_RESULT_TEMPLATE_LIST,
                StringUtil.nounWithCount("task", foundCount))
                + String.format(MESSAGE_RESULT_TEMPLATE_TAB, uiStore.getShownTasks().size()));
        }

        String searchParameters = nameSearchParameters(isSearchByTag, isSearchByName);

        String keywords = String.join(MESSAGE_STRING_JOINING, keywordList);
        return new CommandResult(String.format(MESSAGE_RESULT_TEMPLATE_FIND,
                keywords, searchParameters, StringUtil.nounWithCount("result", foundCount))
                + String.format(MESSAGE_RESULT_TEMPLATE_TAB, uiStore.getShownTasks().size()));
    }

    private String nameSearchParameters(boolean isSearchByTag, boolean isSearchByName) {
        if (isSearchByName && isSearchByTag) {
            return MESSAGE_NAME_AND_TAG;
        } else if (isSearchByName) {
            return MESSAGE_NAME;
        } else { //isSearchByTag
            return MESSAGE_TAG;
        }
    }

    public Map<String, String> tokenize(String command) {
        Map<String, String> tokens = super.tokenize(command);

        // keyword for matching
        String keywords = Pattern.compile(PARAMETER_TAG, Pattern.CASE_INSENSITIVE).matcher(command)
                .replaceAll(PARAMETER_NULL);
        keywords = Pattern.compile(PARAMETER_NAME, Pattern.CASE_INSENSITIVE).matcher(keywords)
                .replaceAll(PARAMETER_NULL);
        String[] listOfParameters = keywords.split(COMMAND_SPLITTER_REGEX, NUMBER_OF_SPLITS_FOR_COMMAND_PARSE);
        if (listOfParameters.length > 1) {
            tokens.put(PARAMETER_KEYWORDS, listOfParameters[SECTION_PARAMETER].trim());
        }

        return tokens;
    }

    public boolean matchesCommand(String command) {
        String trimmedAndLowerCasedCommand = command.trim().toLowerCase();
        return (trimmedAndLowerCasedCommand.startsWith(COMMAND_WORD_FILTER.toLowerCase())
                || trimmedAndLowerCasedCommand.startsWith(COMMAND_WORD_FIND.toLowerCase())
                || trimmedAndLowerCasedCommand.startsWith(COMMAND_WORD_LIST.toLowerCase()));
    }

    public String[] getCommandWords() {
        return new String[] { COMMAND_WORD_FILTER, COMMAND_WORD_FIND, COMMAND_WORD_LIST };
    }

    public Map<String, String[]> getCommandKeywordMap() {
        String[] keywords = new String[] { PARAMETER_NAME, PARAMETER_TAG };
        HashMap<String, String[]> keywordMap = new HashMap<>();
        for (String keyword : keywords) {
            keywordMap.put(keyword, new String[0]);
        }
        return keywordMap;
    }

    public String[] getBasicHelp() {
        return new String[] { String.join(StringUtil.FORWARD_SLASH, getCommandWords()), HELP_FORMAT,
            HELP_DETAILS };
    }

    public String[][] getDetailedHelp() {
        return new String[][] { getBasicHelp(), HELP_COMMENTS, HELP_EXAMPLES };
    }
}
```
###### /java/seedu/toluist/controller/HelpController.java
``` java
package seedu.toluist.controller;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.logging.Logger;
import java.util.stream.Collectors;

import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.ui.UiStore;

/**
 * HelpController is responsible for rendering the initial UI
 */
public class HelpController extends Controller {
    private static final Logger logger = LogsCenter.getLogger(HelpController.class);
    private static final String MESSAGE_ERROR = "Sorry, that command does not exist.\n"
                                                    + "Please type help for available commands.";
    private static final String HEADING_GENERAL = "Displaying general help. Press any keys to go back.";
    private static final String HEADING_SPECIFIC = "Displaying detailed help for %s. "
                                                    + "Press any keys to go back.";
    private static final String COMMAND_WORD = "help";
    private static final String COMMAND_REGEX = "(?iu)^\\s*help.*";

    private static final String HELP_DETAILS = "Marks a task to be complete or incomplete.";
    private static final String HELP_FORMAT = "mark [complete/incomplete] INDEX(ES)";
    private static final String[] HELP_EXAMPLES = { "`help`\nShows general help for all commands.",
                                                    "`help add`\nShows detailed help for `add` command." };

    //for detailed help
    private static final String STRING_BASIC_INFO = "Basic info:\n";
    private static final String STRING_COMMENTS = "\n\nComments:\n";
    private static final String STRING_EXAMPLES = "\n\nExamples:\n";
    private static final int INDEX_HELP_BASIC = 0;
    private static final int INDEX_HELP_COMMENTS = 1;
    private static final int INDEX_HELP_EXAMPLES = 2;
    private static final String FORMAT_SPACING = "\n";
    //for basic help
    private static final String STRING_COMMAND = "Command: ";
    private static final String STRING_DESCRIPTION = "\n";
    private static final String STRING_FORMAT = "\nFormat: ";
    private static final int INDEX_HELP_COMMAND = 0;
    private static final int INDEX_HELP_DESCRIPTION = 2;
    private static final int INDEX_HELP_FORMAT = 1;

    private ControllerLibrary controllerLibrary = new ControllerLibrary();

    public void execute(Map<String, String> tokens) throws InvalidCommandException {
        logger.info(getClass().getName() + " will handle command");

        Optional<String> commandWord = tokens.keySet().stream()
                .filter(key -> !key.equals(Controller.DEFAULT_DESCRIPTION_KEYWORD))
                .findFirst();
        boolean isSpecificHelp = commandWord.isPresent()
                && controllerLibrary.getCommandControllerCommandWords()
                    .contains(commandWord.get().toLowerCase());
        boolean isGeneralHelp = !StringUtil.isPresent(tokens.get(Controller.DEFAULT_DESCRIPTION_KEYWORD))
                && !isSpecificHelp;

        if (isGeneralHelp) {
            showGeneralHelp();
        } else if (isSpecificHelp) {
            showSpecificHelp(commandWord.get());
        } else {
            throw new InvalidCommandException(MESSAGE_ERROR);
        }
    }

    private void showSpecificHelp(String commandWord) {
        UiStore uiStore = UiStore.getInstance();
        List<List<String>> detailedHelp =
                Arrays.asList(getControllerFromKeyword(commandWord).getDetailedHelp()).stream()
                    .filter(help -> help != null)
                    .map(help -> Arrays.asList(help))
                    .collect(Collectors.toList());
        uiStore.setHelp(String.format(HEADING_SPECIFIC, commandWord),
                Arrays.asList(convertListListToStringForDetailed(detailedHelp)));
    }

    private Controller getControllerFromKeyword(String commandWord) {
        Collection<Controller> controllers = controllerLibrary.getCommandControllers();
        for (Controller controller : controllers) {
            if (Arrays.stream(controller.getCommandWords())
                    .anyMatch(word -> commandWord.equalsIgnoreCase(word))) {
                return controller;
            }
        }
        return null;
    }

    private void showGeneralHelp() {
        UiStore uiStore = UiStore.getInstance();
        List<List<String>> generalHelp = controllerLibrary.getCommandControllerBasicHelps();
        uiStore.setHelp(HEADING_GENERAL, convertListListToListStringForGeneral(generalHelp));
    }

    private List<String> convertListListToListStringForGeneral(List<List<String>> generalHelp) {
        return generalHelp.stream().map(help -> {
            String finalResult = StringUtil.EMPTY_STRING;
            finalResult += STRING_COMMAND;
            finalResult += String.join(FORMAT_SPACING, help.get(INDEX_HELP_COMMAND));
            finalResult += STRING_FORMAT;
            finalResult += String.join(FORMAT_SPACING, help.get(INDEX_HELP_FORMAT));
            finalResult += STRING_DESCRIPTION;
            finalResult += String.join(FORMAT_SPACING, help.get(INDEX_HELP_DESCRIPTION));
            return finalResult;
        }).collect(Collectors.toList());
    }

    private String convertListListToStringForDetailed(List<List<String>> detailedHelp) {
        String finalResult = StringUtil.EMPTY_STRING;
        finalResult += STRING_BASIC_INFO;
        finalResult += String.join(FORMAT_SPACING, detailedHelp.get(INDEX_HELP_BASIC));
        finalResult += STRING_COMMENTS;
        finalResult += String.join(FORMAT_SPACING, detailedHelp.get(INDEX_HELP_COMMENTS));
        if (INDEX_HELP_EXAMPLES < detailedHelp.size()) {
            finalResult += STRING_EXAMPLES;
            finalResult += String.join(FORMAT_SPACING, detailedHelp.get(INDEX_HELP_EXAMPLES));
        }
        return finalResult;
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_REGEX);
    }

    public String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }

    public Map<String, String[]> getCommandKeywordMap() {
        HashMap<String, String[]> keywordMap = new HashMap<>();
        for (String keyword : controllerLibrary.getCommandControllerCommandWords()) {
            keywordMap.put(keyword, new String[0]);
        }
        return keywordMap;
    }

    public String[][][] getConflictingKeywordsList() {
        return new String[][][] {
            StringUtil.collectionToArrayOfArrays(controllerLibrary.getCommandControllerCommandWords())
        };
    }

    public String[] getBasicHelp() {
        return new String[] { String.join(StringUtil.FORWARD_SLASH, getCommandWords()), HELP_FORMAT,
            HELP_DETAILS };
    }

    public String[][] getDetailedHelp() {
        return new String[][] { getBasicHelp(), null, HELP_EXAMPLES };
    }
}
```
###### /java/seedu/toluist/controller/HistoryController.java
``` java
package seedu.toluist.controller;

import java.util.ArrayList;
import java.util.Map;
import java.util.logging.Logger;

import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.dispatcher.CommandHistoryList;
import seedu.toluist.ui.UiStore;
import seedu.toluist.ui.commons.CommandResult;

/**
 * HistoryController is responsible for showing past commands entered
 */
public class HistoryController extends Controller {
    private static final Logger logger = LogsCenter.getLogger(HistoryController.class);
    private static final String MESSAGE_RESULT = "%s\n%s displayed.";
    private static final String COMMAND_WORD = "history";
    private static final String COMMAND_REGEX = "(?iu)^\\s*history\\s*";

    private static final String HELP_DETAILS = "Shows previous commands entered.";
    private static final String HELP_FORMAT = "history";
    private static final String[] HELP_COMMENTS = { "Commands are listed in order "
                                                        + "from latest command to earlier command.",
                                                    "You can also use the up and down arrow keys "
                                                        + "to cycle through the commands in the command box." };

    private CommandHistoryList commandHistoryList;

    public void setCommandHistory(CommandHistoryList commandHistoryList) {
        this.commandHistoryList = commandHistoryList;
    }

    public void execute(Map<String, String> tokens) throws InvalidCommandException {
        logger.info(getClass().getName() + " will handle command");
        UiStore uiStore = UiStore.getInstance();
        ArrayList<String> commandHistory = commandHistoryList.getCommandHistory();
        String result = String.join("\n", commandHistory);
        uiStore.setCommandResult(new CommandResult(String.format(
                MESSAGE_RESULT, result, StringUtil.nounWithCount("command", commandHistory.size()))));
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_REGEX);
    }

    public String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }

    public String[] getBasicHelp() {
        return new String[] { String.join(StringUtil.FORWARD_SLASH, getCommandWords()), HELP_FORMAT,
            HELP_DETAILS };
    }

    public String[][] getDetailedHelp() {
        return new String[][] { getBasicHelp(), HELP_COMMENTS, null };
    }
}
```
###### /java/seedu/toluist/controller/LoadController.java
``` java
    private static final String HELP_DETAILS = "Changes the location for the storage file used in this system.";
    private static final String HELP_FORMAT = "load NEWFILELOCATION";
    private static final String[] HELP_COMMENTS = { "Related commands: `save`",
                                                    "The displayed data will be updated to the data from the new file.",
                                                    "The old file will remain in your computer.",
                                                    "The file location entered is relative "
                                                        + "to the location of the program.",
                                                    "Warning: If a file with the requested name already exists, "
                                                        + "it will be overwritten." };
    private static final String[] HELP_EXAMPLES = { "`load newfile.json`\nLoads ToLuist data from `newfile.json`.",
                                                    "`load newfolder/newfile.json`\nLoads ToLuist data "
                                                        + "from `newfile.json` in the folder `newfolder`.",
                                                    "`load ../newfile.json`\nLoads ToLuist data "
                                                        + "from `newfile.json` in the parent folder" };

```
###### /java/seedu/toluist/controller/LoadController.java
``` java
    public String[] getBasicHelp() {
        return new String[] { String.join(StringUtil.FORWARD_SLASH, getCommandWords()), HELP_FORMAT,
            HELP_DETAILS };
    }

    public String[][] getDetailedHelp() {
        return new String[][] { getBasicHelp(), HELP_COMMENTS, HELP_EXAMPLES };
    }
}
```
###### /java/seedu/toluist/controller/MarkController.java
``` java
    private static final String HELP_DETAILS = "Marks a task to be complete or incomplete.";
    private static final String HELP_FORMAT = "mark [complete/incomplete] INDEX(ES)";
    private static final String[] HELP_COMMENTS = { "Using complete as a parameter will mark the selected "
                                                        + "task(s) as complete.",
                                                    "Using incomplete as a parameter will mark the selected "
                                                        + "task(s) as incomplete.",
                                                    "Using neither will default the command to mark as complete.",
                                                    "Supports marking of multiple indexes in a single command." };
    private static final String[] HELP_EXAMPLES = { "`mark 1`\nMarks the task at index 1 complete.",
                                                    "`mark incomplete 2`\nMarks the task at index 2 incomplete.",
                                                    "`mark complete 3`\nMarks the task at index 3 complete.",
                                                    "`mark -4`\nMarks the tasks up to index 4 complete.",
                                                    "`mark 5-`\nMarks the tasks starting from index 5 complete.",
                                                    "`mark 1, 6`\nMarks the tasks at index 1 and 6 complete." };

```
###### /java/seedu/toluist/controller/MarkController.java
``` java
    public String[] getBasicHelp() {
        return new String[] { String.join(StringUtil.FORWARD_SLASH, getCommandWords()), HELP_FORMAT,
            HELP_DETAILS };
    }

    public String[][] getDetailedHelp() {
        return new String[][] { getBasicHelp(), HELP_COMMENTS, HELP_EXAMPLES };
    }
}
```
###### /java/seedu/toluist/controller/NavigateHistoryController.java
``` java
package seedu.toluist.controller;

import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;

import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.dispatcher.CommandHistoryList;
import seedu.toluist.ui.UiStore;

/**
 * NavigateHistoryController is responsible for handling cycling through previous commands
 */
public class NavigateHistoryController extends Controller {
    private static final Logger logger = LogsCenter.getLogger(NavigateHistoryController.class);
    private static final String COMMAND_WORD = "navigatehistory";
    private static final String PARAMETER_UP = "up";
    private static final String PARAMETER_DOWN = "down";
    private static final String PARAMETER_DIRECTION = "direction";
    private CommandHistoryList commandHistory;

    public void execute(Map<String, String> tokens) throws InvalidCommandException {
        logger.info(getClass().getName() + " will handle command");

        String direction = tokens.get(PARAMETER_DIRECTION);
        UiStore uiStore = UiStore.getInstance();

        if (direction.equals(PARAMETER_UP)) {
            showPreviousCommand(uiStore.getCommandInputProperty().getValue());
        } else if (direction.equals(PARAMETER_DOWN)) {
            showNextCommand();
        }
    }

    private void showNextCommand() {
        UiStore uiStore = UiStore.getInstance();
        String command = commandHistory.movePointerDown();
        uiStore.setCommandInput(command);
    }

    private void showPreviousCommand(String currentCommand) {
        UiStore uiStore = UiStore.getInstance();
        String command = commandHistory.movePointerUp(currentCommand);
        uiStore.setCommandInput(command);
    }

    public Map<String, String> tokenize(String command) {
        HashMap<String, String> tokens = new HashMap<>();

        command = command.replace(COMMAND_WORD, StringUtil.EMPTY_STRING).trim();
        tokens.put(PARAMETER_DIRECTION, command);

        return tokens;
    }

    public boolean matchesCommand(String command) {
        return command.startsWith(COMMAND_WORD);
    }

    public String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }

    public void setCommandHistory(CommandHistoryList commandHistory) {
        this.commandHistory = commandHistory;
    }
}
```
###### /java/seedu/toluist/controller/RedoController.java
``` java
    private static final String HELP_DETAILS = "Redo previously undone commands by the user.";
    private static final String HELP_FORMAT = "redo [NUMBER]";
    private static final String[] HELP_COMMENTS = { "Related commands: `undo`",
                                                    "Redo commands which were undone by the `undo` command.",
                                                    "If a number is entered, will redo that amount of `undo` commands.",
                                                    "Commands which can be undone: `add`, `update`, `delete`, "
                                                        + "`clear`, `tag`, `untag`, `mark`",
                                                    "Warning: After undo, once a new command "
                                                        + "which can be undone is entered, redo cannot be used." };
    private static final String[] HELP_EXAMPLES = { "`redo`\nRedo the latest undo command.",
                                                    "`redo 5`\nRedo the latest 5 undo commands." };

```
###### /java/seedu/toluist/controller/RedoController.java
``` java
    public String[] getBasicHelp() {
        return new String[] { String.join(StringUtil.FORWARD_SLASH, getCommandWords()), HELP_FORMAT,
            HELP_DETAILS };
    }

    public String[][] getDetailedHelp() {
        return new String[][] { getBasicHelp(), HELP_COMMENTS, HELP_EXAMPLES };
    }
}
```
###### /java/seedu/toluist/controller/SortController.java
``` java
package seedu.toluist.controller;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Logger;
import java.util.regex.Pattern;

import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.core.Messages;
import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.model.Task;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.UiStore;
import seedu.toluist.ui.commons.CommandResult;

/**
 * Sort Controller is responsible for changing the order of the displayed tasks
 */
public class SortController extends Controller {
    private static final String MESSAGE_RESULT = "List is now sorted by: %s.";
    private static final String MESSAGE_ERROR = "Unable to sort by: %s";
    private static final String MESSAGE_NO_VALID_KEYWORD = "No valid keyword entered."
            + " Please type 'help sort' for details";
    private static final String MESSAGE_MULTIPLE_KEYWORDS_AND_DEFAULT = "'Default' keyword may not"
            + " be used with other parameters.";
    private static final String COMMAND_TEMPLATE = "(?iu)^\\s*sort.*";
    private static final String COMMAND_WORD = "sort";
    private static final String WORD_BY = "by";


    private static final String[] KEYWORD_CATEGORIES = {
        Task.CATEGORY_DEFAULT, Task.CATEGORY_DESCRIPTION, Task.CATEGORY_ENDDATE,
        Task.CATEGORY_OVERDUE, Task.CATEGORY_PRIORITY, Task.CATEGORY_STARTDATE
    };
    private static final String PARAMETER_CATEGORY = "category";

    private static final Logger logger = LogsCenter.getLogger(SortController.class);

    private static final String HELP_DETAILS = "Changes the sorting order of the tasks.";
    private static final String HELP_FORMAT = "sort CATEGORY(priority/overdue/enddate/startdate/description/default)";
    private static final String[] HELP_COMMENTS = { "The default sorting order is: "
                                                    + "overdue, priority, end date, start date, description",
                                                    "Using this command will push the chosen category"
                                                    + " to the top of the sorting order." };
    private static final String[] HELP_EXAMPLES = { "`sort priority`\nReorders the task list by description.",
                                                    "`sort overdue`\nReorders the task list by description.",
                                                    "`sort enddate`\nReorders the task list by description.",
                                                    "`sort startdate`\nReorders the task list by description.",
                                                    "`sort description`\nReorders the task list by description.",
                                                    "`sort default`\nResets the task list to the default ordering." };

    public void execute(Map<String, String> tokens) throws InvalidCommandException {
        logger.info(getClass().toString() + " will handle command");

        String keywords = tokens.get(PARAMETER_CATEGORY);
        if (keywords.equals(StringUtil.EMPTY_STRING)) {
            throw new InvalidCommandException(String.format(
                    Messages.MESSAGE_INVALID_COMMAND_FORMAT, COMMAND_WORD));
        }
        ArrayList<String> keywordList = new ArrayList<String>(Arrays.asList(StringUtil.convertToArray(keywords)));
        if (keywordList.contains(Task.CATEGORY_DEFAULT) && keywordList.size() > 1) {
            throw new InvalidCommandException(MESSAGE_MULTIPLE_KEYWORDS_AND_DEFAULT);
        }
        ArrayList<String> invalidKeywords = new ArrayList<String>();
        removeInvalidKeywords(keywordList, invalidKeywords);

        sortByKeywords(keywordList);

        displayResult(invalidKeywords, keywordList);
    }

    private void displayResult(ArrayList<String> invalidKeywords, ArrayList<String> keywordList)
            throws InvalidCommandException {
        String[] resultantOrder = Task.getCurrentSort();
        String resultMessage = StringUtil.EMPTY_STRING;
        UiStore uiStore = UiStore.getInstance();
        if (keywordList.isEmpty()) {
            throw new InvalidCommandException(MESSAGE_NO_VALID_KEYWORD);
        }
        if (!invalidKeywords.isEmpty()) {
            resultMessage += String.format(MESSAGE_ERROR, String.join(StringUtil.COMMA_DELIMITER, invalidKeywords));
            resultMessage += StringUtil.NEW_LINE;
        }
        resultMessage += String.format(MESSAGE_RESULT, String.join(StringUtil.COMMA_DELIMITER, resultantOrder));
        uiStore.setTasks(TodoList.getInstance().getTasks());
        uiStore.setCommandResult(new CommandResult(resultMessage));
    }

    private void sortByKeywords(ArrayList<String> keywordList) {
        for (int i = keywordList.size() - 1; i >= 0; i--) {
            Task.sortBy(keywordList.get(i).toLowerCase());
        }
    }

    private void removeInvalidKeywords(ArrayList<String> keywordList, ArrayList<String> invalidKeywords) {
        for (String keyword : keywordList) {
            if (!isKeywordInCategoryList(keyword)) {
                invalidKeywords.add(keyword);
            }
        }
        for (String keyword : invalidKeywords) {
            keywordList.remove(keyword);
        }
    }

    private boolean isKeywordInCategoryList(String keyword) {
        for (String category : KEYWORD_CATEGORIES) {
            if (keyword.equalsIgnoreCase(category)) {
                return true;
            }
        }
        return false;
    }

    public Map<String, String> tokenize(String command) {
        HashMap<String, String> tokens = new HashMap<>();
        String replacedCommand = Pattern.compile(WORD_BY, Pattern.CASE_INSENSITIVE).matcher(command)
                .replaceFirst(StringUtil.EMPTY_STRING);
        replacedCommand = Pattern.compile(COMMAND_WORD, Pattern.CASE_INSENSITIVE).matcher(replacedCommand)
                .replaceFirst(StringUtil.EMPTY_STRING).trim();

        tokens.put(PARAMETER_CATEGORY, replacedCommand);
        return tokens;
    }

    public Map<String, String[]> getCommandKeywordMap() {
        Map<String, String[]> keywords = new HashMap<>();
        for (String category : KEYWORD_CATEGORIES) {
            keywords.put(category, new String[0]);
        }
        return keywords;
    }

    public String[][][] getConflictingKeywordsList() {
        return new String[][][] { new String[][] {
            new String[] { Task.CATEGORY_DEFAULT },
            new String[] { Task.CATEGORY_DESCRIPTION, Task.CATEGORY_ENDDATE,
                Task.CATEGORY_OVERDUE, Task.CATEGORY_PRIORITY, Task.CATEGORY_STARTDATE
            }
        }};
    }

    public boolean matchesCommand(String command) {
        return command.matches(COMMAND_TEMPLATE);
    }

    public String[] getCommandWords() {
        return new String[] { COMMAND_WORD };
    }

    public String[] getBasicHelp() {
        return new String[] { String.join(StringUtil.FORWARD_SLASH, getCommandWords()), HELP_FORMAT,
            HELP_DETAILS };
    }

    public String[][] getDetailedHelp() {
        return new String[][] { getBasicHelp(), HELP_COMMENTS, HELP_EXAMPLES };
    }
}
```
###### /java/seedu/toluist/controller/StoreController.java
``` java
    private static final String HELP_DETAILS = "Changes the location for the storage file used in this system.";
    private static final String HELP_FORMAT = "save NEWFILELOCATION";
    private static final String[] HELP_COMMENTS = { "Related commands: `load`",
                                                    "All data will be moved to the new file location.",
                                                    "If the file does not exist, the file will be created.",
                                                    "The old file will be removed.",
                                                    "The file location entered is relative "
                                                        + "to the location of the program.",
                                                    "Warning: If a file with the requested name already exists, "
                                                        + "it will be overwritten." };
    private static final String[] HELP_EXAMPLES = { "`save newfile.json`\nSaves ToLuist data to `newfile.json`.",
                                                    "`save newfolder/newfile.json`\nSaves ToLuist data "
                                                        + "to `newfile.json` in the folder `newfolder`.",
                                                    "`save ../newfile.json`\nSaves ToLuist data "
                                                        + "to `newfile.json` in the parent folder" };


```
###### /java/seedu/toluist/controller/StoreController.java
``` java
    public String[] getBasicHelp() {
        return new String[] { String.join(StringUtil.FORWARD_SLASH, getCommandWords()), HELP_FORMAT,
            HELP_DETAILS };
    }

    public String[][] getDetailedHelp() {
        return new String[][] { getBasicHelp(), HELP_COMMENTS, HELP_EXAMPLES };
    }
}
```
###### /java/seedu/toluist/controller/SwitchController.java
``` java
    private static final String HELP_DETAILS = "Changes the displayed task list.";
    private static final String HELP_FORMAT = "switch WINDOWIDENTIFIER";
    private static final String[] HELP_COMMENTS = { "`WindowIdentifier` corresponds to the underlined letter "
                                                        + "at the top of the program.",
                                                    "Allowed values are `I`, `T`, `N`, `C`, `A`.",
                                                    "Alternatively, you can call them by their order: "
                                                        + "+`1`, `2`, `3`, `4`, `5`",
                                                    "Alternatively, you can use the shortcut command "
                                                        + "+`ctrl + (`I`/`T`/`N`/`C`/`A`)." };
    private static final String[] HELP_EXAMPLES = { "`switch 1`\nSwitches the screen to the `Incomplete` window.",
                                                    "`switch T`\nSwitches the screen to the `Today` window.",
                                                    "`ctrl + N`\nSwitches the screen to the `Next 7 Days` window." };

```
###### /java/seedu/toluist/controller/SwitchController.java
``` java
    public String[] getBasicHelp() {
        return new String[] { String.join(StringUtil.FORWARD_SLASH, getCommandWords()), HELP_FORMAT,
            HELP_DETAILS };
    }

    public String[][] getDetailedHelp() {
        return new String[][] { getBasicHelp(), HELP_COMMENTS, HELP_EXAMPLES };
    }
}
```
###### /java/seedu/toluist/controller/TagController.java
``` java
package seedu.toluist.controller;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import org.apache.commons.lang.StringUtils;

import seedu.toluist.commons.core.Messages;
import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.model.Task;
import seedu.toluist.model.TodoList;
import seedu.toluist.ui.UiStore;
import seedu.toluist.ui.commons.CommandResult;

/**
 * Searches the task list for matches in the parameters, and displays the results received
 */
public abstract class TagController extends Controller {

    private static final String PARAMETER_INDEX = "index";
    private static final String PARAMETER_KEYWORDS = "keywords";

    private static final int NUMBER_OF_SPLITS_FOR_COMMAND_PARSE = 2;
    private static final String COMMAND_SPLITTER_REGEX = StringUtil.SINGLE_SPACE;
    private static final int SECTION_INDEX = 0;
    private static final int SECTION_KEYWORDS = 1;

    public void execute(Map<String, String> tokens) throws InvalidCommandException {
        if (isInvalidFormat(tokens)) {
            showInvalidFormatMessage();
            return;
        }
        if (isIndexOutOfBounds(tokens)) {
            throw new InvalidCommandException(Messages.MESSAGE_INVALID_TASK_INDEX);
        }

        ArrayList<String> successfulList = new ArrayList<String>();
        ArrayList<String> failedList = new ArrayList<String>();
        UiStore uiStore = UiStore.getInstance();
        Task task = getTaskFromIndex(Integer.parseInt(tokens.get(PARAMETER_INDEX)) - 1);
        modifyTagsForTask(successfulList, failedList,
                task, tokens.get(PARAMETER_KEYWORDS));

        updateList(task);

        uiStore.setCommandResult(formatDisplay(successfulList.toArray(new String[successfulList.size()]),
                                failedList.toArray(new String[failedList.size()]),
                                successfulList.size()));
    }

    private Task getTaskFromIndex(int index) {
        return UiStore.getInstance().getShownTasks().get(index);
    }

    protected abstract void showInvalidFormatMessage() throws InvalidCommandException;

    protected boolean isIndexOutOfBounds(Map<String, String> tokens) {
        int index = Integer.parseInt(tokens.get(PARAMETER_INDEX)) - 1;
        if (index < 0 || index >= UiStore.getInstance().getShownTasks().size()) {
            return true;
        }
        return false;
    }

    protected boolean isInvalidFormat(Map<String, String> tokens) {
        String index = tokens.get(PARAMETER_INDEX);
        if (index.equals("") || tokens.get(PARAMETER_KEYWORDS).equals("")) {
            return true;
        }
        if (!StringUtils.isNumeric(index)) {
            return true;
        }

        return false;
    }

    protected void updateList(Task task) {
        TodoList todoList = TodoList.getInstance();
        UiStore uiStore = UiStore.getInstance();
        if (todoList.save()) {
            uiStore.setTasks(todoList.getTasks(), task);
        }
    }

    protected abstract void modifyTagsForTask(ArrayList<String> successfulList,
            ArrayList<String> failedList, Task task, String keywords);

    protected abstract CommandResult formatDisplay(String[] successfulList, String[] failedList, int successCount);

    public Map<String, String> tokenize(String command) {
        HashMap<String, String> tokens = new HashMap<>();

        String[] listOfParameters = extractCommandWords(command);
        try {
            tokens.put(PARAMETER_INDEX, listOfParameters[SECTION_INDEX]);
            tokens.put(PARAMETER_KEYWORDS, listOfParameters[SECTION_KEYWORDS]);
        } catch (Exception e) {
            tokens.put(PARAMETER_INDEX, "");
            tokens.put(PARAMETER_KEYWORDS, "");
        }

        return tokens;
    }

    protected String[] extractCommandWords(String command) {
        return command.split(COMMAND_SPLITTER_REGEX, NUMBER_OF_SPLITS_FOR_COMMAND_PARSE);
    }
}
```
###### /java/seedu/toluist/controller/UnaliasController.java
``` java
    private static final String HELP_DETAILS = "Removes an alias for a command.";
    private static final String HELP_FORMAT = "unalias ALIAS";
    private static final String[] HELP_COMMENTS = { "Related commands: `alias`, `viewalias`" };
    private static final String[] HELP_EXAMPLES = { "`unalias abc`\nRemoves the alias `abc` from the program." };

```
###### /java/seedu/toluist/controller/UnaliasController.java
``` java
    public String[] getBasicHelp() {
        return new String[] { String.join(StringUtil.FORWARD_SLASH, getCommandWords()), HELP_FORMAT,
            HELP_DETAILS };
    }

    public String[][] getDetailedHelp() {
        return new String[][] { getBasicHelp(), HELP_COMMENTS, HELP_EXAMPLES };
    }
}
```
###### /java/seedu/toluist/controller/UndoController.java
``` java
    private static final String HELP_DETAILS = "Undoes previous commands by the user.";
    private static final String HELP_FORMAT = "undo [NUMBER]";
    private static final String[] HELP_COMMENTS = { "Related commands: `undo`",
                                                    "Undo commands which `morph` data in the program.",
                                                    "If a number is entered, will undo that amount of commands.",
                                                    "Commands which can be undone: `add`, "
                                                        + "`update`, `delete`, `clear`, `tag`, `untag`, `mark`" };
    private static final String[] HELP_EXAMPLES = { "`undo`\nUndo the latest morphing command.",
                                                    "`undo 5`\nUndo the latest 5 morphing commands." };

```
###### /java/seedu/toluist/controller/UndoController.java
``` java
    public String[] getBasicHelp() {
        return new String[] { String.join(StringUtil.FORWARD_SLASH, getCommandWords()), HELP_FORMAT,
            HELP_DETAILS };
    }

    public String[][] getDetailedHelp() {
        return new String[][] { getBasicHelp(), HELP_COMMENTS, HELP_EXAMPLES };
    }
}
```
###### /java/seedu/toluist/controller/UntagController.java
``` java
package seedu.toluist.controller;

import java.util.ArrayList;
import java.util.Map;
import java.util.logging.Logger;
import java.util.regex.Pattern;

import seedu.toluist.commons.core.LogsCenter;
import seedu.toluist.commons.core.Messages;
import seedu.toluist.commons.exceptions.InvalidCommandException;
import seedu.toluist.commons.util.StringUtil;
import seedu.toluist.model.Tag;
import seedu.toluist.model.Task;
import seedu.toluist.ui.commons.CommandResult;

/**
 * Searches the task list for matches in the parameters, and displays the results received
 */
public class UntagController extends TagController {
    private static final String COMMAND_UNTAG_WORD = "untag";

    private static final String MESSAGE_TEMPLATE_SUCCESS = "Sucessfully removed \"%s\".\n";
    private static final String MESSAGE_TEMPLATE_FAIL = "Failed to remove \"%s\".\n";
    private static final String MESSAGE_TEMPLATE_RESULT = "%s%s successfully removed.";

    private static final String HELP_DETAILS = "Removes a tag or multiple tags from an existing task.";
    private static final String HELP_FORMAT = "untag INDEX TAG(S)";
    private static final String[] HELP_COMMENTS = { "Related commands: `tag`",
                                                    "All tags are one word long.",
                                                    "Each word entered after the index will be untagged separately.", };
    private static final String[] HELP_EXAMPLES = { "`untag 1 schoolwork`\n"
                                                        + "Removes the tag `schoolwork` from the task at index 1.",
                                                    "`untag 1 housework groceries`\nRemoves the tags "
                                                        + "`housework` and `groceries` from the task at index 1." };

    private static final Logger logger = LogsCenter.getLogger(UntagController.class);

    public void execute(Map<String, String> tokens) throws InvalidCommandException {
        logger.info(getClass() + "will handle command");

        super.execute(tokens);
    }

    public boolean matchesCommand(String command) {
        String trimmedAndLowercasedCommand = command.trim().toLowerCase();
        return trimmedAndLowercasedCommand.startsWith(COMMAND_UNTAG_WORD);
    }

    protected String[] extractCommandWords(String command) {
        String replacedCommand = Pattern.compile(COMMAND_UNTAG_WORD, Pattern.CASE_INSENSITIVE).matcher(command)
            .replaceFirst(StringUtil.EMPTY_STRING).trim();
        return super.extractCommandWords(replacedCommand);
    }

    public String[] getCommandWords() {
        return new String[] { COMMAND_UNTAG_WORD };
    }

    public String[] getBasicHelp() {
        return new String[] { String.join(StringUtil.FORWARD_SLASH, getCommandWords()), HELP_FORMAT,
            HELP_DETAILS };
    }

    public String[][] getDetailedHelp() {
        return new String[][] { getBasicHelp(), HELP_COMMENTS, HELP_EXAMPLES };
    }

    protected void modifyTagsForTask(ArrayList<String> successfulList,
            ArrayList<String> failedList, Task task, String keywords) {
        String[] keywordList = StringUtil.convertToArray(keywords);
        for (String keyword : keywordList) {
            if (task.removeTag(new Tag(keyword))) {
                successfulList.add(keyword);
            } else {
                failedList.add(keyword);
            }
        }
    }

    protected CommandResult formatDisplay(String[] successfulList, String[] failedList, int successCount) {
        String successWords = String.join(StringUtil.QUOTE_DELIMITER, successfulList);
        String failWords = String.join(StringUtil.QUOTE_DELIMITER, failedList);
        String resultMessage = StringUtil.EMPTY_STRING;

        if (successfulList.length > 0) {
            resultMessage += String.format(MESSAGE_TEMPLATE_SUCCESS, successWords);
        }
        if (failedList.length > 0) {
            resultMessage += String.format(MESSAGE_TEMPLATE_FAIL, failWords);
        }

        return new CommandResult(String.format(MESSAGE_TEMPLATE_RESULT, resultMessage,
                StringUtil.nounWithCount(StringUtil.WORD_TAG, successCount)));
    }

    protected void showInvalidFormatMessage() throws InvalidCommandException {
        throw new InvalidCommandException(
                String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, COMMAND_UNTAG_WORD));
    }
}
```
###### /java/seedu/toluist/controller/UpdateTaskController.java
``` java
    private static final String HELP_DETAILS = "Updates an existing task in the todo list.";
    private static final String HELP_FORMAT = "update INDEX [NAME] [from/STARTDATE to/ENDDATE] "
                                                        + "[by/ENDDATE] [repeat/PERIOD(daily/weekly/monthly)] "
                                                        + "[priority/PRIORITY(high/low)] [tags/TAGS]";
    private static final String[] HELP_COMMENTS = { "Related commands: `add`, `delete`",
                                                    "Only fields entered will be updated.",
                                                    "When editing tags, the existing tags "
                                                        + "will be replaced with the new tags.",
                                                    "Events can be changed to deadlines by using `by/`",
                                                    "Deadlines can be changed to events by using `from/` and `to/`" };
    private static final String[] HELP_EXAMPLES = { "`update 1 new name`\nUpdates the name "
                                                        + "for the floating task at index 1 to `new name`.",
                                                    "`update 2 from/today to/tomorrow`\n"
                                                        + "Updates the start and end time of the event at index 2.",
                                                    "`update 3 by/sunday`\n"
                                                        + "Updates the end time of the deadline at index 3.",
                                                    "`update 4 repeat/daily by/9pm`\nUpdates the task "
                                                        + "at index 4 to repeat every day with a deadline of 9pm.",
                                                    "`update 5 priority/high`\n"
                                                        + "Updates the priority of the task at index 5 to high.",
                                                    "`update 6 tags/newtag`\n"
                                                        + "Updates the tags for the task at index 6 to `newtag`." };

```
###### /java/seedu/toluist/controller/UpdateTaskController.java
``` java
    public String[] getBasicHelp() {
        return new String[] { String.join(StringUtil.FORWARD_SLASH, getCommandWords()), HELP_FORMAT,
            HELP_DETAILS };
    }

    public String[][] getDetailedHelp() {
        return new String[][] { getBasicHelp(), HELP_COMMENTS, HELP_EXAMPLES };
    }
}
```
###### /java/seedu/toluist/controller/ViewAliasController.java
``` java
    public String[] getBasicHelp() {
        return new String[] { String.join(StringUtil.FORWARD_SLASH, getCommandWords()), HELP_FORMAT,
            HELP_DETAILS };
    }

    public String[][] getDetailedHelp() {
        return new String[][] { getBasicHelp(), HELP_COMMENTS, null };
    }
}
```
###### /java/seedu/toluist/dispatcher/CommandDispatcher.java
``` java
    /**
     * ArrayList to store previous commands entered since starting the application
     */
    private CommandHistoryList commandHistory = new CommandHistoryList();
    private ControllerLibrary controllerLibrary = new ControllerLibrary();
    private TokenHistoryList tokenHistoryList = new TokenHistoryList();

```
###### /java/seedu/toluist/dispatcher/CommandDispatcher.java
``` java
    /**
     * Special handling for navigate history controller (if applicable)
     * @param controller a Controller instance
     */
    private void handleNavigateHistoryController(Controller controller) {
        if (controller instanceof NavigateHistoryController) {
            ((NavigateHistoryController) controller).setCommandHistory(commandHistory);
        }
    }

    /**
     * Special handling for history controller (if applicable)
     * @param controller a Controller instance
     */
    private void handleHistoryController(Controller controller) {
        if (controller instanceof HistoryController) {
            ((HistoryController) controller).setCommandHistory(commandHistory);
        }
    }

```
###### /java/seedu/toluist/dispatcher/CommandHistoryList.java
``` java
package seedu.toluist.dispatcher;

import java.util.ArrayList;

import seedu.toluist.commons.util.StringUtil;

public class CommandHistoryList {
    private ArrayList<String> commandHistory;
    private int historyPointer = 0;
    private String currentCommand;

    public CommandHistoryList() {
        commandHistory = new ArrayList();
        currentCommand = StringUtil.EMPTY_STRING;
    }

    public ArrayList<String> getCommandHistory() {
        return commandHistory;
    }

    public void recordCommand(String command) {
        commandHistory.add(command);
        historyPointer = commandHistory.size();
    }

    public String movePointerDown() {
        if (historyPointer != commandHistory.size()) {
            historyPointer++;
        }

        if (historyPointer == commandHistory.size()) {
            return currentCommand;
        }
        return commandHistory.get(historyPointer);
    }

    public String movePointerUp(String currentCommand) {
        if (historyPointer == commandHistory.size()) {
            this.currentCommand = currentCommand;
        }
        if (commandHistory.size() == 0) {
            return this.currentCommand;
        }

        if (historyPointer != 0) {
            historyPointer--;
        }
        return commandHistory.get(historyPointer);
    }
}
```
###### /java/seedu/toluist/model/Task.java
``` java
    public static final String CATEGORY_PRIORITY = "priority";
    public static final String CATEGORY_STARTDATE = "startdate";
    public static final String CATEGORY_ENDDATE = "enddate";
    public static final String CATEGORY_OVERDUE = "overdue";
    public static final String CATEGORY_DESCRIPTION = "description";
    public static final String CATEGORY_DEFAULT = "default";
    private static final int START_OF_ARRAY_INDEX = 0;

    private static String[] defaultSortOrder = { CATEGORY_OVERDUE, CATEGORY_PRIORITY, CATEGORY_ENDDATE,
                                                 CATEGORY_STARTDATE, CATEGORY_DESCRIPTION};
    private static LinkedList<String> sortingOrder = new LinkedList<String>(Arrays.asList(defaultSortOrder));

```
###### /java/seedu/toluist/model/Task.java
``` java
    public boolean addTag(Tag tag) {
        if (allTags.contains(tag)) {
            return false;
        }

        this.allTags.add(tag);
        return true;
    }

    public boolean removeTag(Tag tag) {
        if (!allTags.contains(tag)) {
            return false;
        }

        allTags.remove(tag);
        return true;
    }

```
###### /java/seedu/toluist/model/Task.java
``` java
    public boolean isAnyKeywordsContainedInDescriptionIgnoreCase(String[] keywords) {
        for (String keyword: keywords) {
            if (description.toLowerCase().contains(keyword.toLowerCase())) {
                return true;
            }
        }
        return false;
    }

    public boolean isAnyKeywordsContainedInAnyTagIgnoreCase(String[] keywords) {
        for (String keyword: keywords) {
            for (Tag tag : allTags) {
                if (tag.getTagName().toLowerCase().contains(keyword.toLowerCase())) {
                    return true;
                }
            }
        }
        return false;
    }

```
###### /java/seedu/toluist/model/Task.java
``` java
    @Override
    /**
     * Compare by sortingOrder
     */
    public int compareTo(Task comparison) {
        for (String currentSort : sortingOrder) {
            switch (currentSort) {
            case CATEGORY_PRIORITY :
                if (priority.compareTo(comparison.priority) != 0) {
                    return priority.compareTo(comparison.priority);
                }
                break;
            case CATEGORY_STARTDATE :
                if (!Objects.equals(startDateTime, comparison.startDateTime)) {
                    return DateTimeUtil.isBeforeOrEqual(startDateTime, comparison.startDateTime) ? -1 : 1;
                }
                break;
            case CATEGORY_ENDDATE :
                if (!Objects.equals(endDateTime, comparison.endDateTime)) {
                    return DateTimeUtil.isBeforeOrEqual(endDateTime, comparison.endDateTime) ? -1 : 1;
                }
                break;
            case CATEGORY_OVERDUE :
                if (isOverdue() != comparison.isOverdue()) {
                    return isOverdue() ? -1 : 1;
                }
                break;
            case CATEGORY_DESCRIPTION :
                if (this.description.compareToIgnoreCase(comparison.description) != 0) {
                    return this.description.compareToIgnoreCase(comparison.description);
                }
            }
        }
        return -1;
    }

```
###### /java/seedu/toluist/model/Task.java
``` java
    /**
     * Changes the sorting order
     * @param keyword to sort by
     * @return true if sorting order changes / false if not
     */
    public static String[] sortBy(String keyword) {
        if (keyword.equals(CATEGORY_DEFAULT)) {
            sortingOrder = new LinkedList<String>(Arrays.asList(defaultSortOrder));
        } else {
            updateSortingOrder(keyword);
        }
        return sortingOrder.toArray(new String[sortingOrder.size()]);
    }

    public static String[] getCurrentSort() {
        return sortingOrder.toArray(new String[sortingOrder.size()]);
    }

    private static boolean updateSortingOrder(String keyword) {
        if (sortingOrder.indexOf(keyword) == START_OF_ARRAY_INDEX) {
            return false;
        }
        sortingOrder.remove(keyword);
        sortingOrder.add(START_OF_ARRAY_INDEX,  keyword);
        return true;
    }
}
```
###### /java/seedu/toluist/model/TodoList.java
``` java
    public void setTasks(List<Task> newTaskList) {
        allTasks = new ArrayList<>(newTaskList);
    }
}
```
###### /java/seedu/toluist/ui/MainWindow.java
``` java
    /**
     * Configure Up/Down for history navigation
     */
    private void configureHistoryNavigationKeyPresses() {
        Arrays.stream(KEYCODES_NAVIGATEHISTORY).forEach(keyName -> {
            KeyCode keycode = getKeyCode(keyName);
            String navigateCommand = COMMAND_NAVIGATEHISTORY + keyName;
            EventHandler<ActionEvent> handler = event -> dispatcher.dispatch(navigateCommand);
            FxViewUtil.setKeyCode(commandBox.getRoot(), keycode, handler);
        });
    }

```
###### /java/seedu/toluist/ui/UiStore.java
``` java
    public ObservableValue<Pair<String, List<String>>> getObservableHelp() {
        return observableHelp;
    }

    /**
     * method to setHelp
     * @param heading general or help or specific command
     * @param helpList details to replace current help
     */
    public void setHelp(String heading, List<String> helpList) {
        observableHelp.setValue(new Pair(heading, helpList));
    }
}
```
###### /java/seedu/toluist/ui/view/HelpListView.java
``` java
package seedu.toluist.ui.view;

import java.util.List;

import javafx.collections.FXCollections;
import javafx.fxml.FXML;
import javafx.geometry.Pos;
import javafx.scene.control.ContentDisplay;
import javafx.scene.control.Label;
import javafx.scene.control.ListCell;
import javafx.scene.control.ListView;
import javafx.util.Pair;
import seedu.toluist.commons.util.FxViewUtil;
import seedu.toluist.ui.UiStore;

/**
 * HelpListView is responsible for the view displaying help
 */
public class HelpListView extends UiView {

    private static final String FXML = "HelpListView.fxml";
    private static final double OFFSET_WRAPPING = 10;

    @FXML
    private ListView<String> helpListView;
    @FXML
    private Label headerLabel;

    public HelpListView() {
        super(FXML);
        FxViewUtil.makeFullWidth(getRoot());
        FxViewUtil.makeFullWidth(helpListView);
        FxViewUtil.makeFullWidth(headerLabel);
        helpListView.setCellFactory(help -> new HelpListCell());
        configureBindings();
    }

    private void configureBindings() {
        UiStore store = UiStore.getInstance();
        store.bind(this, store.getObservableHelp());
        helpListView.prefHeightProperty().bind(getRoot().heightProperty());
    }

    protected void viewDidMount() {
        UiStore store = UiStore.getInstance();
        Pair<String, List<String>> help = store.getObservableHelp().getValue();
        String heading = help.getKey();
        List<String> helpList = help.getValue();
        helpListView.setItems(FXCollections.observableArrayList(helpList));
        headerLabel.setText(heading);
        getParent().setVisible(helpList != null && !helpList.isEmpty());
    }

    class HelpListCell extends ListCell<String> {

        @Override
        protected void updateItem(String helpString, boolean empty) {
            super.updateItem(helpString, empty);

            if (empty || helpString == null) {
                setGraphic(null);
                setText(null);
            } else {
                Label label = new Label(helpString);
                label.setWrapText(true);
                label.maxWidthProperty().bind(helpListView.widthProperty().subtract(OFFSET_WRAPPING));
                label.setContentDisplay(ContentDisplay.CENTER);
                setPrefWidth(0);
                setGraphic(label);
                setAlignment(Pos.CENTER_LEFT);
            }
        }
    }
}
```
###### /java/seedu/toluist/ui/view/TagView.java
``` java
package seedu.toluist.ui.view;

import javafx.fxml.FXML;
import javafx.scene.control.Label;

/**
 * View to display the indiviual tag
 */
public class TagView extends UiView {
    private static final String FXML = "TagView.fxml";

    @FXML
    protected Label tagLabel;
    private final String tagName;

    public TagView(String tagName) {
        super(FXML);
        this.tagName = tagName;
    }

    @Override
    protected void viewDidMount() {
        tagLabel.setText(tagName);
    }
}
```
###### /resources/view/HelpListView.fxml
``` fxml

<?import java.lang.String?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.VBox?>


<VBox xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <Label fx:id="headerLabel" alignment="CENTER" maxWidth="1.7976931348623157E308"
             text="Viewing help. Press any key(s) to go back.">
         <styleClass>
            <String fx:value="help-header" />
            <String fx:value="bold-text" />
            <String fx:value="header" />
         </styleClass>
      </Label>
      <ListView fx:id="helpListView" maxHeight="1.7976931348623157E308" />
   </children>
</VBox>
```
###### /resources/view/TagView.fxml
``` fxml

<?import java.lang.String?>
<?import javafx.scene.control.Label?>

<Label fx:id="tagLabel" stylesheets="@../stylesheet/DefaultTheme.css" text="Label" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <styleClass>
      <String fx:value="dark" />
      <String fx:value="tag" />
      <String fx:value="bold-text" />
   </styleClass>
</Label>
```
