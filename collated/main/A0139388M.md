# A0139388M
###### \java\seedu\address\logic\commands\ExportCommand.java
``` java
/*
 * Exports task manager data to specified file path.
 */
public class ExportCommand extends Command {

    public static final String COMMAND_WORD = "export";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Exports data to the specified directory.\n"
            + "Parameters: dir_location\n" + "Example: " + COMMAND_WORD + " example_folder";
    public static final String MESSAGE_SUCCESS = "Data has been exported to: %1$s";
    public static final String MESSAGE_SUCCESS_STATUS_BAR = "Data has been exported to: %1$s";
    public static final String MESSAGE_WRITE_FILE_ERROR = "Unable to write data to: %1$s";

    public static final String TASK_MANAGER_FILE_NAME = "taskmanager.xml";

    private final String exportDir;

    /**
     * Creates an ExportCommand using raw values.
     */
    public ExportCommand(String dirLocation) {
        this.exportDir = dirLocation;
    }

    @Override
    public CommandResult execute() throws CommandException {
        String path = getPath();

        if (FileUtil.isWritable(path)) {
            model.exportToLocation(path);
            return new CommandResult(String.format(MESSAGE_SUCCESS, path),
                    String.format(MESSAGE_SUCCESS_STATUS_BAR, path));
        } else {
            throw new CommandException(String.format(MESSAGE_WRITE_FILE_ERROR, path));
        }
    }

    private String getPath() {
        File file = new File(exportDir, TASK_MANAGER_FILE_NAME);

        try {
            return file.getCanonicalPath();
        } catch (IOException e) {
            return file.getAbsolutePath();
        }
    }

}
```
###### \java\seedu\address\logic\commands\ImportCommand.java
``` java
/*
 * Changes task manager save location to specified file path.
 */
public class ImportCommand extends Command {

    public static final String COMMAND_WORD = "import";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Imports file data from the specified file directory. \n" + "Parameters: dir_location\n" + "Example: "
            + COMMAND_WORD + " example_folder";
    public static final String MESSAGE_SUCCESS = "Data imported from: %1$s";
    public static final String MESSAGE_SUCCESS_STATUS_BAR = "Data imported from %1$s";
    public static final String MESSAGE_FILE_MISSING_ERROR = "The directory does not contain the file: %1$s";

    public static final String TASK_MANAGER_FILE_NAME = "taskmanager.xml";

    private final String useThisDir;

    /**
     * Creates an UseThisCommand using raw values.
     */
    public ImportCommand(String dirLocation) {
        useThisDir = dirLocation;
    }

    @Override
    public CommandResult execute() throws CommandException {
        String path = getPath();
        File file = new File(path);

        if (FileUtil.isFileExists(file)) {
            model.importFromLocation(path);
            return new CommandResult(String.format(MESSAGE_SUCCESS, path),
                    String.format(MESSAGE_SUCCESS_STATUS_BAR, path));
        } else {
            throw new CommandException(String.format(MESSAGE_FILE_MISSING_ERROR, path));
        }
    }

    private String getPath() {
        File file = new File(useThisDir, TASK_MANAGER_FILE_NAME);

        try {
            return file.getCanonicalPath();
        } catch (IOException e) {
            return file.getAbsolutePath();
        }
    }
}
```
###### \java\seedu\address\logic\commands\RedoCommand.java
``` java
/*
 * Undo the last command by the user.
 */
public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";
    public static final String MESSAGE_NO_PREV_COMMAND = "No commands left to redo";
    public static final String MESSAGE_SUCCESS_STATUS_BAR = "Redo successfully.";

    @Override
    public CommandResult execute() {
        return new CommandResult("Should not execute", MESSAGE_SUCCESS_STATUS_BAR);
    }

    public String getToRedo() throws CommandException {
        try {
            return model.getRedoCommand();
        } catch (NoPreviousCommandException e) {
            throw new CommandException(MESSAGE_NO_PREV_COMMAND);
        }
    }

}
```
###### \java\seedu\address\logic\commands\SaveToCommand.java
``` java
/*
 * Changes task manager save location to specified file path.
 */
public class SaveToCommand extends Command {

    public static final String COMMAND_WORD = "saveto";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Saves to the specified directory.\n"
            + "Parameters: dir_location\n" + "Example: " + COMMAND_WORD + " example_folder";
    public static final String MESSAGE_SUCCESS = "Save location has been changed to: %1$s";
    public static final String MESSAGE_SUCCESS_STATUS_BAR = "Save location changed to: %1$s";
    public static final String MESSAGE_WRITE_FILE_ERROR = "Unable to write data to: %1$s";

    public static final String TASK_MANAGER_FILE_NAME = "taskmanager.xml";

    private final String saveToDir;

    /**
     * Creates an SaveToCommand using raw values.
     */
    public SaveToCommand(String dirLocation) {
        this.saveToDir = dirLocation;
    }

    @Override
    public CommandResult execute() throws CommandException {
        String path = getPath();

        if (FileUtil.isWritable(path)) {
            model.updateSaveLocation(path);
            return new CommandResult(String.format(MESSAGE_SUCCESS, path),
                    String.format(MESSAGE_SUCCESS_STATUS_BAR, path));
        } else {
            throw new CommandException(String.format(MESSAGE_WRITE_FILE_ERROR, path));
        }
    }

    private String getPath() {
        File file = new File(saveToDir, TASK_MANAGER_FILE_NAME);

        try {
            return file.getCanonicalPath();
        } catch (IOException e) {
            return file.getAbsolutePath();
        }
    }

}
```
###### \java\seedu\address\logic\commands\UndoCommand.java
``` java
/*
 * Undo the last command by the user.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undo your last command.\n";
    public static final String MESSAGE_SUCCESS = "We have reversed your last command: %1$s";
    public static final String MESSAGE_NO_PREV_COMMAND = "No commands left to undo";
    public static final String MESSAGE_SUCCESS_STATUS_BAR = "We have reversed your last command: %1$s";

    @Override
    public CommandResult execute() throws CommandException {
        try {
            String prevCommand = model.undoLastCommand();
            return new CommandResult(String.format(MESSAGE_SUCCESS, prevCommand),
                    String.format(MESSAGE_SUCCESS_STATUS_BAR, prevCommand));
        } catch (NoPreviousCommandException e) {
            throw new CommandException(MESSAGE_NO_PREV_COMMAND);
        }
    }

}
```
###### \java\seedu\address\logic\commands\UseThisCommand.java
``` java
/*
 * Changes task manager save location to specified file path.
 */
public class UseThisCommand extends Command {

    public static final String COMMAND_WORD = "usethis";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Loads file from the specified file directory. \n"
            + "Parameters: dir_location\n" + "Example: " + COMMAND_WORD + "to .\\example_folder";
    public static final String MESSAGE_SUCCESS = "Read location has been changed to: %1$s";
    public static final String MESSAGE_SUCCESS_STATUS_BAR = "Read location changed to: %1$s";
    public static final String MESSAGE_FILE_MISSING_ERROR = "The directory does not contain the file: %1$s";

    public static final String TASK_MANAGER_FILE_NAME = "taskmanager.xml";

    private final String useThisDir;

    /**
     * Creates an UseThisCommand using raw values.
     */
    public UseThisCommand(String dirLocation) {
        useThisDir = dirLocation;
    }

    @Override
    public CommandResult execute() throws CommandException {
        String path = getPath();
        File file = new File(path);

        if (FileUtil.isFileExists(file)) {
            model.useNewSaveLocation(path);
            return new CommandResult(String.format(MESSAGE_SUCCESS, path),
                    String.format(MESSAGE_SUCCESS_STATUS_BAR, path));
        } else {
            throw new CommandException(String.format(MESSAGE_FILE_MISSING_ERROR, path));
        }
    }

    private String getPath() {
        File file = new File(useThisDir, TASK_MANAGER_FILE_NAME);

        try {
            return file.getCanonicalPath();
        } catch (IOException e) {
            return file.getAbsolutePath();
        }
    }
}
```
###### \java\seedu\address\logic\LogicManager.java
``` java
    private CommandResult executeCommand(String commandText, Command toExecute) throws CommandException {
        try {
            if (!(toExecute instanceof UndoCommand)) {

                if (toExecute instanceof RedoCommand) {
                    commandText = ((RedoCommand) toExecute).getToRedo();
                    toExecute = getCommand(commandText);
                } else {
                    model.clearRedoCommandHistory();
                }

                model.saveCurrentState(commandText.trim());

            }

            return toExecute.execute();
        } catch (CommandException e) {
            if (!(toExecute instanceof UndoCommand)) {
                model.discardCurrentState();
            }

            throw e;
        }
    }
```
###### \java\seedu\address\model\ModelManager.java
``` java
    /** Raises an event to indicate the model has changed */
    private void indicateTaskManagerChanged(String message) {
        logger.fine(message);
        raise(new TaskManagerChangedEvent(taskManager));
    }

    /** Raises an event to indicate the path needs to be changed */
    private void indicateTaskManagerPathChanged(String message, String path) {
        logger.fine(message);
        raise(new TaskManagerPathChangedEvent(taskManager, path));
    }

    /** Raises an event to indicate the path needs to be changed */
    private void indicateTaskManagerExport(String message, String path) {
        logger.fine(message);
        raise(new TaskManagerExportEvent(taskManager, path));
    }

    /**
     * Raises an event to indicate that the task manager should import data from
     * specified path
     */
    private void indicateTaskManagerImport(String message, String path) {
        logger.fine(message);
        raise(new TaskManagerImportEvent(path));
    }

    /**
     * Raises an event to indicate that the task manager should read from a
     * different path
     */
    private void indicateTaskManagerUseNewPath(String message, String path) {
        logger.fine(message);
        raise(new TaskManagerUseNewPathEvent(path));
    }
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public void updateSaveLocation(String path) {
        assert path != null;
        indicateTaskManagerPathChanged(MESSAGE_ON_SAVETO + path, path);
    }

    @Override
    public void exportToLocation(String path) {
        assert path != null;
        indicateTaskManagerExport(MESSAGE_ON_EXPORT + path, path);
    }

    @Override
    public void importFromLocation(String path) {
        assert path != null;
        indicateTaskManagerImport(MESSAGE_ON_IMPORT + path, path);
    }

    @Override
    public void useNewSaveLocation(String path) {
        assert path != null;
        indicateTaskManagerUseNewPath(MESSAGE_ON_USETHIS + path, path);
    }

    @Override
    public void saveCurrentState(String commandText) {
        TaskManager copiedTaskManager = new TaskManager(taskManager);
        taskHistory.add(copiedTaskManager);
        Predicate<? super ReadOnlyTask> predicate = filteredTasks.getPredicate();
        predicateHistory.add(predicate);
        commandHistory.add(commandText);
        completedViewHistory.add(completedViewOpen);
    }

    @Override
    public void discardCurrentState() {
        assert commandHistory.size() == taskHistory.size() && taskHistory.size() == predicateHistory.size()
                && predicateHistory.size() == completedViewHistory.size();
        if (!commandHistory.isEmpty()) {
            commandHistory.pop();
            taskHistory.pop();
            predicateHistory.pop();
            completedViewHistory.pop();
        }
    }

    @Override
    public String undoLastCommand() throws NoPreviousCommandException {
        assert commandHistory.size() == taskHistory.size() && taskHistory.size() == predicateHistory.size()
                && predicateHistory.size() == completedViewHistory.size();

        if (commandHistory.isEmpty()) {
            throw new NoPreviousCommandException("No previous commands were found.");
        }

        // Get previous command, taskManager and view
        String toUndo = commandHistory.pop();
        taskManager.setData(taskHistory.pop(), true);
        filteredTasks.setPredicate(predicateHistory.pop());

        // Set completed tasks view
        if (completedViewHistory.pop()) {
            showCompletedTaskList();
        } else {
            hideCompletedTaskList();
        }

        // Store command in case of redo
        redoCommandHistory.add(toUndo);

        if (toUndo.startsWith(SaveToCommand.COMMAND_WORD)) {
            indicateTaskManagerPathChanged(MESSAGE_ON_UNDO, null);
        } else if (toUndo.startsWith(UseThisCommand.COMMAND_WORD)) {
            indicateTaskManagerUseNewPath(MESSAGE_ON_UNDO, null);
        } else if (toUndo.startsWith(ExportCommand.COMMAND_WORD)) {
            indicateTaskManagerExport(MESSAGE_ON_UNDO, null);
        } else {
            indicateTaskManagerChanged(MESSAGE_ON_UNDO);
        }

        return toUndo;
    }

    @Override
    public String getRedoCommand() throws NoPreviousCommandException {

        if (redoCommandHistory.isEmpty()) {
            throw new NoPreviousCommandException("No previous commands were found.");
        }

        return redoCommandHistory.pop();
    }

    @Override
    public void clearRedoCommandHistory() {
        redoCommandHistory.clear();
    }

    @Override
    @Subscribe
    public void handleReadFromNewFileEvent(ReadFromNewFileEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "New file data loaded into model"));
        setData(event.data, true);
    }

    @Override
    @Subscribe
    public void handleImportEvent(ImportEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Add file data into model"));
        setData(event.data, false);
    }
```
###### \java\seedu\address\storage\StorageManager.java
``` java
    @Override
    @Subscribe
    public void handleTaskManagerPathChangedEvent(TaskManagerPathChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Local data path changed, saving to file"));

        String path = event.path;
        String oldPath = getTaskManagerFilePath();
        path = getFromBackupIfNull(path, oldPath);

        try {
            setTaskManagerFilePath(path);
            saveTaskManager(event.data);
            setAndSaveConfig(path);

            deleteExtraCopy(oldPath);

        } catch (IOException e) {
            raise(new DataSavingExceptionEvent(e));
        }
    }

    @Override
    @Subscribe
    public void handleTaskManagerExportEvent(TaskManagerExportEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Exporting data to file"));

        String path = event.path;
        path = getFromBackupIfNull(path, path);

        try {
            if (event.path != null) {
                saveTaskManager(event.data, path);
            } else {
                deleteExtraCopy(path);
            }

        } catch (IOException e) {
            raise(new DataSavingExceptionEvent(e));
        }
    }

    /**
     * If path is null, it sets it to the last seen value. Otherwise, it saves
     * currPath.
     *
     * @param path
     *            is set to last seen path if null
     * @param currPath
     *            is saved to history for future use
     * @return
     */
    private String getFromBackupIfNull(String path, String currPath) {
        if (path == null) {
            assert !taskManagerStorageHistory.isEmpty();
            path = taskManagerStorageHistory.pop();
        } else {
            taskManagerStorageHistory.add(currPath);
        }
        return path;
    }

    private void setAndSaveConfig(String path) throws IOException {
        config.setTaskManagerFilePath(path);
        config.save();
    }

    private void deleteExtraCopy(String path) throws IOException {
        if (!FileUtil.deleteFile(new File(path))) {
            throw new IOException("File at " + path + " cannot be deleted");
        }
    }

    @Override
    @Subscribe
    public void handleTaskManagerImportEvent(TaskManagerImportEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Importing from file"));
        indicateImportFile(event.path);
    }

    @Override
    @Subscribe
    public void handleTaskManagerUseNewPathEvent(TaskManagerUseNewPathEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Local data path changed, reading from file"));

        String path = event.path;
        String oldPath = getTaskManagerFilePath();
        path = getFromBackupIfNull(path, oldPath);

        try {
            setTaskManagerFilePath(path);
            setAndSaveConfig(path);
            indicateReadFromNewFile();
        } catch (IOException e) {
            raise(new DataSavingExceptionEvent(e));
        }
    }

    /**
     * Raises an event to indicate that a new data file is to be imported.
     */
    private void indicateImportFile(String path) {
        ReadOnlyTaskManager taskManager = getInitialData(path);
        raise(new ImportEvent(taskManager));
    }

    /**
     * Raises an event to indicate that a new data file has been read.
     */
    private void indicateReadFromNewFile() {
        ReadOnlyTaskManager taskManager = getInitialData(taskManagerStorage.getTaskManagerFilePath());
        raise(new ReadFromNewFileEvent(taskManager));
    }

```
###### \java\seedu\address\storage\XmlAdaptedTask.java
``` java
    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source
     *            future changes to this will not affect the created
     *            XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        name = source.getName().toString();
        done = source.isDone();
        manualToday = source.isManualToday();
        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }

        if (source.getStartingTime().isPresent()) {
            startingTime = Long.toString(source.getStartingTime().get().getDate().getTime());
        }
        if (source.getDeadline().isPresent()) {
            deadline = Long.toString(source.getDeadline().get().getDate().getTime());
        }
    }

```
