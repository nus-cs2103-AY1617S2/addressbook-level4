# A0143029M
###### /java/seedu/onetwodo/commons/events/ui/CloseDialogEvent.java
``` java
public class CloseDialogEvent extends BaseEvent {

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### /java/seedu/onetwodo/logic/commands/EditCommand.java
``` java
/**
 * Edits the details of an existing task in the todo task.
 */
public class EditCommand extends Command {

    public static final String COMMAND_WORD = "edit";
    public static final String SHORT_COMMAND_WORD = "e";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Edits the details of the task identified "
            + "by the index used in the last task listing. "
            + "Existing values will be overwritten by the input values.\n"
            + "Parameters: INDEX (must be a positive prefix integer) [NAME] "
            + "[s/START_DATE] [e/END_DATE] [r/RECUR] [p/PRIORITY] [d/DESCRIPTION ] [t/TAG]...\n"
            + "Example: " + COMMAND_WORD + " e1 s/tmr 9:00am d/beware of dogs";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited %1$s";
    public static final String MESSAGE_NOT_EDITED = "At least one field to edit must be provided.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the todo list.";
    public static final String MESSAGE_TYPE_ERROR = "Task is invalid.";

    private final int filteredTaskListIndex;
    private final EditTaskDescriptor editTaskDescriptor;
    private final TaskType taskType;

    /**
     * @param filteredTaskListIndex
     *            the index of the task in the filtered task list to edit
     * @param editTaskDescriptor
     *            details to edit the task with
     */
    public EditCommand(int filteredTaskListIndex, EditTaskDescriptor editTaskDescriptor, char taskType) {
        assert filteredTaskListIndex > 0;
        assert editTaskDescriptor != null;

        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex;
        this.editTaskDescriptor = new EditTaskDescriptor(editTaskDescriptor);
        this.taskType = TaskType.getTaskTypeFromChar(taskType);
    }

    @Override
    public CommandResult execute() throws CommandException {
        FilteredList<ReadOnlyTask> lastShownList = model.getFilteredByDoneFindType(taskType);
        if (lastShownList.size() < filteredTaskListIndex || taskType == null) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = lastShownList.get(filteredTaskListIndex - 1);
        Task editedTask = createEditedTask(taskToEdit, editTaskDescriptor);
        int internalIdx = model.getFilteredTaskList().indexOf(taskToEdit);

        // Throw CommandException if edited task is invalid
        TaskAttributesChecker.validateEditedAttributes(editedTask);
        try {
            model.updateTask(taskToEdit, internalIdx, editedTask);
            model.jumpToNewTask(editedTask);
        } catch (UniqueTaskList.DuplicateTaskException dpe) {
            reverseAdd(taskToEdit, internalIdx);
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        } catch (UniqueTaskList.TaskNotFoundException tne) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, editedTask));
    }

    private void reverseAdd(ReadOnlyTask taskToEdit, int internalIdx) throws CommandException {
        try {
            model.addTaskForEdit(internalIdx, (Task) taskToEdit);
        } catch (UniqueTaskList.DuplicateTaskException dpe2) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
    }

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     */
    private static Task createEditedTask(ReadOnlyTask taskToEdit, EditTaskDescriptor editTaskDescriptor) {
        assert taskToEdit != null;

        Name updatedName = editTaskDescriptor.getName().orElseGet(taskToEdit::getName);
        StartDate updatedStartDate = editTaskDescriptor.getStartDate().orElseGet(taskToEdit::getStartDate);
        EndDate updatedEndDate = editTaskDescriptor.getDate().orElseGet(taskToEdit::getEndDate);
        Recurring updatedRecur = editTaskDescriptor.getRecur().orElseGet(taskToEdit::getRecur);
        Priority updatedPriority = editTaskDescriptor.getPriority().orElseGet(taskToEdit::getPriority);
        Description updatedDescription = editTaskDescriptor.getDescription().orElseGet(taskToEdit::getDescription);
        UniqueTagList updatedTags = editTaskDescriptor.getTags().orElseGet(taskToEdit::getTags);

        Task edited = new Task(updatedName, updatedStartDate, updatedEndDate,
                updatedRecur, updatedPriority, updatedDescription, updatedTags);
        if (taskToEdit.getDoneStatus()) {
            edited.setDone();
        }
        return edited;
    }

    /**
     * Stores the details to edit the task with. Each non-empty field value will
     * replace the corresponding field value of the task.
     */
    public static class EditTaskDescriptor {
        private Optional<Name> name = Optional.empty();
        private Optional<StartDate> startDate = Optional.empty();
        private Optional<EndDate> endDate = Optional.empty();
        private Optional<Recurring> recur = Optional.empty();
        private Optional<Priority> priority = Optional.empty();
        private Optional<Description> description = Optional.empty();
        private Optional<UniqueTagList> tags = Optional.empty();

        public EditTaskDescriptor() {
        }

        public EditTaskDescriptor(EditTaskDescriptor toCopy) {
            this.name = toCopy.getName();
            this.startDate = toCopy.getStartDate();
            this.endDate = toCopy.getDate();
            this.recur = toCopy.getRecur();
            this.priority = toCopy.getPriority();
            this.description = toCopy.getDescription();
            this.tags = toCopy.getTags();
        }

        /**
         * Returns true if at least one field is edited.
         */
        public boolean isAnyFieldEdited() {
            return CollectionUtil.isAnyPresent(this.name, this.startDate, this.endDate, this.recur,
                    this.priority, this.description, this.tags);
        }

        public void setName(Optional<Name> name) {
            assert name != null;
            this.name = name;
        }

        public Optional<Name> getName() {
            return name;
        }

        public void setTime(Optional<StartDate> startDate) {
            assert startDate != null;
            this.startDate = startDate;
        }

        public Optional<StartDate> getStartDate() {
            return startDate;
        }

        public void setDate(Optional<EndDate> endDate) {
            assert endDate != null;
            this.endDate = endDate;
        }

        public Optional<EndDate> getDate() {
            return endDate;
        }

        public void setRecur(Optional<Recurring> recur) {
            assert recur != null;
            this.recur = recur;
        }

        public Optional<Recurring> getRecur() {
            return recur;
        }

        public void setPriority(Optional<Priority> priority) {
            assert priority != null;
            this.priority = priority;
        }

        public Optional<Priority> getPriority() {
            return priority;
        }

        public void setDescription(Optional<Description> description) {
            assert description != null;
            this.description = description;
        }

        public Optional<Description> getDescription() {
            return description;
        }

        public void setTags(Optional<UniqueTagList> tags) {
            assert tags != null;
            this.tags = tags;
        }

        public Optional<UniqueTagList> getTags() {
            return tags;
        }
    }
}
```
###### /java/seedu/onetwodo/logic/commands/ListCommand.java
``` java
/**
 * Lists all tasks in the todo list to the user.
 */
public class ListCommand extends Command {

    private static final String DATES_ARE_INVALID = "Dates are invalid";
    public static final String COMMAND_WORD = "list";
    public static final String COMMAND_LIST_DONE = COMMAND_WORD + " done";
    public static final String COMMAND_LIST_UNDONE = COMMAND_WORD + " undone";
    public static final String COMMAND_LIST_ALL = COMMAND_WORD + " all";
    public static final String SHORT_COMMAND_WORD = "ls";
    public static final String MESSAGE_LIST_DONE_SUCCESS = "Listed completed tasks";
    public static final String MESSAGE_LIST_UNDONE_SUCCESS = "Listed uncompleted tasks";
    public static final String MESSAGE_LIST_ALL_SUCCESS = "Listed all tasks";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": List tasks by done status"
            + "\nParameters: [DONE_STATUS] [DATE] [p/PRIORITY] [t/TAG]...\n";

    private DoneStatus doneStatus;
    private EndDate before;
    private StartDate after;
    private Priority priority;
    private Set<Tag> tagSet;
    private SortOrder sortOrder;
    private boolean isReversed = false;

    public ListCommand(String doneString, String beforeDate, String afterDate,
            String priorityString, Set<String> tags, String order, boolean isReversed) throws IllegalValueException {
        setDone(doneString);
        setSortOder(order, isReversed);
        setDates(beforeDate, afterDate);
        setPriority(priorityString);
        setTags(tags);
    }

    private void setTags(Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.tagSet = tagSet;
    }

    private void setPriority(String priorityString) throws IllegalValueException {
        priority = new Priority(priorityString);
    }

    private void setDates(String beforeDate, String afterDate) throws IllegalValueException {
        before = new EndDate(beforeDate);
        after = new StartDate(afterDate);
        if (before.hasDate() && after.hasDate() && before.getLocalDateTime().isBefore(after.getLocalDateTime())) {
            throw new IllegalValueException(DATES_ARE_INVALID);
        }
    }

    private void setSortOder(String order, boolean isReversed) throws IllegalValueException {
        sortOrder = SortOrder.getSortOrder(order);
        this.isReversed = isReversed;
    }

    private void setDone(String doneString) {
        assert doneString != null;
        switch (doneString) {
        case DoneStatus.DONE_STRING: // view done tasks
            doneStatus = DoneStatus.DONE;
            break;
        case DoneStatus.UNDONE_STRING:
            doneStatus = DoneStatus.UNDONE;
            break;
        case DoneStatus.ALL_STRING: // view all tasks
            doneStatus = DoneStatus.ALL;
            break;
        }
    }

    @Override
    public CommandResult execute() {
        String feecbackMessageToReturn;
        switch (doneStatus) {
        case ALL:
            model.setDoneStatus(DoneStatus.ALL);
            feecbackMessageToReturn = MESSAGE_LIST_ALL_SUCCESS;
            break;
        case DONE:
            model.setDoneStatus(DoneStatus.DONE);
            feecbackMessageToReturn = MESSAGE_LIST_DONE_SUCCESS;
            break;
        case UNDONE:
        default:
            model.setDoneStatus(DoneStatus.UNDONE);
            feecbackMessageToReturn = MESSAGE_LIST_UNDONE_SUCCESS;
        }
        if (sortOrder != SortOrder.NONE) {
            model.sortBy(sortOrder, isReversed);
        }
        model.resetSearchStrings();
        model.updateByDoneDatePriorityTags(before, after, priority, tagSet);
        return new CommandResult(feecbackMessageToReturn);
    }
}
```
###### /java/seedu/onetwodo/logic/LogicManager.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getFilteredTaskList() {
        return model.getFilteredTaskList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFilteredTasksByDoneStatus() {
        DoneStatus doneStatus = model.getDoneStatus();
        switch (doneStatus) {
        case ALL:
            model.updateFilteredListToShowAll();
            break;
        case DONE:
            model.updateFilteredDoneTaskList();
            break;
        case UNDONE:
            model.updateFilteredUndoneTaskList();
            break;
        }
        return model.getFilteredTaskList();
    }
}
```
###### /java/seedu/onetwodo/logic/parser/ListCommandParser.java
``` java
/**
 * Parses input arguments and creates a new ListCommand object
 */
public class ListCommandParser {

    private static final String TODAY = "today";
    private static final String TODAY_START = "0000h";
    private static final String TOMORROW = "tomorrow";

    /**
     * Parses the given {@code String} of arguments in the context of the ListCommand
     * and returns an ListCommand object for execution.
     */
    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(
                PREFIX_BEFORE, PREFIX_AFTER, PREFIX_PRIORITY, PREFIX_TAG, PREFIX_ORDER, PREFIX_REVERSE);
        argsTokenizer.tokenize(args);
        Optional<String> preamble = argsTokenizer.getPreamble();
        String beforeDate = argsTokenizer.getValue(PREFIX_BEFORE).orElse("");
        String afterDate = argsTokenizer.getValue(PREFIX_AFTER).orElse("");
        String priority = argsTokenizer.getValue(PREFIX_PRIORITY).orElse("");
        String order = argsTokenizer.getValue(PREFIX_ORDER).orElse("");
        boolean isReversed = argsTokenizer.getValue(PREFIX_REVERSE).isPresent();
        Set<String> tags = ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG));

        try {
            if (!preamble.isPresent()) {
                return new ListCommand(DoneStatus.UNDONE_STRING, beforeDate, afterDate,
                        priority, tags, order, isReversed);
            }
            switch (preamble.get().toLowerCase()) {
            case DoneStatus.DONE_STRING:
                return new ListCommand(DoneStatus.DONE_STRING, beforeDate, afterDate,
                        priority, tags, order, isReversed);
            case DoneStatus.ALL_STRING:
                return new ListCommand(DoneStatus.ALL_STRING, beforeDate, afterDate,
                        priority, tags, order, isReversed);
            case DoneStatus.UNDONE_STRING:
            case "":
                return new ListCommand(DoneStatus.UNDONE_STRING, beforeDate, afterDate,
                        priority, tags, order, isReversed);
            case TODAY:
                return new ListCommand(DoneStatus.UNDONE_STRING, TOMORROW, TODAY_START,
                        priority, tags, order, isReversed);
            default:
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
}
```
###### /java/seedu/onetwodo/model/ModelManager.java
``` java
    @Override
    /**
     * Filters task list according to the dates, priority and tags given.
     */
    public void updateByDoneDatePriorityTags(EndDate before, StartDate after, Priority priority, Set<Tag> tags) {
        boolean hasBefore = before.hasDate();
        boolean hasAfter = after.hasDate();
        PredicateExpression predicate = new PredicateExpression(task -> isTaskSameDoneStatus(task, doneStatus)
                && (hasBefore ? isTaskBefore(task, before) : true)
                && (hasAfter ? isTaskAfter(task, after) : true)
                && (priority.hasPriority() ? isPrioritySame(task, priority) : true)
                && (!tags.isEmpty() ? containsAnyTag(task, tags) : true));
        updateFilteredTaskList(predicate);
    }

    private boolean containsAnyTag(ReadOnlyTask task, Set<Tag> tags) {
        Set<Tag> tagsRemoved = task.getTags().toSet();
        tagsRemoved.removeAll(tags);
        return tagsRemoved.size() != task.getTags().toSet().size();
    }

```
###### /java/seedu/onetwodo/model/ModelManager.java
``` java
    private boolean isTaskSameDoneStatus(ReadOnlyTask task, DoneStatus doneStatus) {
        switch (doneStatus) {
        case DONE:
            return task.getDoneStatus() == true;
        case UNDONE:
            return task.getDoneStatus() == false;
        case ALL:
        default:
            return true;
        }
    }

    private boolean isTaskBefore(ReadOnlyTask task, EndDate endDate) {
        switch (task.getTaskType()) {
        case DEADLINE:
            return task.getEndDate().getLocalDateTime().isBefore(endDate.getLocalDateTime());
        case EVENT:
            return task.getStartDate().getLocalDateTime().isBefore(endDate.getLocalDateTime());
        case TODO:
        default:
            return true;
        }
    }

    private boolean isTaskAfter(ReadOnlyTask task, StartDate startDate) {
        switch (task.getTaskType()) {
        case DEADLINE:
        case EVENT:
            return task.getEndDate().getLocalDateTime().isAfter(startDate.getLocalDateTime());
        case TODO:
        default:
            return true;
        }
    }

    @Override
    public void updateByDoneStatus() {
        switch (doneStatus) {
        case DONE:
            updateFilteredDoneTaskList();
            break;
        case UNDONE:
            updateFilteredUndoneTaskList();
            break;
        case ALL:
            updateFilteredListToShowAll();
            break;
        }
    };

    @Override
    public void updateBySearchStrings() {
        if (searchStrings.size() > 0) {
            updateByNameDescriptionTag(searchStrings);
        }
    }

    @Override
    public FilteredList<ReadOnlyTask> getFilteredByDoneFindType(TaskType type) {
        updateBySearchStrings();

        FilteredList<ReadOnlyTask> filtered = getFilteredTaskList().filtered(t -> t.getTaskType() == type);

        switch (doneStatus) {
        case DONE:
            return filtered.filtered(t -> t.getDoneStatus() == true);
        case UNDONE:
            return filtered.filtered(t -> t.getDoneStatus() == false);
        case ALL:
        default:
            return filtered;
        }
    }

    @Override
    public int getTaskIndex(ReadOnlyTask task) {
        FilteredList<ReadOnlyTask> filtered = getFilteredByDoneFindType(task.getTaskType());
        return filtered.indexOf(task);
    }

    /**
     * Scroll to task provided.
     * @param task to jump to
     */
    @Override
    public void jumpToNewTask(ReadOnlyTask task) {
        int filteredIndex = getTaskIndex(task);
        TimerTask postJumpToEvent = new TimerTask() {
            @Override
            public void run() {
                EventsCenter.getInstance().post(new JumpToListRequestEvent(filteredIndex, task.getTaskType()));
            }
        };
        new Timer().schedule(postJumpToEvent, AUTOSCROLL_LAG);
    }

```
###### /java/seedu/onetwodo/model/task/UniqueTaskList.java
``` java
    /**
     * Sorts the internalList according to the given sort order.
     */
    public void sortTasks(SortOrder sortOrder, boolean isReversed) {
        switch (sortOrder) {
        case ALPHANUMERIC:
            if (!isReversed) {
                FXCollections.sort(internalList, (Task t1, Task t2) -> t1.getName().compareTo(t2.getName()));
            } else {
                FXCollections.sort(internalList, (Task t1, Task t2) -> t2.getName().compareTo(t1.getName()));
            }
            break;
        case PRIORITY:
            if (!isReversed) {
                FXCollections.sort(internalList, (Task t1, Task t2) -> t1.getPriority().compareTo(t2.getPriority()));
            } else {
                FXCollections.sort(internalList, (Task t1, Task t2) -> t2.getPriority().compareTo(t1.getPriority()));
            }
            break;
        case DATETIME:
            if (!isReversed) {
                FXCollections.sort(internalList, (Task t1, Task t2) -> t1.compareTo(t2));
            } else {
                FXCollections.sort(internalList, (Task t1, Task t2) -> t2.compareTo(t1));
            }
            break;
        default:
        }
    }

    public void setTasks(UniqueTaskList replacement) {
        this.internalList.setAll(replacement.internalList);
    }

    public void setTasks(List<? extends ReadOnlyTask> tasks) throws DuplicateTaskException {
        final UniqueTaskList replacement = new UniqueTaskList();
        for (final ReadOnlyTask task : tasks) {
            replacement.add(new Task(task));
        }
        setTasks(replacement);
    }

    public UnmodifiableObservableList<Task> asObservableList() {
        return new UnmodifiableObservableList<>(internalList);
    }

    @Override
    public Iterator<Task> iterator() {
        return internalList.iterator();
    }

    public boolean isEmpty() {
        return internalList.isEmpty();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueTaskList // instanceof handles nulls
                        && this.internalList.equals(((UniqueTaskList) other).internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }

    /**
     * Signals that an operation would have violated the 'no duplicates'
     * property of the list.
     */
    public static class DuplicateTaskException extends DuplicateDataException {
        protected DuplicateTaskException() {
            super("Operation would result in duplicate tasks");
        }
    }

    /**
     * Signals that an operation targeting a specified task in the list would
     * fail because there is no such matching task in the list.
     */
    public static class TaskNotFoundException extends Exception {
    }

}
```
###### /java/seedu/onetwodo/ui/CommandBox.java
``` java
    public void handleCommands(String command) {
        try {
            CommandResult commandResult = logic.execute(command);
            setKeyListenerForMutators(command);
            setErrorStyleForCommandResult(false);
            commandTextField.setText("");
            logger.info("Result: " + commandResult.feedbackToUser);
            raise(new NewResultAvailableEvent(commandResult.feedbackToUser));
        } catch (CommandException e) {
            setErrorStyleForCommandResult(true);
            logger.info("Invalid command: " + commandTextField.getText());
            raise(new NewResultAvailableEvent(e.getMessage()));
        }
    }

    /**
     * Sets the command box error pseudo-style based on command result.
     */
    private void setErrorStyleForCommandResult(boolean isError) {
        commandTextField.pseudoClassStateChanged(ERROR_PSEUDOCLASS, isError);
    }

    public void focus() {
        commandTextField.requestFocus();
    }

    public void undoTextField() {
        commandTextField.undo();
    }

    public void setKeyListener(EventHandler<KeyEvent> ke) {
        commandTextField.setOnKeyPressed(ke);
    }

    public void setKeyListenerReleased(EventHandler<KeyEvent> ke) {
        commandTextField.setOnKeyReleased(ke);
    }

    private void setKeyListenerForMutators(String command) {
        switch (command) {
        case AddCommand.COMMAND_WORD:
        case EditCommand.COMMAND_WORD:
            commandTextField.setOnKeyPressed((KeyEvent ke) -> {
                raise(new DeselectCardsEvent());
                resetKeyListener();
            });
            break;
        default:
            break;
        }
    }

    public void resetKeyListener() {
        commandTextField.setOnKeyPressed(null);
        commandTextField.setOnKeyPressed(new EventHandler<KeyEvent>() {
            @Override
            public void handle(KeyEvent ke) {
                setErrorStyleForCommandResult(false);
                resetIfUpDownKey(ke);
            }
        });
        commandTextField.setOnKeyReleased(null);
        commandTextField.setOnKeyReleased(scrollHandler);
    }

    private void resetIfUpDownKey(KeyEvent ke) {
        if (ke.isShiftDown()) {
            return;
        }
        KeyCode keyCode = ke.getCode();
        switch (keyCode) {
        case UP:
            undoTextArea();
            break;
        case DOWN:
            redoTextArea();
            break;
        default: break;
        }
    }

    private void undoTextArea() {
        if (previousCommands.isEmpty()) {
            return;
        }
        String previousCommand = previousCommands.pop();
        refilledCommands.push(previousCommand);
        if (refilledCommands.isEmpty()) {
            commandTextField.setText("");
        } else {
            commandTextField.setText(refilledCommands.peek());
        }
    }

    private void redoTextArea() {
        if (refilledCommands.isEmpty()) {
            return;
        }
        String previousRefilledCommand = refilledCommands.pop();
        previousCommands.push(previousRefilledCommand);
        if (refilledCommands.isEmpty()) {
            commandTextField.setText("");
        } else {
            commandTextField.setText(refilledCommands.peek());
        }
    }

    public void setScrollKeyListener(EventHandler<KeyEvent> scrollHandler) {
        this.scrollHandler = scrollHandler;
        commandTextField.setOnKeyReleased(scrollHandler);
    }

}
```
###### /java/seedu/onetwodo/ui/MainWindow.java
``` java
    public TaskListPanel getDeadlineTaskListPanel() {
        return this.deadlineTaskListPanel;
    }

    public TaskListPanel getEventTaskListPanel() {
        return this.eventTaskListPanel;
    }

    public TaskListPanel getTodoTaskListPanel() {
        return this.todoTaskListPanel;
    }

    public TaskListPanel getTaskListPanel(TaskType type) {
        switch (type) {
        case DEADLINE:
            return getDeadlineTaskListPanel();
        case EVENT:
            return getEventTaskListPanel();
        case TODO:
        default:
            return getTodoTaskListPanel();
        }
    }

    public void openDialog(ReadOnlyTask task) {
        JFXDialogLayout content = new JFXDialogLayout();
        Text nameText = new Text(task.getName().fullName);
        Text descriptionText = new Text(task.getDescription().value);
        nameText.setWrappingWidth(MIN_WIDTH);
        descriptionText.setWrappingWidth(MIN_WIDTH);
        content.setHeading(nameText);
        content.setBody(descriptionText);
        closeDialog();
        dialog = new JFXDialog(dialogStackPane, content, JFXDialog.DialogTransition.CENTER, true);
        dialog.show();
        closeDialogOnNextKeyPress();
    }

    void closeDialog() {
        if (dialog == null) {
            return;
        }
        dialog.close();
        dialog = null;
        commandBox.focus();
    }

    private void closeDialogOnNextKeyPress() {
        commandBox.setKeyListener((KeyEvent ke) -> {
            KeyCode code = ke.getCode();
            if (code == KeyCode.UP || code == KeyCode.DOWN) {
                return;
            }
            ke.consume();
            closeDialog();
            commandBox.resetKeyListener();
            commandBox.focus();
        });
    }

    /**
     * Handle scrolling KeyEvents for browser WebView and TaskListPanels
     */
    private void setScrollOnUpDown() {
        commandBox.setScrollKeyListener((KeyEvent ke) -> {
            KeyCode code = ke.getCode();
            if (!(code == KeyCode.UP || code == KeyCode.DOWN)) {
                return;
            }
            if (dialog == null && ke.isShiftDown()) {
                int maxDeadlineIndex = deadlineTaskListPanel.getNumberOfItems() - 1;
                int maxEventIndex = eventTaskListPanel.getNumberOfItems() - 1;
                int maxTodoIndex = todoTaskListPanel.getNumberOfItems() - 1;
                deadlineScrollIndex = getScrollIndex(ke.getCode(), maxDeadlineIndex, deadlineScrollIndex, SCROLL_AMT);
                eventScrollIndex = getScrollIndex(ke.getCode(), maxEventIndex, eventScrollIndex, SCROLL_AMT);
                todoScrollIndex = getScrollIndex(ke.getCode(), maxTodoIndex, todoScrollIndex, SCROLL_AMT);
                deadlineTaskListPanel.viewScrollTo(deadlineScrollIndex);
                eventTaskListPanel.viewScrollTo(eventScrollIndex);
                todoTaskListPanel.viewScrollTo(todoScrollIndex);
            } else {
                scrollBrowser(ke);
            }
        });
    }

    private void scrollBrowser(KeyEvent ke) {
        if (browser == null) {
            return;
        }
        switch (ke.getCode()) {
        case UP:
            browser.fireEvent(new KeyEvent(KeyEvent.KEY_PRESSED, "", "",
                    KeyCode.UP, true, true, true, true));
            break;
        case DOWN:
            browser.fireEvent(new KeyEvent(KeyEvent.KEY_PRESSED, "", "",
                    KeyCode.DOWN, true, true, true, true));
            break;
        default:
            break;
        }
        browser.fireEvent(new KeyEvent(KeyEvent.KEY_PRESSED, "", "",
                KeyCode.ESCAPE, true, true, true, true));
        browser.requestFocus();
    }

    private int getScrollIndex(KeyCode code, int maxIndex, int originalIndex, int scrollAmount) {
        int index = originalIndex;
        if (code == KeyCode.UP) {
            index -= scrollAmount;
        } else if (code == KeyCode.DOWN) {
            index += scrollAmount;
        }
        index = index < 0 ? 0 : index > maxIndex ? maxIndex : index;
        return index;
    }

    /**
     * Displays HTML file in JFXDialogLayout
     */
    private void showHTML(String urlString) {
        JFXDialogLayout content = new JFXDialogLayout();
        browser = new WebView();
        URL help = MainApp.class.getResource(urlString);
        browser.getEngine().load(help.toString());
        hideScrollBar(browser);
        FxViewUtil.applyAnchorBoundaryParameters(browser, 0.0, 0.0, 0.0, 0.0);
        content.setBody(browser);
        closeDialog();
        if (urlString.equals(HELPWINDOW_URL)) {
            EventsCenter.getInstance().post(new NewResultAvailableEvent(HelpCommand.SHOWING_HELP_MESSAGE));
        } else if (urlString.equals(USERGUIDE_URL)) {
            EventsCenter.getInstance().post(new NewResultAvailableEvent(HelpCommand.SHOWING_HELP_MESSAGE_USERGUIDE));
        }
        dialog = new JFXDialog(dialogStackPane, content, JFXDialog.DialogTransition.CENTER, true);
        dialog.show();
        setBrowserCloseListener();
    }

    private void setBrowserCloseListener() {
        closeDialogOnNextKeyPress();
        browser.setOnKeyReleased((KeyEvent ke) -> {
            KeyCode code = ke.getCode();
            if (code == KeyCode.UP || code == KeyCode.DOWN) {
                return;
            }
            ke.consume();
            closeDialog();
            commandBox.resetKeyListener();
            commandBox.focus();
        });
    }

    private void hideScrollBar(WebView browser) {
        browser.getChildrenUnmodifiable().addListener((ListChangeListener<Node>) c -> browser
                .lookupAll(".scroll-bar")
                .forEach((node) -> node.setVisible(false)));
    }

}
```
###### /java/seedu/onetwodo/ui/TaskCard.java
``` java
    public TaskCard(ReadOnlyTask task, int displayedIndex, char indexPrefix) {
        super(FXML);
        prefixId = Character.toString(indexPrefix) + displayedIndex;
        registerCard();
        name.setText(task.getName().fullName);
        id.setText(prefixId);
        setPriority(task);
        setDate(task);
        setRecur(task);
        setDescription(task);
        initTags(task);
        if (task.getDoneStatus()) {
            PseudoClass donePseudoClass = PseudoClass.getPseudoClass(DONE_PSEUDO_CLASS);
            name.pseudoClassStateChanged(donePseudoClass, true);
            cardPane.pseudoClassStateChanged(donePseudoClass, true);
        }
    }

    private void registerCard() {
        EventsCenter.getInstance().registerHandler(this);
    }

    private void setPriority(ReadOnlyTask task) {
        String priorityText = task.getPriority().value;
        priority.setText(priorityText);
        switch (priorityText) {
        case Priority.HIGH_LABEL:
            PseudoClass donePseudoClass = PseudoClass.getPseudoClass(Priority.HIGH_LABEL);
            priority.pseudoClassStateChanged(donePseudoClass, true);
            break;
        case Priority.MEDIUM_LABEL:
            PseudoClass mediumPseudoClass = PseudoClass.getPseudoClass(Priority.MEDIUM_LABEL);
            priority.pseudoClassStateChanged(mediumPseudoClass, true);
            break;
        case Priority.LOW_LABEL:
            PseudoClass lowPseudoClass = PseudoClass.getPseudoClass(Priority.LOW_LABEL);
            priority.pseudoClassStateChanged(lowPseudoClass, true);
            break;
        }
    }

    private void setDate(ReadOnlyTask task) {
        switch (task.getTaskType()) {
        case DEADLINE:
            LocalDateTime deadlineDateTime = task.getEndDate().getLocalDateTime();
            endDate.setText(DEADLINE_PREFIX + deadlineDateTime.format(OUTFORMATTER));
            highlightIfOverdue(task, endDate);
            break;
        case EVENT:
            LocalDateTime eventStartDateTime = task.getStartDate().getLocalDateTime();
            LocalDateTime eventEndDateTime = task.getEndDate().getLocalDateTime();
            startDate.setText(eventStartDateTime.format(OUTFORMATTER) + DATE_SPACING);
            endDate.setText(eventEndDateTime.format(OUTFORMATTER));
            highlightIfOverdue(task, startDate, endDate);
            break;
        case TODO:
            dateBox.getChildren().clear();
            break;
        }
    }

    private void highlightIfOverdue(ReadOnlyTask task, Label... labels) {
        if (!task.isOverdue()) {
            return;
        }
        for (Label label : labels) {
            PseudoClass overduePseudoClass = PseudoClass.getPseudoClass(OVERDUE_PSEUDO_CLASS);
            label.pseudoClassStateChanged(overduePseudoClass, true);
        }
    }

    private void setDescription(ReadOnlyTask task) {
        String descriptionText = task.getDescription().value;
        if (descriptionText.length() > 0) {
            description.setText(descriptionText);
        } else {
            description.setText("");
            descriptionBox.setMaxHeight(0);
            description.setMaxHeight(0);
        }
    }

    private void setRecur(ReadOnlyTask task) {
        String recurText = task.getRecur().value;
        recur.setText(recurText);
    }

    private void initTags(ReadOnlyTask task) {
        task.getTags().forEach(tag -> tags.getChildren().add(new Label(tag.tagName)));
    }

    @Subscribe
    private void handleSelectTaskEvent(SelectCardEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        String prefix = event.taskType.toString();
        String cardPrefixId = prefix + (event.targetIndex + 1);
        if (prefixId.equals(cardPrefixId)) {
            PseudoClass selectedPseudoClass = PseudoClass.getPseudoClass(SELECTED_PSEUDO_CLASS);
            cardPane.pseudoClassStateChanged(selectedPseudoClass, true);
        }
    }

    @Subscribe
    private void handleDeselectCard(DeselectCardsEvent event) {
        PseudoClass selectedPseudoClass = PseudoClass.getPseudoClass(SELECTED_PSEUDO_CLASS);
        cardPane.pseudoClassStateChanged(selectedPseudoClass, false);
    }
}
```
###### /java/seedu/onetwodo/ui/TaskListPanel.java
``` java
/**
 * Panel containing the list of tasks.
 */
public class TaskListPanel extends UiPart<Region> {
    private final Logger logger = LogsCenter.getLogger(TaskListPanel.class);
    private static final String FXML = "TaskListPanel.fxml";
    private TaskType taskType;

    // For tests robot.lookup(#{ID})
    public static final String DEADLINE_PANEL_ID = "deadline-panel";
    public static final String EVENT_PANEL_ID = "event-panel";
    public static final String TODO_PANEL_ID = "todo-panel";

    @FXML
    private ListView<ReadOnlyTask> taskListView;

    public TaskListPanel(AnchorPane taskListPlaceholder, ObservableList<ReadOnlyTask> taskList, TaskType taskType) {
        super(FXML);
        this.taskType = taskType;
        setId(taskType);
        setConnections(taskList);
        addToPlaceholder(taskListPlaceholder);
    }

    private void setId(TaskType taskType) {
        switch (taskType) {
        case DEADLINE:
            taskListView.setId(DEADLINE_PANEL_ID);
            break;
        case EVENT:
            taskListView.setId(EVENT_PANEL_ID);
            break;
        case TODO:
            taskListView.setId(TODO_PANEL_ID);
            break;
        }
    }

    public int getNumberOfItems() {
        return taskListView.getItems().size();
    }

    private void setConnections(ObservableList<ReadOnlyTask> taskList) {
        taskListView.setItems(getFilteredTasks(taskList));
        taskListView.setCellFactory(listView -> new TaskListViewCell());
        setEventHandlerForSelectionChangeEvent();
    }

    private FilteredList<ReadOnlyTask> getFilteredTasks(ObservableList<ReadOnlyTask> taskList) {
        return new FilteredList<ReadOnlyTask>(taskList, t -> t.getTaskType() == taskType);
    }

    private void addToPlaceholder(AnchorPane placeHolderPane) {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        FxViewUtil.applyAnchorBoundaryParameters(getRoot(), 0.0, 0.0, 0.0, 0.0);
        placeHolderPane.getChildren().add(getRoot());
    }

    private void setEventHandlerForSelectionChangeEvent() {
        taskListView.setOnMouseClicked((MouseEvent click) -> {
            ReadOnlyTask selectedValue = taskListView.getSelectionModel().getSelectedItem();
            if (selectedValue != null) {
                logger.fine("Selection in task list panel changed to : '" + selectedValue + "'");
                raise(new TaskPanelSelectionChangedEvent(selectedValue));
            }
        });
    }

    public void scrollToAndHighlight(int index) {
        Platform.runLater(() -> {
            taskListView.scrollTo(index);
            taskListView.getSelectionModel().clearAndSelect(index);
        });
        highlightTaskCard(index);
    }

    private void highlightTaskCard(int index) {
        TimerTask highlightTask = new TimerTask() {
            @Override
            public void run() {
                EventsCenter.getInstance().post(new SelectCardEvent(index, taskType));
            }
        };
        new Timer().schedule(highlightTask, AUTOSCROLL_LAG);
    }

    public void viewScrollTo(int index) {
        Platform.runLater(() -> {
            taskListView.scrollTo(index);
        });
    }

    class TaskListViewCell extends ListCell<ReadOnlyTask> {
        @Override
        protected void updateItem(ReadOnlyTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(new TaskCard(task, getIndex() + 1, taskType.getPrefix()).getRoot());
            }
        }
    }

}
```
###### /java/seedu/onetwodo/ui/UiManager.java
``` java
    @Subscribe
    private void handleJumpToListRequestEvent(JumpToListRequestEvent event) {
        // Scroll when testing
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        switch (event.taskType) {
        case DEADLINE:
            mainWindow.getDeadlineTaskListPanel().scrollToAndHighlight(event.targetIndex);
            break;
        case EVENT:
            mainWindow.getEventTaskListPanel().scrollToAndHighlight(event.targetIndex);
            break;
        case TODO:
            mainWindow.getTodoTaskListPanel().scrollToAndHighlight(event.targetIndex);
            break;
        }
    }

    @Subscribe
    private void handleTaskPanelSelectionChangedEvent(TaskPanelSelectionChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.openDialog(event.getNewSelection());
    }

}
```
###### /resources/view/MainWindow.fxml
``` fxml

<VBox minHeight="600.0" minWidth="800.0" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <MenuBar VBox.vgrow="NEVER">
         <menus>
            <Menu mnemonicParsing="false" text="File">
               <items>
                  <MenuItem fx:id="exitMenuItem" mnemonicParsing="false" onAction="#handleExit" text="Exit" />
               </items>
            </Menu>
            <Menu fx:id="editMenu" mnemonicParsing="false" text="Edit">
              <items>
                <MenuItem fx:id="undoMenuItem" mnemonicParsing="false" onAction="#handleUndo" text="Undo" />
                  <MenuItem fx:id="redoMenuItem" mnemonicParsing="false" onAction="#handleRedo" text="Redo" />
              </items>
            </Menu>
            <Menu mnemonicParsing="false" text="List">
              <items>
                <MenuItem fx:id="listDoneMenuItem" mnemonicParsing="false" onAction="#handleListDone" text="Done" />
                  <MenuItem fx:id="listUndoneMenuItem" mnemonicParsing="false" onAction="#handleListUndone" text="Undone" />
                  <MenuItem fx:id="listAllMenuItem" mnemonicParsing="false" onAction="#handleListAll" text="All" />
              </items>
            </Menu>
            <Menu mnemonicParsing="false" text="Help">
               <items>
                  <MenuItem fx:id="helpMenuItem" mnemonicParsing="false" onAction="#handleHelp" text="Show Command Help" />
                  <MenuItem fx:id="helpUGMenuItem" mnemonicParsing="false" onAction="#handleHelpUG" text="Show User Guide" />
               </items>
            </Menu>
         </menus>
      </MenuBar>
      <StackPane fx:id="dialogStackPane" VBox.vgrow="ALWAYS">
         <children>
            <SplitPane id="splitPane" fx:id="splitPane" dividerPositions="0.5, 0.5">
               <items>
                  <VBox fx:id="DeadlineList" alignment="CENTER" minWidth="340.0" prefWidth="340" styleClass="panel-shadow" stylesheets="@PanelTheme.css">
                      <padding>
                          <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
                      </padding>
                     <children>
                        <HBox minHeight="64.0" prefHeight="64.0" prefWidth="320.0" styleClass="header-deadlines" stylesheets="@PanelTheme.css">
                           <children>
                              <ImageView fitHeight="21.0" fitWidth="21.0" pickOnBounds="true">
                                 <viewport>
                                    <Rectangle2D />
                                 </viewport>
                                 <HBox.margin>
                                    <Insets left="30.0" top="21.0" />
                                 </HBox.margin>
                                 <image>
                                    <Image url="@../images/alarm.png" />
                                 </image>
                              </ImageView>
                              <Label alignment="CENTER" contentDisplay="CENTER" prefHeight="64.0" prefWidth="1000.0" styleClass="header-font" stylesheets="@PanelTheme.css" text="Deadlines" textAlignment="CENTER">
                                 <HBox.margin>
                                    <Insets right="30.0" />
                                 </HBox.margin>
                              </Label>
                           </children>
                        </HBox>
                        <AnchorPane fx:id="deadlineListPanelPlaceholder" styleClass="list-view" VBox.vgrow="ALWAYS" />
                     </children>
                  </VBox>
                  <VBox fx:id="EventList" alignment="CENTER" minWidth="340" prefWidth="340" styleClass="panel-shadow" stylesheets="@PanelTheme.css">
                     <padding>
                        <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
                     </padding>
                     <children>
                        <HBox minHeight="64.0" prefHeight="64.0" prefWidth="320.0" styleClass="header-events" stylesheets="@PanelTheme.css">
                           <children>
                              <ImageView fitHeight="21.0" fitWidth="21.0" pickOnBounds="true">
                                 <viewport>
                                    <Rectangle2D />
                                 </viewport>
                                 <image>
                                    <Image url="@../images/events-calendar.png" />
                                 </image>
                                 <HBox.margin>
                                    <Insets left="30.0" top="21.0" />
                                 </HBox.margin>
                              </ImageView>
                              <Label alignment="CENTER" contentDisplay="CENTER" prefHeight="64.0" prefWidth="1000.0" styleClass="header-font" stylesheets="@PanelTheme.css" text="Events" textAlignment="CENTER">
                                 <HBox.margin>
                                    <Insets right="30.0" />
                                 </HBox.margin>
                              </Label>
                           </children>
                        </HBox>
                        <AnchorPane fx:id="eventListPanelPlaceholder" VBox.vgrow="ALWAYS" />
                     </children>
                  </VBox>
                  <VBox fx:id="TodoList" alignment="CENTER" minWidth="340" prefWidth="340" styleClass="panel-shadow" stylesheets="@PanelTheme.css">
                     <padding>
                        <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
                     </padding>
                     <children>
                        <HBox minHeight="64.0" prefHeight="64.0" prefWidth="320.0" stylesheets="@PanelTheme.css">
                           <children>
                              <ImageView fitHeight="21.0" fitWidth="21.0" pickOnBounds="true">
                                 <viewport>
                                    <Rectangle2D />
                                 </viewport>
                                 <image>
                                    <Image url="@../images/no-alarm.png" />
                                 </image>
                                 <HBox.margin>
                                    <Insets left="30.0" top="21.0" />
                                 </HBox.margin>
                              </ImageView>
                              <Label alignment="CENTER" contentDisplay="CENTER" prefHeight="64.0" prefWidth="1000.0" styleClass="header-font" stylesheets="@PanelTheme.css" text="To do" textAlignment="CENTER">
                                 <HBox.margin>
                                    <Insets right="30.0" />
                                 </HBox.margin>
                              </Label>
                           </children>
                           <styleClass>
                              <String fx:value="header-task-panel" />
                              <String fx:value="header-todo" />
                           </styleClass>
                        </HBox>
                        <AnchorPane fx:id="todoListPanelPlaceholder" VBox.vgrow="ALWAYS" />
                     </children>
                  </VBox>
               </items>
            </SplitPane>
         </children>
      </StackPane>
       <AnchorPane fx:id="resultDisplayPlaceholder" maxHeight="100" minHeight="100" prefHeight="100" styleClass="anchor-pane-with-border" VBox.vgrow="NEVER">
           <padding>
               <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
           </padding>
       </AnchorPane>
      <AnchorPane fx:id="commandBoxPlaceholder" styleClass="commandbox" VBox.vgrow="NEVER">
         <padding>
            <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
         </padding>
      </AnchorPane>
      <AnchorPane fx:id="statusbarPlaceholder" VBox.vgrow="NEVER" />
   </children>
   <stylesheets>
      <URL value="@DarkTheme.css" />
      <URL value="@Extensions.css" />
   </stylesheets>
</VBox>
```
###### /resources/view/PanelTheme.css
``` css
@font-face {
    font-family: 'Avenir Light';
    src: url('/fonts/avenir-light.ttf');
}

.header-font {
    -fx-text-fill: #FFFFFF;
    -fx-font-family: "Avenir Light";
    -fx-font-size: 18;
}

.header-deadlines {
    -fx-background-color: #E55A5A;
}

.header-events {
    -fx-background-color: #4AB6AC;
}

.header-todo {
    -fx-background-color: #6BA0DD;
}

.panel-shadow {
    -fx-effect: dropshadow(three-pass-box, rgba(0,0,0,0.3), 10, 0, 0, 0);
}

.tasklist {
	-fx-background-color: #FFFFFF;
	-fx-border-width: 3;
	-fx-border-color: #FFFFFF;
}

.list-cell {
	-fx-background-color: #FFFFFF;
    -fx-label-padding: 0 0 0 0;
    -fx-graphic-text-gap : 0;
    -fx-padding: 0 0 0 0;
}

.list-cell .label {
    -fx-text-fill: #010504;
}

.date-box {
    -fx-opacity: 0.66;
}

.grid-pane {
    -fx-background-color: transparent;
}

.grid-pane .anchor-pane {
    -fx-border-color: transparent;
    -fx-border-width: 0;
}

.chip {
    -fx-background-color: darkgrey;
    -fx-background-radius: 40;
    -fx-text-fill: white;
    -fx-background-position: center center;
}

```
###### /resources/view/Strikethrough.css
``` css
#cardPane:done {
	-fx-background-color: lightgray;
}

.label:done .text {
	-fx-strikethrough: true;
	-fx-opacity: 0.5;
}

.label:done .text {
	-fx-background-color: lightgray;
	-fx-text-fill: white;
}

.label:overdue {
	-fx-text-fill: maroon !important;
}

.label-priority {
	-fx-font-weight: bold;
	-fx-text-fill: darkgray;
}

.label-priority:HIGH {
	-fx-background-color: #FF4C25 !important;
	-fx-padding: 3px;
	-fx-background-radius: 3px;
}

.label-priority:MEDIUM {
	-fx-background-color: #FA8215 !important;
	-fx-padding: 3px;
	-fx-background-radius: 3px;
}

.label-priority:LOW {
	-fx-background-color: #9DFA00 !important;
	-fx-padding: 3px;
	-fx-background-radius: 3px;
}
```
