# A0147980U
###### \java\seedu\doist\commons\util\History.java
``` java
    /**
     * Method that returns the next state entered by the user, if it exists
     * Returns null if overflow is empty
     */
    public S getNextState() {
        try {
            history.push(overflow.pop());
            return overflow.peek();
        } catch (EmptyStackException e) {
            return null;
        }
    }

    /**
     * Move the current state and everything in the overflow stack
     * back into history stack
     */
    public void restore() {
        while (!overflow.isEmpty()) {
            history.push(overflow.pop());
        }
    }

    /**
     * forget all the states in the overflow except the peek
     */
    public void forgetStatesAfter() {
        if (!overflow.isEmpty()) {
            history.push(overflow.pop());
        }
        overflow.clear();
    }

    public boolean isAtMostRecentState() {
        return overflow.isEmpty();
    }
}


```
###### \java\seedu\doist\logic\commands\AddCommand.java
``` java
/**
 * Adds a task to the to-do list.
 */
public class AddCommand extends Command {
```
###### \java\seedu\doist\logic\commands\AliasCommand.java
``` java
/**
 * Adds an alias for an existing command
 */
public class AliasCommand extends Command {
    public static final String DEFAULT_COMMAND_WORD = "alias";

    public static final String MESSAGE_USAGE = DEFAULT_COMMAND_WORD + ": Adds an alias for a command\n"
            + "Parameters: ALIAS  [\\for DEFAULT_COMMAND_WORD]\n"
            + "Example: " + DEFAULT_COMMAND_WORD + " list_tasks \\for list";

    public static final String MESSAGE_SUCCESS = "New alias \"%1$s\" added to command \"%2$s\"";
    public static final String MESSAGE_COMMAND_WORD_NOT_EXIST = "This command word \"%1$s\" does not exist";
    public static final String MESSAGE_ALIAS_IS_DEFAULT_COMMAND_WORD = "The input alias \"%1$s\" " +
                                                                       "is already a default command word";

    private final String defaultCommandWord;
    private final String alias;

    public AliasCommand(String alias, String defaultCommandWord) {
        this.defaultCommandWord = defaultCommandWord;
        this.alias = alias;
    }

    @Override
    public CommandResult execute() throws CommandException {
        if (!aliasModel.getDefaultCommandWordSet().contains(defaultCommandWord)) {
            throw new CommandException(String.format(MESSAGE_COMMAND_WORD_NOT_EXIST, defaultCommandWord));
        } else if (aliasModel.getDefaultCommandWordSet().contains(alias)) {
            throw new CommandException(String.format(MESSAGE_ALIAS_IS_DEFAULT_COMMAND_WORD, alias));
        } else {
            aliasModel.setAlias(alias, defaultCommandWord);
            return new CommandResult(String.format(MESSAGE_SUCCESS, alias, defaultCommandWord));
        }
    }
}
```
###### \java\seedu\doist\logic\commands\Command.java
``` java
    public ArrayList<ReadOnlyTask> getMultipleTasksFromIndices(int[] targetIndices) throws CommandException {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
        ArrayList<ReadOnlyTask> relatedTasks = new ArrayList<ReadOnlyTask>();

        for (int targetIndex : targetIndices) {
            if (lastShownList.size() < targetIndex) {
                throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }
            ReadOnlyTask relatedTask = lastShownList.get(targetIndex - 1);
            relatedTasks.add(relatedTask);
        }
        return relatedTasks;
    }
}
```
###### \java\seedu\doist\logic\commands\DeleteCommand.java
``` java
/**
 * Deletes a task identified using it's last displayed index from the to-do list.
 */
public class DeleteCommand extends Command {

    public static final String DEFAULT_COMMAND_WORD = "delete";

    public static final String MESSAGE_USAGE = DEFAULT_COMMAND_WORD
            + ": Deletes the tasks identified by the index numbers used in the last task listing.\n"
            + "Parameters: INDEX [INDEX...] (must be a positive integer)\n"
            + "Example: " + DEFAULT_COMMAND_WORD + " 1 8";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted Task: %1$s";

    public final int[] targetIndices;

    public DeleteCommand(int[] targetIndices) {
        this.targetIndices = targetIndices;
    }

    @Override
    public CommandResult execute() throws CommandException {
        ArrayList<ReadOnlyTask> tasksToDelete = getMultipleTasksFromIndices(targetIndices);
        for (ReadOnlyTask task : tasksToDelete) {
            try {
                model.deleteTask(task);
            } catch (TaskNotFoundException pnfe) {
                assert false : "The target task cannot be missing";
            }
        }
        return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, tasksToDelete), true);
    }
}
```
###### \java\seedu\doist\logic\commands\EditCommand.java
``` java
        public void setPriority(Optional<Priority> priority) {
            assert priority != null;
            this.priority = priority;
        }
```
###### \java\seedu\doist\logic\commands\EditCommand.java
``` java
        public Optional<Priority> getPriority() {
            return priority;
        }
```
###### \java\seedu\doist\logic\commands\ListCommand.java
``` java
    public enum TaskType {
        PENDING,
        FINISHED,
        OVERDUE,
        ALL
    }
```
###### \java\seedu\doist\logic\commands\ListCommand.java
``` java
    private UniqueTagList tagList = new UniqueTagList();
    private TaskType type = null;
    private TaskDate dates = null;

```
###### \java\seedu\doist\logic\commands\RedoCommand.java
``` java
/**
 * Re-do commands that are undone previously.
 */
public class RedoCommand extends Command {

    public static final String DEFAULT_COMMAND_WORD = "redo";

    public static final String MESSAGE_REDO_SUCCESS = "redo %1$d steps successful";

    private int numSteps = 1;

    @Override
    public CommandResult execute() {
        assert model != null;
        int i = 0;
        while (i < numSteps && model.recoverNextTodoList()) {
            i++;
        }
        return new CommandResult(String.format(MESSAGE_REDO_SUCCESS, i));
    }

    public RedoCommand(int numSteps) {
        this.numSteps = numSteps;
    }
}
```
###### \java\seedu\doist\logic\commands\RemoveAliasCommand.java
``` java
/**
 * Adds an alias for an existing command
 */
public class RemoveAliasCommand extends Command {
    public static final String DEFAULT_COMMAND_WORD = "remove_alias";

    public static final String MESSAGE_USAGE = DEFAULT_COMMAND_WORD + ": Remove the alias if it exists\n"
            + "Parameters: ALIAS\n"
            + "Example: " + DEFAULT_COMMAND_WORD + " del";

    public static final String MESSAGE_SUCCESS = "Alias \"%1$s\" is removed";
    public static final String MESSAGE_INPUT_NOT_ALIAS = "\"%1$s\" is not an alias";

    private final String alias;

    public RemoveAliasCommand(String alias) {
        this.alias = alias;
    }

    @Override
    public CommandResult execute() throws CommandException {
        for (ArrayList<String> aliasList : aliasModel.getAliasListMap().getAliasListMapping().values()) {
            if (aliasList.contains(alias)) {
                aliasModel.removeAlias(alias);
                return new CommandResult(String.format(MESSAGE_SUCCESS, alias));
            }
        }
        throw new CommandException(String.format(MESSAGE_INPUT_NOT_ALIAS, alias));
    }
}
```
###### \java\seedu\doist\logic\commands\ResetAliasCommand.java
``` java
/**
 * Reset aliases to the default.
 */
public class ResetAliasCommand extends Command {

    public static final String DEFAULT_COMMAND_WORD = "reset_alias";

    public static final String MESSAGE_RESET_ALIAS_SUCCESS = "All aliases reset to default!";

    @Override
    public CommandResult execute() {
        aliasModel.resetToDefaultCommandWords();
        return new CommandResult(MESSAGE_RESET_ALIAS_SUCCESS);
    }
}
```
###### \java\seedu\doist\logic\commands\UndoCommand.java
``` java
/**
 * Undo commands that are done previously.
 */
public class UndoCommand extends Command {

    public static final String DEFAULT_COMMAND_WORD = "undo";

    public static final String MESSAGE_UNDO_SUCCESS = "undo %1$d steps successful";

    private int numSteps = 1;

    @Override
    public CommandResult execute() {
        assert model != null;
        int i = 0;
        while (i < numSteps && model.recoverPreviousTodoList()) {
            i++;
        }
        return new CommandResult(String.format(MESSAGE_UNDO_SUCCESS, i));
    }

    public UndoCommand(int numSteps) {
        this.numSteps = numSteps;
    }
}
```
###### \java\seedu\doist\logic\commands\ViewAliasCommand.java
``` java
/**
 * Display all aliases.
 */
public class ViewAliasCommand extends Command {

    public static final String DEFAULT_COMMAND_WORD = "view_alias";

    @Override
    public CommandResult execute() {
        return new CommandResult(formatAliasesForOutput());
    }

    private String formatAliasesForOutput() {
        Set<String> allCommandWords = aliasModel.getDefaultCommandWordSet();
        StringBuilder sb = new StringBuilder();
        for (String word: allCommandWords) {
            sb.append(word + ": ");
            for (String alias : aliasModel.getAliasList(word)) {
                sb.append(alias + ", ");
            }
            // remove the comma after the last alias
            if (sb.charAt(sb.length() - 2) == ',') {
                sb.deleteCharAt(sb.length() - 2);
            }
            sb.append("\n");
        }
        return sb.toString();
    }
}
```
###### \java\seedu\doist\logic\Logic.java
``` java
    /**
     * This method is used for auto completion in UI component
     * It is defined in Logic component rather than in Model component to
     * avoid introducing the association from UI component to Model component
     * @return all the command words, including the default command words and aliases specified by the user
     */
    List<String> getAllCommandWords();

```
###### \java\seedu\doist\logic\LogicManager.java
``` java
    @Override
    public CommandResult execute(String commandText) throws CommandException {
        logger.info("----------------[USER COMMAND][" + commandText + "]");
        Command command = parser.parseCommand(commandText);
        command.setData(model, aliasModel, configModel);

        CommandResult result = command.execute();
        if (result.isMutating) {
            model.saveCurrentToHistory();
        }
        return result;
    }

```
###### \java\seedu\doist\logic\LogicManager.java
``` java
    public List<String> getAllCommandWords() {
        ArrayList<String> allCommandWords = new ArrayList<String>();
        Set<String> allDefaultCommandWords = aliasModel.getDefaultCommandWordSet();
        for (String defaultCommandWords : allDefaultCommandWords) {
            allCommandWords.addAll(aliasModel.getValidCommandList(defaultCommandWords));
        }
        return allCommandWords;
    }

```
###### \java\seedu\doist\logic\parser\AliasCommandParser.java
``` java
public class AliasCommandParser {
    private static final Pattern ALIAS_COMMAND_REGEX = Pattern.compile("(?<preamble>[^\\\\]*)" +
                                                                      "(?<parameters>((\\\\)(\\S+)(\\s+)([^\\\\]*))*)");
    public static final String MESSAGE_COMMAND_WORD_NOT_SPECIFIED = "Command word must be specified. \n%1$s";
    public static final String MESSAGE_ALIAS_FORMAT_INVALID = "Alias can only contain alphabet"
                                                                    + "and underscores. \n%1$s";

    /**
     * Parses the given {@code String} of arguments in the context of the AliasCommand
     * and returns an AliasCommand object for execution.
     */
    public Command parse(String args) {
        final Matcher matcher = ALIAS_COMMAND_REGEX.matcher(args.trim());

        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AliasCommand.MESSAGE_USAGE));
        }
        final String preamble = matcher.group("preamble").trim();
        final String parameters = matcher.group("parameters").trim();
        ArrayList<String> tokens = ParserUtil.getParameterKeysFromString(parameters);

        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_FOR);

        if (!argsTokenizer.validateTokens(tokens)) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AliasCommand.MESSAGE_USAGE));
        }
        argsTokenizer.tokenize(parameters);

        try {
            List<String> parameter = argsTokenizer.getTokenizedArguments().get(PREFIX_FOR.toString());
            if (parameter == null || parameter.isEmpty()) {
                throw new IllegalValueException(String.format(MESSAGE_COMMAND_WORD_NOT_SPECIFIED,
                                                    AliasCommand.MESSAGE_USAGE));
            }
            if (!preamble.matches("[a-zA-Z_]+")) {
                throw new IllegalValueException(String.format(MESSAGE_ALIAS_FORMAT_INVALID,
                                                    AliasCommand.MESSAGE_USAGE));
            }
            String commandWord = parameter.get(0);
            return new AliasCommand(preamble, commandWord);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
}
```
###### \java\seedu\doist\logic\parser\CliSyntax.java
``` java
    public static final Prefix[] ALL_PREFICES = {
        PREFIX_FROM,
        PREFIX_TO,
        PREFIX_AS,
        PREFIX_UNDER,
        PREFIX_BY,
        PREFIX_IN,
        PREFIX_FOR
    };
}
```
###### \java\seedu\doist\logic\parser\Parser.java
``` java
    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group("commandWord");
        final String arguments = matcher.group("arguments");

        if (doesTriggerSameCommand(commandWord, AddCommand.DEFAULT_COMMAND_WORD)) {
            return new AddCommandParser().parse(arguments);
        } else if (doesTriggerSameCommand(commandWord, EditCommand.DEFAULT_COMMAND_WORD)) {
            return new EditCommandParser().parse(arguments);
        } else if (doesTriggerSameCommand(commandWord, SelectCommand.DEFAULT_COMMAND_WORD)) {
            return new SelectCommandParser().parse(arguments);
        } else if (doesTriggerSameCommand(commandWord, SortCommand.DEFAULT_COMMAND_WORD)) {
            return new SortCommandParser().parse(arguments);
        } else if (doesTriggerSameCommand(commandWord, DeleteCommand.DEFAULT_COMMAND_WORD)) {
            return new DeleteCommandParser().parse(arguments);
        } else if (doesTriggerSameCommand(commandWord, FinishCommand.DEFAULT_COMMAND_WORD)) {
            return new FinishCommandParser().parse(arguments);
        } else if (doesTriggerSameCommand(commandWord, UnfinishCommand.DEFAULT_COMMAND_WORD)) {
            return new UnfinishCommandParser().parse(arguments);
        } else if (doesTriggerSameCommand(commandWord, ClearCommand.DEFAULT_COMMAND_WORD)) {
            return new ClearCommand();
        } else if (doesTriggerSameCommand(commandWord, FindCommand.DEFAULT_COMMAND_WORD)) {
            return new FindCommandParser().parse(arguments);
        } else if (doesTriggerSameCommand(commandWord, ListCommand.DEFAULT_COMMAND_WORD)) {
            return new ListCommandParser().parse(arguments);
        } else if (doesTriggerSameCommand(commandWord, ExitCommand.DEFAULT_COMMAND_WORD)) {
            return new ExitCommand();
        } else if (doesTriggerSameCommand(commandWord, HelpCommand.DEFAULT_COMMAND_WORD)) {
            return new HelpCommand();
        } else if (doesTriggerSameCommand(commandWord, LoadCommand.DEFAULT_COMMAND_WORD)) {
            return new LoadCommandParser().parse(arguments);
        } else if (doesTriggerSameCommand(commandWord, SaveAtCommand.DEFAULT_COMMAND_WORD)) {
            return new SaveAtCommandParser().parse(arguments);
        } else if (doesTriggerSameCommand(commandWord, AliasCommand.DEFAULT_COMMAND_WORD)) {
            return new AliasCommandParser().parse(arguments);
        } else if (doesTriggerSameCommand(commandWord, RemoveAliasCommand.DEFAULT_COMMAND_WORD)) {
            return new RemoveAliasCommandParser().parse(arguments);
        } else if (doesTriggerSameCommand(commandWord, ResetAliasCommand.DEFAULT_COMMAND_WORD)) {
            return new ResetAliasCommand();
        } else if (doesTriggerSameCommand(commandWord, UndoCommand.DEFAULT_COMMAND_WORD)) {
            return new UndoCommand(1);
        } else if (doesTriggerSameCommand(commandWord, RedoCommand.DEFAULT_COMMAND_WORD)) {
            return new RedoCommand(1);
        } else if (doesTriggerSameCommand(commandWord, ViewAliasCommand.DEFAULT_COMMAND_WORD)) {
            return new ViewAliasCommand();
        } else {
            return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
        }
    }

    public boolean doesTriggerSameCommand(String word, String defaultCommandWord) {
        List<String> validCommandList = aliasModel.getValidCommandList(defaultCommandWord);
        return validCommandList.contains(word);
    }
}
```
###### \java\seedu\doist\logic\parser\ParserUtil.java
``` java
    /**
     * Returns an list of integers separated using space in the input string
     * hyphen can be used to represent a range of indices
     */
    public static List<Optional<Integer>> parseIndices(String command) {
        ArrayList<Optional<Integer>> indices = new ArrayList<Optional<Integer>>();
        String[] commandStringComponents = command.trim().split(" +");
        for (String component : commandStringComponents) {
            String[] ends = component.split("-+");
            if (ends.length == 2 && !"".equals(ends[0]) && !"".equals(ends[1])) {
                indices.addAll(parseIndexRange(ends));
            } else {
                indices.add(parseIndex(component));
            }
        }
        return indices;
    }

    /**
     * @param twoEnds : A String array containing 2 elements,
     *                  representing the start and the end of the range (both included)
     * @return a list of Optional Integers in the range
     */
    public static List<Optional<Integer>> parseIndexRange(String[] twoEnds) {
        assert twoEnds.length == 2 && !"".equals(twoEnds[0]) && !"".equals(twoEnds[1]);
        ArrayList<Optional<Integer>> indices = new ArrayList<Optional<Integer>>();
        int start = parseIndex(twoEnds[0]).get();
        int end = parseIndex(twoEnds[1]).get();
        for (int i = start; i <= end; i++) {
            indices.add(Optional.of(i));
        }
        return indices;
    }

    /**
     * Returns an array of integers separated using space in the input string
     */
    public static int[] parseStringToIntArray(String string) {
        List<Optional<Integer>> optionalIndices = ParserUtil.parseIndices(string);
        for (Optional<Integer> optionalIndex : optionalIndices) {
            if (!optionalIndex.isPresent()) {
                return null;
            }
        }
        int[] indices = new int[optionalIndices.size()];
        for (int i = 0; i < indices.length; i++) {
            indices[i] = optionalIndices.get(i).get().intValue();
        }
        return indices;
    }
```
###### \java\seedu\doist\logic\parser\RemoveAliasCommandParser.java
``` java
public class RemoveAliasCommandParser {
    private static final Pattern ALIAS_COMMAND_REGEX = Pattern.compile("(?<preamble>[^\\\\]*)" +
                                                                      "(?<parameters>((\\\\)(\\S+)(\\s+)([^\\\\]*))*)");
    public static final String MESSAGE_ALIAS_NOT_SPECIFIED = "Alias must be specified.";
    public static final String MESSAGE_ALIAS_FORMAT_INVALID = "Alias can only contain alphabet"
                                                                    + "and underscores. \n%1$s";

    /**
     * Parses the given {@code String} of arguments in the context of the RemoveAliasCommand
     * and returns an RemoveAliasCommand object for execution.
     */
    public Command parse(String args) {
        final Matcher matcher = ALIAS_COMMAND_REGEX.matcher(args.trim());

        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AliasCommand.MESSAGE_USAGE));
        }
        final String preamble = matcher.group("preamble").trim();

        try {
            if ("".equals(preamble)) {
                throw new IllegalValueException(MESSAGE_ALIAS_NOT_SPECIFIED);
            }
            if (!preamble.matches("[a-zA-Z_]+")) {
                throw new IllegalValueException(String.format(MESSAGE_ALIAS_FORMAT_INVALID,
                                                RemoveAliasCommand.MESSAGE_USAGE));
            }
            return new RemoveAliasCommand(preamble);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
}
```
###### \java\seedu\doist\model\AliasListMap.java
``` java
    /**
     * Initializes the entire HashMap for all aliases, resets to default
     */
    public void setDefaultAliasListMapping() {
        HashMap<String, ArrayList<String>> defaultCommandAliases = getDefaultAliasListMapping();
        commandAliases = new HashMap<String, ArrayList<String>>();
        for (String word : defaultCommandAliases.keySet()) {
            commandAliases.put(word, defaultCommandAliases.get(word));
        }
    }

    private HashMap<String, ArrayList<String>> getDefaultAliasListMapping() {
        HashMap<String, ArrayList<String>> aliasMap = new HashMap<String, ArrayList<String>>();
        aliasMap.put("add",  new ArrayList<>(Arrays.asList("do")));
        aliasMap.put("clear",  new ArrayList<>());
        aliasMap.put("delete",  new ArrayList<>(Arrays.asList("del")));
        aliasMap.put("edit",  new ArrayList<>(Arrays.asList("update")));
        aliasMap.put("exit",  new ArrayList<>());
        aliasMap.put("find",  new ArrayList<>());
        aliasMap.put("finish",  new ArrayList<>(Arrays.asList("fin")));
        aliasMap.put("help",  new ArrayList<>());
        aliasMap.put("list",  new ArrayList<>(Arrays.asList("ls")));
        aliasMap.put("load",  new ArrayList<>());
        aliasMap.put("save_at", new ArrayList<>(Arrays.asList("save")));
        aliasMap.put("select",  new ArrayList<>());
        aliasMap.put("sort",  new ArrayList<>(Arrays.asList("sort_by")));
        aliasMap.put("unfinish",  new ArrayList<>(Arrays.asList("unfin")));
        aliasMap.put("alias",  new ArrayList<>());
        aliasMap.put("remove_alias",  new ArrayList<>());
        aliasMap.put("reset_alias",  new ArrayList<>());
        aliasMap.put("view_alias",  new ArrayList<>(Arrays.asList("list_alias", "ls_alias")));
        aliasMap.put("undo",  new ArrayList<>());
        aliasMap.put("redo",  new ArrayList<>());
        return aliasMap;
    }

    /**
     * @return a set of strings which are the default command words
     */
    public Set<String> getDefaultCommandWordSet() {
        return getDefaultAliasListMapping().keySet();
    }

    @Override
    public Map<String, ArrayList<String>> getAliasListMapping() {
        return Collections.unmodifiableMap(commandAliases);
    }

    /**
     * Returns an unmodifiable list of the alias list of the specified default command word
     */
    public List<String> getAliasList(String defaultCommandWord) {
        return Collections.unmodifiableList(commandAliases.get(defaultCommandWord));
    }

    /**
     * Adds an alias to the alias list for that default command word
     * Also removes any occurrence of that alias in the alias list of other default command words
     */
    public void setAlias(String alias, String commandWord) {
        assert(commandAliases.get(commandWord) != null);
        if (commandAliases == null) {
            setDefaultAliasListMapping();
        }
        for (String word : commandAliases.keySet()) {
            commandAliases.get(word).remove(alias);
        }
        ArrayList<String> aliases = commandAliases.get(commandWord);
        aliases.add(alias);
        commandAliases.replace(commandWord, aliases);
    }

    /**
     * remove the specified alias from the corresponding command word if such alias exists
     * nothing happen it the input string is not an alias
     * @param alias
     */
    public void removeAlias(String alias) {
        for (String word : commandAliases.keySet()) {
            commandAliases.get(word).remove(alias);
        }
    }

```
###### \java\seedu\doist\model\ModelManager.java
``` java
    //=========== TodoList =============================================================

    @Override
    public void resetData(ReadOnlyTodoList newData) {
        todoList.resetData(newData);
        sortTasksByDefault();
        indicateTodoListChanged();
    }

    @Override
    public ReadOnlyTodoList getTodoList() {
        return todoList;
    }

    /** Raises an event to indicate the model has changed */
    private void indicateTodoListChanged() {
        raise(new TodoListChangedEvent(todoList));
    }

    @Override
    public synchronized void deleteTask(ReadOnlyTask target) throws TaskNotFoundException {
        todoList.removeTask(target);
        indicateTodoListChanged();
    }

```
###### \java\seedu\doist\model\ModelManager.java
``` java
    private class TagQualifier implements Qualifier {
        private UniqueTagList tags;

        public TagQualifier(UniqueTagList tags2) {
            this.tags = tags2;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            for (Tag tag : tags) {
                if (task.getTags().contains(tag)) {
                    return true;
                }
            }
            return false;
        }
    }

    private class TaskTypeQualifier implements Qualifier {
        private TaskType type;

        public TaskTypeQualifier(TaskType type) {
            this.type = type;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            switch (type) {
            case FINISHED:
                return task.getFinishedStatus().getIsFinished();
            case PENDING:
                return !task.getFinishedStatus().getIsFinished() && !task.isOverdue();
            case OVERDUE:
                return task.isOverdue();
            default:
                return true;
            }
        }
    }

```
###### \java\seedu\doist\model\ModelManager.java
``` java
    //========== handle undo and re-do operation =================================================
    public void saveCurrentToHistory() {
        todoListHistory.forgetStatesAfter();
        TodoList toSave = new TodoList();
        toSave.resetData(todoList);
        todoListHistory.addToHistory(toSave);
    }

    public boolean recoverPreviousTodoList() {
        boolean isAtMostRecentState = todoListHistory.isAtMostRecentState();
        TodoList previousTodoList = todoListHistory.getPreviousState();
        if (previousTodoList != null) {
            todoList.resetData(previousTodoList);
        } else {
            return false;
        }
        if (isAtMostRecentState) {
            recoverPreviousTodoList();
        }
        indicateTodoListChanged();
        return true;
    }

    public boolean recoverNextTodoList() {
        TodoList nextTodoList = todoListHistory.getNextState();
        if (nextTodoList != null) {
            todoList.resetData(nextTodoList);
        } else {
            return false;
        }
        indicateTodoListChanged();
        return true;
    }
}
```
###### \java\seedu\doist\ui\CommandBox.java
``` java
    private void highlightAndSuggestCompletion() {
        highlightManager.highlight(commandTextField);
        autoCompleteManager.suggestCompletion(commandTextField, logic);
    }
```
###### \java\seedu\doist\ui\CommandBox.java
``` java
    private void handleKeyPressedInNavigationMode(KeyEvent event) {
        event.consume();
        if (event.getCode() == KeyCode.J) {
            if (currentIndex + 1 < logic.getFilteredTaskList().size()) {
                currentIndex++;
            }
        } else if (event.getCode() == KeyCode.K) {
            if (currentIndex - 1 >= 0) {
                currentIndex--;
            }
        } else if (event.getCode() == KeyCode.ESCAPE) {
            currentIndex = -1;
            turnOnEditingMode();
        }
        EventsCenter.getInstance().post(new JumpToListRequestEvent(currentIndex));
    }

    private void handleKeyPressedInEditingMode(KeyEvent event) {
        if (event.getCode() == KeyCode.ESCAPE) {
            event.consume();
            turnOnNavigationMode();
        } else if (event.getCode() == KeyCode.ENTER) {
            event.consume();
            handleEnterKey();
        } else if (event.getCode() == KeyCode.UP) {
            // up and down arrow key will move the cursor to the position 0
            // use consume() method to marks this Event as consumed. This stops such further propagation.
            event.consume();
            handleUpKey();
        } else if (event.getCode() == KeyCode.DOWN) {
            event.consume();
            handleDownKey();
        } else if (event.getCode() == KeyCode.TAB) {  // auto complete
            event.consume();
            completeWithSelectedSuggestion();
        } else if (undoKeys.match(event)) {  // use control+z and control+y to execute undo and re-do operation
            event.consume();
            handleCtrlZKeyCombination();
        } else if (redoKeys.match(event)) {
            event.consume();
            handleCtrlYKeyCombination();
        }
    }

    private void turnOnNavigationMode() {
        navigationMode = true;
        commandTextField.textProperty().removeListener(highlightListener);
        commandTextField.textProperty().addListener(disableInputListener);
        logger.info("turn on navigation mode");
        raise(new NewResultAvailableEvent(NAVIGATION_MODE_MESSAGE));
    }

    private void turnOnEditingMode() {
        navigationMode = false;
        commandTextField.textProperty().removeListener(disableInputListener);
        commandTextField.textProperty().addListener(highlightListener);
        logger.info("turn on editing mode");
        raise(new NewResultAvailableEvent(EDITING_MODE_MESSAGE));
    }

    private void removeInput() {
        commandTextField.clear();
    }

```
###### \java\seedu\doist\ui\CommandBox.java
``` java
    //Handle Control + z key combination for undo operation
    private void handleCtrlZKeyCombination() {
        try {
            CommandResult commandResult  = logic.execute(UndoCommand.DEFAULT_COMMAND_WORD);
            logger.info("Result: " + commandResult.feedbackToUser);
            raise(new NewResultAvailableEvent(commandResult.feedbackToUser));
        } catch (CommandException e) { /* DEFAULT_COMMAND_WORD will not cause exception */ }
    }

    //Handle Control + y key combination for re-do operation
    private void handleCtrlYKeyCombination() {
        try {
            CommandResult commandResult  = logic.execute(RedoCommand.DEFAULT_COMMAND_WORD);
            logger.info("Result: " + commandResult.feedbackToUser);
            raise(new NewResultAvailableEvent(commandResult.feedbackToUser));
        } catch (CommandException e) { /* DEFAULT_COMMAND_WORD will not cause exception */ }
    }

    //Restores the command history pointer
    //Throws exception is 'add' fails
    private void restoreCommandHistoryAndAppend(String userCommandText) {
        commandHistory.restore();
        if (!commandHistory.addToHistory(userCommandText)) {
            throw new ArrayIndexOutOfBoundsException();
        }
    }

    private void setCommandInput(String string) {
        commandTextField.clear();
        commandTextField.appendText(string);

        // move the cursor to the end of the input string
        commandTextField.positionCaret(string.length());
    }

    private void completeWithSelectedSuggestion() {
        ContextMenu suggestionList = (ContextMenu) commandTextField.getPopupWindow();
        if (suggestionList.isShowing() && !suggestionList.getItems().isEmpty()) {
            int cursorPosition = commandTextField.getCaretPosition();
            // -1 means trailing space will NOT be discarded
            String[] words = commandTextField.getText(0, cursorPosition).split(" +", -1);
            String lastWord = words[words.length - 1].replaceAll("\\\\", "\\\\\\\\");
            String suggestion = suggestionList.getItems().get(0).getText();
            if ("find".equals(words[0])) {
                handleFindTab(cursorPosition, words, suggestion);
            } else {
                String remainingString = suggestion.replaceAll(lastWord, "");
                commandTextField.insertText(cursorPosition, remainingString);
            }
        }
    }

```
###### \java\seedu\doist\ui\util\CommandAutoCompleteController.java
``` java
public class CommandAutoCompleteController {
    private static CommandAutoCompleteController instance;
    private boolean isFind = false;

    // relative to cursor center
    private final Point2D suggestionBoxOffset = new Point2D(-8, 12);
    private final int maxItemNu = 8;

    // for singleton pattern
    public static CommandAutoCompleteController getInstance() {
        if (instance == null) {
            instance = new CommandAutoCompleteController();
        }
        return instance;
    }

    // get the list of suggestions according to the input then display it
    public void suggestCompletion(InlineCssTextArea commandTextField, Logic logic) {
        attachSuggestionWindowIfNecessary(commandTextField);

        int cursorPosition = commandTextField.getCaretPosition();
        String[] words = commandTextField.getText(0, cursorPosition).split(" +", -1);
        String lastWord = words[words.length - 1];  // -1 means trailing space will NOT be discarded
        isFindCommand(words);
        if (!"".equals(lastWord)) {
            if (isFind) {
                displaySuggestions(commandTextField, getSuggestionsForSearch(words, logic));
            } else {
                displaySuggestions(commandTextField, getSuggestions(lastWord, logic));
            }
        } else {
            commandTextField.getPopupWindow().hide();
        }
    }

    private ArrayList<String> getSuggestions(String lastWord, Logic logic) {
        // TODO: make this method more "powerful"
        // handle different cases (command word, key, search history) differently
        // make better suggestion by using a queue to store history and store the frequency
        int count = 0;
        ArrayList<String> suggestions = new ArrayList<>();
        for (String commandWord : logic.getAllCommandWords()) {
            if (commandWord.startsWith(lastWord) && count < maxItemNu) {
                suggestions.add(commandWord);
                count++;
            }
        }
        for (Prefix prefix : CliSyntax.ALL_PREFICES) {
            if (prefix.toString().startsWith(lastWord) && count < maxItemNu) {
                suggestions.add(prefix.toString());
                count++;
            }
        }
        return suggestions;
    }

    /**
     * display the suggested text in a ContextMenu pop-up window
     */
    private void displaySuggestions(InlineCssTextArea commandTextField, ArrayList<String> suggestions) {
        ContentAssistPopupWindow suggestionList = (ContentAssistPopupWindow) commandTextField.getPopupWindow();
        suggestionList.replaceItems(suggestions);

        if (!commandTextField.getPopupWindow().isShowing()) {
            suggestionList.show(commandTextField);
        }
    }

    public void attachSuggestionWindowIfNecessary(InlineCssTextArea commandTextField) {
        if (commandTextField.getPopupWindow() == null) {
            commandTextField.setPopupWindow(new ContentAssistPopupWindow());
            commandTextField.setPopupAnchorOffset(suggestionBoxOffset);
        }
    }

```
###### \java\seedu\doist\ui\util\CommandHighlightController.java
``` java
public class CommandHighlightController {
    public static final String COMMAND_WORD_STYLE = "-fx-fill: #1a75ff;";  // blue"
    public static final String PARAMETER_KEY_STYLE = "-fx-fill: #55ae47;";  // green
    public static final String TIME_VALUE_STYLE = "-fx-fill: #e68a00;";  // orange
    public static final String PRIORITY_VALUE_STYLE = "-fx-fill: #cd5c5c;";  // red
    public static final String TAGS_STYLE = "-fx-fill: #7300e6;";  // purple
    public static final String NORMAL_STYLE = "-fx-fill: black;";

    private static CommandHighlightController instance;

    // for singleton pattern
    public static CommandHighlightController getInstance() {
        if (instance == null) {
            instance = new CommandHighlightController();
        }
        return instance;
    }

    public void highlight(InlineCssTextArea commandTextField) {
        String content = commandTextField.getText();
        int i = 0;
        while (i < content.length() && content.charAt(i) != ' ') {
            commandTextField.setStyle(i, i + 1, COMMAND_WORD_STYLE);
            i++;
        }
        String key = "";
        while (i < content.length()) {
            if (content.charAt(i) == '\\') {
                StringBuilder keyBuilder = new StringBuilder();
                while (i < content.length() && content.charAt(i) != ' ') {
                    commandTextField.setStyle(i, i + 1, PARAMETER_KEY_STYLE);
                    keyBuilder.append(content.charAt(i));
                    i++;
                }
                key = keyBuilder.toString();
            }
            if (i >= content.length()) {
                break;
            }
            if (key.equals(PREFIX_BY.toString()) ||
                key.equals(PREFIX_FROM.toString()) ||
                key.equals(PREFIX_TO.toString())) {
                commandTextField.setStyle(i, i + 1, TIME_VALUE_STYLE);
            } else if (key.equals(PREFIX_AS.toString())) {
                commandTextField.setStyle(i, i + 1, PRIORITY_VALUE_STYLE);
            } else if (key.equals(PREFIX_UNDER.toString())) {
                commandTextField.setStyle(i, i + 1, TAGS_STYLE);
            } else {
                commandTextField.setStyle(i, i + 1, NORMAL_STYLE);
            }
            i++;
        }
    }
}
```
###### \java\seedu\doist\ui\util\ContentAssistPopupWindow.java
``` java
/**
 * A window that displays the list that contains the list of word completion suggestions
 * The position of the window will update with the cursor
 *
 */
public class ContentAssistPopupWindow extends ContextMenu {
    public ContentAssistPopupWindow() {
        super();
        setEventDispatcher(new ConsumeEventDispatch());
    }

    public void show(Node inputBox) {
        this.show(inputBox, this.getAnchorX(), this.getAnchorY());
    }

    public void replaceItems(ArrayList<String> stringItems) {
        getItems().clear();

        for (int i = 0; i < stringItems.size(); i++) {
            getItems().add(i, new ContentAssistSuggestionItem(stringItems.get(i)));
        }
    }
}

/**
 * Represents each item in ContentAssistPopupWindow
 */
class ContentAssistSuggestionItem extends MenuItem {
    private ContentAssistSuggestionItem() {
        super();
        setMnemonicParsing(false);
    }

    public ContentAssistSuggestionItem(String content) {
        this();
        this.setText(content);
    }
}

class ConsumeEventDispatch implements EventDispatcher {
    @Override
    public Event dispatchEvent(Event event, EventDispatchChain tail) {
        return null;
    }
}

```
