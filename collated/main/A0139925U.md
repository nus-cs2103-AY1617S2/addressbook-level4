# A0139925U
###### \java\seedu\tache\commons\events\ui\PopulateRecurringGhostTaskEvent.java
``` java
package seedu.tache.commons.events.ui;

import javafx.collections.ObservableList;
import seedu.tache.commons.events.BaseEvent;
import seedu.tache.model.task.ReadOnlyTask;

/**
 * Represents a selection change in the Task List Panel
 */
public class PopulateRecurringGhostTaskEvent extends BaseEvent {


    private final ObservableList<ReadOnlyTask> allRecurringGhostTasks;

    public PopulateRecurringGhostTaskEvent(ObservableList<ReadOnlyTask> allRecurringGhostTasks) {
        this.allRecurringGhostTasks = allRecurringGhostTasks;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public ObservableList<ReadOnlyTask> getAllRecurringGhostTasks() {
        return allRecurringGhostTasks;
    }
}
```
###### \java\seedu\tache\commons\events\ui\TaskPanelConnectionChangedEvent.java
``` java
package seedu.tache.commons.events.ui;

import javafx.collections.ObservableList;
import seedu.tache.commons.events.BaseEvent;
import seedu.tache.model.task.ReadOnlyTask;

/**
 * Represents a selection change in the Task List Panel
 */
public class TaskPanelConnectionChangedEvent extends BaseEvent {


    private final ObservableList<ReadOnlyTask> newConnection;

    public TaskPanelConnectionChangedEvent(ObservableList<ReadOnlyTask> newConnection) {
        this.newConnection = newConnection;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public ObservableList<ReadOnlyTask> getNewConnection() {
        return newConnection;
    }
}
```
###### \java\seedu\tache\logic\commands\CompleteCommand.java
``` java
package seedu.tache.logic.commands;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;

import seedu.tache.commons.core.Messages;
import seedu.tache.logic.commands.exceptions.CommandException;
import seedu.tache.model.task.ReadOnlyTask;
import seedu.tache.model.task.Task;
import seedu.tache.model.task.UniqueTaskList;

/**
 * Edits the details of an existing task in the task manager.
 */
public class CompleteCommand extends Command implements Undoable {

    public static final String COMMAND_WORD = "complete";
    public static final String SHORT_COMMAND_WORD = "c";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Completes the task identified "
            + "by the index number used in the last tasks listing. "
            + "Existing values will be overwritten by the input values.\n"
            + "Parameters: INDEX1 (must be a positive integer), INDEX2, INDEX3, ... \n"
            + "Example: " + COMMAND_WORD + " 1, 2, 6, 8";

    public static final String MESSAGE_COMPLETED_TASK_SUCCESS = "Completed Task: \n%1$s";
    public static final String MESSAGE_NOT_COMPLETED = "At least one task's index must be provided.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";

    private final List<Integer> indexList;

    private boolean commandSuccess;
    private List<ReadOnlyTask> completedList;

    /**
     * @param filteredTaskListIndex the index of the task in the filtered task list to edit
     * @param completeTaskDescriptor details to edit the task with
     */
    public CompleteCommand(List<Integer> indexList) {
        assert indexList.size() > 0;
        this.indexList = indexList;

        // converts indexList from one-based to zero-based.
        for (int i = 0; i < indexList.size(); i++) {
            this.indexList.set(i, indexList.get(i) - 1);
        }
        Collections.reverse(indexList);
        commandSuccess = false;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = new ArrayList<ReadOnlyTask>(model.getFilteredTaskList());
        completedList = new ArrayList<ReadOnlyTask>();

        //Check all indexes are valid before proceeding
        for (int i = 0; i < indexList.size(); i++) {
            if (indexList.get(i) >= lastShownList.size()) {
                commandSuccess = false;
                throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }
        }

        for (int i = 0; i < indexList.size(); i++) {
            ReadOnlyTask taskToEdit = lastShownList.get(indexList.get(i));
            Task completedTask = createCompletedTask(taskToEdit);
            try {
                if (taskToEdit.getRecurringStatus()) {
                    model.updateTask(createOriginalRecurringTask(taskToEdit), completedTask);
                } else {
                    model.updateTask(taskToEdit, completedTask);
                }
            } catch (UniqueTaskList.DuplicateTaskException dpe) {
                commandSuccess = false;
                throw new CommandException(MESSAGE_DUPLICATE_TASK);
            }
            completedList.add(completedTask);
        }
        commandSuccess = true;
        undoHistory.push(this);
        model.updateCurrentFilteredList();
        model.getFilteredTaskList();

        return new CommandResult(String.format(MESSAGE_COMPLETED_TASK_SUCCESS, getSuccessMessage(completedList)));
    }

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     */
    private static Task createCompletedTask(ReadOnlyTask taskToEdit) {
        assert taskToEdit != null;
        if (taskToEdit.getRecurringStatus() && !taskToEdit.getRecurDisplayDate().equals("")) {
            List<Date> tempList = (ArrayList<Date>) ((ArrayList<Date>) taskToEdit.getRecurCompletedList()).clone();
            tempList.add(new Date(taskToEdit.getRecurDisplayDate()));
            ((Task) taskToEdit).setRecurDisplayDate("");
            return new Task(taskToEdit.getName(), taskToEdit.getStartDateTime(), taskToEdit.getEndDateTime(),
                    taskToEdit.getTags(), taskToEdit.getTimedStatus(), taskToEdit.getActiveStatus(),
                    taskToEdit.getRecurringStatus(), taskToEdit.getRecurInterval(), tempList);
        } else {
            return new Task(taskToEdit.getName(), taskToEdit.getStartDateTime(), taskToEdit.getEndDateTime(),
                            taskToEdit.getTags(), taskToEdit.getTimedStatus(), false, taskToEdit.getRecurringStatus(),
                            taskToEdit.getRecurInterval(), taskToEdit.getRecurCompletedList());
        }
    }

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     */
    private static Task createUncompletedTask(ReadOnlyTask taskToEdit) {
        assert taskToEdit != null;

        return new Task(taskToEdit.getName(), taskToEdit.getStartDateTime(), taskToEdit.getEndDateTime(),
                            taskToEdit.getTags(), taskToEdit.getTimedStatus(), true, taskToEdit.getRecurringStatus(),
                                taskToEdit.getRecurInterval(), taskToEdit.getRecurCompletedList());

    }

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     */
    private static Task createOriginalRecurringTask(ReadOnlyTask taskToEdit) {
        assert taskToEdit != null;
        ((Task) taskToEdit).setRecurDisplayDate("");
        return new Task(taskToEdit.getName(), taskToEdit.getStartDateTime(), taskToEdit.getEndDateTime(),
                            taskToEdit.getTags(), taskToEdit.getTimedStatus(), taskToEdit.getActiveStatus(),
                            taskToEdit.getRecurringStatus(), taskToEdit.getRecurInterval(),
                            taskToEdit.getRecurCompletedList());

    }

    /**
     * Creates and returns a formatted String message with the details of {@code completedList}
     */
    private static String getSuccessMessage(List<ReadOnlyTask> completedList) {
        assert completedList != null;
        String successMessage = "";
        for (int i = 0; i < completedList.size(); i++) {
            successMessage += completedList.get(i).toString();
        }
        return successMessage;
    }

    @Override
    public boolean isUndoable() {
        return commandSuccess;
    }

    @Override
    public String undo() throws CommandException {
        for (int i = 0; i < completedList.size(); i++) {
            try {
                ReadOnlyTask original = completedList.get(i);
                ReadOnlyTask revert = createUncompletedTask(completedList.get(i));
                model.updateTask(original, revert);
            } catch (UniqueTaskList.DuplicateTaskException dpe) {
                throw new CommandException(MESSAGE_DUPLICATE_TASK);
            }
        }
        return String.format(MESSAGE_COMPLETED_TASK_SUCCESS, completedList);
    }
}
```
###### \java\seedu\tache\logic\commands\DeleteCommand.java
``` java
    private void checkPartOfRecurringTask(ReadOnlyTask taskToEdit) throws IllegalValueException {
        if (taskToEdit.getRecurringStatus() && !taskToEdit.getRecurDisplayDate().equals("")) {
            throw new IllegalValueException(MESSAGE_PART_OF_RECURRING_TASK);
        }
    }

```
###### \java\seedu\tache\logic\commands\EditCommand.java
``` java
package seedu.tache.logic.commands;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Optional;

import seedu.tache.commons.core.EventsCenter;
import seedu.tache.commons.core.Messages;
import seedu.tache.commons.events.ui.JumpToListRequestEvent;
import seedu.tache.commons.exceptions.IllegalValueException;
import seedu.tache.commons.util.CollectionUtil;
import seedu.tache.logic.commands.exceptions.CommandException;
import seedu.tache.model.tag.UniqueTagList;
import seedu.tache.model.task.DateTime;
import seedu.tache.model.task.Name;
import seedu.tache.model.task.ReadOnlyTask;
import seedu.tache.model.task.Task;
import seedu.tache.model.task.Task.RecurInterval;
import seedu.tache.model.task.UniqueTaskList;
import seedu.tache.model.task.UniqueTaskList.DuplicateTaskException;

/**
 * Edits the details of an existing task in the task manager.
 */
public class EditCommand extends Command implements Undoable {

    public static final String COMMAND_WORD = "edit";
    public static final String SHORT_COMMAND_WORD = "e";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Edits the details of the task identified "
            + "by the index number used in the last tasks listing. "
            + "Existing values will be overwritten by the input values.\n"
            + "Parameters: INDEX (must be a positive integer); <parameter1> <new_value1>;"
            + "<parameter2> <new_value2>...\n"
            + "Example: " + COMMAND_WORD + " 1; start_date 10/11/2017; start_time 3.30pm;"
            + "Or alternatively you can use the following format\n"
            + "Parameters: INDEX (must be a positive integer) change <parameter1> to <new_value1> and "
            + "<parameter2> to <new_value2>...\n"
            + "Example: " + COMMAND_WORD + " 1 change startdate to 10/11/2017 and change starttime to 3.30pm;";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Task: %1$s";
    public static final String MESSAGE_NOT_EDITED = "At least one field to edit must be provided.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";
    public static final String MESSAGE_PART_OF_RECURRING_TASK =
                        "This task is part of a recurring task and cannot be edited.";

    private final int filteredTaskListIndex;
    private final EditTaskDescriptor editTaskDescriptor;

    private boolean commandSuccess;
    private ReadOnlyTask taskToEdit;
    private ReadOnlyTask originalTask;

    /**
     * @param filteredTaskListIndex the index of the task in the filtered task list to edit
     * @param editTaskDescriptor details to edit the task with
     */
    public EditCommand(int filteredTaskListIndex, EditTaskDescriptor editTaskDescriptor) {
        assert filteredTaskListIndex > 0;
        assert editTaskDescriptor != null;

        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;

        this.editTaskDescriptor = new EditTaskDescriptor(editTaskDescriptor);
        commandSuccess = false;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        taskToEdit = lastShownList.get(filteredTaskListIndex);
        cloneOriginalTask(taskToEdit);
        Task editedTask;
        try {
            checkPartOfRecurringTask(taskToEdit);
            editedTask = createEditedTask(taskToEdit, editTaskDescriptor);
            try {
                model.updateTask(taskToEdit, editedTask);
            } catch (UniqueTaskList.DuplicateTaskException dpe) {
                throw new CommandException(MESSAGE_DUPLICATE_TASK);
            }
            model.updateCurrentFilteredList();
            commandSuccess = true;
            undoHistory.push(this);
            EventsCenter.getInstance().post(new JumpToListRequestEvent(model.getFilteredTaskListIndex(taskToEdit)));
            return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
        } catch (IllegalValueException e) {
            return new IncorrectCommand(e.getMessage()).execute();
        }
    }

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     * @throws IllegalValueException if date or time could not be parsed
     */
    private static Task createEditedTask(ReadOnlyTask taskToEdit,
                                             EditTaskDescriptor editTaskDescriptor) throws IllegalValueException {
        assert taskToEdit != null;

        Name updatedName = editTaskDescriptor.getName().orElseGet(taskToEdit::getName);
        Optional<DateTime> updatedStartDateTime = taskToEdit.getStartDateTime();
        Optional<DateTime> updatedEndDateTime = taskToEdit.getEndDateTime();
        if (editTaskDescriptor.getStartDate().isPresent()) {
            if (updatedStartDateTime.isPresent()) {
                updatedStartDateTime.get().setDateOnly(editTaskDescriptor.getStartDate().get());
            } else {
                updatedStartDateTime = Optional.of(new DateTime(editTaskDescriptor.getStartDate().get()));
                updatedStartDateTime.get().setDefaultTime();
            }
        }
        if (editTaskDescriptor.getEndDate().isPresent()) {
            if (updatedEndDateTime.isPresent()) {
                updatedEndDateTime.get().setDateOnly(editTaskDescriptor.getEndDate().get());
            } else {
                updatedEndDateTime = Optional.of(new DateTime(editTaskDescriptor.getEndDate().get()));
                updatedEndDateTime.get().setDefaultTime();
            }
        }
        if (editTaskDescriptor.getStartTime().isPresent()) {
            if (updatedStartDateTime.isPresent()) {
                updatedStartDateTime.get().setTimeOnly(editTaskDescriptor.getStartTime().get());
            } else {
                updatedStartDateTime = Optional.of(new DateTime(editTaskDescriptor.getStartTime().get()));
            }
        }
        if (editTaskDescriptor.getEndTime().isPresent()) {
            if (updatedEndDateTime.isPresent()) {
                updatedEndDateTime.get().setTimeOnly(editTaskDescriptor.getEndTime().get());
            } else {
                updatedEndDateTime = Optional.of(new DateTime(editTaskDescriptor.getEndTime().get()));
            }
        }
        boolean isTimed;
        if (updatedStartDateTime.isPresent() || updatedEndDateTime.isPresent()) {
            isTimed = true;
        } else {
            isTimed = false;
        }
        UniqueTagList updatedTags = editTaskDescriptor.getTags().orElseGet(taskToEdit::getTags);
        return new Task(updatedName, updatedStartDateTime, updatedEndDateTime,
                            updatedTags, isTimed, true, false, RecurInterval.NONE, new ArrayList<Date>());

    }

    /**
     * Stores the details to edit the task with. Each non-empty field value will replace the
     * corresponding field value of the task.
     */
    public static class EditTaskDescriptor {
        private Optional<Name> name = Optional.empty();
        private Optional<String> startDate = Optional.empty();
        private Optional<String> endDate = Optional.empty();
        private Optional<String> startTime = Optional.empty();
        private Optional<String> endTime = Optional.empty();
        private Optional<UniqueTagList> tags = Optional.empty();

        public EditTaskDescriptor() {}

        public EditTaskDescriptor(EditTaskDescriptor toCopy) {
            this.name = toCopy.getName();
            this.startDate = toCopy.getStartDate();
            this.endDate = toCopy.getEndDate();
            this.startTime = toCopy.getStartTime();
            this.endTime = toCopy.getEndTime();
            this.tags = toCopy.getTags();
        }

        /**
         * Returns true if at least one field is edited.
         */
        public boolean isAnyFieldEdited() {
            return CollectionUtil.isAnyPresent(this.name, this.startDate, this.endDate,
                                               this.startTime, this.endTime, this.tags);
        }

        public void setName(Optional<Name> name) {
            assert name != null;
            this.name = name;
        }

        public Optional<Name> getName() {
            return name;
        }

        public void setStartDate(Optional<String> date) {
            assert date != null;
            this.startDate = date;
        }

        public Optional<String> getStartDate() {
            return startDate;
        }

        public void setEndDate(Optional<String> date) {
            assert date != null;
            this.endDate = date;
        }

        public Optional<String> getEndDate() {
            return endDate;
        }

        public void setStartTime(Optional<String> startTime) {
            assert startTime != null;
            this.startTime = startTime;
        }

        public Optional<String> getStartTime() {
            return startTime;
        }

        public void setEndTime(Optional<String> endTime) {
            assert endTime != null;
            this.endTime = endTime;
        }

        public Optional<String> getEndTime() {
            return endTime;
        }

        public void setTags(Optional<UniqueTagList> tags) {
            assert tags != null;
            this.tags = tags;
        }

        public Optional<UniqueTagList> getTags() {
            return tags;
        }
    }

    private void cloneOriginalTask(ReadOnlyTask taskToEdit) {
        //Workaround as Java could not deep copy taskToEdit for some fields
        DateTime workAroundStartDateTime = null;
        DateTime workAroundEndDateTime = null;
        try {
            if (taskToEdit.getStartDateTime().isPresent()) {
                workAroundStartDateTime = new DateTime(taskToEdit.getStartDateTime().get().getAmericanDateTime());
            }
            if (taskToEdit.getEndDateTime().isPresent()) {
                workAroundEndDateTime = new DateTime(taskToEdit.getEndDateTime().get().getAmericanDateTime());
            }
        } catch (IllegalValueException e1) {
            e1.printStackTrace();
        }
        originalTask = new Task(taskToEdit.getName(), Optional.ofNullable(workAroundStartDateTime),
                                        Optional.ofNullable(workAroundEndDateTime), taskToEdit.getTags(),
               taskToEdit.getTimedStatus(), taskToEdit.getActiveStatus(), taskToEdit.getRecurringStatus(),
               taskToEdit.getRecurInterval(), taskToEdit.getRecurCompletedList());
    }

    private void checkPartOfRecurringTask(ReadOnlyTask taskToEdit) throws IllegalValueException {
        if (taskToEdit.getRecurringStatus() && !taskToEdit.getRecurDisplayDate().equals("")) {
            throw new IllegalValueException(MESSAGE_PART_OF_RECURRING_TASK);
        }
    }

```
###### \java\seedu\tache\logic\commands\ListCommand.java
``` java
    public ListCommand() {
        this.filter = "uncompleted";
    }

    public ListCommand(String filter) {
        assert filter != null;
        this.filter = filter;
    }

    @Override
    public CommandResult execute() {
        switch(filter) {
        case COMPLETED_FILTER:
            model.updateFilteredListToShowCompleted();
            break;
        case TIMED_FILTER:
            model.updateFilteredListToShowTimed();
            break;
        case FLOATING_FILTER:
            model.updateFilteredListToShowFloating();
            break;
        case DUE_TODAY_FILTER:
            model.updateFilteredListToShowDueToday();
            break;
        case DUE_THIS_WEEK_FILTER:
            model.updateFilteredListToShowDueThisWeek();
            break;
        case OVERDUE_FILTER:
            model.updateFilteredListToShowOverdueTasks();
            break;
        case ALL_FILTER:
            model.updateFilteredListToShowAll();
            break;
        case UNCOMPLETED_FILTER:
        default:
            model.updateFilteredListToShowUncompleted();
            return new CommandResult(String.format(MESSAGE_SUCCESS, StringUtil.capitalizeFirstCharacter(filter)));
        }
        return new CommandResult(String.format(MESSAGE_SUCCESS, StringUtil.capitalizeFirstCharacter(filter)));
    }
}
```
###### \java\seedu\tache\logic\Logic.java
``` java
    /** Returns the filtered list of tasks */
    ObservableList<ReadOnlyTask> getFullTaskList();

```
###### \java\seedu\tache\logic\LogicManager.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getFilteredTaskList() {
        model.updateFilteredListToShowUncompleted();
        return model.getFilteredTaskList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFullTaskList() {
        List<ReadOnlyTask> concatenated = new ArrayList<>();
        Collections.addAll(concatenated, model.getTaskManager().getTaskList().toArray());
        Collections.addAll(concatenated, model.getAllRecurringGhostTasks().toArray());
        return FXCollections.observableList(concatenated);
    }

```
###### \java\seedu\tache\logic\parser\CliSyntax.java
``` java
    /* Parameter delimiter definitions */
    public static final String PARAMETER_DELIMITER = new String(";");
    public static final String INDEX_DELIMITER = new String(",");
    public static final String EDIT_PARAMETER_DELIMITER = new String(" ");

    /* Natural Language Processing definitions */
    public static final String EDIT_PARAMETER_KEYWORD = " change ";
    public static final String EDIT_PARAMETER_VALUE_KEYWORD = " to ";
    public static final String EDIT_MULTI_PARAMETER_KEYWORD = " and ";
    public static final String EDIT_MULTI_PARAMETER_KEYWORDS = " and change ";

    /* Parameter names definitions */
    public static final String NAME_PARAMETER = "name";
    public static final String NAME_PARAMETER_2 = "n";
    public static final String START_DATE_PARAMETER = "start_date";
    public static final String START_DATE_PARAMETER_2 = "startdate";
    public static final String START_DATE_PARAMETER_3 = "sd";
    public static final String END_DATE_PARAMETER = "end_date";
    public static final String END_DATE_PARAMETER_2 = "enddate";
    public static final String END_DATE_PARAMETER_3 = "ed";
    public static final String START_TIME_PARAMETER = "start_time";
    public static final String START_TIME_PARAMETER_2 = "starttime";
    public static final String START_TIME_PARAMETER_3 = "st";
    public static final String END_TIME_PARAMETER = "end_time";
    public static final String END_TIME_PARAMETER_2 = "endtime";
    public static final String END_TIME_PARAMETER_3 = "et";
    public static final String TAG_PARAMETER = "tag";
    public static final String TAG_PARAMETER_2 = "t";

    /* List filter definitions */
    public static final String COMPLETED_FILTER = "completed";
    public static final String UNCOMPLETED_FILTER = "uncompleted";
    public static final String ALL_FILTER = "all";
```
###### \java\seedu\tache\logic\parser\CompleteCommandParser.java
``` java
package seedu.tache.logic.parser;

import static seedu.tache.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.tache.logic.parser.CliSyntax.INDEX_DELIMITER;

import java.util.ArrayList;
import java.util.List;

import seedu.tache.commons.util.StringUtil;
import seedu.tache.logic.commands.Command;
import seedu.tache.logic.commands.CompleteCommand;
import seedu.tache.logic.commands.IncorrectCommand;


/**
 * Parses input arguments and creates a new EditCommand object
 */
public class CompleteCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the EditCommand
     * and returns an EditCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;
        String[] preambleFields = args.trim().split(INDEX_DELIMITER);
        if (preambleFields.length == 0 || args.trim().equals("")) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, CompleteCommand.MESSAGE_USAGE));
        }

        List<Integer> indexList = new ArrayList<Integer>();
        for (int i = 0; i < preambleFields.length; i++) {
          //Checking all arguments are valid and creating list
            String currentIndex = preambleFields[i].trim();
            if (!StringUtil.isUnsignedInteger(currentIndex)) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                                                CompleteCommand.MESSAGE_USAGE));
            } else {
                indexList.add(Integer.parseInt(currentIndex));
            }
        }

        return new CompleteCommand(indexList);
    }

}
```
###### \java\seedu\tache\logic\parser\EditCommandParser.java
``` java
package seedu.tache.logic.parser;

import static seedu.tache.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.tache.logic.parser.CliSyntax.EDIT_MULTI_PARAMETER_KEYWORD;
import static seedu.tache.logic.parser.CliSyntax.EDIT_MULTI_PARAMETER_KEYWORDS;
import static seedu.tache.logic.parser.CliSyntax.EDIT_PARAMETER_DELIMITER;
import static seedu.tache.logic.parser.CliSyntax.EDIT_PARAMETER_KEYWORD;
import static seedu.tache.logic.parser.CliSyntax.EDIT_PARAMETER_VALUE_KEYWORD;
import static seedu.tache.logic.parser.CliSyntax.END_DATE_PARAMETER;
import static seedu.tache.logic.parser.CliSyntax.END_DATE_PARAMETER_2;
import static seedu.tache.logic.parser.CliSyntax.END_DATE_PARAMETER_3;
import static seedu.tache.logic.parser.CliSyntax.END_TIME_PARAMETER;
import static seedu.tache.logic.parser.CliSyntax.END_TIME_PARAMETER_2;
import static seedu.tache.logic.parser.CliSyntax.END_TIME_PARAMETER_3;
import static seedu.tache.logic.parser.CliSyntax.NAME_PARAMETER;
import static seedu.tache.logic.parser.CliSyntax.NAME_PARAMETER_2;
import static seedu.tache.logic.parser.CliSyntax.PARAMETER_DELIMITER;
import static seedu.tache.logic.parser.CliSyntax.START_DATE_PARAMETER;
import static seedu.tache.logic.parser.CliSyntax.START_DATE_PARAMETER_2;
import static seedu.tache.logic.parser.CliSyntax.START_DATE_PARAMETER_3;
import static seedu.tache.logic.parser.CliSyntax.START_TIME_PARAMETER;
import static seedu.tache.logic.parser.CliSyntax.START_TIME_PARAMETER_2;
import static seedu.tache.logic.parser.CliSyntax.START_TIME_PARAMETER_3;
import static seedu.tache.logic.parser.CliSyntax.TAG_PARAMETER;
import static seedu.tache.logic.parser.CliSyntax.TAG_PARAMETER_2;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Optional;

import seedu.tache.commons.exceptions.IllegalValueException;
import seedu.tache.logic.commands.Command;
import seedu.tache.logic.commands.EditCommand;
import seedu.tache.logic.commands.EditCommand.EditTaskDescriptor;
import seedu.tache.logic.commands.IncorrectCommand;
import seedu.tache.model.tag.UniqueTagList;
import seedu.tache.model.task.Name;


/**
 * Parses input arguments and creates a new EditCommand object
 */
public class EditCommandParser {

    public static final String MESSAGE_INVALID_PARAMETER = "Invalid parameter given. Valid parameters" +
                                                   " include name, start_date, start_time, end_date, end_time and tags";

    /**
     * Parses the given {@code String} of arguments in the context of the EditCommand
     * and returns an EditCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;
        if (args.contains(PARAMETER_DELIMITER)) {
            return parseStructuredArguments(args);
        } else {
            return parseNaturalLanguageArguments(args);
        }
    }

    /**
     * Parses the given {@code String} of arguments that is of a natural language format in the context of the
     * EditCommand and returns an EditCommand object for execution.
     */
    private Command parseNaturalLanguageArguments(String args) {
        String argsInProcess = args;
        //Maunal expression matching due to regex matching criteria being too broad
        Optional<Integer> index = ParserUtil.parseIndex(argsInProcess.trim().split(" ")[0]);
        if (index.isPresent()) {
            //Process index
            int indexOfIndex = argsInProcess.indexOf(new String("" +  index.get()));
            argsInProcess = argsInProcess.substring(indexOfIndex + new String("" +  index.get()).length());

            //Process Other Arguments
            int indexOfFirstAndChange = argsInProcess.indexOf(EDIT_MULTI_PARAMETER_KEYWORDS);
            if (indexOfFirstAndChange == -1) {
                return processNaturalSingleParameterEdit(index, argsInProcess);
            } else {
                return processNaturalMultiParameterEdit(index, indexOfFirstAndChange, argsInProcess);
            }
        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    EditCommand.MESSAGE_USAGE));
        }
    }

    /**
     * Parses the given {@code String} of arguments that is of a structured format in the context of the
     * EditCommand and returns an EditCommand object for execution.
     */
    private Command parseStructuredArguments(String args) {
        String[] preambleFields = args.split(PARAMETER_DELIMITER);
        Optional<Integer> index = ParserUtil.parseIndex(preambleFields[0]);

        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        EditTaskDescriptor editTaskDescriptor = new EditTaskDescriptor();

        for (int i = 1; i < preambleFields.length; i++) {
            try {
                String updateParameter = preambleFields[i].substring(0, preambleFields[i].replaceAll("^\\s+", "")
                                         .indexOf(EDIT_PARAMETER_DELIMITER) + 1).trim();
                String updateValue = preambleFields[i].substring(preambleFields[i].replaceAll("^\\s+", "")
                                     .indexOf(EDIT_PARAMETER_DELIMITER) + 1).trim();

                switch(updateParameter) {
                case NAME_PARAMETER:
                case NAME_PARAMETER_2:
                    editTaskDescriptor.setName(Optional.of(new Name(updateValue)));
                    break;
                case START_DATE_PARAMETER:
                case START_DATE_PARAMETER_2:
                case START_DATE_PARAMETER_3:
                    editTaskDescriptor.setStartDate(Optional.of(updateValue));
                    break;
                case END_DATE_PARAMETER:
                case END_DATE_PARAMETER_2:
                case END_DATE_PARAMETER_3:
                    editTaskDescriptor.setEndDate(Optional.of(updateValue));
                    break;
                case START_TIME_PARAMETER:
                case START_TIME_PARAMETER_2:
                case START_TIME_PARAMETER_3:
                    editTaskDescriptor.setStartTime(Optional.of(updateValue));
                    break;
                case END_TIME_PARAMETER:
                case END_TIME_PARAMETER_2:
                case END_TIME_PARAMETER_3:
                    editTaskDescriptor.setEndTime(Optional.of(updateValue));
                    break;
                case TAG_PARAMETER:
                case TAG_PARAMETER_2:
                    editTaskDescriptor.setTags(parseTagsForEdit(Arrays.asList(updateValue
                                                                              .split(EDIT_PARAMETER_DELIMITER))));
                    break;
                default:
                    throw new IllegalValueException(MESSAGE_INVALID_PARAMETER);
                }
            } catch (IllegalValueException ive) {
                return new IncorrectCommand(ive.getMessage());
            }
        }
        if (!editTaskDescriptor.isAnyFieldEdited()) {
            return new IncorrectCommand(EditCommand.MESSAGE_NOT_EDITED);
        }
        return new EditCommand(index.get(), editTaskDescriptor);
    }

    /**
     * Process the given {@code String} of arguments that contains only one parameter of interest
     * that is of a natural language format and returns an EditCommand object for execution.
     */
    private Command processNaturalSingleParameterEdit(Optional<Integer> index, String argsInProcess) {
        int indexOfFirstChange = argsInProcess.indexOf(EDIT_PARAMETER_KEYWORD);
        int indexOfFirstTo = argsInProcess.indexOf(EDIT_PARAMETER_VALUE_KEYWORD);
        if (indexOfFirstChange != -1 && indexOfFirstTo != -1) {
            String updateParameter = argsInProcess.substring(indexOfFirstChange
                                        + new String(EDIT_PARAMETER_KEYWORD).length(), indexOfFirstTo);
            String updateValue = argsInProcess.substring(indexOfFirstTo
                                        + new String(EDIT_PARAMETER_VALUE_KEYWORD).length());
            return parseStructuredArguments(index.get() + PARAMETER_DELIMITER + updateParameter
                                                + EDIT_PARAMETER_DELIMITER + updateValue);
        } else {
            if (indexOfFirstChange == -1 && indexOfFirstTo == -1) {
                return new IncorrectCommand(EditCommand.MESSAGE_NOT_EDITED);
            }
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    EditCommand.MESSAGE_USAGE));
        }
    }

    /**
     * Process the given {@code String} of arguments that contains only multiple parameters of interest
     * that is of a natural language format and returns an EditCommand object for execution.
     */
    private Command processNaturalMultiParameterEdit (Optional<Integer> index,
                                int indexOfFirstAndChange, String argsInProcess) {
        int currentIndexOfFirstAndChange = indexOfFirstAndChange;
        ArrayList<String> updateParameterList = new ArrayList<String>();
        ArrayList<String> updateValueList = new ArrayList<String>();
        while (argsInProcess.length() > 0) {
            int indexOfFirstChange = argsInProcess.indexOf(EDIT_PARAMETER_KEYWORD);
            int indexOfFirstTo = argsInProcess.indexOf(EDIT_PARAMETER_VALUE_KEYWORD);
            if (indexOfFirstChange != -1 && indexOfFirstTo != -1) {
                String updateParameter = argsInProcess.substring(indexOfFirstChange
                        + new String(EDIT_PARAMETER_KEYWORD).length(), indexOfFirstTo);
                String updateValue = "";
                if (currentIndexOfFirstAndChange != -1) {
                    updateValue = argsInProcess.substring(indexOfFirstTo
                            + new String(EDIT_PARAMETER_VALUE_KEYWORD).length(), currentIndexOfFirstAndChange);
                    argsInProcess = argsInProcess.substring(currentIndexOfFirstAndChange
                            + new String(EDIT_MULTI_PARAMETER_KEYWORD).length() - 1);
                    currentIndexOfFirstAndChange = argsInProcess.indexOf(EDIT_MULTI_PARAMETER_KEYWORDS);
                } else {
                    updateValue = argsInProcess.substring(indexOfFirstTo
                                    + new String(EDIT_PARAMETER_VALUE_KEYWORD).length());
                    argsInProcess = "";
                }
                updateParameterList.add(updateParameter);
                updateValueList.add(updateValue);
            } else {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                        EditCommand.MESSAGE_USAGE));
            }
        }
        String structuredArgument = index.get() + PARAMETER_DELIMITER;
        for (int i = 0; i < updateParameterList.size(); i++) {
            structuredArgument += updateParameterList.get(i) + EDIT_PARAMETER_DELIMITER
                                + updateValueList.get(i) + EDIT_PARAMETER_DELIMITER + PARAMETER_DELIMITER;
        }
        return parseStructuredArguments(structuredArgument);
    }

    /**
     * Parses {@code Collection<String> tags} into an {@code Optional<UniqueTagList>} if {@code tags} is non-empty.
     * If {@code tags} contain only one element which is an empty string, it will be parsed into a
     * {@code Optional<UniqueTagList>} containing zero tags.
     */
    private Optional<UniqueTagList> parseTagsForEdit(Collection<String> tags) throws IllegalValueException {
        assert tags != null;

        if (tags.isEmpty()) {
            return Optional.empty();
        }
        Collection<String> tagSet = tags.size() == 1 && tags.contains("") ? Collections.emptySet() : tags;
        return Optional.of(ParserUtil.parseTags(tagSet));
    }

}
```
###### \java\seedu\tache\logic\parser\FindCommandParser.java
``` java
        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindCommand(keywordSet);
    }

}
```
###### \java\seedu\tache\logic\parser\HelpCommandParser.java
``` java
package seedu.tache.logic.parser;

import static seedu.tache.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import seedu.tache.logic.commands.AddCommand;
import seedu.tache.logic.commands.ClearCommand;
import seedu.tache.logic.commands.Command;
import seedu.tache.logic.commands.CompleteCommand;
import seedu.tache.logic.commands.DeleteCommand;
import seedu.tache.logic.commands.EditCommand;
import seedu.tache.logic.commands.ExitCommand;
import seedu.tache.logic.commands.FindCommand;
import seedu.tache.logic.commands.HelpCommand;
import seedu.tache.logic.commands.IncorrectCommand;
import seedu.tache.logic.commands.ListCommand;
import seedu.tache.logic.commands.LoadCommand;
import seedu.tache.logic.commands.SaveCommand;
import seedu.tache.logic.commands.SelectCommand;
import seedu.tache.logic.commands.UndoCommand;


/**
 * Parses input arguments and creates a new HelpCommand object
 */
public class HelpCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the HelpCommand
     * and returns an HelpCommand object for execution.
     */
    public Command parse(String args) {
        String trimmedArgs = args.trim();
        if (!trimmedArgs.equals("")) {
            switch(trimmedArgs) {
            case AddCommand.COMMAND_WORD:
            case ClearCommand.COMMAND_WORD:
            case CompleteCommand.COMMAND_WORD:
            case DeleteCommand.COMMAND_WORD:
            case EditCommand.COMMAND_WORD:
            case ExitCommand.COMMAND_WORD:
            case FindCommand.COMMAND_WORD:
            case ListCommand.COMMAND_WORD:
            case LoadCommand.COMMAND_WORD:
            case SaveCommand.COMMAND_WORD:
            case SelectCommand.COMMAND_WORD:
            case UndoCommand.COMMAND_WORD:
                return new HelpCommand(trimmedArgs);
            default:
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
            }
        } else {
            return new HelpCommand();
        }
    }

}
```
###### \java\seedu\tache\logic\parser\ListCommandParser.java
``` java
package seedu.tache.logic.parser;

import static seedu.tache.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.tache.logic.parser.CliSyntax.ALL_FILTER;
import static seedu.tache.logic.parser.CliSyntax.COMPLETED_FILTER;
import static seedu.tache.logic.parser.CliSyntax.DUE_THIS_WEEK_FILTER;
import static seedu.tache.logic.parser.CliSyntax.DUE_TODAY_FILTER;
import static seedu.tache.logic.parser.CliSyntax.FLOATING_FILTER;
import static seedu.tache.logic.parser.CliSyntax.OVERDUE_FILTER;
import static seedu.tache.logic.parser.CliSyntax.TIMED_FILTER;
import static seedu.tache.logic.parser.CliSyntax.UNCOMPLETED_FILTER;

import seedu.tache.logic.commands.Command;
import seedu.tache.logic.commands.IncorrectCommand;
import seedu.tache.logic.commands.ListCommand;


/**
 * Parses input arguments and creates a new ListCommand object
 */
public class ListCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the ListCommand
     * and returns an ListCommand object for execution.
     */
    public Command parse(String args) {
        String trimmedArgs = args.trim();
        if (!trimmedArgs.equals("")) {
            switch(trimmedArgs) {
            case COMPLETED_FILTER:
            case UNCOMPLETED_FILTER:
            case TIMED_FILTER:
            case FLOATING_FILTER:
            case DUE_TODAY_FILTER:
            case DUE_THIS_WEEK_FILTER:
            case OVERDUE_FILTER:
            case ALL_FILTER:
                return new ListCommand(trimmedArgs);
            default:
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
            }
        } else {
            return new ListCommand();
        }
    }

}
```
###### \java\seedu\tache\logic\parser\ParserUtil.java
``` java
    private static final Pattern INDEX_ARGS_FORMAT = Pattern.compile("(?<targetIndex>.+)");

    private static final Pattern NAME_FORMAT = Pattern.compile("^\".+\"");
    private static final Pattern DATE_FORMAT = Pattern.compile("^[0-3]?[0-9]/[0-1]?[0-9]/(?:[0-9]{2})?[0-9]{2}$"
                                                               + "|^[0-3]?[0-9]-[0-1]?[0-9]-(?:[0-9]{2})?[0-9]{2}$"
                                                               + "|^[0-3]{1}[0-9]{1}[0-1]{1}[0-9]{1}"
                                                               + "(?:[0-9]{2})?[0-9]{2}$");
    private static final Pattern TIME_FORMAT = Pattern.compile("^[0-2][0-9][0-5][0-9]|^([0-1][0-2]|[0-9])"
                                                               + "([.][0-5][0-9])?\\s?(am|pm){1}");
    private static final Pattern DURATION_FORMAT = Pattern.compile("^\\d+\\s?((h|hr|hrs)|(m|min|mins))");

    public static final int TYPE_TASK = 0;
    public static final int TYPE_DETAILED_TASK = 1;
```
###### \java\seedu\tache\logic\parser\ParserUtil.java
``` java
    /**
     * Returns True if input is a valid date
     * Returns False otherwise.
     */
    public static boolean isValidDate(String input) {
        final Matcher matcher = DATE_FORMAT.matcher(input.trim());
        return matcher.matches();
    }

    /**
     * Returns True if input is a valid time
     * Returns False otherwise.
     */
    public static boolean isValidTime(String input) {
        final Matcher matcher = TIME_FORMAT.matcher(input.trim());
        return matcher.matches();
    }

    /**
     * Returns True if input is a valid duration
     * Returns False otherwise.
     */
    public static boolean isValidDuration(String input) {
        final Matcher matcher = DURATION_FORMAT.matcher(input.trim());
        return matcher.matches();
    }

    /**
     * Returns True if input is a valid name
     * Returns False otherwise.
     */
    public static boolean isValidName(String input) {
        final Matcher matcher = NAME_FORMAT.matcher(input.trim());
        return matcher.matches();
    }
```
###### \java\seedu\tache\model\Model.java
``` java
    /** Updates the filter of the filtered task list to show all uncompleted tasks */
    void updateFilteredListToShowUncompleted();

    /** Updates the filter of the filtered task list to show all completed tasks */
    void updateFilteredListToShowCompleted();

```
###### \java\seedu\tache\model\Model.java
``` java
    /** Updates the filter of the current filtered task list to reflect changes */
    void updateCurrentFilteredList();
}
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    public static final int MARGIN_OF_ERROR = 1;
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    public static final String FOUND_TASK_LIST_TYPE = "Found Tasks";
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    private final TaskManager taskManager;
    private final FilteredList<ReadOnlyTask> filteredTasks;

    private Set<String> latestKeywords;
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowUncompleted() {
        updateFilteredTaskList(new PredicateExpression(new ActiveQualifier(true)));
        updateFilteredTaskListType(UNCOMPLETED_TASK_LIST_TYPE);

    }

    @Override
    public void updateFilteredListToShowCompleted() {
        updateFilteredTaskList(new PredicateExpression(new ActiveQualifier(false)));
        updateFilteredTaskListType(COMPLETED_TASK_LIST_TYPE);
    }

```
###### \java\seedu\tache\model\ModelManager.java
``` java
    private void retainLatestKeywords(Set<String> keywords) {
        latestKeywords = keywords;
    }

    public void updateCurrentFilteredList() {
        switch(filteredTaskListType) {
        case ALL_TASK_LIST_TYPE:
            updateFilteredListToShowAll();
            break;
        case COMPLETED_TASK_LIST_TYPE:
            updateFilteredListToShowCompleted();
            break;
        case UNCOMPLETED_TASK_LIST_TYPE:
            updateFilteredListToShowUncompleted();
            break;
        case TIMED_TASK_LIST_TYPE:
            updateFilteredListToShowTimed();
            break;
        case FLOATING_TASK_LIST_TYPE:
            updateFilteredListToShowFloating();
            break;
        case FOUND_TASK_LIST_TYPE:
            updateFilteredTaskList(latestKeywords);
            break;
        case DUE_TODAY_TASK_LIST_TYPE:
            updateFilteredListToShowDueToday();
            break;
        case DUE_THIS_WEEK_TASK_LIST_TYPE:
            updateFilteredListToShowDueThisWeek();
            break;
        default:
        }
    }
```
###### \java\seedu\tache\model\ModelManager.java
``` java
        @Override
        public boolean run(ReadOnlyTask task) {
            String[] nameElements = task.getName().fullName.split(" ");
            boolean partialMatch = false;
            String trimmedNameKeyWords = nameKeyWords.toString()
                                         .substring(1, nameKeyWords.toString().length() - 1).toLowerCase();
            for (int i = 0; i < nameElements.length; i++) {
                if (computeLevenshteinDistance(trimmedNameKeyWords, nameElements[i].toLowerCase()) <= MARGIN_OF_ERROR) {
                    partialMatch = true;
                    break;
                }
            }
            return nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(task.getName().fullName, keyword))
                    .findAny()
                    .isPresent()
                    || partialMatch;
        }
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    private class ActiveQualifier implements Qualifier {
        private boolean isActive;

        ActiveQualifier(boolean isActive) {
            this.isActive = isActive;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            if (isActive) {
                return task.getActiveStatus();
            } else {
                return !task.getActiveStatus();
            }
        }

        @Override
        public String toString() {
            return "active=" + isActive;
        }
    }
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    private class DateTimeQualifier implements Qualifier {
        private Set<String> dateTimeKeyWords;

        DateTimeQualifier(Set<String> dateTimeKeyWords) {
            this.dateTimeKeyWords = dateTimeKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            if (task.getStartDateTime().isPresent()) {
                for (int i = 0; i < dateTimeKeyWords.size(); i++) {
                    if (dateTimeKeyWords.toArray()[i].equals(task.getStartDateTime().get().getDateOnly()) ||
                                dateTimeKeyWords.toArray()[i].equals(task.getStartDateTime().get().getTimeOnly())) {
                        return true;
                    }
                }
            }
            if (task.getEndDateTime().isPresent()) {
                for (int i = 0; i < dateTimeKeyWords.size(); i++) {
                    if (dateTimeKeyWords.toArray()[i].equals(task.getEndDateTime().get().getDateOnly()) ||
                                dateTimeKeyWords.toArray()[i].equals(task.getEndDateTime().get().getTimeOnly())) {
                        return true;
                    }
                }
            }
            return false;
        }

        @Override
        public String toString() {
            return "datetime=" + String.join(", ", dateTimeKeyWords);
        }

    }

    private class MultiQualifier implements Qualifier {
        private Set<String> multiKeyWords;
        private NameQualifier nameQualifier;
        private DateTimeQualifier dateTimeQualifier;
        private ActiveQualifier activeQualifier;

        MultiQualifier(Set<String> multiKeyWords) {
            this.multiKeyWords = multiKeyWords;
            nameQualifier = new NameQualifier(multiKeyWords);
            dateTimeQualifier = new DateTimeQualifier(multiKeyWords);
            activeQualifier = new ActiveQualifier(true);
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return (nameQualifier.run(task) || dateTimeQualifier.run(task)) && activeQualifier.run(task);
        }

        @Override
        public String toString() {
            return "multi=" + String.join(", ", multiKeyWords);
        }

    }

    private class ActiveTimedQualifier implements Qualifier {
        private TimedQualifier timedQualifier;
        private ActiveQualifier activeQualifier;

        ActiveTimedQualifier(boolean isTimed) {
            timedQualifier = new TimedQualifier(isTimed);
            activeQualifier = new ActiveQualifier(true);
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return timedQualifier.run(task) && activeQualifier.run(task);
        }

        @Override
        public String toString() {
            return "activetimed";
        }

    }

    private int computeLevenshteinDistance(CharSequence str1, CharSequence str2) {
        int[][] distance = new int[str1.length() + 1][str2.length() + 1];

        for (int i = 0; i <= str1.length(); i++) {
            distance[i][0] = i;
        }
        for (int j = 1; j <= str2.length(); j++) {
            distance[0][j] = j;
        }
        for (int i = 1; i <= str1.length(); i++) {
            for (int j = 1; j <= str2.length(); j++) {
                distance[i][j] =
                 minimum(
                    distance[i - 1][j] + 1,
                    distance[i][j - 1] + 1,
                    distance[i - 1][j - 1] +
                        ((str1.charAt(i - 1) == str2.charAt(j - 1)) ? 0 : 1));
            }
        }
        return distance[str1.length()][str2.length()];
    }

    private int minimum(int a, int b, int c) {
        return Math.min(Math.min(a, b), c);
    }

    private ObservableList<ReadOnlyTask> populateUncompletedRecurringDatesAsTask() {
        List<ReadOnlyTask> concatenated = new ArrayList<>();
        for (int i = 0; i < filteredTasks.size(); i++) {
            if (filteredTasks.get(i).getRecurringStatus()) {
                if (filteredTaskListType.equals(DUE_TODAY_TASK_LIST_TYPE)) {
                    Collections.addAll(concatenated, filteredTasks.get(i)
                                                .getUncompletedRecurList(new Date()).toArray());
                } else if (filteredTaskListType.equals(DUE_TODAY_TASK_LIST_TYPE)) {
                    Calendar dateThisWeek = Calendar.getInstance();
                    dateThisWeek.setTime(new Date());
                    dateThisWeek.add(Calendar.WEEK_OF_YEAR, 1);
                    Collections.addAll(concatenated, filteredTasks.get(i)
                                                .getUncompletedRecurList(dateThisWeek.getTime()).toArray());
                } else {
                    Collections.addAll(concatenated, filteredTasks.get(i).getUncompletedRecurList(null).toArray());
                }
            }
        }
        Collections.addAll(concatenated, filteredTasks.toArray());
        return FXCollections.observableList(concatenated);
    }

    public ObservableList<ReadOnlyTask> getAllRecurringGhostTasks() {
        List<ReadOnlyTask> concatenated = new ArrayList<>();
        for (int i = 0; i < taskManager.getTaskList().size(); i++) {
            if (taskManager.getTaskList().get(i).getRecurringStatus()) {
                Collections.addAll(concatenated, taskManager.getTaskList().get(i)
                                            .getUncompletedRecurList(null).toArray());
            }
        }
        return FXCollections.observableList(concatenated);
    }
```
###### \java\seedu\tache\model\task\DateTime.java
``` java
package seedu.tache.model.task;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.List;

import org.ocpsoft.prettytime.PrettyTime;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

import seedu.tache.commons.exceptions.IllegalValueException;


public class DateTime {

    private static final String EXPLICIT_DATE_TREE_IDENTIFIER = "EXPLICIT_DATE";
    private static final String EXPLICIT_TIME_TREE_IDENTIFIER = "EXPLICIT_TIME";

    public static final String MESSAGE_DATE_CONSTRAINTS = "Unknown date format. It is recommended to "
                                        + "interchangeably use the following few formats:"
                                        + "\nMM-DD-YY hh:mm:ss or MM/DD/YY 10.30pm";

    public static final String DEFAULT_TIME_STRING = "00:00:00";

    private final Date date;

    /**
     * Validates given date.
     *
     * @throws IllegalValueException if given date string is invalid.
     */
    public DateTime(String date) throws IllegalValueException {
        assert date != null;
        String trimmedStartDate = date.trim();
        List<DateGroup> temp = new Parser().parse(trimmedStartDate);
        if (temp.isEmpty()) {
            throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS);
        }
        this.date = temp.get(0).getDates().get(0);
        String syntaxTree = temp.get(0).getSyntaxTree().toStringTree();
        boolean hasExplicitDate = syntaxTree.contains(EXPLICIT_DATE_TREE_IDENTIFIER);
        boolean hasExplicitTime = syntaxTree.contains(EXPLICIT_TIME_TREE_IDENTIFIER);
        if (hasExplicitDate ^ hasExplicitTime) {
            if (hasExplicitDate) {
                this.date.setHours(0);
                this.date.setMinutes(0);
                this.date.setSeconds(0);
            }
        }
    }

    @Override
    public String toString() {
        return new PrettyTime().format(date);
    }

    public String getDateOnly() {
        SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
        return sdf.format(date);
    }

    public void setDateOnly(String date) throws IllegalValueException {
        List<DateGroup> temp = new Parser().parse(date);
        if (temp.isEmpty()) {
            throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS);
        }
        Date parsedDate = temp.get(0).getDates().get(0);
        this.date.setDate(parsedDate.getDate());
        this.date.setMonth(parsedDate.getMonth());
        this.date.setYear(parsedDate.getYear());
    }

    public void setTimeOnly(String time) throws IllegalValueException {
        List<DateGroup> temp = new Parser().parse(time);
        if (temp.isEmpty()) {
            throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS);
        }
        Date parsedTime = temp.get(0).getDates().get(0);
        this.date.setHours(parsedTime.getHours());
        this.date.setMinutes(parsedTime.getMinutes());
        this.date.setSeconds(parsedTime.getSeconds());
    }

    public void setDefaultTime() throws IllegalValueException {
        setTimeOnly(DEFAULT_TIME_STRING);
    }

    public String getTimeOnly() {
        SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss");
        return sdf.format(date);
    }

    public String getAmericanDateTime() {
        SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss");
        return sdf.format(date);
    }

    public String getAmericanDateOnly() {
        SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy");
        return sdf.format(date);
    }

```
###### \java\seedu\tache\model\task\Task.java
``` java
    @Override
    public boolean getRecurringStatus() {
        return isRecurring;
    }

    public void setRecurringStatus(boolean isRecurring) {
        this.isRecurring = isRecurring;
    }

    @Override
    public RecurInterval getRecurInterval() {
        return interval;
    }

    public void setRecurInterval(RecurInterval interval) {
        this.interval = interval;
    }

    @Override
    public boolean isMasterRecurring() {
        return this.isRecurring && this.recurDisplayDate.equals("");
    }

    @Override
    public List<Date> getRecurCompletedList() {
        return this.recurCompletedList;
    }

    public void setRecurCompletedList(List<Date> recurCompletedList) {
        this.recurCompletedList = recurCompletedList;
    }

    public List<Task> getUncompletedRecurList(Date endingRangeDate) {
        List<Task> uncompletedRecurList = new ArrayList<Task>();
        if (startDateTime.isPresent() && isRecurring) {
            Date currentDate = new Date(startDateTime.get().getAmericanDateOnly()
                                            + " " + startDateTime.get().getTimeOnly());
            Calendar calendarNow = Calendar.getInstance();
            if (endingRangeDate == null) {
                calendarNow.setTime(new Date());
                if (interval.equals(RecurInterval.DAY)) {
                    calendarNow.add(Calendar.WEEK_OF_YEAR, 2);
                } else if (interval.equals(RecurInterval.WEEK)) {
                    calendarNow.add(Calendar.MONTH, 2);
                } else if (interval.equals(RecurInterval.MONTH)) {
                    calendarNow.add(Calendar.YEAR, 1);
                } else if (interval.equals(RecurInterval.YEAR)) {
                    calendarNow.add(Calendar.YEAR, 5);
                }
            } else {
                calendarNow.setTime(endingRangeDate);
            }
            while ((currentDate.before(calendarNow.getTime())
                    || (currentDate.getDate() == calendarNow.get(Calendar.DAY_OF_MONTH)
                    && currentDate.getMonth() == calendarNow.get(Calendar.MONTH)
                    && currentDate.getYear() == calendarNow.get(Calendar.YEAR)))) {
                if (endDateTime.isPresent()) {
                    if (currentDate.after(new Date(endDateTime.get().getAmericanDateOnly()
                                            + " " + endDateTime.get().getTimeOnly()))) {
                        break;
                    }
                }
                Task temp = new Task(this);
                if (!temp.isRecurCompleted(currentDate)) {
                    DateFormat df = new SimpleDateFormat("MM/dd/yyyy");
                    String tempDate = df.format(currentDate);
                    temp.setRecurDisplayDate(tempDate);
                    uncompletedRecurList.add(temp);
                }
                Calendar calendar = Calendar.getInstance();
                calendar.setTime(currentDate);
                if (temp.interval == RecurInterval.DAY) {
                    calendar.add(Calendar.DATE, 1);
                    currentDate = calendar.getTime();
                } else if (temp.interval == RecurInterval.WEEK) {
                    calendar.add(Calendar.WEEK_OF_YEAR, 1);
                    currentDate = calendar.getTime();
                } else if (temp.interval == RecurInterval.MONTH) {
                    calendar.add(Calendar.MONTH, 1);
                    currentDate = calendar.getTime();
                } else if (temp.interval == RecurInterval.YEAR) {
                    calendar.add(Calendar.YEAR, 1);
                    currentDate = calendar.getTime();
                }
            }
        }
        return uncompletedRecurList;

    }

    public boolean isRecurCompleted(Date recurCompleted) {
        DateFormat outputFormatter = new SimpleDateFormat("MM/dd/yyyy");
        for (int i = 0; i < getRecurCompletedList().size(); i++) {
            if (outputFormatter.format(getRecurCompletedList().get(i))
                                .equals(outputFormatter.format(recurCompleted))) {
                return true;
            }
        }
        return false;
    }

    public String getRecurDisplayDate() {
        return this.recurDisplayDate;
    }

    public void setRecurDisplayDate(String recurDisplayDate) {
        this.recurDisplayDate = recurDisplayDate;
    }
```
###### \java\seedu\tache\ui\HotkeyManager.java
``` java
package seedu.tache.ui;

import java.awt.AWTException;
import java.awt.MenuItem;
import java.awt.PopupMenu;
import java.awt.SystemTray;
import java.awt.TrayIcon;
import java.awt.TrayIcon.MessageType;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.Timer;
import java.util.TimerTask;

import javax.swing.ImageIcon;
import javax.swing.KeyStroke;

import com.tulskiy.keymaster.common.HotKey;
import com.tulskiy.keymaster.common.HotKeyListener;
import com.tulskiy.keymaster.common.Provider;

import javafx.application.Platform;
import javafx.stage.Stage;

public class HotkeyManager {
    public static final String DEFAULT_HOTKEY_COMBINATION = "control alt D";
    public static final String LUCKY_DRAW_NOTIFICATION_COMBINATION = "alt Q";

    private Provider hotkeyManager;
    private Stage stage;
    private String hotkeyCombination;
    private Timer notificationTimer;

    public HotkeyManager(Stage stage) {
        this.stage = stage;
        this.hotkeyCombination = DEFAULT_HOTKEY_COMBINATION;
        this.notificationTimer = new Timer();
    }

    public HotkeyManager(Stage stage, String hotkeyCombination) {
        this.stage = stage;
        this.hotkeyCombination = hotkeyCombination;
        this.notificationTimer = new Timer();
    }

    /**
     * Bind show/hide (toggle) hotkey
     */
    private void bindToggleSystemHotkey() {
        if (hotkeyManager == null) {
            hotkeyManager = Provider.getCurrentProvider(false);
        }
        hotkeyManager.register(KeyStroke.getKeyStroke(hotkeyCombination), new HotKeyListener() {
            public void onHotKey(HotKey hotKey) {
                System.out.println(hotKey);
                if (stage.isFocused()) {
                    if (stage.isIconified()) {
                        Platform.runLater(()-> {
                            stage.setIconified(false); });
                    } else {
                        Platform.runLater(()-> {
                            stage.setIconified(true); });
                    }
                } else {
                    Platform.runLater(()-> {
                        stage.setIconified(false);
                        stage.toFront(); });
                }
            }
        });
    }

    /**
     * Bind lucky draw notification trigger hotkey
     */
    private void bindTriggerNotificationHotkey() {
        if (hotkeyManager == null) {
            hotkeyManager = Provider.getCurrentProvider(false);
        }
        hotkeyManager.register(KeyStroke.getKeyStroke(LUCKY_DRAW_NOTIFICATION_COMBINATION), new HotKeyListener() {
            public void onHotKey(HotKey hotKey) {
                System.out.println(hotKey);
                Platform.runLater(()-> {
                    notificationTimer.schedule(new TimerTask() {
                        @Override
                        public void run() {
                            try {
                                SystemTray tray = SystemTray.getSystemTray();
                                ImageIcon icon = new ImageIcon(getClass().getResource("/images/info_icon.png"));
                                java.awt.Image image = icon.getImage();
                                TrayIcon trayIcon = new TrayIcon(image, "notification");
                                trayIcon.setImageAutoSize(true);
                                trayIcon.setToolTip("Lucky Draw Reminder");

                                MenuItem dismissMenuItem = new MenuItem("Dismiss");
                                dismissMenuItem.addActionListener(new ActionListener() {
                                    @Override
                                    public void actionPerformed(ActionEvent e) {
                                        tray.remove(trayIcon);
                                    }
                                });

                                PopupMenu popupMenu = new PopupMenu();
                                popupMenu.add(dismissMenuItem);

                                trayIcon.setPopupMenu(popupMenu);
                                tray.add(trayIcon);
                                trayIcon.displayMessage("Lucky Draw Reminder",
                                                        "This task is due now.", MessageType.INFO);
                            } catch (AWTException e) {
                                e.printStackTrace();
                            }
                        }
                    }, 0); //0 indicate that it will only be scheduled once
                });
            }
        });
    }

    /**
     * Starts binding of toggle hotkey
     */
    public void start() {
        bindToggleSystemHotkey();
        bindTriggerNotificationHotkey();
    }

    /**
     * Stops binding of toggle hotkey
     */
    public void stop() {
        if (hotkeyManager != null) {
            hotkeyManager.reset();
            hotkeyManager.stop();
            notificationTimer.cancel();
        }
    }
}
```
###### \java\seedu\tache\ui\MainWindow.java
``` java
    public CalendarPanel getCalendarPanel() {
        return this.calendarPanel;
    }

```
###### \java\seedu\tache\ui\TaskListPanel.java
``` java
    public void resetConnections(ObservableList<ReadOnlyTask> taskList) {
        setConnections(taskList);
    }
```
###### \java\seedu\tache\ui\UiManager.java
``` java
    @Subscribe
    private void handleTaskPanelConnectionChangedEvent(TaskPanelConnectionChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        if (mainWindow.getTaskListPanel() != null) {
            mainWindow.getTaskListPanel().resetConnections(event.getNewConnection());
        }
    }

    @Subscribe
    private void handlePopulateRecurringGhostTaskEvent(PopulateRecurringGhostTaskEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        if (mainWindow.getTaskListPanel() != null) {
            mainWindow.getCalendarPanel().addAllEvents(event.getAllRecurringGhostTasks());;
        }
    }

    @Subscribe
    public void handleUpdateNotificationsEvent(TaskManagerChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        notificationManager.updateNotifications(event);
    }

}
```
