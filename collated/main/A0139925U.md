# A0139925U
###### \java\seedu\tache\commons\events\ui\PopulateRecurringGhostTaskEvent.java
``` java
package seedu.tache.commons.events.ui;

import javafx.collections.ObservableList;
import seedu.tache.commons.events.BaseEvent;
import seedu.tache.model.task.ReadOnlyTask;

/**
 * Represents an event adding recurring 'Ghost' task into the Task List Panel
 */
public class PopulateRecurringGhostTaskEvent extends BaseEvent {


    private final ObservableList<ReadOnlyTask> allUncompletedRecurringGhostTasks;
    private final ObservableList<ReadOnlyTask> allCompletedRecurringGhostTasks;

    public PopulateRecurringGhostTaskEvent(ObservableList<ReadOnlyTask> allUncompletedRecurringGhostTasks,
                                    ObservableList<ReadOnlyTask> allCompletedRecurringGhostTasks) {
        this.allUncompletedRecurringGhostTasks = allUncompletedRecurringGhostTasks;
        this.allCompletedRecurringGhostTasks = allCompletedRecurringGhostTasks;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public ObservableList<ReadOnlyTask> getAllUncompletedRecurringGhostTasks() {
        return allUncompletedRecurringGhostTasks;
    }

    public ObservableList<ReadOnlyTask> getAllCompletedRecurringGhostTasks() {
        return allCompletedRecurringGhostTasks;
    }
}
```
###### \java\seedu\tache\commons\events\ui\TaskPanelConnectionChangedEvent.java
``` java
package seedu.tache.commons.events.ui;

import javafx.collections.ObservableList;
import seedu.tache.commons.events.BaseEvent;
import seedu.tache.model.task.ReadOnlyTask;

/**
 * Represents a connection change in the Task List Panel.
 */
public class TaskPanelConnectionChangedEvent extends BaseEvent {


    private final ObservableList<ReadOnlyTask> newConnection;

    public TaskPanelConnectionChangedEvent(ObservableList<ReadOnlyTask> newConnection) {
        this.newConnection = newConnection;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public ObservableList<ReadOnlyTask> getNewConnection() {
        return newConnection;
    }
}
```
###### \java\seedu\tache\logic\commands\CompleteCommand.java
``` java
package seedu.tache.logic.commands;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;

import seedu.tache.commons.core.Messages;
import seedu.tache.logic.commands.exceptions.CommandException;
import seedu.tache.model.task.ReadOnlyTask;
import seedu.tache.model.task.Task;
import seedu.tache.model.task.UniqueTaskList;

/**
 * Mark existing task(s) as completed
 */
public class CompleteCommand extends Command implements Undoable {

    public static final String COMMAND_WORD = "complete";
    public static final String SHORT_COMMAND_WORD = "c";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Completes the task identified "
            + "by the index number used in the last tasks listing. "
            + "Existing values will be overwritten by the input values.\n"
            + "Parameters: INDEX1 (must be a positive integer), INDEX2, INDEX3, ... \n"
            + "Example: " + COMMAND_WORD + " 1, 2, 6, 8";

    public static final String MESSAGE_COMPLETED_TASK_SUCCESS = "Completed Task(s): \n%1$s";
    public static final String MESSAGE_NOT_COMPLETED = "At least one task's index must be provided.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";

    private final List<Integer> indexList;

    private boolean commandSuccess;
    private List<ReadOnlyTask> completedList;

    /**
     * @param {@code indexList}, the list of indexes that will be marked as completed
     */
    public CompleteCommand(List<Integer> indexList) {
        assert indexList.size() > 0;
        this.indexList = indexList;

        // converts indexList from one-based to zero-based.
        for (int i = 0; i < indexList.size(); i++) {
            this.indexList.set(i, indexList.get(i) - 1);
        }
        Collections.reverse(indexList);
        completedList = new ArrayList<ReadOnlyTask>();
        commandSuccess = false;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = new ArrayList<ReadOnlyTask>(model.getFilteredTaskList());

        ArrayList<ReadOnlyTask> tasksToEdit = new ArrayList<ReadOnlyTask>();
        ArrayList<ReadOnlyTask> completedTasks = new ArrayList<ReadOnlyTask>();

        checkAllIndexValid(lastShownList);

        commandSuccess = processNonRecurringTask(lastShownList, tasksToEdit, completedTasks)
                        && processRecurringTask(lastShownList, tasksToEdit, completedTasks);

        UndoHistory.getInstance().push(this);

        return new CommandResult(String.format(MESSAGE_COMPLETED_TASK_SUCCESS, getSuccessMessage(completedList)));
    }

    /**
     * Checks that all indexes given in the input is valid.
     * @throws CommandException, if any of the indexes is detected as invalid
     * @param {@code lastShownList}, is used to determine the max size;
     */
    private void checkAllIndexValid(List<ReadOnlyTask> lastShownList) throws CommandException {
        for (int i = 0; i < indexList.size(); i++) {
            if (indexList.get(i) >= lastShownList.size()) {
                throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
            }
        }
    }

    /**
     * Processes all non-recurring tasks, marking them as completed
     * @throws CommandException, if duplicates are detected
     * @param {@code lastShownList}, is used get the corresponding task object;
     * @param {@code tasksToEdit}, stores all original uncompleted tasks in this process;
     * @param {@code completedTasks}, stores all modified completed tasks in this process;
     */
    private boolean processNonRecurringTask(List<ReadOnlyTask> lastShownList,
                                            ArrayList<ReadOnlyTask> tasksToEdit,
                                            ArrayList<ReadOnlyTask> completedTasks) throws CommandException {
        for (int i = 0; i < indexList.size(); i++) {
            ReadOnlyTask taskToEdit = lastShownList.get(indexList.get(i));
            if (taskToEdit.getRecurState().isRecurring()) {
                continue;
            } else {
                Task completedTask = createCompletedTask(taskToEdit);
                completedTasks.add(completedTask);
                tasksToEdit.add(taskToEdit);
            }
        }
        ReadOnlyTask[] arrayListMould = new ReadOnlyTask[0];
        try {
            completedList = model.updateMultipleTasks(
                    tasksToEdit.toArray(arrayListMould), completedTasks.toArray(arrayListMould));
        } catch (UniqueTaskList.DuplicateTaskException dpe) {
            assert false : "There shouldn't be a duplicate task";
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        return true;
    }

    /**
     * Processes all recurring tasks, marking them as completed
     * @throws CommandException, if duplicates are detected
     * @param {@code lastShownList}, is used get the corresponding task object;
     * @param {@code tasksToEdit}, stores all original uncompleted tasks in this process;
     * @param {@code completedTasks}, stores all modified completed tasks in this process;
     */
    private boolean processRecurringTask(List<ReadOnlyTask> lastShownList,
                                        ArrayList<ReadOnlyTask> tasksToEdit,
                                        ArrayList<ReadOnlyTask> completedTasks) throws CommandException {
        for (int i = 0; i < indexList.size(); i++) {
            ReadOnlyTask taskToEdit = lastShownList.get(indexList.get(i));
            Task completedTask = createCompletedTask(taskToEdit);
            try {
                if (taskToEdit.getRecurState().isRecurring()) {
                    if (taskToEdit.getRecurState().isRecurring()) {
                        model.updateTask(createMasterRecurringTask(taskToEdit), completedTask);
                    } else {
                        model.updateTask(taskToEdit, completedTask);
                    }
                    completedList.add(completedTask);
                }
            } catch (UniqueTaskList.DuplicateTaskException dpe) {
                throw new CommandException(MESSAGE_DUPLICATE_TASK);
            }
        }
        return true;
    }

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     */
    private static Task createCompletedTask(ReadOnlyTask taskToEdit) {
        assert taskToEdit != null;
        if (taskToEdit.getRecurState().isGhostRecurring()) {
            List<Date> tempList = taskToEdit.getRecurState().getRecurCompletedList();
            tempList.add(new Date(taskToEdit.getRecurState().getRecurDisplayDate()));
            ((Task) taskToEdit).getRecurState().setRecurDisplayDate("");
            return new Task(taskToEdit.getName(), taskToEdit.getStartDateTime(), taskToEdit.getEndDateTime(),
                            taskToEdit.getTags(), taskToEdit.getActiveStatus(),
                            taskToEdit.getRecurState().getRecurInterval(), tempList);
        } else {
            return new Task(taskToEdit.getName(), taskToEdit.getStartDateTime(), taskToEdit.getEndDateTime(),
                            taskToEdit.getTags(), false,
                            taskToEdit.getRecurState().getRecurInterval(),
                            taskToEdit.getRecurState().getRecurCompletedList());
        }
    }

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     */
    private static Task createUncompletedTask(ReadOnlyTask taskToEdit) {
        assert taskToEdit != null;

        if (taskToEdit.getRecurState().isMasterRecurring()) {
            List<Date> tempList = taskToEdit.getRecurState().getRecurCompletedList();
            tempList.remove(tempList.size() - 1);
            return new Task(taskToEdit.getName(), taskToEdit.getStartDateTime(), taskToEdit.getEndDateTime(),
                                taskToEdit.getTags(), true,
                                taskToEdit.getRecurState().getRecurInterval(), tempList);
        } else {
            return new Task(taskToEdit.getName(), taskToEdit.getStartDateTime(), taskToEdit.getEndDateTime(),
                                taskToEdit.getTags(), true,
                                taskToEdit.getRecurState().getRecurInterval(),
                                taskToEdit.getRecurState().getRecurCompletedList());
        }

    }

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     */
    private static Task createMasterRecurringTask(ReadOnlyTask taskToEdit) {
        assert taskToEdit != null;
        ((Task) taskToEdit).getRecurState().setRecurDisplayDate("");
        return new Task(taskToEdit.getName(), taskToEdit.getStartDateTime(), taskToEdit.getEndDateTime(),
                            taskToEdit.getTags(), taskToEdit.getActiveStatus(),
                            taskToEdit.getRecurState().getRecurInterval(),
                            taskToEdit.getRecurState().getRecurCompletedList());

    }

    /**
     * Creates and returns a formatted String message with the details of {@code completedList}
     */
    private static String getSuccessMessage(List<ReadOnlyTask> completedList) {
        assert completedList != null;
        String successMessage = "";
        for (int i = 0; i < completedList.size(); i++) {
            successMessage += completedList.get(i).getAsText();
        }
        return successMessage;
    }

    @Override
    public boolean isUndoable() {
        return commandSuccess;
    }

    /**
     * Undo any changes made by this command
     */
    @Override
    public String undo() throws CommandException {
        for (int i = 0; i < completedList.size(); i++) {
            try {
                ReadOnlyTask original = completedList.get(i);
                ReadOnlyTask revert = createUncompletedTask(completedList.get(i));
                model.updateTask(original, revert);
            } catch (UniqueTaskList.DuplicateTaskException dpe) {
                throw new CommandException(MESSAGE_DUPLICATE_TASK);
            }
        }
        return String.format(MESSAGE_COMPLETED_TASK_SUCCESS, completedList);
    }
}
```
###### \java\seedu\tache\logic\commands\DeleteCommand.java
``` java
    /**
     * Checks that the given tasks is not a recurring 'Ghost' task
     * @throws IllegalValueException if task given is a 'Ghost' task
     * @param {@code taskToEdit}, the task that needs checking
     */
    private void checkPartOfRecurringTask(ReadOnlyTask taskToEdit) throws IllegalValueException {
        if (taskToEdit.getRecurState().isGhostRecurring()) {
            throw new IllegalValueException(MESSAGE_PART_OF_RECURRING_TASK);
        }
    }

```
###### \java\seedu\tache\logic\commands\EditCommand.java
``` java
package seedu.tache.logic.commands;

import java.util.Date;
import java.util.List;
import java.util.Optional;

import seedu.tache.commons.core.EventsCenter;
import seedu.tache.commons.core.Messages;
import seedu.tache.commons.events.ui.JumpToListRequestEvent;
import seedu.tache.commons.exceptions.IllegalValueException;
import seedu.tache.commons.util.CollectionUtil;
import seedu.tache.logic.commands.exceptions.CommandException;
import seedu.tache.model.recurstate.RecurState.RecurInterval;
import seedu.tache.model.tag.UniqueTagList;
import seedu.tache.model.task.DateTime;
import seedu.tache.model.task.Name;
import seedu.tache.model.task.ReadOnlyTask;
import seedu.tache.model.task.Task;
import seedu.tache.model.task.UniqueTaskList;
import seedu.tache.model.task.UniqueTaskList.DuplicateTaskException;

/**
 * Edits the details of an existing task in the task manager.
 */
public class EditCommand extends Command implements Undoable {

    public static final String COMMAND_WORD = "edit";
    public static final String SHORT_COMMAND_WORD = "e";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Edits the details of the task identified "
            + "by the index number used in the last tasks listing. "
            + "Existing values will be overwritten by the input values.\n"
            + "Parameters: INDEX (must be a positive integer) change <parameter1> to <new_value1> and "
            + "<parameter2> to <new_value2>...\n"
            + "Example: " + COMMAND_WORD + " 1 change startdate to 10 nov and change starttime to 3.30pm";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Task: \n%1$s";
    public static final String MESSAGE_NOT_EDITED = "No valid parameter detected to edit.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";
    public static final String MESSAGE_INVALID_DATE_RANGE = "Start date can not be before end date";
    public static final String MESSAGE_PART_OF_RECURRING_TASK =
                        "This task is part of a recurring task and cannot be edited.";
    public static final String MESSAGE_REQUIRE_BOTH_START_END = "Recurring tasks requires both start date and end date";

    public static final String SPECIAL_CASE_TIME_STRING = "23:59:59";

    private final int filteredTaskListIndex;
    private final EditTaskDescriptor editTaskDescriptor;

    private boolean commandSuccess;
    private ReadOnlyTask taskToEdit;
    private ReadOnlyTask originalTask;

    /**
     * @param filteredTaskListIndex the index of the task in the filtered task list to edit
     * @param editTaskDescriptor details to edit the task with
     */
    public EditCommand(int filteredTaskListIndex, EditTaskDescriptor editTaskDescriptor) {
        assert filteredTaskListIndex > 0;
        assert editTaskDescriptor != null;

        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;

        this.editTaskDescriptor = new EditTaskDescriptor(editTaskDescriptor);
        commandSuccess = false;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        taskToEdit = lastShownList.get(filteredTaskListIndex);
        cloneOriginalTask(taskToEdit);
        Task editedTask;
        try {
            checkPartOfRecurringTask(taskToEdit);
            editedTask = createEditedTask(taskToEdit, editTaskDescriptor);
            try {
                model.updateTask(taskToEdit, editedTask);
            } catch (UniqueTaskList.DuplicateTaskException dpe) {
                throw new CommandException(MESSAGE_DUPLICATE_TASK);
            }
            //model.updateCurrentFilteredList();
            commandSuccess = true;
            UndoHistory.getInstance().push(this);
            EventsCenter.getInstance().post(new JumpToListRequestEvent(model.getFilteredTaskListIndex(taskToEdit)));
            return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
        } catch (IllegalValueException e) {
            return new IncorrectCommand(e.getMessage()).execute();
        }
    }

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     * @param {@code taskToEdit}, task that needs editing
     * @param {@code editTaskDescriptor}, edit details
     * @throws IllegalValueException if date or time could not be parsed
     * or if user is trying to edit a non-recurring task into a recurring task without both start date and end date
     */
    private static Task createEditedTask(ReadOnlyTask taskToEdit,
                                             EditTaskDescriptor editTaskDescriptor) throws IllegalValueException {
        assert taskToEdit != null;

        Name updatedName = editTaskDescriptor.getName().orElseGet(taskToEdit::getName);
        Optional<DateTime> updatedStartDateTime;
        Optional<DateTime> updatedEndDateTime;
        if (taskToEdit.getStartDateTime().isPresent()) {
            updatedStartDateTime = Optional.of(new DateTime(taskToEdit.getStartDateTime().get()));
        } else {
            updatedStartDateTime = Optional.empty();
        }
        if (taskToEdit.getEndDateTime().isPresent()) {
            updatedEndDateTime = Optional.of(new DateTime(taskToEdit.getEndDateTime().get()));
        } else {
            updatedEndDateTime = Optional.empty();
        }
        if (editTaskDescriptor.getStartDate().isPresent()) {
            if (updatedStartDateTime.isPresent()) {
                updatedStartDateTime.get().setDateOnly(editTaskDescriptor.getStartDate().get());
            } else {
                updatedStartDateTime = Optional.of(new DateTime(editTaskDescriptor.getStartDate().get()));
                updatedStartDateTime.get().setDefaultTime();
            }
        }
        if (editTaskDescriptor.getEndDate().isPresent()) {
            if (updatedEndDateTime.isPresent()) {
                updatedEndDateTime.get().setDateOnly(editTaskDescriptor.getEndDate().get());
            } else {
                updatedEndDateTime = Optional.of(new DateTime(editTaskDescriptor.getEndDate().get()));
                updatedEndDateTime.get().setDefaultTime();
            }
        }
        if (editTaskDescriptor.getStartTime().isPresent()) {
            if (updatedStartDateTime.isPresent()) {
                updatedStartDateTime.get().setTimeOnly(editTaskDescriptor.getStartTime().get());
            } else {
                updatedStartDateTime = Optional.of(new DateTime(editTaskDescriptor.getStartTime().get()));
            }
        }
        if (editTaskDescriptor.getEndTime().isPresent()) {
            if (updatedEndDateTime.isPresent()) {
                updatedEndDateTime.get().setTimeOnly(editTaskDescriptor.getEndTime().get());
            } else {
                updatedEndDateTime = Optional.of(new DateTime(editTaskDescriptor.getEndTime().get()));
            }
        }

        UniqueTagList updatedTags = editTaskDescriptor.getTags().orElseGet(taskToEdit::getTags);

        RecurInterval updatedRecurInterval = taskToEdit.getRecurState().getRecurInterval();
        if (editTaskDescriptor.getRecurringInterval().isPresent()) {
            if (updatedStartDateTime.isPresent() && updatedEndDateTime.isPresent()) {
                updatedRecurInterval = editTaskDescriptor.getRecurringInterval().get();
            } else {
                throw new IllegalValueException(MESSAGE_REQUIRE_BOTH_START_END);
            }
        }

        updatedEndDateTime = checkFloatingToNonFloatingCase(editTaskDescriptor, updatedStartDateTime,
                                                                updatedEndDateTime);
        checkValidDateRange(updatedStartDateTime, updatedEndDateTime);
        checkSpecialCase(editTaskDescriptor, updatedEndDateTime);

        return new Task(updatedName, updatedStartDateTime, updatedEndDateTime,
                            updatedTags, true, updatedRecurInterval,
                            taskToEdit.getRecurState().getRecurCompletedList());

    }

    /**
     * Check if edit causes a floating task to become non-floating with only a start date and no end date
     * @param {@code editTaskDescriptor}, edit details
     * @param {@code updatedEndDateTime}, the final end date that will be in the new edited task
     * @param {@code updatedStartDateTime}, the final start date that will be in the new edited task
     * @throws IllegalValueException if date or time could not be parsed
     * or if user is trying to edit a non-recurring task into a recurring task without both start date and end date
     */
    private static Optional<DateTime> checkFloatingToNonFloatingCase(EditTaskDescriptor editTaskDescriptor,
                                Optional<DateTime> updatedStartDateTime, Optional<DateTime> updatedEndDateTime)
                                throws IllegalValueException {
        if (!updatedEndDateTime.isPresent() && !editTaskDescriptor.getEndDate().isPresent()) {
            if (updatedStartDateTime.isPresent()) {
                //Floating Task to Non-Floating, do not allow start date only
                Optional<DateTime> temp = Optional.of(updatedStartDateTime.get());
                return temp;
            }
        }
        return updatedEndDateTime;
    }

    /**
     * Check if start date < end date
     * @param {@code updatedEndDateTime}, the final end date that will be in the new edited task
     * @param {@code updatedStartDateTime}, the final start date that will be in the new edited task
     * @throws IllegalValueException if start date > end date
     */
    private static void checkValidDateRange(Optional<DateTime> updatedStartDateTime,
                                                Optional<DateTime> updatedEndDateTime) throws IllegalValueException {
        if (updatedStartDateTime.isPresent() && updatedEndDateTime.isPresent()) {
            if (updatedStartDateTime.get().compareTo(updatedEndDateTime.get()) == 1) {
                throw new IllegalValueException(MESSAGE_INVALID_DATE_RANGE);
            }
        }
    }

    /**
     * If overdue task date's end date is changed to today and end date < now,
     * then end time would be overwritten to 2359hrs
     * @param {@code updatedEndDateTime}, the final end date that will be in the new edited task
     * @param {@code editTaskDescriptor}, edit details
     * @throws IllegalValueException if date or time could not be parsed
     */
    private static void checkSpecialCase(EditTaskDescriptor editTaskDescriptor,
                            Optional<DateTime> updatedEndDateTime) throws IllegalValueException {
        //Special case End Date -> Today will result in a default timing of 2359 instead of 0000
        if (editTaskDescriptor.getEndDate().isPresent() && updatedEndDateTime.isPresent()
                && !editTaskDescriptor.getEndTime().isPresent()) {
            if ((new DateTime(editTaskDescriptor.getEndDate().get()).isToday())
                        && updatedEndDateTime.get().getDate().before(new Date())) {
                updatedEndDateTime.get().setTimeOnly(SPECIAL_CASE_TIME_STRING);
            }
        }
    }

    /**
     * Stores the details to edit the task with. Each non-empty field value will replace the
     * corresponding field value of the task.
     */
    public static class EditTaskDescriptor {
        private Optional<Name> name = Optional.empty();
        private Optional<String> startDate = Optional.empty();
        private Optional<String> endDate = Optional.empty();
        private Optional<String> startTime = Optional.empty();
        private Optional<String> endTime = Optional.empty();
        private Optional<UniqueTagList> tags = Optional.empty();
        private Optional<RecurInterval> interval = Optional.empty();
        private Optional<Boolean> recurringStatus = Optional.empty();

        public EditTaskDescriptor() {}

        public EditTaskDescriptor(EditTaskDescriptor toCopy) {
            this.name = toCopy.getName();
            this.startDate = toCopy.getStartDate();
            this.endDate = toCopy.getEndDate();
            this.startTime = toCopy.getStartTime();
            this.endTime = toCopy.getEndTime();
            this.tags = toCopy.getTags();
            this.interval = toCopy.getRecurringInterval();
            this.recurringStatus = toCopy.getRecurringStatus();
        }

        /**
         * Returns true if at least one field is edited.
         */
        public boolean isAnyFieldEdited() {
            return CollectionUtil.isAnyPresent(this.name, this.startDate, this.endDate,
                                               this.startTime, this.endTime, this.tags,
                                               this.interval, this.recurringStatus);
        }

        public void setName(Optional<Name> name) {
            assert name != null;
            this.name = name;
        }

        public Optional<Name> getName() {
            return name;
        }

        public void setStartDate(Optional<String> date) {
            assert date != null;
            this.startDate = date;
        }

        public Optional<String> getStartDate() {
            return startDate;
        }

        public void setEndDate(Optional<String> date) {
            assert date != null;
            this.endDate = date;
        }

        public Optional<String> getEndDate() {
            return endDate;
        }

        public void setStartTime(Optional<String> startTime) {
            assert startTime != null;
            this.startTime = startTime;
        }

        public Optional<String> getStartTime() {
            return startTime;
        }

        public void setEndTime(Optional<String> endTime) {
            assert endTime != null;
            this.endTime = endTime;
        }

        public Optional<String> getEndTime() {
            return endTime;
        }

        public void setTags(Optional<UniqueTagList> tags) {
            assert tags != null;
            this.tags = tags;
        }

        public Optional<UniqueTagList> getTags() {
            return tags;
        }

        public void setRecurringInterval(Optional<RecurInterval> interval) {
            assert interval != null;
            this.interval = interval;
        }

        public Optional<RecurInterval> getRecurringInterval() {
            return interval;
        }

        public void setRecurringStatus(Optional<Boolean> recurringStatus) {
            assert recurringStatus != null;
            this.recurringStatus = recurringStatus;
        }

        public Optional<Boolean> getRecurringStatus() {
            return recurringStatus;
        }
    }

    private void cloneOriginalTask(ReadOnlyTask taskToEdit) {
        //Workaround as Java could not deep copy taskToEdit for some fields
        DateTime workAroundStartDateTime = null;
        DateTime workAroundEndDateTime = null;
        try {
            if (taskToEdit.getStartDateTime().isPresent()) {
                workAroundStartDateTime = new DateTime(taskToEdit.getStartDateTime().get().getAmericanDateTime());
            }
            if (taskToEdit.getEndDateTime().isPresent()) {
                workAroundEndDateTime = new DateTime(taskToEdit.getEndDateTime().get().getAmericanDateTime());
            }
        } catch (IllegalValueException e1) {
            e1.printStackTrace();
        }
        originalTask = new Task(taskToEdit.getName(), Optional.ofNullable(workAroundStartDateTime),
                                        Optional.ofNullable(workAroundEndDateTime), taskToEdit.getTags(),
                                        taskToEdit.getActiveStatus(),
                                        taskToEdit.getRecurState().getRecurInterval(),
                                        taskToEdit.getRecurState().getRecurCompletedList());
    }

    private void checkPartOfRecurringTask(ReadOnlyTask taskToEdit) throws IllegalValueException {
        if (taskToEdit.getRecurState().isGhostRecurring()) {
            throw new IllegalValueException(MESSAGE_PART_OF_RECURRING_TASK);
        }
    }

```
###### \java\seedu\tache\logic\commands\ListCommand.java
``` java
    public ListCommand() {
        this.filter = "uncompleted";
    }

    public ListCommand(String filter) {
        assert filter != null;
        this.filter = filter;
    }

    @Override
    public CommandResult execute() {
        switch(filter) {
        case FILTER_COMPLETED:
            model.updateFilteredListToShowCompleted();
            break;
        case FILTER_TIMED:
            model.updateFilteredListToShowTimed();
            break;
        case FILTER_FLOATING:
            model.updateFilteredListToShowFloating();
            break;
        case FILTER_DUE_TODAY:
            model.updateFilteredListToShowDueToday();
            break;
        case FILTER_DUE_THIS_WEEK:
            model.updateFilteredListToShowDueThisWeek();
            break;
        case FILTER_OVERDUE:
            model.updateFilteredListToShowOverdueTasks();
            break;
        case FILTER_ALL:
            model.updateFilteredListToShowAll();
            break;
        case FILTER_UNCOMPLETED:
        default:
            model.updateFilteredListToShowUncompleted();
            return new CommandResult(String.format(MESSAGE_SUCCESS, StringUtil.capitalizeFirstCharacter(filter)));
        }
        return new CommandResult(String.format(MESSAGE_SUCCESS, StringUtil.capitalizeFirstCharacter(filter)));
    }
}
```
###### \java\seedu\tache\logic\Logic.java
``` java
    /** Returns the filtered list of tasks */
    ObservableList<ReadOnlyTask> getFullTaskList();

```
###### \java\seedu\tache\logic\LogicManager.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getFilteredTaskList() {
        model.updateFilteredListToShowUncompleted();
        return model.getFilteredTaskList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFullTaskList() {
        List<ReadOnlyTask> concatenated = new ArrayList<>();
        Collections.addAll(concatenated, model.getTaskManager().getTaskList().toArray());
        Collections.addAll(concatenated, model.getAllCompletedRecurringGhostTasks().toArray());
        Collections.addAll(concatenated, model.getAllUncompletedRecurringGhostTasks().toArray());
        return FXCollections.observableList(concatenated);
    }

```
###### \java\seedu\tache\logic\parser\CliSyntax.java
``` java
    /* Parameter delimiter definitions */
    public static final String DELIMITER_PARAMETER = new String(";");
    public static final String DELIMITER_INDEX = new String(",");
    public static final String DELIMITER_EDIT_PARAMETER = new String(" ");

    /* Natural Language Processing definitions */
    public static final String KEYWORD_EDIT_PARAMETER_VALUE = "to";
    public static final String KEYWORD_EDIT_PARAMETER = "change";
    public static final String KEYWORD_EDIT_MULTI_PARAMETER = "and";

    /* Parameter names definitions */
    public static final String[] PARAMETER_NAME = {"name", "n"};
    public static final String[] PARAMETER_START_DATE = {"start_date", "startdate", "sd"};
    public static final String[] PARAMETER_END_DATE = {"end_date", "enddate", "ed"};
    public static final String[] PARAMETER_START_TIME = {"start_time", "starttime", "st"};
    public static final String[] PARAMETER_END_TIME = {"end_time", "endtime", "et"};
    public static final String[] PARAMETER_TAG = {"tag", "t"};
    public static final String[] PARAMETER_RECUR_INTERVAL = {"recur_interval", "recurinterval", "ri"};
    public static final String[] PARAMETER_RECUR_STATUS = {"recur_status", "recurstatus", "rs"};

    /* List filter definitions */
    public static final String FILTER_COMPLETED = "completed";
    public static final String FILTER_UNCOMPLETED = "uncompleted";
    public static final String FILTER_ALL = "all";
```
###### \java\seedu\tache\logic\parser\CompleteCommandParser.java
``` java
package seedu.tache.logic.parser;

import static seedu.tache.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.tache.logic.parser.CliSyntax.DELIMITER_INDEX;

import java.util.ArrayList;
import java.util.List;

import seedu.tache.commons.util.StringUtil;
import seedu.tache.logic.commands.Command;
import seedu.tache.logic.commands.CompleteCommand;
import seedu.tache.logic.commands.IncorrectCommand;


/**
 * Parses input arguments and creates a new EditCommand object
 */
public class CompleteCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the EditCommand
     * and returns an EditCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;
        String[] preambleFields = args.trim().split(DELIMITER_INDEX);
        if (preambleFields.length == 0 || args.trim().equals("")) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, CompleteCommand.MESSAGE_USAGE));
        }

        List<Integer> indexList = new ArrayList<Integer>();
        for (int i = 0; i < preambleFields.length; i++) {
          //Checking all arguments are valid and creating list
            String currentIndex = preambleFields[i].trim();
            if (!StringUtil.isUnsignedInteger(currentIndex)) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                                                CompleteCommand.MESSAGE_USAGE));
            } else {
                indexList.add(Integer.parseInt(currentIndex));
            }
        }

        return new CompleteCommand(indexList);
    }

}
```
###### \java\seedu\tache\logic\parser\EditCommandParser.java
``` java
package seedu.tache.logic.parser;

import static seedu.tache.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.tache.logic.parser.CliSyntax.DELIMITER_EDIT_PARAMETER;
import static seedu.tache.logic.parser.CliSyntax.DELIMITER_PARAMETER;
import static seedu.tache.logic.parser.CliSyntax.KEYWORD_EDIT_MULTI_PARAMETER;
import static seedu.tache.logic.parser.CliSyntax.KEYWORD_EDIT_PARAMETER;
import static seedu.tache.logic.parser.CliSyntax.KEYWORD_EDIT_PARAMETER_VALUE;
import static seedu.tache.logic.parser.CliSyntax.PARAMETER_END_DATE;
import static seedu.tache.logic.parser.CliSyntax.PARAMETER_END_TIME;
import static seedu.tache.logic.parser.CliSyntax.PARAMETER_NAME;
import static seedu.tache.logic.parser.CliSyntax.PARAMETER_RECUR_INTERVAL;
import static seedu.tache.logic.parser.CliSyntax.PARAMETER_START_DATE;
import static seedu.tache.logic.parser.CliSyntax.PARAMETER_START_TIME;
import static seedu.tache.logic.parser.CliSyntax.PARAMETER_TAG;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Optional;

import seedu.tache.commons.exceptions.IllegalValueException;
import seedu.tache.logic.commands.Command;
import seedu.tache.logic.commands.EditCommand;
import seedu.tache.logic.commands.EditCommand.EditTaskDescriptor;
import seedu.tache.logic.commands.IncorrectCommand;
import seedu.tache.model.tag.UniqueTagList;
import seedu.tache.model.task.Name;


/**
 * Parses input arguments and creates a new EditCommand object
 */
public class EditCommandParser {

    public static final String MESSAGE_INVALID_PARAMETER = "Invalid parameter given. Valid parameters" +
                                                   " include name, start_date, start_time, end_date, end_time and tags";

    /**
     * Parses the given {@code String} of arguments in the context of the EditCommand
     * and returns an EditCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;
        if (args.contains(DELIMITER_PARAMETER)) {
            return parseStructuredArguments(args);
        } else {
            return parseNaturalLanguageArguments(args);
        }
    }

    /**
     * Parses the given {@code String} of arguments that is of a natural language format in the context of the
     * EditCommand and returns an EditCommand object for execution.
     */
    private Command parseNaturalLanguageArguments(String args) {
        String argsInProcess = args;
        //Manual expression matching due to regex matching criteria being too broad
        Optional<Integer> index = ParserUtil.parseIndex(argsInProcess.trim().split(" ")[0]);
        if (index.isPresent()) {
            //Process index
            int indexOfIndex = argsInProcess.indexOf(new String("" +  index.get()));
            argsInProcess = argsInProcess.substring(indexOfIndex + new String("" +  index.get()).length());

            return processNaturalMultiParameterEdit(index, argsInProcess);

        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    EditCommand.MESSAGE_USAGE));
        }
    }

    /**
     * Parses the given {@code String} of arguments that is of a structured format in the context of the
     * EditCommand and returns an EditCommand object for execution.
     */
    private Command parseStructuredArguments(String args) {
        String[] preambleFields = args.split(DELIMITER_PARAMETER);
        Optional<Integer> index = ParserUtil.parseIndex(preambleFields[0]);

        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        EditTaskDescriptor editTaskDescriptor = new EditTaskDescriptor();

        for (int i = 1; i < preambleFields.length; i++) {
            try {
                String updateParameter = preambleFields[i].substring(0, preambleFields[i].replaceAll("^\\s+", "")
                                         .indexOf(DELIMITER_EDIT_PARAMETER) + 1).trim();
                String updateValue = preambleFields[i].substring(preambleFields[i].replaceAll("^\\s+", "")
                                     .indexOf(DELIMITER_EDIT_PARAMETER) + 1).trim();

                if (ParserUtil.isFoundIn(updateParameter, PARAMETER_NAME)) {
                    editTaskDescriptor.setName(Optional.of(new Name(updateValue)));
                } else if (ParserUtil.isFoundIn(updateParameter, PARAMETER_START_DATE)) {
                    editTaskDescriptor.setStartDate(Optional.of(updateValue));
                } else if (ParserUtil.isFoundIn(updateParameter, PARAMETER_END_DATE)) {
                    editTaskDescriptor.setEndDate(Optional.of(updateValue));
                } else if (ParserUtil.isFoundIn(updateParameter, PARAMETER_START_TIME)) {
                    editTaskDescriptor.setStartTime(Optional.of(updateValue));
                } else if (ParserUtil.isFoundIn(updateParameter, PARAMETER_END_TIME)) {
                    editTaskDescriptor.setEndTime(Optional.of(updateValue));
                } else if (ParserUtil.isFoundIn(updateParameter, PARAMETER_TAG)) {
                    editTaskDescriptor.setTags(parseTagsForEdit(Arrays.asList(updateValue
                                                                              .split(DELIMITER_EDIT_PARAMETER))));
                } else if (ParserUtil.isFoundIn(updateParameter, PARAMETER_RECUR_INTERVAL)) {
                    editTaskDescriptor.setRecurringInterval(
                                    Optional.of(ParserUtil.parseStringToRecurInterval(updateValue)));
                } else {
                    throw new IllegalValueException(MESSAGE_INVALID_PARAMETER);
                }
            } catch (IllegalValueException ive) {
                return new IncorrectCommand(ive.getMessage());
            }
        }
        if (!editTaskDescriptor.isAnyFieldEdited()) {
            return new IncorrectCommand(EditCommand.MESSAGE_NOT_EDITED);
        }
        return new EditCommand(index.get(), editTaskDescriptor);
    }

    /**
     * Process the given {@code String} of arguments that contains only multiple parameters of interest
     * that is of a natural language format and returns an EditCommand object for execution.
     */
    private Command processNaturalMultiParameterEdit (Optional<Integer> index, String argsInProcess) {
        String[] argsInProcessElements = argsInProcess.trim().split(DELIMITER_EDIT_PARAMETER);
        ArrayList<String> updateParameterList = new ArrayList<String>();
        ArrayList<String> updateValueList = new ArrayList<String>();

        if (!argsInProcessElements[0].equals(KEYWORD_EDIT_PARAMETER)) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    EditCommand.MESSAGE_USAGE));
        }

        boolean processingParameter = false;
        String currentParameter = "";
        String currentValue = "";
        for (int i = 1; i < argsInProcessElements.length; i++) {
            if (ParserUtil.isValidParameter(argsInProcessElements[i]) && !processingParameter) {
                if (argsInProcessElements[i + 1] != null
                        && argsInProcessElements[i + 1].equals(KEYWORD_EDIT_PARAMETER_VALUE)) {
                    processingParameter = true;
                    currentParameter = argsInProcessElements[i];
                    i++;
                    continue;
                }
            }
            if (processingParameter) {
                if (argsInProcessElements[i].equals(KEYWORD_EDIT_MULTI_PARAMETER)
                        && (i + 1 < argsInProcessElements.length)
                        && ParserUtil.isValidParameter(argsInProcessElements[i + 1])
                        && (i + 2 < argsInProcessElements.length)
                        && argsInProcessElements[i + 2].equals(KEYWORD_EDIT_PARAMETER_VALUE)) {
                    processingParameter = false;
                    updateParameterList.add(currentParameter);
                    updateValueList.add(currentValue.trim());
                    currentValue = "";
                } else if (i + 1 == argsInProcessElements.length) {
                    currentValue += " " + argsInProcessElements[i];
                    processingParameter = false;
                    updateParameterList.add(currentParameter);
                    updateValueList.add(currentValue.trim());
                    currentValue = "";
                } else {
                    currentValue += " " + argsInProcessElements[i];
                }
            }
        }

        String structuredArgument = index.get() + DELIMITER_PARAMETER;
        for (int i = 0; i < updateParameterList.size(); i++) {
            structuredArgument += updateParameterList.get(i) + DELIMITER_EDIT_PARAMETER
                                + updateValueList.get(i) + DELIMITER_EDIT_PARAMETER + DELIMITER_PARAMETER;
        }
        return parseStructuredArguments(structuredArgument);
    }

    /**
     * Parses {@code Collection<String> tags} into an {@code Optional<UniqueTagList>} if {@code tags} is non-empty.
     * If {@code tags} contain only one element which is an empty string, it will be parsed into a
     * {@code Optional<UniqueTagList>} containing zero tags.
     */
    private Optional<UniqueTagList> parseTagsForEdit(Collection<String> tags) throws IllegalValueException {
        assert tags != null;

        if (tags.isEmpty()) {
            return Optional.empty();
        }
        Collection<String> tagSet = tags.size() == 1 && tags.contains("") ? Collections.emptySet() : tags;
        return Optional.of(ParserUtil.parseTags(tagSet));
    }

}
```
###### \java\seedu\tache\logic\parser\FindCommandParser.java
``` java
        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new LinkedHashSet<>(Arrays.asList(keywords));
        return new FindCommand(keywordSet);
    }

}
```
###### \java\seedu\tache\logic\parser\ListCommandParser.java
``` java
package seedu.tache.logic.parser;

import static seedu.tache.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.tache.logic.parser.CliSyntax.FILTER_ALL;
import static seedu.tache.logic.parser.CliSyntax.FILTER_COMPLETED;
import static seedu.tache.logic.parser.CliSyntax.FILTER_DUE_THIS_WEEK;
import static seedu.tache.logic.parser.CliSyntax.FILTER_DUE_TODAY;
import static seedu.tache.logic.parser.CliSyntax.FILTER_FLOATING;
import static seedu.tache.logic.parser.CliSyntax.FILTER_OVERDUE;
import static seedu.tache.logic.parser.CliSyntax.FILTER_TIMED;
import static seedu.tache.logic.parser.CliSyntax.FILTER_UNCOMPLETED;

import seedu.tache.logic.commands.Command;
import seedu.tache.logic.commands.IncorrectCommand;
import seedu.tache.logic.commands.ListCommand;


/**
 * Parses input arguments and creates a new ListCommand object
 */
public class ListCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the ListCommand
     * and returns an ListCommand object for execution.
     */
    public Command parse(String args) {
        String trimmedArgs = args.trim();
        if (!trimmedArgs.equals("")) {
            switch(trimmedArgs) {
            case FILTER_COMPLETED:
            case FILTER_UNCOMPLETED:
            case FILTER_TIMED:
            case FILTER_FLOATING:
            case FILTER_DUE_TODAY:
            case FILTER_DUE_THIS_WEEK:
            case FILTER_OVERDUE:
            case FILTER_ALL:
                return new ListCommand(trimmedArgs);
            default:
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
            }
        } else {
            return new ListCommand();
        }
    }

}
```
###### \java\seedu\tache\logic\parser\ParserUtil.java
``` java
    private static final Pattern FORMAT_INDEX_ARGS = Pattern.compile("(?<targetIndex>.+)");

    private static final Pattern FORMAT_DATE = Pattern.compile("^[0-3]?[0-9]/[0-1]?[0-9]/(?:[0-9]{2})?[0-9]{2}$"
                                                               + "|^[0-3]?[0-9]-[0-1]?[0-9]-(?:[0-9]{2})?[0-9]{2}$"
                                                               + "|^[0-3]{1}[0-9]{1}[0-1]{1}[0-9]{1}"
                                                               + "(?:[0-9]{2})?[0-9]{2}$");
    private static final Pattern FORMAT_TIME = Pattern.compile("^[0-2][0-9][0-5][0-9]|^([0-1][0-2]|[0-9])"
                                                               + "([.][0-5][0-9])?\\s?(am|pm){1}");
    private static final Pattern FORMAT_DURATION = Pattern.compile("^\\d+\\s?((h|hr|hrs)|(m|min|mins))");

    /**
     * Returns the specified index in the {@code command} if it is a positive unsigned integer
     * Returns an {@code Optional.empty()} otherwise.
     */
    public static Optional<Integer> parseIndex(String command) {
        final Matcher matcher = FORMAT_INDEX_ARGS.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("targetIndex");
        if (!StringUtil.isUnsignedInteger(index)) {
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));

    }

    /**
     * Parses {@code Collection<String> tags} into an {@code UniqueTagList}.
     */
    public static UniqueTagList parseTags(Collection<String> tags) throws IllegalValueException {
        assert tags != null;
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        return new UniqueTagList(tagSet);
    }
```
###### \java\seedu\tache\logic\parser\ParserUtil.java
``` java
    /**
     * Returns True if input is a valid parameter
     * Returns False otherwise.
     */
    public static boolean isValidParameter(String input) {
        return ParserUtil.isFoundIn(input, PARAMETER_NAME, PARAMETER_START_DATE, PARAMETER_END_DATE,
                PARAMETER_START_TIME, PARAMETER_END_TIME, PARAMETER_TAG,
                PARAMETER_RECUR_INTERVAL, PARAMETER_RECUR_STATUS);
    }

    /**
     * Parses a string into a valid RecurInterval enum reference
     * @param input String to parse
     * @return valid RecurInterval enum reference if input is valid, throws IllegalValueException otherwise
     */
    public static RecurInterval parseStringToRecurInterval(String input) throws IllegalValueException {
        RecurInterval stringToEnum = null;
        switch (input.trim().toLowerCase()) {
        case "none":
            stringToEnum = RecurInterval.NONE;
            break;
        case "day":
            stringToEnum = RecurInterval.DAY;
            break;
        case "week":
            stringToEnum = RecurInterval.WEEK;
            break;
        case "month":
            stringToEnum = RecurInterval.MONTH;
            break;
        case "year":
            stringToEnum = RecurInterval.YEAR;
            break;
        }
        if (stringToEnum == null) {
            throw new IllegalValueException(RecurState.MESSAGE_RECUR_INTERVAL_CONSTRAINTS);
        }
        return stringToEnum;
    }
```
###### \java\seedu\tache\model\Model.java
``` java
    /** Updates the filter of the filtered task list to show all tasks */
    void updateFilteredListToShowAll();

    /** Updates the filter of the filtered task list to filter by the given keywords*/
    void updateFilteredTaskList(Set<String> keywords);

    /** Updates the filter of the filtered task list to show all uncompleted tasks */
    void updateFilteredListToShowUncompleted();

    /** Updates the filter of the filtered task list to show all completed tasks */
    void updateFilteredListToShowCompleted();

    /** Returns the all completed recurring ghost (not an actual task but will still be displayed to the user) tasks
     * as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    ObservableList<ReadOnlyTask> getAllCompletedRecurringGhostTasks();

    /** Returns the all uncompleted recurring ghost (not an actual task but will still be displayed to the user) tasks
     * as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    ObservableList<ReadOnlyTask> getAllUncompletedRecurringGhostTasks();

```
###### \java\seedu\tache\model\ModelManager.java
``` java
    public static final int MARGIN_OF_ERROR = 1;
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    public static final String TASK_LIST_TYPE_FOUND = "Found Tasks";
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    private final TaskManager taskManager;
    private final FilteredList<ReadOnlyTask> filteredTasks;

    private Set<String> latestKeywords;
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        ObservableList<ReadOnlyTask> filteredTasksWithRecurringTasks = populateRecurringDatesAsTask();
        raise(new TaskPanelConnectionChangedEvent(filteredTasksWithRecurringTasks));
        return new UnmodifiableObservableList<>(filteredTasksWithRecurringTasks);
    }

```
###### \java\seedu\tache\model\ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowUncompleted() {
        updateFilteredTaskListType(TASK_LIST_TYPE_UNCOMPLETED);
        updateFilteredTaskList(new PredicateExpression(new ActiveQualifier(true)));
    }

    @Override
    public void updateFilteredListToShowCompleted() {
        updateFilteredTaskListType(TASK_LIST_TYPE_COMPLETED);
        updateFilteredTaskList(new PredicateExpression(new ActiveQualifier(false)));
    }

```
###### \java\seedu\tache\model\ModelManager.java
``` java
    private void retainLatestKeywords(Set<String> keywords) {
        latestKeywords = keywords;
    }
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    private class NameQualifier implements Qualifier {
        private Set<String> nameKeyWords;

        NameQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            String[] nameElements = task.getName().fullName.split(" ");
            boolean partialMatch = false;
            //Remove square brackets
            String trimmedNameKeywords = nameKeyWords.toString()
                                         .substring(1, nameKeyWords.toString().length() - 1).toLowerCase();
            for (int i = 0; i < nameElements.length; i++) {
                if (computeLevenshteinDistance(trimmedNameKeywords, nameElements[i].toLowerCase()) <= MARGIN_OF_ERROR) {
                    partialMatch = true;
                    break;
                }
            }
            return nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(task.getName().fullName, keyword))
                    .findAny()
                    .isPresent()
                    || partialMatch;
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords);
        }
    }
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    private class ActiveQualifier implements Qualifier {
        private boolean isActive;

        ActiveQualifier(boolean isActive) {
            this.isActive = isActive;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            if (isActive) {
                return task.getActiveStatus();
            } else {
                return !task.getActiveStatus();
            }
        }

        @Override
        public String toString() {
            return "active=" + isActive;
        }
    }

```
###### \java\seedu\tache\model\ModelManager.java
``` java
    private class DateTimeQualifier implements Qualifier {
        private Set<String> dateTimeKeyWords;

        DateTimeQualifier(Set<String> dateTimeKeyWords) {
            this.dateTimeKeyWords = dateTimeKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            if (task.getStartDateTime().isPresent()) {
                for (int i = 0; i < dateTimeKeyWords.size(); i++) {
                    if (dateTimeKeyWords.toArray()[i].equals(task.getStartDateTime().get().getDateOnly()) ||
                                dateTimeKeyWords.toArray()[i].equals(task.getStartDateTime().get().getTimeOnly())) {
                        return true;
                    }
                }
            }
            if (task.getEndDateTime().isPresent()) {
                for (int i = 0; i < dateTimeKeyWords.size(); i++) {
                    if (dateTimeKeyWords.toArray()[i].equals(task.getEndDateTime().get().getDateOnly()) ||
                                dateTimeKeyWords.toArray()[i].equals(task.getEndDateTime().get().getTimeOnly())) {
                        return true;
                    }
                }
            }
            return false;
        }

        @Override
        public String toString() {
            return "datetime=" + String.join(", ", dateTimeKeyWords);
        }

    }

    private class MultiQualifier implements Qualifier {
        private Set<String> multiKeyWords;
        private NameQualifier nameQualifier;
        private DateTimeQualifier dateTimeQualifier;
        private ActiveQualifier activeQualifier;
        private TagQualifier tagQualifier;

        MultiQualifier(Set<String> multiKeyWords) {
            this.multiKeyWords = multiKeyWords;
            nameQualifier = new NameQualifier(multiKeyWords);
            dateTimeQualifier = new DateTimeQualifier(multiKeyWords);
            activeQualifier = new ActiveQualifier(true);
            tagQualifier = new TagQualifier(multiKeyWords);
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return (nameQualifier.run(task) || dateTimeQualifier.run(task)
                        || tagQualifier.run(task)) && activeQualifier.run(task);
        }

        @Override
        public String toString() {
            return "multi=" + String.join(", ", multiKeyWords);
        }

    }

    private class TagQualifier implements Qualifier {
        private Set<String> tagKeywords;

        TagQualifier(Set<String> tagKeywords) {
            this.tagKeywords = tagKeywords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            if (task.getTags().toSet().size() != 0) {
                Set<Tag> tagElements = (Set<Tag>) task.getTags().toSet();
                boolean validMatch = false;
                //Remove square brackets
                String trimmedTagKeywords = tagKeywords.toString()
                                             .substring(1, tagKeywords.toString().length() - 1).toLowerCase();
                for (Tag tag: tagElements) {
                    if (computeLevenshteinDistance(trimmedTagKeywords, tag.tagName.toLowerCase())
                                    <= MARGIN_OF_ERROR) {
                        validMatch = true;
                        break;
                    }
                }
                return validMatch;
            }
            return false;
        }

        @Override
        public String toString() {
            return "tag=" + String.join(", ", tagKeywords);
        }
    }

    private class ActiveTimedQualifier implements Qualifier {
        private TimedQualifier timedQualifier;
        private ActiveQualifier activeQualifier;

        ActiveTimedQualifier(boolean isTimed) {
            timedQualifier = new TimedQualifier(isTimed);
            activeQualifier = new ActiveQualifier(true);
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return timedQualifier.run(task) && activeQualifier.run(task);
        }

        @Override
        public String toString() {
            return "activetimed";
        }

    }

    private int computeLevenshteinDistance(CharSequence str1, CharSequence str2) {
        int[][] distance = new int[str1.length() + 1][str2.length() + 1];

        for (int i = 0; i <= str1.length(); i++) {
            distance[i][0] = i;
        }
        for (int j = 1; j <= str2.length(); j++) {
            distance[0][j] = j;
        }
        for (int i = 1; i <= str1.length(); i++) {
            for (int j = 1; j <= str2.length(); j++) {
                distance[i][j] =
                 minimum(
                    distance[i - 1][j] + 1,
                    distance[i][j - 1] + 1,
                    distance[i - 1][j - 1] +
                        ((str1.charAt(i - 1) == str2.charAt(j - 1)) ? 0 : 1));
            }
        }
        return distance[str1.length()][str2.length()];
    }

    private int minimum(int a, int b, int c) {
        return Math.min(Math.min(a, b), c);
    }

    private ObservableList<ReadOnlyTask> populateRecurringDatesAsTask() {
        List<ReadOnlyTask> concatenated = new ArrayList<>();
        for (int i = 0; i < filteredTasks.size(); i++) {
            if (filteredTasks.get(i).getRecurState().isRecurring()) {
                if (filteredTaskListType.equals(TASK_LIST_TYPE_DUE_TODAY)) {
                    Collections.addAll(concatenated, filteredTasks.get(i)
                                                .getUncompletedRecurList(new Date()).toArray());
                } else if (filteredTaskListType.equals(TASK_LIST_TYPE_DUE_THIS_WEEK)) {
                    Calendar dateThisWeek = Calendar.getInstance();
                    dateThisWeek.setTime(new Date());
                    dateThisWeek.add(Calendar.WEEK_OF_YEAR, 1);
                    Collections.addAll(concatenated, filteredTasks.get(i)
                                                .getUncompletedRecurList(dateThisWeek.getTime()).toArray());
                } else {
                    Collections.addAll(concatenated, filteredTasks.get(i).getUncompletedRecurList().toArray());
                }
            }
        }
        if (filteredTaskListType.equals(TASK_LIST_TYPE_COMPLETED) || filteredTaskListType.equals(TASK_LIST_TYPE_ALL)) {
            for (int i = 0; i < taskManager.getTaskList().size(); i++) {
                if (taskManager.getTaskList().get(i).getRecurState().isRecurring()) {
                    if (taskManager.getTaskList().get(i).getActiveStatus()) {
                        Collections.addAll(concatenated, taskManager.getTaskList().get(i)
                                                .getCompletedRecurList().toArray());
                    } else {
                        Collections.addAll(concatenated, taskManager.getTaskList().get(i)
                                .getCompletedRecurList().toArray());
                    }
                }
            }
        }
        Collections.addAll(concatenated, filteredTasks.toArray());
        ObservableList<ReadOnlyTask> concatenatedList = FXCollections.observableList(concatenated);
        concatenatedList.sort(ReadOnlyTask.READONLYTASK_DATE_COMPARATOR);
        return concatenatedList;
    }

    public ObservableList<ReadOnlyTask> getAllUncompletedRecurringGhostTasks() {
        List<ReadOnlyTask> concatenated = new ArrayList<>();
        for (int i = 0; i < taskManager.getTaskList().size(); i++) {
            if (taskManager.getTaskList().get(i).getRecurState().isRecurring()) {
                Collections.addAll(concatenated, taskManager.getTaskList().get(i)
                                            .getUncompletedRecurList().toArray());
            }
        }
        ObservableList<ReadOnlyTask> concatenatedList = FXCollections.observableList(concatenated);
        concatenatedList.sort(ReadOnlyTask.READONLYTASK_DATE_COMPARATOR);
        return concatenatedList;
    }

    public ObservableList<ReadOnlyTask> getAllCompletedRecurringGhostTasks() {
        List<ReadOnlyTask> concatenated = new ArrayList<>();
        for (int i = 0; i < taskManager.getTaskList().size(); i++) {
            if (taskManager.getTaskList().get(i).getRecurState().isRecurring()) {
                Collections.addAll(concatenated, taskManager.getTaskList().get(i)
                                            .getCompletedRecurList().toArray());
            }
        }
        ObservableList<ReadOnlyTask> concatenatedList = FXCollections.observableList(concatenated);
        concatenatedList.sort(ReadOnlyTask.READONLYTASK_DATE_COMPARATOR);
        return concatenatedList;
    }
```
###### \java\seedu\tache\model\recurstate\RecurState.java
``` java
package seedu.tache.model.recurstate;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;

import seedu.tache.commons.exceptions.IllegalValueException;
import seedu.tache.model.task.DateTime;

public class RecurState {
    public static final String MESSAGE_RECUR_INTERVAL_CONSTRAINTS = "Unknown recur interval format. "
                                                            + "Valid values include: None, Day, Week, Month and Year";

    public enum RecurInterval { NONE, DAY, WEEK, MONTH, YEAR };

    private RecurInterval interval;
    private List<Date> recurCompletedList;
    private String recurDisplayDate;

    public RecurState() {
        this.interval = RecurInterval.NONE;
        this.recurCompletedList = new ArrayList<Date>();
        this.recurDisplayDate = "";
    }

    public RecurState(RecurInterval interval, List<Date> recurCompletedList) {
        this.interval = interval;
        this.recurCompletedList = recurCompletedList;
        this.recurDisplayDate = "";
    }

    public boolean isRecurring() {
        return !interval.equals(RecurInterval.NONE);
    }

    public RecurInterval getRecurInterval() {
        return interval;
    }

    public void setRecurInterval(RecurInterval interval) throws IllegalValueException {
        if (interval == null) {
            throw new IllegalValueException(MESSAGE_RECUR_INTERVAL_CONSTRAINTS);
        }
        this.interval = interval;
    }

    public boolean isMasterRecurring() {
        return isRecurring() && this.recurDisplayDate.equals("");
    }

    public boolean isGhostRecurring() {
        return isRecurring() && !this.recurDisplayDate.equals("");
    }

    public List<Date> getRecurCompletedList() {
        return this.recurCompletedList;
    }

    public void setRecurCompletedList(List<Date> recurCompletedList) {
        this.recurCompletedList = recurCompletedList;
    }

    /**
     * Get a list of all dates that are in the {@code recurCompletedList} and meets the recurring requirements
     * @param {@code startDateTime}, start of date range
     * @param {@code endDateTime}, end of date range
     * @param {@code filterEndDate}, soft cap for the date listing
     * @return List of dates that meet the criteria
     */
    public List<Date> getCompletedRecurDates(DateTime startDateTime, DateTime endDateTime, Date filterEndDate) {
        List<Date> completedRecurList = new ArrayList<Date>();
        if (isRecurring()) {
            Calendar calendarCurrent = Calendar.getInstance();
            calendarCurrent.setTime(new Date(startDateTime.getAmericanDateOnly()
                                        + " " + startDateTime.getTimeOnly()));

            Calendar calendarEnd = Calendar.getInstance();
            calendarEnd.setTime(new Date(endDateTime.getAmericanDateOnly()
                                        + " " + endDateTime.getTimeOnly()));
            calendarEnd.add(Calendar.SECOND, 1);

            //Populate 'Ghost' Task
            while (calendarCurrent.getTime().before(calendarEnd.getTime())
                    && (filterEndDate == null || calendarCurrent.getTime().before(filterEndDate))) {

                if (isRecurCompleted(calendarCurrent.getTime())) {
                    completedRecurList.add(calendarCurrent.getTime());
                }

                if (interval.equals(RecurInterval.DAY)) {
                    calendarCurrent.add(Calendar.DATE, 1);
                } else if (interval.equals(RecurInterval.WEEK)) {
                    calendarCurrent.add(Calendar.WEEK_OF_YEAR, 1);
                } else if (interval.equals(RecurInterval.MONTH)) {
                    calendarCurrent.add(Calendar.MONTH, 1);
                } else if (interval.equals(RecurInterval.YEAR)) {
                    calendarCurrent.add(Calendar.YEAR, 1);
                }
            }
        }
        return completedRecurList;

    }

    /**
     * Gets a list of all dates that are not in the {@code recurCompletedList} and meets the recurring requirements
     * @param {@code startDateTime}, start of date range
     * @param {@code endDateTime}, end of date range
     * @param {@code filterEndDate}, soft cap for the date listing
     * @return List of dates that meet the criteria
     */
    public List<Date> getUncompletedRecurDates(DateTime startDateTime, DateTime endDateTime, Date filterEndDate) {
        List<Date> uncompletedRecurList = new ArrayList<Date>();
        if (isRecurring()) {
            Calendar calendarCurrent = Calendar.getInstance();
            calendarCurrent.setTime(new Date(startDateTime.getAmericanDateOnly()
                                        + " " + startDateTime.getTimeOnly()));

            Calendar calendarEnd = Calendar.getInstance();
            calendarEnd.setTime(new Date(endDateTime.getAmericanDateOnly()
                                        + " " + endDateTime.getTimeOnly()));
            calendarEnd.add(Calendar.SECOND, 1);

            //Populate 'Ghost' Task
            while (calendarCurrent.getTime().before(calendarEnd.getTime())
                    && (filterEndDate == null || calendarCurrent.getTime().before(filterEndDate))) {

                if (!isRecurCompleted(calendarCurrent.getTime())) {
                    uncompletedRecurList.add(calendarCurrent.getTime());
                }

                if (interval.equals(RecurInterval.DAY)) {
                    calendarCurrent.add(Calendar.DATE, 1);
                } else if (interval.equals(RecurInterval.WEEK)) {
                    calendarCurrent.add(Calendar.WEEK_OF_YEAR, 1);
                } else if (interval.equals(RecurInterval.MONTH)) {
                    calendarCurrent.add(Calendar.MONTH, 1);
                } else if (interval.equals(RecurInterval.YEAR)) {
                    calendarCurrent.add(Calendar.YEAR, 1);
                }
            }
        }
        return uncompletedRecurList;

    }

    /**
     * Check if {@code recurCompleted} is in {@code recurCompletedList}
     * @return true if {@code recurCompleted} is in {@code recurCompletedList}, otherwise false
     */
    public boolean isRecurCompleted(Date recurCompleted) {
        DateFormat outputFormatter = new SimpleDateFormat("MM/dd/yyyy");
        for (int i = 0; i < getRecurCompletedList().size(); i++) {
            if (outputFormatter.format(getRecurCompletedList().get(i))
                                .equals(outputFormatter.format(recurCompleted))) {
                return true;
            }
        }
        return false;
    }

    public String getRecurDisplayDate() {
        return this.recurDisplayDate;
    }

    public void setRecurDisplayDate(String recurDisplayDate) {
        this.recurDisplayDate = recurDisplayDate;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof RecurState // instanceof handles nulls
                && this.interval.equals(((RecurState) other).getRecurInterval())
                && this.recurCompletedList.equals(((RecurState) other).getRecurCompletedList())
                && this.recurDisplayDate.equals(((RecurState) other).getRecurDisplayDate())); // state check
    }
}
```
###### \java\seedu\tache\model\task\DateTime.java
``` java
package seedu.tache.model.task;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.List;

import org.ocpsoft.prettytime.PrettyTime;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

import seedu.tache.commons.exceptions.IllegalValueException;


public class DateTime implements Comparable {

    private static final String EXPLICIT_DATE_TREE_IDENTIFIER = "EXPLICIT_DATE";
    private static final String EXPLICIT_TIME_TREE_IDENTIFIER = "EXPLICIT_TIME";

    public static final String MESSAGE_DATE_CONSTRAINTS = "Unknown date format. It is recommended to "
                                        + "interchangeably use the following few formats:"
                                        + "\nMM-DD-YY hh:mm:ss or MM/DD/YY 10.30pm";

    public static final String DEFAULT_TIME_STRING = "00:00:00";

    private final Date date;

    /**
     * Validates given date.
     *
     * @throws IllegalValueException if given date string is invalid.
     */
    public DateTime(String date) throws IllegalValueException {
        assert date != null;
        String trimmedStartDate = date.trim();
        List<DateGroup> temp = new Parser().parse(trimmedStartDate);
        if (temp.isEmpty()) {
            throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS);
        }
        this.date = temp.get(0).getDates().get(0);
        String syntaxTree = temp.get(0).getSyntaxTree().toStringTree();
        boolean hasExplicitDate = syntaxTree.contains(EXPLICIT_DATE_TREE_IDENTIFIER);
        boolean hasExplicitTime = syntaxTree.contains(EXPLICIT_TIME_TREE_IDENTIFIER);
        if (hasExplicitDate ^ hasExplicitTime) {
            if (hasExplicitDate) {
                this.date.setHours(0);
                this.date.setMinutes(0);
                this.date.setSeconds(0);
            }
        }
    }

    /**
     * Creates a copy of the given DateTime.
     * @throws IllegalValueException if source date string is invalid
     */
    public DateTime(DateTime source) throws IllegalValueException {
        this(source.getAmericanDateTime());
    }

    @Override
    public String toString() {
        return new PrettyTime().format(date);
    }

    public String getDateOnly() {
        SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
        return sdf.format(date);
    }

    public void setDateOnly(String date) throws IllegalValueException {
        List<DateGroup> temp = new Parser().parse(date);
        if (temp.isEmpty()) {
            throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS);
        }
        Date parsedDate = temp.get(0).getDates().get(0);
        this.date.setDate(parsedDate.getDate());
        this.date.setMonth(parsedDate.getMonth());
        this.date.setYear(parsedDate.getYear());
    }

    public void setTimeOnly(String time) throws IllegalValueException {
        List<DateGroup> temp = new Parser().parse(time);
        if (temp.isEmpty()) {
            throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS);
        }
        Date parsedTime = temp.get(0).getDates().get(0);
        this.date.setHours(parsedTime.getHours());
        this.date.setMinutes(parsedTime.getMinutes());
        this.date.setSeconds(parsedTime.getSeconds());
    }

    public void setDefaultTime() throws IllegalValueException {
        setTimeOnly(DEFAULT_TIME_STRING);
    }

    public String getTimeOnly() {
        SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss");
        return sdf.format(date);
    }

    public String getAmericanDateTime() {
        SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss");
        return sdf.format(date);
    }

    public String getAmericanDateOnly() {
        SimpleDateFormat sdf = new SimpleDateFormat("MM/dd/yyyy");
        return sdf.format(date);
    }

    @Override
    public int compareTo(Object other) {
        assert other instanceof DateTime;
        if (this.equals(other)) {
            return 0;
        } else if (date.after(((DateTime) other).getDate())) {
            return 1;
        } else {
            return -1;
        }
    }

```
###### \java\seedu\tache\model\task\ReadOnlyTask.java
``` java
    /**
     * Comparator use to sort readonlytask based on endDate
     */
    public static Comparator<ReadOnlyTask> READONLYTASK_DATE_COMPARATOR = new Comparator<ReadOnlyTask>() {

        public int compare(ReadOnlyTask task1, ReadOnlyTask task2) {
            Date lastComparableDate = new Date(0);
            int result = 0;
            //ascending order
            if (!task1.getEndDateTime().isPresent() && task2.getEndDateTime().isPresent()) {
                result = lastComparableDate.compareTo(task2.getEndDateTime().get().getDate());
                lastComparableDate = task2.getEndDateTime().get().getDate();
            }
            if (task1.getEndDateTime().isPresent() && !task2.getEndDateTime().isPresent()) {
                result = task1.getEndDateTime().get().getDate().compareTo(lastComparableDate);
                lastComparableDate = task1.getEndDateTime().get().getDate();
            }
            if (task1.getEndDateTime().isPresent() && task2.getEndDateTime().isPresent()) {
                return task1.getEndDateTime().get().getDate().compareTo(task2.getEndDateTime().get().getDate());
            }
            return (result);
        }

    };
}
```
###### \java\seedu\tache\model\task\Task.java
``` java
    public RecurState getRecurState() {
        return recurState;
    }

    public void setRecurState(RecurState recurState) {
        this.recurState = recurState;
    }

    @Override
    public List<Task> getCompletedRecurList() {
        assert startDateTime.isPresent();
        assert endDateTime.isPresent();

        List<Task> completedRecurList = new ArrayList<Task>();
        List<Date> completedRecurDates = this.recurState.getCompletedRecurDates(startDateTime.get(),
                                                                                    endDateTime.get(), null);
        for (int i = 0; i < completedRecurDates.size(); i++) {
            Task temp = new Task(this);
            DateFormat df = new SimpleDateFormat("MM/dd/yyyy");
            String tempDate = df.format(completedRecurDates.get(i));
            temp.getRecurState().setRecurDisplayDate(tempDate);
            temp.setActiveStatus(false);
            completedRecurList.add(temp);
        }

        return completedRecurList;
    }

    @Override
    public List<Task> getUncompletedRecurList() {
        assert startDateTime.isPresent();
        assert endDateTime.isPresent();

        List<Task> uncompletedRecurList = new ArrayList<Task>();
        List<Date> uncompletedRecurDates = this.recurState.getUncompletedRecurDates(startDateTime.get(),
                                                                                    endDateTime.get(), null);
        for (int i = 0; i < uncompletedRecurDates.size(); i++) {
            Task temp = new Task(this);
            DateFormat df = new SimpleDateFormat("MM/dd/yyyy");
            String tempDate = df.format(uncompletedRecurDates.get(i));
            temp.getRecurState().setRecurDisplayDate(tempDate);
            uncompletedRecurList.add(temp);
        }

        return uncompletedRecurList;
    }

    @Override
    public List<Task> getUncompletedRecurList(Date filterEndDate) {
        assert startDateTime.isPresent();
        assert endDateTime.isPresent();

        List<Task> uncompletedRecurList = new ArrayList<Task>();
        List<Date> uncompletedRecurDates = this.recurState.getUncompletedRecurDates(startDateTime.get(),
                                                                                    endDateTime.get(), filterEndDate);
        for (int i = 0; i < uncompletedRecurDates.size(); i++) {
            Task temp = new Task(this);
            DateFormat df = new SimpleDateFormat("MM/dd/yyyy");
            String tempDate = df.format(uncompletedRecurDates.get(i));
            temp.getRecurState().setRecurDisplayDate(tempDate);
            uncompletedRecurList.add(temp);
        }

        return uncompletedRecurList;
    }
```
###### \java\seedu\tache\ui\HotkeyManager.java
``` java
package seedu.tache.ui;

import javax.swing.KeyStroke;

import com.tulskiy.keymaster.common.HotKey;
import com.tulskiy.keymaster.common.HotKeyListener;
import com.tulskiy.keymaster.common.Provider;

import javafx.application.Platform;
import javafx.stage.Stage;

public class HotkeyManager {
    public static final String DEFAULT_HOTKEY_COMBINATION = "control alt D";

    private Provider hotkeyManager;
    private Stage stage;
    private String hotkeyCombination;

    public HotkeyManager(Stage stage) {
        this.stage = stage;
        this.hotkeyCombination = DEFAULT_HOTKEY_COMBINATION;
    }

    /**
     * Bind show/hide (toggle) hotkey
     */
    private void bindToggleSystemHotkey() {
        if (hotkeyManager == null) {
            hotkeyManager = Provider.getCurrentProvider(false);
        }
        hotkeyManager.register(KeyStroke.getKeyStroke(hotkeyCombination), new HotKeyListener() {
            public void onHotKey(HotKey hotKey) {
                if (stage.isFocused()) {
                    if (stage.isIconified()) {
                        Platform.runLater(()-> {
                            stage.setIconified(false); });
                    } else {
                        Platform.runLater(()-> {
                            stage.setIconified(true); });
                    }
                } else {
                    Platform.runLater(()-> {
                        stage.setIconified(false);
                        stage.toFront(); });
                }
            }
        });
    }

    /**
     * Starts binding of toggle hotkey
     */
    public void start() {
        bindToggleSystemHotkey();
    }

    /**
     * Stops binding of toggle hotkey
     */
    public void stop() {
        if (hotkeyManager != null) {
            hotkeyManager.reset();
            hotkeyManager.stop();
        }
    }
}
```
###### \java\seedu\tache\ui\MainWindow.java
``` java
    public CalendarPanel getCalendarPanel() {
        return this.calendarPanel;
    }

    void releaseResources() {
        calendarPanel.freeResources();
    }

}
```
###### \java\seedu\tache\ui\TaskListPanel.java
``` java
    public void resetConnections(ObservableList<ReadOnlyTask> taskList) {
        setConnections(taskList);
    }
```
###### \java\seedu\tache\ui\UiManager.java
``` java
    @Subscribe
    private void handleTaskPanelConnectionChangedEvent(TaskPanelConnectionChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        if (mainWindow.getTaskListPanel() != null) {
            mainWindow.getTaskListPanel().resetConnections(event.getNewConnection());
        }
    }

    @Subscribe
    private void handlePopulateRecurringGhostTaskEvent(PopulateRecurringGhostTaskEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        if (mainWindow.getTaskListPanel() != null) {
            mainWindow.getCalendarPanel().addAllEvents(event.getAllCompletedRecurringGhostTasks());
            mainWindow.getCalendarPanel().addAllEvents(event.getAllUncompletedRecurringGhostTasks());
        }
    }

    @Subscribe
    public void handleUpdateNotificationsEvent(TaskManagerChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        notificationManager.updateNotifications(event);
    }

}
```
###### \resources\html\calendar.html
``` html
<link rel="stylesheet" type="text/css" href="http://cdnjs.cloudflare.com/ajax/libs/fullcalendar/3.2.0/fullcalendar.min.css">
<script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.17.1/moment.min.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/fullcalendar/3.2.0/fullcalendar.min.js"></script>

```
