# A0140032E
###### /java/seedu/taskmanager/commons/events/model/TaskManagerChangedEvent.java
``` java
    public final String commandText;

    public TaskManagerChangedEvent(ReadOnlyTaskManager data, String commandText) {
        this.data = data;
        this.commandText = commandText;
    }
```
###### /java/seedu/taskmanager/commons/util/StringUtil.java
``` java
    private static final int TOLERANCE_SIMPLE_RATIO = 90;
    private static final int TOLERANCE_PARTIAL_RATIO = 90;
    private static final int TOLERANCE_TOKEN_SORT_PARTIAL_RATIO = 80;
    private static final int TOLERANCE_TOKEN_SORT_RATIO = 90;
```
###### /java/seedu/taskmanager/commons/util/StringUtil.java
``` java
        int simpleRatio = FuzzySearch.ratio(preppedSentence, preppedWord);
        int partialRatio = FuzzySearch.partialRatio(preppedSentence, preppedWord);
        int tokenSortPartialRatio = FuzzySearch.tokenSortPartialRatio(preppedSentence, preppedWord);
        int tokenSortRatio = FuzzySearch.tokenSortRatio(preppedSentence, preppedWord);
        if (simpleRatio >= TOLERANCE_SIMPLE_RATIO ||
                partialRatio >= TOLERANCE_PARTIAL_RATIO ||
                tokenSortPartialRatio >= TOLERANCE_TOKEN_SORT_PARTIAL_RATIO ||
                tokenSortRatio >= TOLERANCE_TOKEN_SORT_RATIO) {
            return true;
        }
```
###### /java/seedu/taskmanager/logic/commands/AddCommand.java
``` java
    public static final String MESSAGE_DATE_ORDER_CONSTRAINTS = "Start Date should be earlier or same as End Date";
```
###### /java/seedu/taskmanager/logic/commands/AddCommand.java
``` java
        if (startDate.isPresent() && endDate.isPresent() &&
                new StartDate(startDate.get()).after(new EndDate(endDate.get()))) {
            throw new IllegalValueException(MESSAGE_DATE_ORDER_CONSTRAINTS);
        }
        this.toAdd = new Task(
                new Title(title),
                startDate.isPresent() && !startDate.get().trim().equals("") ?
                        Optional.of(new StartDate(startDate.get())) : Optional.empty(),
                endDate.isPresent() && !endDate.get().trim().equals("") ?
                        Optional.of(new EndDate(endDate.get())) : Optional.empty(),
                description.isPresent() && !description.get().trim().equals("") ?
                        Optional.of(new Description(description.get())) : Optional.empty(),
                new Status(),
                new UniqueTagList(tagSet)
        );
```
###### /java/seedu/taskmanager/logic/commands/EditCommand.java
``` java
    public static final String MESSAGE_DATE_ORDER_CONSTRAINTS = "Start Date should be earlier or same as End Date";
```
###### /java/seedu/taskmanager/logic/commands/EditCommand.java
``` java
        if (editedTask.getStartDate().isPresent() && editedTask.getEndDate().isPresent() &&
                editedTask.getStartDate().get().after(editedTask.getEndDate().get())) {
            throw new CommandException(MESSAGE_DATE_ORDER_CONSTRAINTS);
        }
```
###### /java/seedu/taskmanager/logic/commands/EditCommand.java
``` java
        Optional <StartDate> updatedStartDate = editTaskDescriptor.isStartDateChanged() ?
                editTaskDescriptor.getStartDate() : taskToEdit.getStartDate();
        Optional <EndDate> updatedEndDate = editTaskDescriptor.isEndDateChanged() ?
                editTaskDescriptor.getEndDate() : taskToEdit.getEndDate();
        Optional <Description> updatedDescription = editTaskDescriptor.isDescriptionChanged() ?
                editTaskDescriptor.getDescription() : taskToEdit.getDescription();
```
###### /java/seedu/taskmanager/logic/commands/EditCommand.java
``` java
        private boolean anyChangesMade;
        private boolean startDateChanged;
        private boolean endDateChanged;
        private boolean descriptionChanged;

        public EditTaskDescriptor() {
            anyChangesMade = false;
            startDateChanged = false;
            endDateChanged = false;
            descriptionChanged = false;
        }


        public EditTaskDescriptor(EditTaskDescriptor toCopy) {
            this.title = toCopy.getTitle();
            this.startDate = toCopy.getStartDate();
            this.endDate = toCopy.getEndDate();
            this.description = toCopy.getDescription();
            this.status = toCopy.getStatus();
            this.tags = toCopy.getTags();
            this.anyChangesMade = toCopy.isAnyFieldEdited();
            this.startDateChanged = toCopy.isStartDateChanged();
            this.endDateChanged = toCopy.isEndDateChanged();
            this.descriptionChanged = toCopy.isDescriptionChanged();
        }

        /**
         * Returns true if at least one field is edited.
         */
        public boolean isAnyFieldEdited() {
            return anyChangesMade;
        }

        public void setTitle(Optional<Title> title) {
            assert title != null;
            this.title = title;
            anyChangesMade = true;
        }
```
###### /java/seedu/taskmanager/logic/commands/EditCommand.java
``` java
        public void setStartDate(Optional<StartDate> startDate) {
            assert startDate != null;
            this.startDate = startDate;
            startDateChanged = true;
            anyChangesMade = true;
        }

        public boolean isStartDateChanged() {
            return startDateChanged;
        }
```
###### /java/seedu/taskmanager/logic/commands/EditCommand.java
``` java
        public void setEndDate(Optional<EndDate> endDate) {
            assert endDate != null;
            this.endDate = endDate;
            anyChangesMade = true;
            endDateChanged = true;
        }

        public boolean isEndDateChanged() {
            return endDateChanged;
        }
```
###### /java/seedu/taskmanager/logic/commands/EditCommand.java
``` java
        public void setDescription(Optional<Description> description) {
            assert description != null;
            this.description = description;
            anyChangesMade = true;
            descriptionChanged = true;
        }

        public boolean isDescriptionChanged() {
            return descriptionChanged;
        }
```
###### /java/seedu/taskmanager/logic/commands/EditCommand.java
``` java
        public void setTags(Optional<UniqueTagList> tags) {
            assert tags != null;
            this.tags = tags;
            anyChangesMade = true;
        }
```
###### /java/seedu/taskmanager/logic/commands/FindDateCommand.java
``` java
/**
 * Finds and lists all tasks in task manager which fall in the date(s) range
 * requirements.
 */
public class FindDateCommand extends Command {

    private boolean isRange;
    private Date startDateRange, endDateRange;

    private static final SimpleDateFormat sdfOutput = new SimpleDateFormat("dd/MM/yyyy");

    public static final String COMMAND_WORD = "findbydate";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all non-floating tasks which is within "
            + "the specified date or date range and displays them as a list with index numbers.\n"
            + "Parameters: DATE [to DATE]\n" + "Example: " + COMMAND_WORD + " 12/03/2017\n" + COMMAND_WORD
            + "10/03/2017 to 15/03/2017";
    public static final String MESSAGE_INVALID_RANGE = "Invalid date range. "
            + "Either provide a single date or a starting date to ending date";
    public static final String MESSAGE_SUCCESS = "Finding tasks ";

    public FindDateCommand(String args) throws IllegalValueException {
        Parser parser = new Parser();
        List<DateGroup> dateGroups = parser.parse(args);

        if (dateGroups.isEmpty()) {
            throw new IllegalValueException(MESSAGE_INVALID_RANGE);
        }

        switch (dateGroups.get(0).getDates().size()) {

        case 1:
            isRange = false;
            startDateRange = dateGroups.get(0).getDates().get(0);
            break;

        case 2:
            isRange = true;
            startDateRange = dateGroups.get(0).getDates().get(0);
            endDateRange = dateGroups.get(0).getDates().get(1);
            if (startDateRange.after(endDateRange)) {
                Date temp = startDateRange;
                startDateRange = endDateRange;
                endDateRange = temp;
            }
            break;

        default:
            throw new IllegalValueException(MESSAGE_INVALID_RANGE);
        }
    }

    @Override
    public CommandResult execute() throws CommandException {
        StringBuilder sb = new StringBuilder(MESSAGE_SUCCESS);
        if (isRange) {
            model.updateFilteredTaskList(startDateRange, endDateRange);
            sb.append(sdfOutput.format(startDateRange));
            sb.append(" to ");
            sb.append(sdfOutput.format(endDateRange));
        } else {
            model.updateFilteredTaskList(startDateRange);
            sb.append("on ");
            sb.append(sdfOutput.format(startDateRange));
        }
        sb.append("\n");
        return new CommandResult(sb.toString() + getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }
}
```
###### /java/seedu/taskmanager/logic/commands/RedoCommand.java
``` java
public class RedoCommand extends Command {
    public static final String COMMAND_WORD = "redo";

    public static final String MESSAGE_SUCCESS = "Redo successful: ";
    public static final String MESSAGE_NO_MORE_REDO = "No more actions available to redo";

    @Override
    public CommandResult execute() throws CommandException {
        HistoryManager historyManager = HistoryManager.getInstance();
        String commandText;
        try {
            commandText = historyManager.redo();
        } catch (Exception e) {
            throw new CommandException(MESSAGE_NO_MORE_REDO);
        }
        return new CommandResult(MESSAGE_SUCCESS + commandText);
    }
}
```
###### /java/seedu/taskmanager/logic/commands/UndoCommand.java
``` java
public class UndoCommand extends Command {
    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_SUCCESS = "Undo successful: ";
    public static final String MESSAGE_NO_MORE_UNDO = "No more actions available to undo";

    @Override
    public CommandResult execute() throws CommandException {
        HistoryManager historyManager = HistoryManager.getInstance();
        String commandText;
        try {
            commandText = historyManager.undo();
        } catch (Exception e) {
            throw new CommandException(MESSAGE_NO_MORE_UNDO);
        }
        return new CommandResult(MESSAGE_SUCCESS + commandText);
    }
}
```
###### /java/seedu/taskmanager/logic/Logic.java
``` java
    void init(Model model, Storage storage);

    String getCommandText();
```
###### /java/seedu/taskmanager/logic/LogicManager.java
``` java
    private static LogicManager instance = null;
    private Model model;
    private Parser parser;
    private Storage storage;
    private String commandText;

    // Singleton pattern
    private LogicManager() {
    }

    public static LogicManager getInstance() {
        if (instance == null) {
            instance = new LogicManager();
        }
        return instance;
    }

    public void init(Model model, Storage storage) {
        this.model = model;
        this.storage = storage;
        this.parser = new Parser();
    }

    @Override
    public CommandResult execute(String commandText) throws CommandException {
        logger.info("----------------[USER COMMAND][" + commandText + "]");
        this.commandText = commandText;
        Command command = parser.parseCommand(commandText);
        command.setData(model);
        command.setStorage(storage);
        return command.execute();
    }
```
###### /java/seedu/taskmanager/logic/LogicManager.java
``` java
    public String getCommandText() {
        return this.commandText;
    }
```
###### /java/seedu/taskmanager/logic/parser/FindDateCommandParser.java
``` java
/**
 * Parses input arguments and creates a new FindDateCommand object
 */
public class FindDateCommandParser {
    public Command parse(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindDateCommand.MESSAGE_USAGE));
        }
        try {
            return new FindDateCommand(args.trim());
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
}
```
###### /java/seedu/taskmanager/logic/parser/ParserUtil.java
``` java
    public static Optional<StartDate> parseStartDate(Optional<String> startDate) throws IllegalValueException {
        assert startDate != null;
        return startDate.isPresent() && !startDate.get().trim().equals("") ? Optional.of(new StartDate(startDate.get()))
                : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> description} into an
     * {@code Optional<Description>} if {@code description} is present.
     */
    public static Optional<Description> parseDescription(Optional<String> description) throws IllegalValueException {
        assert description != null;
        return description.isPresent() && !description.get().trim().equals("")
                ? Optional.of(new Description(description.get())) : Optional.empty();
    }

    /**
     * Parses a {@code Optional<String> endDate} into an
     * {@code Optional<EndDate>} if {@code endDate} is present.
     */
    public static Optional<EndDate> parseEndDate(Optional<String> endDate) throws IllegalValueException {
        assert endDate != null;
        return endDate.isPresent() && !endDate.get().trim().equals("") ? Optional.of(new EndDate(endDate.get()))
                : Optional.empty();
    }
```
###### /java/seedu/taskmanager/MainApp.java
``` java
        history = HistoryManager.getInstance();

        history.init(model);

        logic = LogicManager.getInstance();

        logic.init(model, storage);
```
###### /java/seedu/taskmanager/model/HistoryManager.java
``` java
/**
 * Represents the History of user commands in this session
 */
public class HistoryManager extends ComponentManager {

    private Model model;
    private static HistoryManager instance = null;
    private static final Logger logger = LogsCenter.getLogger(StorageManager.class);
    private ArrayList<ReadOnlyTaskManager> historyList;
    private ArrayList<ReadOnlyTaskManager> futureList;
    private ArrayList<String> historyCommands;
    private ArrayList<String> futureCommands;

    protected HistoryManager() {
        super();

        historyList = new ArrayList<ReadOnlyTaskManager>();
        futureList = new ArrayList<ReadOnlyTaskManager>();
        historyCommands = new ArrayList<String>();
        futureCommands = new ArrayList<String>();
    }

    public static HistoryManager getInstance() {
        if (instance == null) {
            instance = new HistoryManager();
        }
        return instance;
    }

    public void init(Model model) {
        this.model = model;
        TaskManager taskManager = new TaskManager(model.getTaskManager());
        historyList.add(taskManager);
    }

    @Subscribe
    public void handleTaskManagerChangedEvent(TaskManagerChangedEvent event) {
        TaskManager taskManager = new TaskManager(event.data);
        String commandText = new String(event.commandText);
        historyList.add(taskManager);
        if (!commandText.equals(RedoCommand.COMMAND_WORD) && !commandText.equals(UndoCommand.COMMAND_WORD)) {
            historyCommands.add(commandText);
        }
        if (!(commandText.equals(RedoCommand.COMMAND_WORD) || commandText.equals(UndoCommand.COMMAND_WORD))) {
            futureList.clear();
            futureCommands.clear();
        }
        logger.info(LogsCenter.getEventHandlingLogMessage(event,
                ("Local data changed, updating history manager. Histories = " + historyList.size() + " Futures = "
                        + futureList.size())));
    }

    @Subscribe
    public void handleTaskManagerStorageDirectoryChangedEvent(TaskManagerStorageDirectoryChangedEvent event) {
        historyList.clear();
        futureList.clear();
        historyCommands.clear();
        futureCommands.clear();
        logger.info(LogsCenter.getEventHandlingLogMessage(event,
                ("Storage file location changed, resetting history. Histories = " + historyList.size() + " Futures = "
                        + futureList.size())));
    }

    private HistoryItemPair getMostRecentHistory() {
        if (historyList.size() < 2) {
            throw new NullPointerException();
        }
        ReadOnlyTaskManager taskManager = historyList.remove(historyList.size() - 1);
        futureList.add(new TaskManager(taskManager));
        String commandText = historyCommands.remove(historyCommands.size() - 1);
        futureCommands.add(new String(commandText));
        HistoryItemPair history = new HistoryItemPair(historyList.remove(historyList.size() - 1), commandText);
        return history;
    }

    private HistoryItemPair getMostRecentFuture() {
        if (futureList.size() < 1) {
            throw new NullPointerException();
        }
        String commandText = futureCommands.remove(futureCommands.size() - 1);
        historyCommands.add(new String(commandText));
        HistoryItemPair history = new HistoryItemPair(futureList.remove(futureList.size() - 1),
                commandText);
        return history;
    }

    public String undo() {
        HistoryItemPair t = getMostRecentHistory();
        model.resetData(t.getTaskManager());
        return t.getCommandText();
    }

    public String redo() {
        HistoryItemPair t = getMostRecentFuture();
        model.resetData(t.getTaskManager());
        return t.getCommandText();
    }
}

class HistoryItemPair {
    private ReadOnlyTaskManager taskManager;
    private String commandText;

    public HistoryItemPair(ReadOnlyTaskManager tm, String text) {
        taskManager = tm;
        commandText = text;
    }

    public ReadOnlyTaskManager getTaskManager() {
        return taskManager;
    }

    public String getCommandText() {
        return commandText;
    }
}
```
###### /java/seedu/taskmanager/model/Model.java
``` java
    /**
     * Updates the filter of the filtered task list to filter by the given
     * date(s)
     */
    void updateFilteredTaskList(Date date);

    void updateFilteredTaskList(Date startDateCriteria, Date endDateCriteria);
```
###### /java/seedu/taskmanager/model/ModelManager.java
``` java
    @Override
    public void updateFilteredTaskList(Date date) {
        updateFilteredTaskList(new PredicateExpression(new DateQualifier(date)));

    }

    @Override
    public void updateFilteredTaskList(Date startDateCriteria, Date endDateCriteria) {
        updateFilteredTaskList(new PredicateExpression(new DateRangeQualifier(startDateCriteria, endDateCriteria)));

    }
```
###### /java/seedu/taskmanager/model/ModelManager.java
``` java
        public boolean run(ReadOnlyTask task) {
            boolean hasName = nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(task.getTitle().value, keyword)).findAny()
                    .isPresent();
            boolean hasDescription = nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(
                            task.getDescription().isPresent() ? task.getDescription().get().value : "", keyword))
                    .findAny().isPresent();
            boolean hasTag = false;
            UniqueTagList tagList = task.getTags();
            for (Tag tag : tagList) {
                hasTag = hasTag || nameKeyWords.stream()
                        .filter(keyword -> StringUtil.containsWordIgnoreCase(tag.tagName, keyword)).findAny()
                        .isPresent();
            }
            return hasName || hasDescription || hasTag;
        }
```
###### /java/seedu/taskmanager/model/ModelManager.java
``` java
    private class DateQualifier implements Qualifier {
        private LocalDate date;

        DateQualifier(Date date) {
            this.date = date.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
        }

        @Override
        public boolean run(ReadOnlyTask task) {

            LocalDate taskStartDate = task.getStartDate().isPresent()
                    ? task.getStartDate().get().toInstant().atZone(ZoneId.systemDefault()).toLocalDate() : null;
            LocalDate taskEndDate = task.getEndDate().isPresent()
                    ? task.getEndDate().get().toInstant().atZone(ZoneId.systemDefault()).toLocalDate() : null;

            boolean isFloatingTask = !(task.getStartDate().isPresent() || task.getEndDate().isPresent());
            if (isFloatingTask) {
                return false;
            }
            if (task.getStartDate().isPresent() && task.getEndDate().isPresent()) {

                return !(taskStartDate.isAfter(date) || taskEndDate.isBefore(date));
            }
            if (task.getStartDate().isPresent()) {
                return !(taskStartDate.isAfter(date));
            }
            return !(taskEndDate.isBefore(date));
        }

        @Override
        public String toString() {
            return "date=" + date.toString();
        }
    }

    private class DateRangeQualifier implements Qualifier {
        private LocalDate startDateCriteria, endDateCriteria;

        DateRangeQualifier(Date startDateCriteria, Date endDateCriteria) {
            this.startDateCriteria = startDateCriteria.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
            this.endDateCriteria = endDateCriteria.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            LocalDate taskStartDate = task.getStartDate().isPresent()
                    ? task.getStartDate().get().toInstant().atZone(ZoneId.systemDefault()).toLocalDate() : null;
            LocalDate taskEndDate = task.getEndDate().isPresent()
                    ? task.getEndDate().get().toInstant().atZone(ZoneId.systemDefault()).toLocalDate() : null;

            boolean isFloatingTask = !(task.getStartDate().isPresent() || task.getEndDate().isPresent());
            if (isFloatingTask) {
                return false;
            } else if (task.getStartDate().isPresent() && task.getEndDate().isPresent()) {
                return !(taskStartDate.isBefore(startDateCriteria) || taskEndDate.isAfter(endDateCriteria));
            } else if (task.getStartDate().isPresent()) {
                return !(taskStartDate.isBefore(startDateCriteria) || taskStartDate.isAfter(startDateCriteria));
            } else {
                return !(taskEndDate.isBefore(startDateCriteria) || taskEndDate.isAfter(startDateCriteria));
            }
        }

        @Override
        public String toString() {
            return "date range=" + startDateCriteria.toString() + " to " + endDateCriteria.toString();
        }
    }
```
###### /java/seedu/taskmanager/model/task/EndDate.java
``` java
    private static final SimpleDateFormat sdfOutput = new SimpleDateFormat("dd/MM/yyyy h:mm a");
    private static final SimpleDateFormat sdfInput = new SimpleDateFormat("dd/MM/yyyy");

    /**
     * Validates given end date.
     *
     * @throws IllegalValueException
     *             if given end date string is invalid.
     */
    public EndDate(String endDate) throws IllegalValueException {
        super(endDateConstructor(endDate));
    }

    private static long endDateConstructor(String endDate) throws IllegalValueException {
        try {
            return sdfInput.parse(endDate).getTime();
        } catch (ParseException e) {
            try {
                Parser parser = new Parser();
                List<DateGroup> dateGroups = parser.parse(endDate);
                return dateGroups.get(0).getDates().get(0).getTime();
            } catch (IndexOutOfBoundsException f) {
                throw new IllegalValueException(MESSAGE_ENDDATE_CONSTRAINTS);
            }
        }
    }
```
###### /java/seedu/taskmanager/model/task/EndDate.java
``` java
    @Override
    public String toString() {
        return sdfOutput.format(this);
    }

    public String toFullDateString() {
        return super.toString();
    }
```
###### /java/seedu/taskmanager/model/task/ReadOnlyTask.java
``` java
        builder.append(getTitle())
                .append(getStartDate().isPresent() ? " Start Date: " + getStartDate().get() : "")
                .append(getEndDate().isPresent() ? " End Date: " + getEndDate().get() : "")
                .append(getDescription().isPresent() ? " Description: " + getDescription().get() : "")
                .append(" Status: " + getStatus())
                .append(" Tags: ");
        getTags().forEach(builder::append);
```
###### /java/seedu/taskmanager/model/task/StartDate.java
``` java
    private static final SimpleDateFormat sdfOutput = new SimpleDateFormat("dd/MM/yyyy h:mm a");
    private static final SimpleDateFormat sdfInput = new SimpleDateFormat("dd/MM/yyyy");

    /**
     * Validates given start date.
     *
     * @throws IllegalValueException
     *             if given start date is invalid.
     */
    public StartDate(String startDate) throws IllegalValueException {
        super(startDateConstructor(startDate));
    }

    private static long startDateConstructor(String startDate) throws IllegalValueException {
        try {
            return sdfInput.parse(startDate).getTime();
        } catch (ParseException e) {
            try {
                Parser parser = new Parser();
                List<DateGroup> dateGroups = parser.parse(startDate);
                return dateGroups.get(0).getDates().get(0).getTime();
            } catch (IndexOutOfBoundsException f) {
                throw new IllegalValueException(MESSAGE_STARTDATE_CONSTRAINTS);
            }
        }
    }
```
###### /java/seedu/taskmanager/model/task/StartDate.java
``` java
    @Override
    public String toString() {
        return sdfOutput.format(this);
    }

    public String toFullDateString() {
        return super.toString();
    }
```
###### /java/seedu/taskmanager/model/task/Task.java
``` java
    private Optional<StartDate> startDate;
    private Optional<EndDate> endDate;
    private Optional<Description> description;
```
###### /java/seedu/taskmanager/model/task/Task.java
``` java
    /**
     * Every field must be present and not null.
     */
    public Task(Title title, Optional<StartDate> startDate, Optional<EndDate> endDate,
            Optional<Description> description, Status status, UniqueTagList tags) {
        assert !CollectionUtil.isAnyNull(title, endDate, description, tags);
        this.title = title;
        this.startDate = startDate;
        this.endDate = endDate;
        this.description = description;
        this.tags = new UniqueTagList(tags); // protect internal tags from
                                             // changes in the arg list
        this.status = status;
    }
```
###### /java/seedu/taskmanager/model/task/Task.java
``` java
    public void setStartDate(Optional<StartDate> startDate) {
        this.startDate = startDate;
    }

    @Override
    public Optional<StartDate> getStartDate() {
        return startDate;
    }

    public void setEndDate(Optional<EndDate> endDate) {
        assert endDate != null;
        this.endDate = endDate;
    }

    @Override
    public Optional<EndDate> getEndDate() {
        return endDate;
    }

    public void setDescription(Optional<Description> description) {
        assert description != null;
        this.description = description;
    }

    @Override
    public Optional<Description> getDescription() {
        return description;
    }
```
###### /java/seedu/taskmanager/model/task/UniqueTaskList.java
``` java
            if (!t1.getStartDate().isPresent() && !t2.getStartDate().isPresent()) {
                return 0;
            } else if (t1.getStartDate().isPresent()) {
                return -1;
            } else {
                return 1;
            }
```
###### /java/seedu/taskmanager/model/task/UniqueTaskList.java
``` java
            if (!t1.getEndDate().isPresent() && !t2.getEndDate().isPresent()) {
                return 0;
            } else if (t1.getEndDate().isPresent()) {
                return -1;
            } else {
                return 1;
            }
        }
    }
}
```
###### /java/seedu/taskmanager/model/util/SampleDataUtil.java
``` java
            return new Task[] {
                new Task(new Title("Visit Alex Yeoh"), Optional.ofNullable(new StartDate("01/11/2017")),
                        Optional.ofNullable(new EndDate("02/11/2017")),
                        Optional.ofNullable(new Description("His address is Blk 30 Geylang Street 29, #06-40")),
                        new UniqueTagList("social")),
                new Task(new Title("Collect files from boss"), Optional.ofNullable(new StartDate("05/11/2017")),
                        Optional.ofNullable(new EndDate("08/11/2017")),
                        Optional.ofNullable(new Description("Important business files")),
                        new UniqueTagList("colleagues", "business")),
                new Task(new Title("Visit Charlotte Oliveiro"), Optional.ofNullable(new StartDate("20/12/2017")),
                        Optional.ofNullable(new EndDate("20/12/2017")),
                        Optional.ofNullable(new Description("Her address is Blk 11 Ang Mo Kio Street 74, #11-04")),
                        new UniqueTagList("social")),
                new Task(new Title("Call David Li"), Optional.ofNullable(new StartDate("08/08/2017")),
                        Optional.ofNullable(new EndDate("10/08/2017")),
                        Optional.ofNullable(new Description("his number is 12345678")),
                        new UniqueTagList("schoolwork")),
                new Task(new Title("Submit project report"), Optional.ofNullable(new StartDate("20/07/2017")),
                        Optional.ofNullable(new EndDate("21/07/2017")),
                        Optional.ofNullable(new Description("Submit to tutor in class")),
                        new UniqueTagList("schoolwork")) };
```
###### /java/seedu/taskmanager/storage/XmlAdaptedTask.java
``` java
    public Task toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        final Title title = new Title(this.title);
        final StartDate startDate = this.startDate == null ? null : new StartDate(this.startDate);
        final EndDate endDate = this.endDate == null ? null : new EndDate(this.endDate);
        final Description description = this.description == null ? null : new Description(this.description);
        final UniqueTagList tags = new UniqueTagList(taskTags);
```
###### /java/seedu/taskmanager/storage/XmlAdaptedTask.java
``` java
        return new Task(title, Optional.ofNullable(startDate), Optional.ofNullable(endDate),
                Optional.ofNullable(description), status, tags);
    }
```
###### /java/seedu/taskmanager/ui/TaskCard.java
``` java
        startDate.setText(task.getStartDate().isPresent() ? "Starts on " + task.getStartDate().get() : "");
        endDate.setText(task.getEndDate().isPresent() ? "Ends on " + task.getEndDate().get() : "");
        description.setText(task.getDescription().isPresent() ? task.getDescription().get().value : "");
```
