# A0140023E
###### /java/onlythree/imanager/commons/core/DateTimeFormats.java
``` java
/**
 * Date-time formats used for different purposes
 */
public class DateTimeFormats {
    /**
     * A compact format for CLI display
     */
    public static final DateTimeFormatter CLI_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss z");
    /**
     * Format that is based on the user's locale that is reasonably compact
     */
    public static final DateTimeFormatter LOCALIZED_FORMAT =
            DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM);
    /**
     * Full format that preserves all information about a date-time
     */
    public static final DateTimeFormatter STORAGE_FORMAT = DateTimeFormatter.ISO_DATE_TIME;

    /**
     * Format that can be used for testing. Works with Natty by converting the date-time to the
     * local date-time and omitting the time-zone information as Natty do not handle all time-zones correctly.
     * Milliseconds and nanoseconds are ignored as they are ignored by Natty.
     **/
    public static final DateTimeFormatter TEST_FORMAT = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
    /**
     * The system default time-zone.
     * @see ZoneId#systemDefault()
     * @see TimeZone#getDefault()
     */
    public static final ZoneId SYSTEM_TIME_ZONE = ZoneId.systemDefault();
}
```
###### /java/onlythree/imanager/commons/util/StringUtil.java
``` java
    /**
     * Returns {@code s} with substring of {@code s} specified by {@code startIndex} and {@code endIndex}
     * replaced with the substring {@code replacement}. The substring begins at the
     * specified {@code startIndex} and ends at {@code endIndex} - 1 or to the
     * end of the s if {@code endIndex} is larger than length of s. First the characters in the substring
     * are removed and then the specified String is inserted at {@code startIndex}. (The String will be
     * lengthened to accommodate the specified String if necessary.)
     *
     * @param s the String that contains the substring to be replaced specified by {@code startIndex} and
     *        {@code endIndex}
     * @param startIndex The beginning index, inclusive.
     * @param endIndex The ending index, exclusive.
     * @param replacement the substring to replace
     * @return s with substring replaced
     * @see StringBuilder#replace(int, int, String)
     */
    public static String replace(String s, int startIndex, int endIndex, String replacement) {
        assert s != null && replacement != null;

        StringBuilder sb = new StringBuilder(s);
        sb.replace(startIndex, endIndex, replacement);
        return sb.toString();
    }
}
```
###### /java/onlythree/imanager/logic/commands/AddCommand.java
``` java
    /**
     * Creates an AddCommand using raw values except {@code deadline} and {@code startEndDateTime}
     * that must be pre-initialized.
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String nameArgs, Optional<Deadline> deadline,
            Optional<StartEndDateTime> startEndDateTime, Set<String> tags) throws IllegalValueException {
        toAdd = new Task(new Name(nameArgs), deadline, startEndDateTime, initTagList(tags));
    }

    /**
     * Returns initialized tags as a {@link UniqueTagList}
     * @throws IllegalValueException if there is a tag name that is invalid in the given tags set
     */
    private UniqueTagList initTagList(Set<String> tags) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        return new UniqueTagList(tagSet);
    }


    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        model.addTask(toAdd);
```
###### /java/onlythree/imanager/logic/commands/EditCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = lastShownList.get(filteredTaskListIndex);
        try {
            editTaskDescriptor.processFields(taskToEdit);
        } catch (PastDateTimeException | InvalidDurationException | IllegalValueException e) {
            throw new CommandException(e.getMessage());
        }

        if (!this.editTaskDescriptor.isAnyFieldEdited(taskToEdit)) {
            throw new CommandException(EditCommand.MESSAGE_NOT_EDITED);
        }

        try {
            Task editedTask = new Task(editTaskDescriptor.getUpdatedName(),
                    editTaskDescriptor.getUpdatedDeadline(),
                    editTaskDescriptor.getUpdatedStartEndDateTime(),
                    editTaskDescriptor.getUpdatedTagList());
            model.updateTask(filteredTaskListIndex, editedTask);
            model.updateFilteredListToShowAll();
        } catch (IllegalValueException e) {
            throw new CommandException(e.getMessage());
        }

        int taskIndex = model.getSourceIndexFromFilteredTasks(filteredTaskListIndex);
        EventsCenter.getInstance().post(new JumpToListRequestEvent(taskIndex));

```
###### /java/onlythree/imanager/logic/commands/EditCommand.java
``` java
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
    }

    /**
     * Stores the details to edit the task with. Each non-empty field value will replace the
     * corresponding field value of the task.
     */
    public static class EditTaskDescriptor {
        public static final String MESSAGE_NEED_START_END_DATE_TIME = "Must have both start and end date-time";

        private Optional<Name> name = Optional.empty();
        private Optional<String> rawDeadline = Optional.empty();
        private Optional<String> rawStartDateTime = Optional.empty();
        private Optional<String> rawEndDateTime = Optional.empty();
        private Optional<UniqueTagList> tagList = Optional.empty();

        private Name updatedName;
        private Optional<Deadline> updatedDeadline;
        private Optional<StartEndDateTime> updatedStartEndDateTime;
        private UniqueTagList updatedTagList;

        public EditTaskDescriptor() {}

        public EditTaskDescriptor(EditTaskDescriptor toCopy) {
            name = toCopy.getName();
            rawDeadline = toCopy.getRawDeadline();
            rawStartDateTime = toCopy.getRawStartDateTime();
            rawEndDateTime = toCopy.getRawEndDateTime();
            tagList = toCopy.getTagList();

            updatedName = toCopy.getUpdatedName();
            updatedDeadline = toCopy.getUpdatedDeadline();
            updatedStartEndDateTime = toCopy.getUpdatedStartEndDateTime();
            updatedTagList = toCopy.getUpdatedTagList();
        }

        public void processFields(ReadOnlyTask taskToEdit)
                throws PastDateTimeException, InvalidDurationException, IllegalValueException {

            processName(taskToEdit);
            processDeadline(taskToEdit);
            processStartEndDateTime(taskToEdit);
            processTagList(taskToEdit);
        }

        private void processName(ReadOnlyTask taskToEdit) {
            updatedName = getName().orElseGet(taskToEdit::getName);
        }

        private void processDeadline(ReadOnlyTask taskToEdit)
                throws PastDateTimeException, IllegalValueException {
            if (!getRawDeadline().isPresent()) {
                updatedDeadline = taskToEdit.getDeadline();
                return;
            }

            if (taskToEdit.getDeadline().isPresent()) {
                updatedDeadline = ParserUtil.parseEditedDeadline(getRawDeadline(), taskToEdit.getDeadline().get());
            } else {
                updatedDeadline = ParserUtil.parseNewDeadline(getRawDeadline());
            }
        }

        private void processStartEndDateTime(ReadOnlyTask taskToEdit)
                throws PastDateTimeException, InvalidDurationException, IllegalValueException {
            updatedStartEndDateTime = Optional.empty();

            if (hasNoRawStartAndEndDateTime()) {
                updatedStartEndDateTime = taskToEdit.getStartEndDateTime();
                return;
            }

            if (!taskToEdit.getStartEndDateTime().isPresent()) {
                if (hasBothRawStartAndEndDateTime()) {
                    updatedStartEndDateTime =
                            ParserUtil.parseNewStartEndDateTime(getRawStartDateTime(), getRawEndDateTime());
                    return;
                }
                throw new IllegalValueException(MESSAGE_NEED_START_END_DATE_TIME);
            }

            final StartEndDateTime originalStartEndDateTime = taskToEdit.getStartEndDateTime().get();

            if (hasBothRawStartAndEndDateTime()) {
                processUsingRawStartAndEnd(originalStartEndDateTime);
            } else if (hasOnlyRawStartDateTime()) {
                processUsingRawStart(originalStartEndDateTime);
            } else if (hasOnlyRawEndDateTime()) {
                processUsingRawEnd(originalStartEndDateTime);
            }
        }

        private boolean hasNoRawStartAndEndDateTime() {
            return !getRawStartDateTime().isPresent() && !getRawEndDateTime().isPresent();
        }

        private boolean hasBothRawStartAndEndDateTime() {
            return getRawStartDateTime().isPresent() && getRawEndDateTime().isPresent();
        }

        private boolean hasOnlyRawStartDateTime() {
            return getRawStartDateTime().isPresent() && !getRawEndDateTime().isPresent();
        }

        private boolean hasOnlyRawEndDateTime() {
            return !getRawStartDateTime().isPresent() && getRawEndDateTime().isPresent();
        }

        /**
         * Process the updated StartEndDateTime with the raw start and date-time with reference to the
         * original start-end date-time.
         */
        private void processUsingRawStartAndEnd(StartEndDateTime originalStartEndDateTime)
                throws PastDateTimeException, InvalidDurationException, IllegalValueException {

            updatedStartEndDateTime = ParserUtil.parseEditedStartEndDateTime(getRawStartDateTime(),
                    getRawEndDateTime(), originalStartEndDateTime);
        }

        /**
         * Process the updated StartEndDateTime with the raw start date-time with reference to the
         * original end date time.
         */
        private void processUsingRawStart(StartEndDateTime originalStartEndDateTime)
                throws PastDateTimeException, InvalidDurationException, IllegalValueException {

            ZonedDateTime startDateTime = DateTimeUtil.parseEditedDateTimeString(
                    getRawStartDateTime().get(), originalStartEndDateTime.getStartDateTime());
            ZonedDateTime endDateTime = originalStartEndDateTime.getEndDateTime();
            updatedStartEndDateTime = Optional.of(new StartEndDateTime(startDateTime, endDateTime));
        }

        /**
         * Process the updated StartEndDateTime with the raw end date-time with reference to the
         * original start date time.
         */
        private void processUsingRawEnd(StartEndDateTime originalStartEndDateTime)
                throws PastDateTimeException, InvalidDurationException, IllegalValueException {

            ZonedDateTime startDateTime = originalStartEndDateTime.getStartDateTime();
            ZonedDateTime endDateTime = DateTimeUtil.parseEditedDateTimeString(getRawEndDateTime().get(),
                    originalStartEndDateTime.getEndDateTime());
            updatedStartEndDateTime = Optional.of(new StartEndDateTime(startDateTime, endDateTime));
        }

        private void processTagList(ReadOnlyTask taskToEdit) {
            updatedTagList = getTagList().orElseGet(taskToEdit::getTags);
        }

        /**
         * Returns true if at least one field that is different is edited.
         */
        public boolean isAnyFieldEdited(ReadOnlyTask taskToEdit) {
            // note that the tags are added in alphabetical order and uses list compare vs set compare
            if (updatedName.equals(taskToEdit.getName())
                    && updatedDeadline.equals(taskToEdit.getDeadline())
                    && updatedStartEndDateTime.equals(taskToEdit.getStartEndDateTime())
                    && updatedTagList.equals(taskToEdit.getTags())) {
                return false;
            }
            return true;
        }

        //// methods for initializing an EditTaskDescriptor
        public void setName(Optional<Name> name) {
            assert name != null;
            this.name = name;
        }

        public void setRawDeadline(Optional<String> rawDeadline) {
            assert rawDeadline != null;
            this.rawDeadline = rawDeadline;
        }

        public void setRawStartDateTime(Optional<String> rawStartDateTime) {
            assert rawStartDateTime != null;
            this.rawStartDateTime = rawStartDateTime;
        }

        public void setRawEndDateTime(Optional<String> rawEndDateTime) {
            assert rawEndDateTime != null;
            this.rawEndDateTime = rawEndDateTime;
        }

        public void setTagList(Optional<UniqueTagList> tagList) {
            assert tagList != null;
            this.tagList = tagList;
        }

        //// methods for getting the un-processed edited fields
        public Optional<Name> getName() {
            return name;
        }

        public Optional<String> getRawDeadline() {
            return rawDeadline;
        }

        public Optional<String> getRawStartDateTime() {
            return rawStartDateTime;
        }

        public Optional<String> getRawEndDateTime() {
            return rawEndDateTime;
        }

        public Optional<UniqueTagList> getTagList() {
            return tagList;
        }

        //// methods for getting the processed edited fields
        public Name getUpdatedName() {
            return updatedName;
        }

        public Optional<Deadline> getUpdatedDeadline() {
            return updatedDeadline;
        }
        public Optional<StartEndDateTime> getUpdatedStartEndDateTime() {
            return updatedStartEndDateTime;
        }

        public UniqueTagList getUpdatedTagList() {
            return updatedTagList;
        }
    }
}
```
###### /java/onlythree/imanager/logic/commands/SelectCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.isEmpty()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        if (lastShownList.size() < targetNum) {
            targetNum = lastShownList.size();
        }

        int targetIndex = targetNum - 1;

        ReadOnlyTask selectedTask = lastShownList.get(targetIndex);

        EventsCenter.getInstance().post(new JumpToListRequestEvent(targetIndex));

        return new CommandResult(
                String.format(MESSAGE_SELECT_TASK_SUCCESS, targetNum, getCompactFormattedTask(selectedTask)));
    }

    /**
     * Returns the task with only the task name and tags.
     */
    private String getCompactFormattedTask(ReadOnlyTask task) {
        StringBuilder sb = new StringBuilder();

        sb.append(task.getName());
        sb.append(System.lineSeparator());

        sb.append("Tags: ");
        task.getTags().forEach(sb::append);

        return sb.toString();
    }
}
```
###### /java/onlythree/imanager/logic/DateTimeUtil.java
``` java
/**
 * Contains utility methods used for handling natural-language date-times using Natty.
 */
public class DateTimeUtil {

    private static Parser dateTimeParser = new Parser(TimeZone.getTimeZone(DateTimeFormats.SYSTEM_TIME_ZONE));

    private static final String NATTY_TOKEN_DATE_TIME_ALTERNATIVE = "DATE_TIME_ALTERNATIVE";
    private static final String NATTY_TOKEN_DATE_TIME = "DATE_TIME";
    private static final String NATTY_TOKEN_RELATIVE_DATE = "RELATIVE_DATE";
    private static final String NATTY_TOKEN_RELATIVE_TIME = "RELATIVE_TIME";

    public static final String MESSAGE_NOT_VALID_DATE_TIME = "%1$s is not a valid date/time.";
    public static final String MESSAGE_MULTIPLE_DATE_TIMES_FOUND =
            "Multiple date/times found when expecting only one date from %1$s";
    public static final String MESSAGE_MULTIPLE_DATE_TIME_ALTERNATIVES_FOUND =
            "Date/time alternatives found from %1$s when only one date/time is expected";
    public static final String MESSAGE_RECURRING_DATE_TIME_FOUND =
                    "Recurring date/times are not supported. Found from %1$s";

    public static void initializeNatty() {
        // TODO find a better way to do initialize Natty
        // Hack: Initialize Natty by parsing a valid date-time string
        // because some startup time is required for Natty
        dateTimeParser.parse("tmr");
    }

    /**
     * Parses Date strings into a {@code ZonedDateTime}.
     */
    public static ZonedDateTime parseDateTimeString(String dateTime) throws IllegalValueException {
        DateGroup dateGroup = parseDateTimeStringHelper(dateTime);
        // the date group returned should contain one and only one date.
        assert dateGroup.getDates() != null && dateGroup.getDates().size() == 1;

        final Date date = dateGroup.getDates().get(0);
        // Convert the old java.util.Date class to the much better new classes in java.time package
        ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(date.toInstant(), DateTimeFormats.SYSTEM_TIME_ZONE);
        return zonedDateTime;
    }

    public static ZonedDateTime parseEditedDateTimeString(String dateTime, ZonedDateTime previousDateTime)
            throws IllegalValueException {

        DateGroup dateGroup = parseDateTimeStringHelper(dateTime);
        // the date group returned should contain one and only one date.
        assert dateGroup.getDates() != null && dateGroup.getDates().size() == 1;

        final Date date = dateGroup.getDates().get(0);

        String dateTimeType = getDateTimeType(dateGroup.getSyntaxTree());

        Date newDate;
        if (dateTimeType.equals(NATTY_TOKEN_RELATIVE_DATE) || dateTimeType.equals(NATTY_TOKEN_RELATIVE_TIME)) {
            // Relative date should be parsed relative to the current date, which has been parsed previously
            // special cases such as 2 days after 25 Apr also works
            // but cases such as 2 hours after 25 Apr 8pm does not work
            newDate = date;
        } else if (hasDateAndTimeSpecified(dateGroup)) {
            // date and time already clearly specified so no need to parse relative to previous date-time
            newDate = date;
        } else {
            newDate = parseDateTimeUsingPrevious(dateGroup, previousDateTime);
        }
        // Convert the old java.util.Date class to the much better new classes in java.time package
        ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(newDate.toInstant(), DateTimeFormats.SYSTEM_TIME_ZONE);
        return zonedDateTime;
    }

    /**
     * Returns the type of the date-time, e.g. whether it is an explicit date, relative date, or relative time.
     */
    private static String getDateTimeType(Tree dateTimeAlternativeRoot) {
        assert dateTimeAlternativeRoot != null;

        assert dateTimeAlternativeRoot.getText().equals(NATTY_TOKEN_DATE_TIME_ALTERNATIVE)
        && dateTimeAlternativeRoot.getChildCount() == 1;

        Tree dateTimeSubtree = dateTimeAlternativeRoot.getChild(0);
        assert dateTimeSubtree.getText().equals(NATTY_TOKEN_DATE_TIME)
        && dateTimeSubtree.getChildCount() >= 1;

        // note that we only return the first child of the date-time subtree because it is enough to determine
        // the date-type due to the way Natty parses dates. However, this is a brittle approach but there seems
        // to be no better way to do this.
        Tree dateTimeTypeSubtree = dateTimeSubtree.getChild(0);
        return dateTimeTypeSubtree.getText();
    }

    /**
     * Returns a new date-time using the previous date or time combined with the date or time component extracted.
     */
    private static Date parseDateTimeUsingPrevious(DateGroup previousDateGroup, ZonedDateTime previousDateTime)
            throws IllegalValueException {

        String extractedDateTime = extractComponentFromDateTime(previousDateGroup);
        DateGroup newDateGroup = parseDateTimeStringUsingPreviousHelper(extractedDateTime, previousDateTime);

        // the date group returned should contain one and only one date.
        assert newDateGroup.getDates() != null && newDateGroup.getDates().size() == 1;

        Date newDate = newDateGroup.getDates().get(0);
        return newDate;
    }

    /**
     * Extracts the date or time component from the date-time given and format it as a string. The
     * date component will be extracted if only date is specified and the time component will be extracted
     * if only time is specified.
     */
    private static String extractComponentFromDateTime(DateGroup dateGroup) {
        // the date group given should contain one and only one date.
        assert dateGroup.getDates() != null && dateGroup.getDates().size() == 1;
        // The date and time cannot be both inferred as that means nothing is specified at all
        assert !(dateGroup.isDateInferred() && dateGroup.isTimeInferred());
        // if both date and time is specified we cannot extract any components
        assert !hasDateAndTimeSpecified(dateGroup);

        final Date date = dateGroup.getDates().get(0);

        final boolean hasOnlyTimeSpecified = dateGroup.isDateInferred();
        if (hasOnlyTimeSpecified) {
            // note Natty does not support some timezones so we use offset but this means timezone info
            // such as daylight saving time adjustments may be lost
            // milliseconds are also also ignored as Natty does not parse them
            return new SimpleDateFormat("HH:mm:ss Z").format(date);
        }

        final boolean hasOnlyDateSpecified = dateGroup.isTimeInferred();
        if (hasOnlyDateSpecified) {
            return new SimpleDateFormat("yyyy-MM-dd").format(date);
        }

        throw new AssertionError("An extracted date/time component should have been returned.");
    }

    private static boolean hasDateAndTimeSpecified(DateGroup dateGroup) {
        return !dateGroup.isDateInferred() && !dateGroup.isTimeInferred();
    }

    private static DateGroup parseDateTimeStringUsingPreviousHelper(String dateTime,
            ZonedDateTime previousDateTime) throws IllegalValueException {
        // Convert back to old java.util.Date class for use in Natty
        Date previousDateTimeAsOldDateClass = Date.from(previousDateTime.toInstant());
        List<DateGroup> dateGroups = dateTimeParser.parse(dateTime, previousDateTimeAsOldDateClass);

        checkForSingleDateGroup(dateGroups, dateTime);

        final DateGroup dateGroup = dateGroups.get(0);

        // rejects recurring dates as they implicitly means it's more than one date
        if (dateGroup.isRecurring()) {
            throw new IllegalValueException(String.format(MESSAGE_RECURRING_DATE_TIME_FOUND, dateTime));
        }

        checkForSingleDateAlternative(dateGroup, dateTime);

        // returns the date group that represents the date-time and extra information about it
        return dateGroup;
    }

    /**
     * Returns a DateGroup representing the date-time with extra information about it.
     */
    private static DateGroup parseDateTimeStringHelper(String dateTime) throws IllegalValueException {
        final List<DateGroup> dateGroups = dateTimeParser.parse(dateTime);

        checkForSingleDateGroup(dateGroups, dateTime);

        final DateGroup dateGroup = dateGroups.get(0);

        // rejects recurring dates as they implicitly means it's more than one date
        if (dateGroup.isRecurring()) {
            throw new IllegalValueException(String.format(MESSAGE_RECURRING_DATE_TIME_FOUND, dateTime));
        }

        checkForSingleDateAlternative(dateGroup, dateTime);

        // returns the date group that represents the date-time and extra information about it
        return dateGroup;
    }

    private static void checkForSingleDateGroup(List<DateGroup> dateGroups, String dateTime)
            throws IllegalValueException {

        if (dateGroups.size() == 0) {
            throw new IllegalValueException(String.format(MESSAGE_NOT_VALID_DATE_TIME, dateTime));
        }

        if (dateGroups.size() > 1) {
            throw new IllegalValueException(String.format(MESSAGE_MULTIPLE_DATE_TIMES_FOUND, dateTime));
        }

        assert dateGroups.size() == 1;
    }

    private static void checkForSingleDateAlternative(DateGroup dateGroup, String dateTime)
            throws IllegalValueException {

        final List<Date> dateAlternatives = dateGroup.getDates();

        // if there is at least one date group, there should always be at least one date.
        // Therefore, if the assertion fail there might be a bug in Natty.
        assert dateAlternatives.size() >= 1;

        if (dateAlternatives.size() > 1) {
            throw new IllegalValueException(String.format(MESSAGE_MULTIPLE_DATE_TIME_ALTERNATIVES_FOUND, dateTime));

        }

        assert dateAlternatives.size() == 1;
    }

    /**
     * Returns true if a String contains only a single date-time string parseable by Natty, otherwise returns false.
     */
    public static boolean isSingleDateTimeString(String dateTime) {
        final List<DateGroup> dateGroups = dateTimeParser.parse(dateTime);


        if (!isSingleDateGroup(dateGroups)) {
            return false;
        }

        DateGroup dateGroup = dateGroups.get(0);

        // rejects recurring dates as they implicitly means it's more than one date
        if (dateGroup.isRecurring()) {
            return false;
        }

        if (!isSingleDateAlternative(dateGroup)) {
            return false;
        }

        return true;
    }

    private static boolean isSingleDateGroup(List<DateGroup> dateGroups) {
        if (dateGroups.size() == 0) {
            return false;
        }

        // Example: "Wed ~ Thur" will result in 2 date groups
        if (dateGroups.size() > 1) {
            return false;
        }

        assert dateGroups.size() == 1;
        return true;
    }

    private static boolean isSingleDateAlternative(DateGroup dateGroup) {
        final List<Date> dateAlternatives = dateGroup.getDates();

        // if there is at least one date group, there should always be at least one date.
        // Therefore, if the assertion fail there might be a bug in Natty.
        assert dateAlternatives.size() >= 1;

        // Example: "Wed or Thur" will result in 2 date alternatives
        if (dateAlternatives.size() > 1) {
            return false;
        }

        assert dateAlternatives.size() == 1;
        return true;
    }
}
```
###### /java/onlythree/imanager/logic/parser/AddCommandParser.java
``` java
/**
 * Parses input arguments and creates a new AddCommand object
 */
public class AddCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the AddCommand
     * and returns an AddCommand object for execution.
     */
    public Command parse(String args) {
        DateTimeExtractor dateTimeExtractor;
        try {
            dateTimeExtractor = extractDateTimes(args);
        } catch (PastDateTimeException | InvalidDurationException e) {
            return new IncorrectCommand(e.getMessage());
        }

        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_TAG);
        argsTokenizer.tokenize(dateTimeExtractor.getProcessedArgs());
        try {
            String nameArgs = argsTokenizer.getPreamble().get();

            return new AddCommand(nameArgs, dateTimeExtractor.getProcessedDeadline(),
                    dateTimeExtractor.getProcessedStartEndDateTime(),
                    ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG)));
        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * Extracts date-times from the arguments if they exist and returns a {@link DateTimeExtractor}
     * with the processed date-times if they exist.
     *
     * @param args the arguments to extract date/time from
     * @throws PastDateTimeException if any of the extracted date-times are in the past
     * @throws InvalidDurationException if a start and end date-time is found and the end date-time
     *         is before or same as the start date-time
     */
    private DateTimeExtractor extractDateTimes(String args)
            throws PastDateTimeException, InvalidDurationException {
        DateTimeExtractor dateTimeExtractor = new DateTimeExtractor(args);
        // process StartEndDateTime first because it is more likely to fail due to more constraints
        dateTimeExtractor.processStartEndDateTime();
        // constraints for deadline are looser so it is less likely to fail
        dateTimeExtractor.processDeadline();

        return dateTimeExtractor;
    }

}
```
###### /java/onlythree/imanager/logic/parser/DateTimeExtractor.java
``` java
/**
 * Specialized class that can extract Deadline and StartEndDateTime from a command's arguments. Only
 * a single date-time field can be extracted, which means once a Deadline or StartEndDateTime has
 * been extracted, further attempts on extraction would fail.
 */
public class DateTimeExtractor {

    private static final String SINGLE_DATE_TIME_PROCESSED =
            "A single date-time field has already been processed. Processing is skipped";

    private static final String MESSAGE_ALREADY_PROCESSED =
            "Processing stopped to prevent overriding of %1$s. %1$s is already processed.";

    private static final String MESSAGE_ALREADY_PROCESSED_MULTI =
            "Processing stopped to prevent overriding of %1$s and %2$s."
                    + "Both/either of them are already processed.";

    private final Logger logger = LogsCenter.getLogger(DateTimeExtractor.class);

    /**
     * Regex that matches the preamble before any argument.
     * Matches everything greedily until the next regex so any number of from and to can be included.
     * e.g. preamblePattern matches "from by to" from the String "from by to by tmr" in a Regex expression
     * containing PREAMBLE_REGEX + ARG_NAME_FROM_REGEX
     */
    private static final String PREAMBLE_REGEX = ".*";

    /**
     * Regex that matches the argument name [from].
     * Matches a single whitespace character (i.e. 0x20\t\n\x0B\f\r) in between a "from".
     * This prevents matching words such as therefrom and fromage.
     */
    private static final String ARG_NAME_FROM_REGEX = "(?<fromArg>\\sfrom\\s)";

    /**
     * Regex that matches the argument value startDateTime.
     * Matches everything greedily.
     */
    private static final String ARG_VALUE_FROM_GREEDY_REGEX = "(?<startDateTime>.+)";

    /**
     * Regex that matches the argument value startDateTime.
     * Matches everything lazily.
     */
    private static final String ARG_VALUE_FROM_LAZY_REGEX = "(?<startDateTime>.+?)";

    /**
     * Regex that matches the argument name [to].
     * Matches a single whitespace character (i.e. 0x20\t\n\x0B\f\r) in between a "to".
     * This prevents matching words such as auto and tomorrow.
     */
    private static final String ARG_NAME_TO_REGEX =  "(?<toArg>\\sto\\s)";

    /**
     * Regex that matches the argument value endDateTime.
     * Matches everything lazily.
     */
    private static final String ARG_VALUE_TO_LAZY_REGEX = "(?<endDateTime>.+?)";

    /**
     * Regex that matches the argument name [by].
     * Matches a single whitespace character (i.e. 0x20\t\n\x0B\f\r) in between a "by".
     * This prevents matching words such as baby and bypass.
     */
    private static final String ARG_NAME_BY_REGEX = "(?<byArg>\\sby\\s)";
    /**
     * Regex that matches the argument value deadline.
     * Matches everything lazily.
     */
    private static final String ARG_VALUE_BY_LAZY_REGEX = "(?<deadline>.+?)";

    // match a white space character and a tag with zero or more times
    private static final String ARG_ALL_TAGS_REGEX = "(?<tagArguments>(\\st/[^/]+)*)";

    /**
     * Pattern that checks if a string contains a start and end date-time.
     * Can be used for adding or editing tasks with a start and end date/time.
     */
    public static final Pattern HAS_START_END_DATETIME_FORMAT = Pattern.compile(
            PREAMBLE_REGEX
            + ARG_NAME_FROM_REGEX
            + ARG_VALUE_FROM_GREEDY_REGEX
            + ARG_NAME_TO_REGEX
            + ARG_VALUE_TO_LAZY_REGEX // lazy match as next expression is optional
            + ARG_ALL_TAGS_REGEX);

    /**
     * Pattern that checks if a string contains a deadline date-time.
     * Can be used for adding or editing tasks with a deadline.
     */
    public static final Pattern HAS_DEADLINE_FORMAT = Pattern.compile(
            PREAMBLE_REGEX
            + ARG_NAME_BY_REGEX
            + ARG_VALUE_BY_LAZY_REGEX // lazy match as next expression is optional
            + ARG_ALL_TAGS_REGEX);

    /**
     * Pattern that checks if a string contains a start date-time.
     * Can be used for editing tasks that already has a start and end date-time.
     */
    public static final Pattern HAS_START_DATETIME_FORMAT = Pattern.compile(
            PREAMBLE_REGEX
            + ARG_NAME_FROM_REGEX
            + ARG_VALUE_FROM_LAZY_REGEX // lazy match as next expression is optional
            + ARG_ALL_TAGS_REGEX);

    /**
     * Pattern that checks if a string contains a end date-time.
     * Can be used for editing tasks that already has a start and end date-time.
     */
    public static final Pattern HAS_END_DATETIME_FORMAT = Pattern.compile(
            PREAMBLE_REGEX
            + ARG_NAME_TO_REGEX
            + ARG_VALUE_TO_LAZY_REGEX // lazy match as next expression is optional
            + ARG_ALL_TAGS_REGEX);

    /**
     * Contains the argument string after processing.
     */
    private String processedArgs;

    /**
     * Contains the Deadline after processing. Empty if does not exist.
     */
    private Optional<Deadline> deadline;
    /**
     * Contains the raw Deadline string after processing. Empty if does not exist.
     */
    private Optional<String> rawDeadline;

    /**
     * Contains the startEndDateTime after processing. Empty if does not exist.
     */
    private Optional<StartEndDateTime> startEndDateTime;
    /**
     * Contains the raw startDateTime string after processing. Empty if does not exist.
     */
    private Optional<String> rawStartDateTime;
    /**
     * Contains the raw endDateTime string after processing. Empty if does not exist.
     */
    private Optional<String> rawEndDateTime;

    public DateTimeExtractor(String args) {
        processedArgs = args;
    }

    /**
     * Returns the arguments after processing
     */
    public String getProcessedArgs() {
        return processedArgs;
    }

    /**
     * Returns the processed deadline if it exists, otherwise returns empty. Returns null if not processed.
     */
    public Optional<Deadline> getProcessedDeadline() {
        return deadline;
    }

    /**
     * Returns the processed raw deadline if it exists, otherwise returns empty. Returns null if not processed.
     */
    public Optional<String> getProcessedRawDeadline() {
        return rawDeadline;
    }

    /**
     * Returns the processed startEndDateTime if it exists, otherwise returns empty. Returns null if not processed.
     */
    public Optional<StartEndDateTime> getProcessedStartEndDateTime() {
        return startEndDateTime;
    }

    /**
     * Returns the processed raw startDateTime if it exists, otherwise returns empty. Returns null if not processed.
     */
    public Optional<String> getProcessedRawStartDateTime() {
        return rawStartDateTime;
    }

    /**
     * Returns the processed raw endDateTime if it exists, otherwise returns empty. Returns null if not processed.
     */
    public Optional<String> getProcessedRawEndDateTime() {
        return rawEndDateTime;
    }

    /**
     * Returns if the argument value is processed.
     */
    private boolean isProcessed(Optional<?> argValue) {
        return argValue != null;
    }

    /**
     * Returns if the argument value is processed and has a value present.
     */
    private boolean isProcessedAndPresent(Optional<?> argValue) {
        return isProcessed(argValue) && argValue.isPresent();
    }

    /**
     * Checks if any of the date-time field is processed. Raw date-time fields are not checked.
     */
    private boolean hasDateTimeFieldProcessed() {
        return isProcessedAndPresent(deadline) || isProcessedAndPresent(startEndDateTime);
    }

    public void processDeadline() throws PastDateTimeException {
        if (isProcessedAndPresent(deadline)) {
            logger.warning(String.format(MESSAGE_ALREADY_PROCESSED, "deadline"));
            return;
        }

        deadline = Optional.empty();

        processRawDeadline();

        if (!isProcessedAndPresent(rawDeadline)) {
            return;
        }

        try {
            // Note that if performance is a concern, we should process the Deadline directly instead
            // of calling processRawDeadline so to avoid parsing dates twice
            // i.e. once in processRawDeadline and once in processDeadline
            deadline = Optional.of(new Deadline(DateTimeUtil.parseDateTimeString(rawDeadline.get())));
        } catch (IllegalValueException e) {
            logger.severe("processDeadline() failed with invalid date when processRawDeadline"
                    + "should have ensured a valid date is provided if the raw are present.");
        }
    }

    public void processRawDeadline() {
        if (hasDateTimeFieldProcessed()) {
            logger.info(SINGLE_DATE_TIME_PROCESSED);
            return;
        }

        if (isProcessedAndPresent(rawDeadline)) {
            logger.warning(String.format(MESSAGE_ALREADY_PROCESSED, "rawDeadline"));
            return;
        }

        rawDeadline = Optional.empty();

        Matcher matcher = HAS_DEADLINE_FORMAT.matcher(processedArgs);
        if (!matcher.matches()) {
            logger.info("----------------[PROCESS RAW DEADLINE][No deadline found]");
            return;
        }

        final String matchedRawDeadline = matcher.group("deadline");
        if (!DateTimeUtil.isSingleDateTimeString(matchedRawDeadline)) {
            logger.info("----------------[PROCESS RAWS DEADLINE][Deadline found but not a date]");
            return;
        }
        logger.info("----------------[PROCESS RAW DEADLINE][Start:" + matchedRawDeadline + "]");

        // Note that we still do not know the exact date/time of the deadline so it can be a date in the past.
        rawDeadline = Optional.of(matchedRawDeadline);

        // Date is valid so we can extract the arguments out. However, if it is a past date,
        // the processed argument becomes invalid but a PastDateTimeException will be thrown anyway, thus
        // not allowing the command to continue.
        processedArgs = extractArguments(matcher.start("byArg"), matcher.end("deadline"));
    }

    public void processStartEndDateTime()
            throws PastDateTimeException, InvalidDurationException {

        if (isProcessedAndPresent(startEndDateTime)) {
            logger.warning(String.format(MESSAGE_ALREADY_PROCESSED, "startEndDateTime"));
            return;
        }

        startEndDateTime = Optional.empty();

        processRawStartEndDateTime();

        if (!isProcessedAndPresent(rawStartDateTime) || !isProcessedAndPresent(rawEndDateTime)) {
            return;
        }

        try {
            // Note that if performance is a concern, we should process the startEndDateTime directly instead
            // of calling processRawStartEndDateTime() so to avoid parsing dates twice
            // i.e. once in processRawStartEndDateTime and once in processStartEndDateTime
            startEndDateTime =
                    Optional.of(new StartEndDateTime(DateTimeUtil.parseDateTimeString(rawStartDateTime.get()),
                            DateTimeUtil.parseDateTimeString(rawEndDateTime.get())));
        } catch (IllegalValueException e) {
            logger.severe("processStartEndDateTime() failed with invalid date when processRawStartEndDateTime"
                    + "should have ensured a valid date is provided if the raw are present.");
        }
    }

    public void processRawStartEndDateTime() {
        if (hasDateTimeFieldProcessed()) {
            logger.info(SINGLE_DATE_TIME_PROCESSED);
            return;
        }

        if (isProcessedAndPresent(rawStartDateTime) || isProcessedAndPresent(rawEndDateTime)) {
            logger.warning(String.format(MESSAGE_ALREADY_PROCESSED_MULTI, "rawStartDateTime", "rawEndDateTime"));
            return;
        }

        rawStartDateTime = Optional.empty();
        rawEndDateTime = Optional.empty();

        Matcher matcher = HAS_START_END_DATETIME_FORMAT.matcher(processedArgs);
        if (!matcher.matches()) {
            logger.info("----------------[PROCESS RAWSTARTENDDATETIME][No Start and End Date Time found]");
            return;
        }

        final String matchedStartDateTime = matcher.group("startDateTime");
        final String matchedEndDateTime = matcher.group("endDateTime");
        if (!DateTimeUtil.isSingleDateTimeString(matchedStartDateTime)
                || !DateTimeUtil.isSingleDateTimeString(matchedEndDateTime)) {
            logger.info("----------------[PROCESS RAWSTARTENDDATETIME][Start and End Date/Time found "
                    + "but both/either not a date]");
            return;
        }
        logger.info("----------------[PROCESS RAWSTARTENDDATETIME][Start:"
                + matchedStartDateTime + "]");
        logger.info("----------------[PROCESS RAWSTARTENDDATETIME][End: "
                + matchedEndDateTime + "]");

        // Note that we still do not know the exact date/time of the dates so they can be dates in the past.
        // We also do not know if the end date will be after the start date.
        rawStartDateTime = Optional.of(matchedStartDateTime);
        rawEndDateTime = Optional.of(matchedEndDateTime);

        // Dates are valid so we can extract the arguments out. However, if there is any past date,
        // the processed argument becomes invalid but a PastDateTimeException will be thrown anyway, thus
        // not allowing the command to continue. Similarly, a InvalidDurationException will be thrown if the
        // End Date comes after the Start Date.
        processedArgs = extractArguments(matcher.start("fromArg"), matcher.end("endDateTime"));
    }

    public void processRawStartDateTime() {
        if (hasDateTimeFieldProcessed()) {
            logger.info(SINGLE_DATE_TIME_PROCESSED);
            return;
        }

        if (isProcessedAndPresent(rawStartDateTime)) {
            logger.warning(String.format(MESSAGE_ALREADY_PROCESSED, "rawStartDateTime"));
            return;
        }
        // note the above will make edit 4 from Friday fail previously

        rawStartDateTime = Optional.empty();

        Matcher matcher = HAS_START_DATETIME_FORMAT.matcher(processedArgs);
        if (!matcher.matches()) {
            logger.info("----------------[PROCESS RAWSTARTDATETIME][No Start Date/Time found]");
            return;
        }

        final String matchedStartDateTime = matcher.group("startDateTime");
        if (!DateTimeUtil.isSingleDateTimeString(matchedStartDateTime)) {
            logger.info("----------------[PROCESS RAWSTARTDATETIME][Start Date/Time found but not a date]");
            return;
        }
        logger.info("----------------[PROCESS RAWSTARTDATETIME][Start:"
                + matchedStartDateTime + "]");

        // Note that we still do not know the exact date/time of the date so it can be a date in the past.
        // We also do not know if the end date will be after the start date.
        rawStartDateTime = Optional.of(matchedStartDateTime);

        // Date is valid so we can extract the arguments out. However, if there is any past date,
        // the processed argument becomes invalid but a PastDateTimeException will be thrown anyway, thus
        // not allowing the command to continue. Similarly, an InvalidDurationException will be thrown if the
        // End Date comes after the Start Date.
        processedArgs = extractArguments(matcher.start("fromArg"), matcher.end("startDateTime"));
    }

    public void processRawEndDateTime() {
        if (hasDateTimeFieldProcessed()) {
            logger.info(SINGLE_DATE_TIME_PROCESSED);
            return;
        }

        if (isProcessedAndPresent(rawEndDateTime)) {
            logger.warning(String.format(MESSAGE_ALREADY_PROCESSED, "rawEndDateTime"));
            return;
        }

        rawEndDateTime = Optional.empty();

        Matcher matcher = HAS_END_DATETIME_FORMAT.matcher(processedArgs);
        if (!matcher.matches()) {
            logger.info("----------------[PROCESS RAWENDDATETIME][No End Date/Time found]");
            return;
        }

        final String matchedEndDateTime = matcher.group("endDateTime");
        if (!DateTimeUtil.isSingleDateTimeString(matchedEndDateTime)) {
            logger.info("----------------[PROCESS RAWENDDATETIME][End Date/Time found but not a date]");
            return;
        }
        logger.info("----------------[PROCESS RAWENDDATETIME][End:"
                + matchedEndDateTime + "]");

        // Note that we still do not know the exact date/time of the date so it can be a date in the past.
        // We also do not know if the end date will be after the start date.
        rawEndDateTime = Optional.of(matchedEndDateTime);

        // Date is valid so we can extract the arguments out. However, if there is any past date,
        // the processed argument becomes invalid but a PastDateTimeException will be thrown anyway, thus
        // not allowing the command to continue. Similarly, an InvalidDurationException will be thrown if the
        // End Date comes after the Start Date.
        processedArgs = extractArguments(matcher.start("toArg"), matcher.end("endDateTime"));
    }

    /**
     * Returns the processed arguments that have the arguments specified by
     * {@code startIndex} to {@code endIndex} extracted out.
     */
    private String extractArguments(int startIndex, int endIndex) {
        return StringUtil.replace(processedArgs, startIndex, endIndex, "");
    }

}
```
###### /java/onlythree/imanager/logic/parser/EditCommandParser.java
``` java
    /**
     * Parses the given {@code String} of arguments in the context of the EditCommand
     * and returns an EditCommand object for execution.
     */
    public Command parse(String args) {
        DateTimeExtractor dateTimeExtractor = extractDateTimes(args);

        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer(PREFIX_TAG);
        argsTokenizer.tokenize(dateTimeExtractor.getProcessedArgs());
        List<Optional<String>> preambleFields = ParserUtil.splitPreamble(argsTokenizer.getPreamble().orElse(""), 2);

        Optional<Integer> index = preambleFields.get(0).flatMap(ParserUtil::parseIndex);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        EditTaskDescriptor editTaskDescriptor = new EditTaskDescriptor();
        try {
            editTaskDescriptor.setName(ParserUtil.parseName(preambleFields.get(1)));

            // set raw dates as they are to be referenced from the task's previous dates
            editTaskDescriptor.setRawDeadline(dateTimeExtractor.getProcessedRawDeadline());
            editTaskDescriptor.setRawStartDateTime(dateTimeExtractor.getProcessedRawStartDateTime());
            editTaskDescriptor.setRawEndDateTime(dateTimeExtractor.getProcessedRawEndDateTime());

            editTaskDescriptor.setTagList(parseTagsForEdit(ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG))));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }

        return new EditCommand(index.get(), editTaskDescriptor);
    }

    /**
     * Extracts date-times from the arguments if they exist and returns a {@link DateTimeExtractor} with the
     * processed raw date-times if they exist.
     *
     * @param args the arguments to extract date/time from
     */
    private DateTimeExtractor extractDateTimes(String args) {
        DateTimeExtractor dateTimeExtractor = new DateTimeExtractor(args);
        // process StartEndDateTime first because it is more likely to fail due to more constraints
        // e.g. from [some date to some date] will be parsed as a single date
        // if we process only the startDateTime first
        dateTimeExtractor.processRawStartEndDateTime();
        // give priority to parsing raw deadline before processing the startDateTime and endDateTime separately
        // e.g. so cases such as [edit 10 test by 2 days from 25 Apr] works
        // Note that however [edit 10 test by 2 days later from 25 Apr] will actually fall through
        // and have no deadline found as later is not a recognized token by Natty.
        // Thus two date groups of dates [2 days] and [25 Apr] will be the output.
        dateTimeExtractor.processRawDeadline();
        // since the example above have fell through, the Task name will become [test by 2 days later]
        // and the start date-time becomes 25 Apr if the task already has an end date-time.
        dateTimeExtractor.processRawStartDateTime();
        dateTimeExtractor.processRawEndDateTime();

        return dateTimeExtractor;
    }

```
###### /java/onlythree/imanager/logic/parser/ParserUtil.java
``` java
    /**
     * Parses a {@code Optional<String>} into an {@code Optional<Deadline>} if {@code deadline} is present.
     */
    public static Optional<Deadline> parseNewDeadline(Optional<String> deadline)
            throws PastDateTimeException, IllegalValueException {

        assert deadline != null;

        if (!deadline.isPresent()) {
            return Optional.empty();
        }

        ZonedDateTime parsedDateTime = DateTimeUtil.parseDateTimeString(deadline.get());
        return Optional.of(new Deadline(parsedDateTime));
    }

    /**
     * Parses a {@code Optional<String>} into an {@code Optional<Deadline>} relative to
     * {@code previousDeadline} if {@code rawDeadline} is present.
     */
    public static Optional<Deadline> parseEditedDeadline(Optional<String> rawDeadline, Deadline previousDeadline)
            throws PastDateTimeException, IllegalValueException {

        assert rawDeadline != null && previousDeadline != null;

        if (!rawDeadline.isPresent()) {
            return Optional.empty();
        }

        ZonedDateTime parsedDateTime =
                DateTimeUtil.parseEditedDateTimeString(rawDeadline.get(), previousDeadline.getDateTime());
        return Optional.of(new Deadline(parsedDateTime));
    }

    /**
     * Parses parameters {@code Optional<String> startDateTimeString} and {@code Optional<String> endDateTimeString}
     * into an {@code Optional<StartEndDateTime>} if they are present.
     */
    public static Optional<StartEndDateTime> parseNewStartEndDateTime(Optional<String> startDateTimeString,
            Optional<String> endDateTimeString)
            throws PastDateTimeException, InvalidDurationException, IllegalValueException {

        assert startDateTimeString != null && endDateTimeString != null;

        if (!startDateTimeString.isPresent() || !endDateTimeString.isPresent()) {
            return Optional.empty();
        }

        ZonedDateTime startDateTime = DateTimeUtil.parseDateTimeString(startDateTimeString.get());
        ZonedDateTime endDateTime = DateTimeUtil.parseDateTimeString(endDateTimeString.get());

        StartEndDateTime startEndDateTime = new StartEndDateTime(startDateTime, endDateTime);

        return Optional.of(startEndDateTime);
    }

    /**
     * Parses parameters {@code Optional<String> startDateTimeString} and
     * {@code Optional<String> endDateTimeString} relative to {@code previousStartEndDateTime} into an
     * {@code Optional<StartEndDateTime>} if the parameters are present.
     */
    public static Optional<StartEndDateTime> parseEditedStartEndDateTime(Optional<String> startDateTimeString,
            Optional<String> endDateTimeString, StartEndDateTime previousStartEndDateTime)
            throws PastDateTimeException, InvalidDurationException, IllegalValueException {

        assert startDateTimeString != null && endDateTimeString != null;

        if (!startDateTimeString.isPresent() || !endDateTimeString.isPresent()) {
            return Optional.empty();
        }

        ZonedDateTime startDateTime =
                DateTimeUtil.parseEditedDateTimeString(startDateTimeString.get(),
                                                       previousStartEndDateTime.getStartDateTime());
        ZonedDateTime endDateTime =
                DateTimeUtil.parseEditedDateTimeString(endDateTimeString.get(),
                        previousStartEndDateTime.getEndDateTime());

        StartEndDateTime startEndDateTime = new StartEndDateTime(startDateTime, endDateTime);

        return Optional.of(startEndDateTime);
    }
}
```
###### /java/onlythree/imanager/model/Model.java
``` java
    /** Returns the index of the direct source list given the index from the filtered task list */
    int getSourceIndexFromFilteredTasks(int filteredTaskListIndex);

```
###### /java/onlythree/imanager/model/ModelManager.java
``` java
    /**
     * Adds a task to the task list and select the added task.
     */
    @Override
    public synchronized void addTask(Task task) {
        int taskIndex = taskList.addTask(task);

        updateFilteredListToShowAll();

        indicateTaskListChanged();

        raise(new JumpToListRequestEvent(taskIndex));
    }

```
###### /java/onlythree/imanager/model/ModelManager.java
``` java
    @Override
    public int getSourceIndexFromFilteredTasks(int filteredTaskListIndex) {
        return filteredTasks.getSourceIndex(filteredTaskListIndex);
    }

```
###### /java/onlythree/imanager/model/task/Deadline.java
``` java
public class Deadline {
    public static final String MESSAGE_DEADLINE_CONSTRAINTS = "Deadline should not be in the past";

    private ZonedDateTime dateTime;

    /**
     * Constructs a new Deadline with the given DateTime.
     *
     * @param dateTime the DateTime to specify for the deadline
     * @throws PastDateTimeException if {@code dateTime} is before the current DateTime
     */
    public Deadline(ZonedDateTime dateTime) throws PastDateTimeException {
        this(dateTime, false);
    }

    /**
     * Constructs a new Deadline with the given DateTime. Ignores checking for dates in the past if
     * {@code ignorePast} is true.
     *
     * @param dateTime the DateTime to specify for the deadline
     * @param allowPastDateTime ignore checking if {@code dateTime} is in the past. Avoid setting
     *        to true except for cases such as loading from storage
     * @throws PastDateTimeException if {@code dateTime} is before the current DateTime and
     *         {@code allowPastDateTime} is {@code false}
     */
    public Deadline(ZonedDateTime dateTime, boolean allowPastDateTime) throws PastDateTimeException {
        assert dateTime != null;

        if (!allowPastDateTime) {
            if (dateTime.isBefore(ZonedDateTime.now())) {
                throw new PastDateTimeException(MESSAGE_DEADLINE_CONSTRAINTS);
            }
        }

        this.dateTime = dateTime;
    }

    public ZonedDateTime getDateTime() {
        return dateTime;
    }

    @Override
    public String toString() {
        return dateTime.format(DateTimeFormats.CLI_FORMAT);
    }

    @Override
    public boolean equals(Object o) {
        if (o == null) {
            return false;
        }
        if (o == this) {
            return true;
        }
        if (this.getClass() != o.getClass()) {
            return false;
        }
        final Deadline other = (Deadline) o;

        return Objects.equals(getDateTime(), other.getDateTime());
    }

    @Override
    public int hashCode() {
        return dateTime.hashCode();
    }
}
```
###### /java/onlythree/imanager/model/task/exceptions/IllegalDateTimeException.java
``` java
/**
 * Signals that some given DateTime(s) does not fulfill some date related constraints.
 */
public abstract class IllegalDateTimeException extends Exception {

    /**
     * @param message should contain relevant information on the failed date related constraint(s)
     */
    public IllegalDateTimeException(String message) {
        super(message);
    }

}
```
###### /java/onlythree/imanager/model/task/exceptions/InvalidDurationException.java
``` java
/**
 * Signals that the duration between two dates are negative or zero, thus constituting an invalid duration.
 */
public class InvalidDurationException extends IllegalDateTimeException {

    /**
     * @param message should contain relevant information on how the two dates have an
     *        invalid duration between them
     */
    public InvalidDurationException(String message) {
        super(message);
    }

}
```
###### /java/onlythree/imanager/model/task/exceptions/PastDateTimeException.java
``` java
/**
 * Signals that a date constructed was in the past.
 */
public class PastDateTimeException extends IllegalDateTimeException {

    /**
     * @param message should contain relevant information on why the date should not be in the past.
     */
    public PastDateTimeException(String message) {
        super(message);
    }

}
```
###### /java/onlythree/imanager/model/task/IterableTaskList.java
``` java
    /**
     * Adds a task to the end of the list and returns the index where the task is added.
     */
    public int add(Task toAdd) {
        assert toAdd != null;
        internalList.add(toAdd);

        return internalList.size() - 1;
    }

```
###### /java/onlythree/imanager/model/task/Name.java
``` java
    public static final String MESSAGE_NAME_CONSTRAINTS =
            "Task names should not contain forward slashes, and it should not be blank";

    /**
     * The first character of the name must not be a whitespace or a forward slash,
     * otherwise a whitespace character (i.e.0x20\t\n\x0B\f\r) becomes a valid input.
     */
    public static final String NAME_VALIDATION_REGEX = "[^/\\s][^/]*";

```
###### /java/onlythree/imanager/model/task/ReadOnlyTask.java
``` java
    @Override
    public boolean equals(Object o) {
        if (o == null) {
            return false;
        }
        if (o == this) {
            return true;
        }
        if (this.getClass() != o.getClass()) {
            return false;
        }
        final ReadOnlyTask other = (ReadOnlyTask) o;

        return Objects.equals(getName(), other.getName())
                && Objects.equals(getDeadline(), other.getDeadline())
                && Objects.equals(getStartEndDateTime(), other.getStartEndDateTime())
                && Objects.equals(getTags(), other.getTags())
                && isComplete() == other.isComplete();
    }

    @Override
    public int hashCode() {
        return Objects.hash(getName(), getDeadline(), getStartEndDateTime(), getTags(), isComplete());
    }

    /**
     * Formats the task as text, showing all fields.
     */
    @Override
    public String toString() {
        final StringBuilder builder = new StringBuilder();
        buildNameString(builder);
        buildDeadlineString(builder);
        buildStartEndDateTimeString(builder);
        buildTagsString(builder);
        buildCompleteString(builder);

        return builder.toString();
    }

    private void buildNameString(final StringBuilder builder) {
        builder.append(getName());
        builder.append(System.lineSeparator());
    }

    private void buildDeadlineString(final StringBuilder builder) {
        if (getDeadline().isPresent()) {
            builder.append(getDeadline().get().toString());
            builder.append(System.lineSeparator());
        }
    }

    private void buildStartEndDateTimeString(final StringBuilder builder) {
        if (getStartEndDateTime().isPresent()) {
            builder.append(getStartEndDateTime().get().toString());
            builder.append(System.lineSeparator());
        }
    }

    private void buildTagsString(final StringBuilder builder) {
        builder.append("Tags: ");
        getTags().forEach(builder::append);
    }

```
###### /java/onlythree/imanager/model/task/StartEndDateTime.java
``` java
public class StartEndDateTime {
    public static final String MESSAGE_PAST_START_DATETIME_CONSTRAINTS = "Start Date/Time should not be in the past";
    public static final String MESSAGE_PAST_END_DATETIME_CONSTRAINTS = "End Date/Time should not be in the past";
    public static final String MESSAGE_INVALID_DURATION_CONSTRAINTS = "End Date/Time must be after Start Date/Time";

    private ZonedDateTime startDateTime;
    private ZonedDateTime endDateTime;

    /**
     * Constructs a new StartDateTime with the given start and end date-time.
     *
     * @param startDateTime the start date-time
     * @param endDateTime the end date-time
     * @throws PastDateTimeException if any of the date-times are before the current date-time
     * @throws InvalidDurationException if the end date-time is before or same as the start date-time
     */
    public StartEndDateTime(ZonedDateTime startDateTime, ZonedDateTime endDateTime)
            throws PastDateTimeException, InvalidDurationException {
        this(startDateTime, endDateTime, false);
    }

    /**
     * Constructs a new StartEndDateTime with the given start and end date-time. Ignores checking for
     * dates in the past if {@code ignorePast} is true.
     *
     * @param startDateTime the start date-time
     * @param endDateTime the end date-time
     * @param allowPastDateTime ignore checking if date-times are in the past. Avoid setting to true
     *        except for special cases such as loading from storage
     * @throws PastDateTimeException if any of the date-times are before the current date-time and
     *         {@code allowPastDateTime} is {@code false}
     * @throws InvalidDurationException if the end date-time is before or same as the start date-time
     */
    public StartEndDateTime(ZonedDateTime startDateTime, ZonedDateTime endDateTime, boolean allowPastDateTime)
            throws PastDateTimeException, InvalidDurationException {
        assert startDateTime != null && endDateTime != null;

        if (!allowPastDateTime) {
            // Keep a snapshot of current date time otherwise startDateTime might be after the current date but
            // endDateTime might be before the current date due to a different currentDateTime used
            ZonedDateTime currentDateTime = ZonedDateTime.now();

            if (startDateTime.isBefore(currentDateTime)) {
                throw new PastDateTimeException(MESSAGE_PAST_START_DATETIME_CONSTRAINTS);
            }

            if (endDateTime.isBefore(currentDateTime)) {
                throw new PastDateTimeException(MESSAGE_PAST_END_DATETIME_CONSTRAINTS);
            }
        }

        // The end date time must be after the start date time, but not same or before
        if (!endDateTime.isAfter(startDateTime)) {
            throw new InvalidDurationException(MESSAGE_INVALID_DURATION_CONSTRAINTS);
        }

        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
    }

    public ZonedDateTime getStartDateTime() {
        return startDateTime;
    }

    public ZonedDateTime getEndDateTime() {
        return endDateTime;
    }

    @Override
    public String toString() {
        return "Start: " + startDateTime.format(DateTimeFormats.CLI_FORMAT)
            + " End: " + endDateTime.format(DateTimeFormats.CLI_FORMAT);
    }

    @Override
    public boolean equals(Object o) {
        if (o == null) {
            return false;
        }
        if (o == this) {
            return true;
        }
        if (this.getClass() != o.getClass()) {
            return false;
        }
        final StartEndDateTime other = (StartEndDateTime) o;

        return Objects.equals(getStartDateTime(), other.getStartDateTime())
                && Objects.equals(getEndDateTime(), other.getEndDateTime());
    }

    @Override
    public int hashCode() {
        return Objects.hash(startDateTime, endDateTime);
    }

}
```
###### /java/onlythree/imanager/model/task/Task.java
``` java
    public static final String MESSAGE_TASK_CONSTRAINTS =
            "Task cannot have both deadline and start and end date/time";

```
###### /java/onlythree/imanager/model/task/Task.java
``` java
    private Optional<StartEndDateTime> startEndDateTime;

    private Optional<Deadline> deadline;

```
###### /java/onlythree/imanager/model/task/Task.java
``` java
    /**
     * Every field must not be null except for the {@code Optional} fields. The task is
     * automatically initialized as not complete.
     *
     * @throws IllegalValueException if the Task to be constructed has both Deadline and
     *         StartEndDateTime
     */
    public Task(Name name, Optional<Deadline> deadline, Optional<StartEndDateTime> startEndDateTime,
            UniqueTagList tags) throws IllegalValueException {
        this(name, deadline, startEndDateTime, tags, false);
    }

    /**
     * Every field must not be null except for the {@code Optional} fields. This constructor
     * requires whether the task is complete to be specified.
     *
     * @throws IllegalValueException if the Task to be constructed has both Deadline and
     *         StartEndDateTime
     */
    public Task(Name name, Optional<Deadline> deadline, Optional<StartEndDateTime> startEndDateTime,
            UniqueTagList tags, boolean isComplete) throws IllegalValueException {
        assert !CollectionUtil.isAnyNull(name, deadline, startEndDateTime, tags);

        if (deadline.isPresent() && startEndDateTime.isPresent()) {
            throw new IllegalValueException(MESSAGE_TASK_CONSTRAINTS);
        }

        this.name = name;
        this.deadline = deadline;
        this.startEndDateTime = startEndDateTime;
        this.tags = new UniqueTagList(tags); // protect internal tags from changes in the arg list
        this.complete = isComplete;
    }

    /**
     * Creates a copy of the given ReadOnlyTask.
     * @throws IllegalValueException if the ReadOnlyTask to be copied has both Deadline and StartEndDateTime
     */
    public Task(ReadOnlyTask source) throws IllegalValueException {
        this(source.getName(), source.getDeadline(), source.getStartEndDateTime(), source.getTags(),
             source.isComplete());
    }

```
###### /java/onlythree/imanager/model/task/Task.java
``` java
    @Override
    public Optional<Deadline> getDeadline() {
        return deadline;
    }

    /**
     * Only allow changing the {@link StartEndDateTime} if there is actually a value (not {@link Optional}).
     */
    public void setDeadline(Deadline dateTime) {
        assert dateTime != null;
        this.deadline = Optional.of(dateTime);
    }

```
###### /java/onlythree/imanager/model/task/Task.java
``` java
    @Override
    public Optional<StartEndDateTime> getStartEndDateTime() {
        return startEndDateTime;
    }

    /**
     * Only allow changing the {@link StartEndDateTime} if there is actually a value (not {@link Optional}).
     */
    public void setStartEndDateTime(StartEndDateTime startEndDateTime) {
        assert startEndDateTime != null;
        this.startEndDateTime = Optional.of(startEndDateTime);
    }

```
###### /java/onlythree/imanager/model/task/Task.java
``` java
    /**
     * Updates this task with the details of {@code replacement} using a "shallow copy" of the data. Refer to
     * {@link Object#clone()} for more information about shallow copy.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        // Note that we are shallow copying data replacement's data so replacement should not be
        // reused anymore. Otherwise modify this method to do a deep copy

        setName(replacement.getName());

        // Note that the same Optional is being reused from replacement directly
        // Hence the setter method cannot be used for both deadline and startEndDateTime
        deadline = replacement.getDeadline();
        startEndDateTime = replacement.getStartEndDateTime();

        setTags(replacement.getTags());
        setComplete(replacement.isComplete());
    }
}
```
###### /java/onlythree/imanager/model/TaskList.java
``` java
    /**
     * Adds a task to the task list and returns the index where the task is added.
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     */
    public int addTask(Task p) {
        syncMasterTagListWith(p);
        return tasks.add(p);
    }

```
###### /java/onlythree/imanager/storage/XmlAdaptedTask.java
``` java
/**
 * JAXB-friendly version of the Task.
 */
public class XmlAdaptedTask {

    @XmlElement(name = "name", required = true)
    private String nameElement;

    @XmlElement(name = "deadline")
    private String deadlineElement;

    @XmlElement(name = "startDate")
    private String startDateTimeElement;

    @XmlElement(name = "endDate")
    private String endDateTimeElement;

    @XmlElement(name = "tag")
    private List<XmlAdaptedTag> tagElements = new ArrayList<>();

    @XmlElement(name = "completed")
    private boolean completeElement;

    /**
     * Constructs an XmlAdaptedTask.
     * This is the no-arg constructor that is required by JAXB.
     */
    public XmlAdaptedTask() {}


    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        setNameElement(source.getName().value);

        setDeadlineElementIfPresent(source.getDeadline());
        // the start and end date elements must be set together because they cannot exist separately
        setStartEndDateElementsIfPresent(source.getStartEndDateTime());

        setTagElement(source.getTags());

        setCompleteElement(source.isComplete());
    }

    /**
     * Sets the XmlElement name to the source task's name
     */
    private void setNameElement(String sourceName) {
        nameElement = sourceName;
    }

    /**
     * Sets the XmlElement name to the source task's deadline if it is present
     */
    private void setDeadlineElementIfPresent(Optional<Deadline> sourceDeadline) {
        if (sourceDeadline.isPresent()) {
            Deadline deadline = sourceDeadline.get();
            deadlineElement = deadline.getDateTime().format(DateTimeFormats.STORAGE_FORMAT);
        }
    }

    /**
     * Sets the XmlElement startDate and endDate to the source task's start and dates if they are present
     */
    private void setStartEndDateElementsIfPresent(Optional<StartEndDateTime> sourceStartEndDateTime) {
        if (sourceStartEndDateTime.isPresent()) {
            StartEndDateTime startEndDateTime = sourceStartEndDateTime.get();
            startDateTimeElement = startEndDateTime.getStartDateTime().format(DateTimeFormats.STORAGE_FORMAT);
            endDateTimeElement = startEndDateTime.getEndDateTime().format(DateTimeFormats.STORAGE_FORMAT);
        }
    }

    /**
     * Sets each tag XmlElement to the source task's tags from its unique tag list
     */
    private void setTagElement(UniqueTagList sourceTagList) {
        tagElements = new ArrayList<>();
        for (Tag tag : sourceTagList) {
            tagElements.add(new XmlAdaptedTag(tag));
        }
    }

    /**
     * Sets the XmlElement completed to true if the source task's is complete
     */
    private void setCompleteElement(boolean isComplete) {
        completeElement = isComplete;
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     * @throws PastDateTimeException should never be thrown because dates in the past are allowed
     * @throws InvalidDurationException if the end DateTime is before or same as the start DateTime
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException, InvalidDurationException {
        final Name name = buildNameFromXmlElement();
        final Optional<Deadline> deadline = buildDeadlineFromXmlElement();
        final Optional<StartEndDateTime> startEndDateTime = buildStartEndDateTimeFromXmlElement();
        final UniqueTagList tagList = buildTagListFromXmlElement();
        final boolean isComplete = buildIsCompleteFromXmlElement();

        return new Task(name, deadline, startEndDateTime, tagList, isComplete);
    }

    /**
     * Returns a Name created from the XmlElement.
     * @throws IllegalValueException if the name does not fulfill the name's constraints
     */
    private Name buildNameFromXmlElement() throws IllegalValueException {
        return new Name(nameElement);
    }

    /**
     * Returns an {@link Optional} wrapping the {@link Deadline} created from the XmlElement.
     * If the XmlElement for deadline does not exist, returns an empty {@link Optional}.
     * @throws PastDateTimeException should never be thrown because dates in the past are allowed
     */
    private Optional<Deadline> buildDeadlineFromXmlElement() {
        // return empty if xml element does not exist
        if (deadlineElement == null) {
            return Optional.empty();
        }

        try {
            // construct Deadline with allowPastDateTime set to true because this is loaded from storage
            Deadline deadline =
                    new Deadline(ZonedDateTime.parse(deadlineElement, DateTimeFormats.STORAGE_FORMAT), true);
            return Optional.of(deadline);
        } catch (DateTimeParseException e) {
            return Optional.empty();
        } catch (PastDateTimeException e) {
            throw new AssertionError("Deadline constructed from storage should never throw a PastDateTimeException");
        }
    }

    /**
     * Returns an {@link Optional} wrapping the {@link StartEndDateTime} created from the two XmlElements.
     * If any of the two XmlElements for StartEndDateTime does not exist, returns an empty {@link Optional}.
     * @throws PastDateTimeException should never be thrown because dates in the past are allowed
     * @throws InvalidDurationException if the end DateTime is before or same as the start DateTime
     */
    private Optional<StartEndDateTime> buildStartEndDateTimeFromXmlElement()
            throws InvalidDurationException {
        // a StartEndDateTime cannot be constructed if either XML element do not exist
        if (startDateTimeElement == null || endDateTimeElement == null) {
            return Optional.empty();
        }

        try {
            ZonedDateTime startDateTime = ZonedDateTime.parse(startDateTimeElement, DateTimeFormats.STORAGE_FORMAT);
            ZonedDateTime endDateTime = ZonedDateTime.parse(endDateTimeElement, DateTimeFormats.STORAGE_FORMAT);
            // construct StartEndDateTime with allowPastDateTime set to true because this is loaded from storage
            StartEndDateTime startEndDateTime = new StartEndDateTime(startDateTime, endDateTime, true);
            return Optional.of(startEndDateTime);
        } catch (DateTimeParseException e) {
            return Optional.empty();
        } catch (PastDateTimeException e) {
            throw new AssertionError("StartEndDateTime constructed from storage should never throw"
                                   + "a PastDateTimeException");
        }
    }

    /**
     * Returns a UniqueTagList of the tags created from every tag XmlElement for the Task
     * @throws IllegalValueException if any of the tags from the XML is invalid
     * @throws DuplicateTagException if any of the tags are duplicates
     */
    private UniqueTagList buildTagListFromXmlElement() throws IllegalValueException, DuplicateTagException {
        final List<Tag> tags = new ArrayList<>();
        for (XmlAdaptedTag adaptedTag : tagElements) {
            tags.add(adaptedTag.toModelType());
        }
        return new UniqueTagList(tags);
    }

    /**
     * Returns a Boolean representing whether the task is complete from the XmlElement.
     */
    private boolean buildIsCompleteFromXmlElement() {
        return completeElement;
    }
}
```
