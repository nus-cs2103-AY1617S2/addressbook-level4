# A0142418L
###### \java\seedu\taskmanager\commons\core\Config.java
``` java
    public void setTaskManagerFilePath(String taskManagerFilePath) throws DuplicateTaskManagerFilePathException {
        if (this.taskManagerFilePath.equals(taskManagerFilePath)) {
            throw new DuplicateTaskManagerFilePathException();
        } else {
            this.taskManagerFilePath = taskManagerFilePath;
        }
    }

```
###### \java\seedu\taskmanager\commons\core\Config.java
``` java
    /**
     * Signals that the file path specified is the same as the current one.
     */
    public static class DuplicateTaskManagerFilePathException extends IllegalValueException {
        protected DuplicateTaskManagerFilePathException() {
            super("Operation would result in duplicate tasks");
        }
    }

```
###### \java\seedu\taskmanager\commons\util\DateTimeUtil.java
``` java
public class DateTimeUtil {

    public static final String MESSAGE_DAY_CONSTRAINTS = "Task date should be either "
            + "a day (e.g. thursday) or a date with the format: DD/MM/YY (e.g. 03/03/17)\n"
            + "May also include time (e.g. 1400) behind date \n"
            + "Enter HELP for user guide with detailed explanations of all commands";

    public static final String CURRENTDATE_VALIDATION_REGEX_TODAY1 = "Today";
    public static final String CURRENTDATE_VALIDATION_REGEX_TODAY2 = "today";
    public static final String CURRENTDATE_VALIDATION_REGEX_TOMORROW1 = "Tomorrow";
    public static final String CURRENTDATE_VALIDATION_REGEX_TOMORROW2 = "tomorrow";
    public static final String CURRENTDATE_VALIDATION_REGEX_TOMORROW3 = "Tmr";
    public static final String CURRENTDATE_VALIDATION_REGEX_TOMORROW4 = "tmr";
    public static final String CURRENTDATE_VALIDATION_REGEX_MONDAY1 = "Monday";
    public static final String CURRENTDATE_VALIDATION_REGEX_MONDAY2 = "monday";
    public static final String CURRENTDATE_VALIDATION_REGEX_MONDAY3 = "Mon";
    public static final String CURRENTDATE_VALIDATION_REGEX_MONDAY4 = "mon";
    public static final String CURRENTDATE_VALIDATION_REGEX_TUESDAY1 = "Tuesday";
    public static final String CURRENTDATE_VALIDATION_REGEX_TUESDAY2 = "tuesday";
    public static final String CURRENTDATE_VALIDATION_REGEX_TUESDAY3 = "Tues";
    public static final String CURRENTDATE_VALIDATION_REGEX_TUESDAY4 = "tues";
    public static final String CURRENTDATE_VALIDATION_REGEX_WEDNESDAY1 = "Wednesday";
    public static final String CURRENTDATE_VALIDATION_REGEX_WEDNESDAY2 = "wednesday";
    public static final String CURRENTDATE_VALIDATION_REGEX_WEDNESDAY3 = "Wed";
    public static final String CURRENTDATE_VALIDATION_REGEX_WEDNESDAY4 = "wed";
    public static final String CURRENTDATE_VALIDATION_REGEX_THURSDAY1 = "Thursday";
    public static final String CURRENTDATE_VALIDATION_REGEX_THURSDAY2 = "thursday";
    public static final String CURRENTDATE_VALIDATION_REGEX_THURSDAY3 = "Thurs";
    public static final String CURRENTDATE_VALIDATION_REGEX_THURSDAY4 = "thurs";
    public static final String CURRENTDATE_VALIDATION_REGEX_FRIDAY1 = "Friday";
    public static final String CURRENTDATE_VALIDATION_REGEX_FRIDAY2 = "friday";
    public static final String CURRENTDATE_VALIDATION_REGEX_FRIDAY3 = "Fri";
    public static final String CURRENTDATE_VALIDATION_REGEX_FRIDAY4 = "fri";
    public static final String CURRENTDATE_VALIDATION_REGEX_SATURDAY1 = "Saturday";
    public static final String CURRENTDATE_VALIDATION_REGEX_SATURDAY2 = "saturday";
    public static final String CURRENTDATE_VALIDATION_REGEX_SATURDAY3 = "Sat";
    public static final String CURRENTDATE_VALIDATION_REGEX_SATURDAY4 = "sat";
    public static final String CURRENTDATE_VALIDATION_REGEX_SUNDAY1 = "Sunday";
    public static final String CURRENTDATE_VALIDATION_REGEX_SUNDAY2 = "sunday";
    public static final String CURRENTDATE_VALIDATION_REGEX_SUNDAY3 = "Sun";
    public static final String CURRENTDATE_VALIDATION_REGEX_SUNDAY4 = "sun";

    public static int currentDay;
    public static String currentDate = "";

    public DateTimeUtil() {
        currentDay = getCurrentDay();
        currentDate = getCurrentDate();
    }

    /**
     * Checks to see if user has input a valid day, this function includes
     * different spellings of the same day
     */
    public static boolean isValidDay(String test) {
        return test.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY1) || test.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY4)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY4)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY4)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY4)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY4)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY4)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY4)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TODAY1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TODAY2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TOMORROW1)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TOMORROW2)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TOMORROW3)
                || test.matches(CURRENTDATE_VALIDATION_REGEX_TOMORROW4);
    }

    /**
     * @return Day number relative to the day itself (e.g. Sunday == 1 &
     *         Wednesday == 4)
     */
    public static int getNewDay(String day) {

        if (isSunday(day)) {
            return 1;
        } else {
            if (isMonday(day)) {
                return 2;
            } else {
                if (isTuesday(day)) {
                    return 3;
                } else {
                    if (isWednesday(day)) {
                        return 4;
                    } else {
                        if (isThursday(day)) {
                            return 5;
                        } else {
                            if (isFriday(day)) {
                                return 6;
                            } else {
                                if (isSaturday(day)) {
                                    return 7;
                                } else {
                                    if (isToday(day)) {
                                        Calendar calendar = Calendar.getInstance(TimeZone.getDefault());
                                        return calendar.get(Calendar.DAY_OF_WEEK);
                                    } else {
                                        return getTomorrowDay();
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    /**
     * @return Current Day with respect to the date on the computer
     */
    public static int getCurrentDay() {
        Calendar calendar = Calendar.getInstance(TimeZone.getDefault());
        int day = calendar.get(Calendar.DATE);
        return day;
    }

    /**
     * @return Current Date with respect to the date on the computer
     */
    public static String getCurrentDate() {

        Calendar calendar = Calendar.getInstance(TimeZone.getDefault());
        // getTime() returns the current date in default time zone
        int day = calendar.get(Calendar.DATE);
        // Note: +1 the month for current month
        int month = calendar.get(Calendar.MONTH) + 1;
        int year = calendar.get(Calendar.YEAR);

        return getFormattedDate(day, month, year);
    }

    /**
     * If user inputs a day, function will change the day given by user to the
     * actual date relative to the current date.
     *
     * @param givenDay
     * @return updatedDate in DD/MM/YY format
     * @throws IllegalValueException
     */
    public static String getNewDate(String givenDay) throws IllegalValueException {

        if (!isValidDay(givenDay)) {
            throw new IllegalValueException(MESSAGE_DAY_CONSTRAINTS);
        }

        int inputDay = getNewDay(givenDay);

        Calendar calendar = Calendar.getInstance(TimeZone.getDefault());
        // getTime() returns the current date in default time zone
        int day = calendar.get(Calendar.DATE);
        // Note: +1 the month for current month
        int month = calendar.get(Calendar.MONTH) + 1;
        int year = calendar.get(Calendar.YEAR);
        int dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);

        LocalDate testdate = LocalDate.of(year, month, day);
        int testdays = testdate.lengthOfMonth();

        int diffInDays = dayOfWeek - inputDay;

        if (diffInDays == 0) {
            return getCurrentDate();
        }
        if (diffInDays > 0) {
            day += (7 - diffInDays);
        }
        if (diffInDays < 0) {
            day -= diffInDays;
        }

        if (day > testdays) {
            month += 1;
            day -= testdays;
        }
        if (month > 12) {
            month = 1;
            year += 1;
        }

        return getFormattedDate(day, month, year);
    }

    public static int isDateWithin(String date, String startDate, String endDate) {
        String[] dmy = date.trim().split("/");
        int day = Integer.parseInt(dmy[0]);
        int month = Integer.parseInt(dmy[1]);
        int year = Integer.parseInt(dmy[2]);

        String[] dmyStart = startDate.trim().split("/");
        int dayStart = Integer.parseInt(dmyStart[0]);
        int monthStart = Integer.parseInt(dmyStart[1]);
        int yearStart = Integer.parseInt(dmyStart[2]);

        String[] dmyEnd = endDate.trim().split("/");
        int dayEnd = Integer.parseInt(dmyEnd[0]);
        int monthEnd = Integer.parseInt(dmyEnd[1]);
        int yearEnd = Integer.parseInt(dmyEnd[2]);

        if (year < yearEnd && yearStart < year) {
            return 1;
        } else {
            if (year == yearEnd && year == yearStart) {
                if (month < monthEnd && monthStart < month) {
                    return 1;
                } else {
                    if (month == monthEnd && month == monthStart) {
                        if (day < dayEnd && dayStart < day) {
                            return 1;
                        } else {
                            if (day == dayEnd && dayStart == day) {
                                return 2;
                            }
                        }
                    }
                }
            }
        }
        return 0;
    }

```
###### \java\seedu\taskmanager\commons\util\DateTimeUtil.java
``` java
    /**
     * @param dayOfWeek
     * @return Integer day value of tomorrow.
     */
    private static int getTomorrowDay() {
        Calendar calendar = Calendar.getInstance(TimeZone.getDefault());
        int dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);
        if (dayOfWeek + 1 == 8) {
            return dayOfWeek = 1;
        } else {
            return dayOfWeek + 1;
        }
    }

    /**
     * @param day
     * @return true if input matches "Today" regex.
     */
    private static boolean isToday(String day) {
        return day.matches(CURRENTDATE_VALIDATION_REGEX_TODAY1) || day.matches(CURRENTDATE_VALIDATION_REGEX_TODAY2);
    }

    /**
     * @param day
     * @return true if input matches "Saturday" regex.
     */
    private static boolean isSaturday(String day) {
        return day.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY1)
                || day.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY2)
                || day.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY3)
                || day.matches(CURRENTDATE_VALIDATION_REGEX_SATURDAY4);
    }

    /**
     * @param day
     * @return true if input matches "Friday" regex.
     */
    private static boolean isFriday(String day) {
        return day.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY1) || day.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY2)
                || day.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY3)
                || day.matches(CURRENTDATE_VALIDATION_REGEX_FRIDAY4);
    }

    /**
     * @param day
     * @return true if input matches "Thursday" regex.
     */
    private static boolean isThursday(String day) {
        return day.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY1)
                || day.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY2)
                || day.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY3)
                || day.matches(CURRENTDATE_VALIDATION_REGEX_THURSDAY4);
    }

    /**
     * @param day
     * @return true if input matches "Wednesday" regex.
     */
    private static boolean isWednesday(String day) {
        return day.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY1)
                || day.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY2)
                || day.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY3)
                || day.matches(CURRENTDATE_VALIDATION_REGEX_WEDNESDAY4);
    }

    /**
     * @param day
     * @return true if input matches "Tuesday" regex.
     */
    private static boolean isTuesday(String day) {
        return day.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY1) || day.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY2)
                || day.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY3)
                || day.matches(CURRENTDATE_VALIDATION_REGEX_TUESDAY4);
    }

    /**
     * @param day
     * @return true if input matches "Monday" regex.
     */
    private static boolean isMonday(String day) {
        return day.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY1) || day.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY2)
                || day.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY3)
                || day.matches(CURRENTDATE_VALIDATION_REGEX_MONDAY4);
    }

    /**
     * @param day
     * @return true if input matches "Sunday" regex.
     */
    private static boolean isSunday(String day) {
        return day.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY1) || day.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY2)
                || day.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY3)
                || day.matches(CURRENTDATE_VALIDATION_REGEX_SUNDAY4);
    }

    /**
     * @param day
     * @return Integer as a 2 character string
     */
    private static String convertIntegerToTwoCharString(int integer) {
        String string;
        if (integer < 10) {
            string = "0" + Integer.toString(integer);
        } else {
            string = Integer.toString(integer);
        }
        return string;
    }

    /**
     * @param day
     * @param month
     * @param year
     * @return Date formatted in defined format for application
     */
    private static String getFormattedDate(int day, int month, int year) {
        String updatedDate;
        String stringDay;
        String stringMonth;
        String stringYear;
        stringDay = convertIntegerToTwoCharString(day);
        stringMonth = convertIntegerToTwoCharString(month);
        stringYear = Integer.toString(year).substring(Math.max(Integer.toString(year).length() - 2, 0));

        updatedDate = stringDay + "/" + stringMonth + "/" + stringYear;
        return updatedDate;
    }

}
```
###### \java\seedu\taskmanager\logic\commands\AddCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            model.updateFilteredListToShowAll();
            if (toAdd.isEventTask()) {
                int clashedTaskIndex = model.isBlockedOutTime(toAdd);
                if (clashedTaskIndex != -1) {
                    int addIndex = model.addTask(toAdd);
                    EventsCenter.getInstance().post(new JumpToListRequestEvent(addIndex));
                    String clashFeedback = "Clash with task: Index " + Integer.toString(clashedTaskIndex) + "\n";
                    return new CommandResult(clashFeedback + String.format(MESSAGE_SUCCESS, toAdd) + "\n"
                            + "Task added at index: " + Integer.toString(addIndex + 1));
                }
            }
            int addIndex = model.addTask(toAdd);
            EventsCenter.getInstance().post(new JumpToListRequestEvent(addIndex));
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd) + "\n" + "Task added at index: "
                    + Integer.toString(addIndex + 1));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        } catch (IllegalValueException ive) {
            throw new CommandException(ive.getMessage() + MESSAGE_BLOCKED_OUT_TIME);
        }
    }
}
```
###### \java\seedu\taskmanager\logic\commands\ChangeSaveLocationCommand.java
``` java
    public ChangeSaveLocationCommand(File location) {
        this.toSave = location;
    }

    @Override
    public CommandResult execute() throws CommandException {
        try {
            Config config = new Config();
            config.setTaskManagerFilePath(toSave.toString());
            ConfigUtil.saveConfig(config, Config.DEFAULT_CONFIG_FILE);

            XmlTaskManagerStorage.setTaskManagerFilePath(toSave.toString());
            model.saveTaskManager();

            return new CommandResult(String.format(MESSAGE_SUCCESS, toSave));
        } catch (Config.DuplicateTaskManagerFilePathException dtmfpe) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK_MANAGER_FILE_PATH);
        } catch (IOException ioe) {
            logger.warning("Failed to save config file : " + StringUtil.getDetails(ioe));
            throw new CommandException(MESSAGE_CREATED_NEW_CONFIG_FILE);
        }
    }

}
```
###### \java\seedu\taskmanager\logic\commands\DeleteCommand.java
``` java
/**
 * Deletes a task identified using it's last displayed index from the task
 * manager.
 */
public class DeleteCommand extends Command {

    public static final String COMMAND_WORD = "DELETE";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the task(s) identified by the index number or task name or task date used "
            + "in the last task listing.\n" + "Parameters: INDEX (must be a positive integer)\n" + "Example: "
            + COMMAND_WORD + " 1\n" + "Parameters: TASK NAME (must be a valid task name)\n" + "Example: " + COMMAND_WORD
            + " Eat lunch with mum\n" + "Parameters: TASK DATE (must be a valid task date)\n" + "Example: "
            + COMMAND_WORD + " 15/07/17";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted task: %1$s";
    public static final String MESSAGE_DELETE_TASKS_DATE_SUCCESS_1 = "Deleted tasks on: ";
    public static final String MESSAGE_DELETE_TASKS_DATE_SUCCESS_2 = "\nTotal number of task(s) deleted: ";

    public static final String MESSAGE_DELETE_TASKS_NAME_SUCCESS_1 = "Deleted task all tasks with name '";
    public static final String MESSAGE_DELETE_TASKS_NAME_SUCCESS_2 = "' .\nTotal number of task(s) deleted: ";

    public static final String DELETE_COMMAND_VALIDATION_REGEX_1 = "\\d+";
    public static final String DELETE_COMMAND_VALIDATION_REGEX_2 = "[a-zA-Z]+";
    public static final String DELETE_COMMAND_VALIDATION_REGEX_3 = "\\d{2}/\\d{2}/\\d{2}";

    public static final int DELETE_INDEX_NOT_PRESENT_TOKEN = -1;
    public static final String DELETE_TASKNAME_KEYWORD_NOT_PRESENT_TOKEN = "";
    public static final String DELETE_DATE_KEYWORD_NOT_PRESENT_TOKEN = "";

    public static final String MESSAGE_INVALID_TASK_DATE = "There is no task with the date specified to delete.";
    public static final String MESSAGE_INVALID_TASK_NAME = "There is no task with the name specified to delete.";

    public final int targetIndex;
    public final String targetTaskName;
    public final String targetDate;

    public DeleteCommand(int targetIndex) {
        this.targetIndex = targetIndex;
        this.targetTaskName = DELETE_TASKNAME_KEYWORD_NOT_PRESENT_TOKEN;
        this.targetDate = DELETE_DATE_KEYWORD_NOT_PRESENT_TOKEN;
    }

    public DeleteCommand(String targetString) {
        this.targetIndex = DELETE_INDEX_NOT_PRESENT_TOKEN;
        if (targetString.matches(DELETE_COMMAND_VALIDATION_REGEX_3)) {
            this.targetTaskName = DELETE_TASKNAME_KEYWORD_NOT_PRESENT_TOKEN;
            this.targetDate = targetString;
        } else {
            this.targetTaskName = targetString;
            this.targetDate = DELETE_DATE_KEYWORD_NOT_PRESENT_TOKEN;
        }
    }

    @Override
    public CommandResult execute() throws CommandException {

        if (targetIndex != DELETE_INDEX_NOT_PRESENT_TOKEN) {

            UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

            ReadOnlyTask taskToDelete = findTaskToDeleteByIndex(lastShownList);
            deleteTask(taskToDelete);

            return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, taskToDelete));

        } else {
            if (!targetDate.equals(DELETE_DATE_KEYWORD_NOT_PRESENT_TOKEN)) {

                UnmodifiableObservableList<ReadOnlyTask> lastShownList = findTasksToDeleteByDate();
                int numDeletedTasks = deleteTasksByDate(lastShownList);

                return new CommandResult(MESSAGE_DELETE_TASKS_DATE_SUCCESS_1 + targetDate
                        + MESSAGE_DELETE_TASKS_DATE_SUCCESS_2 + Integer.toString(numDeletedTasks));
            } else {
                UnmodifiableObservableList<ReadOnlyTask> lastShownList = findTasksToDeleteByName();
                int numDeletedTasks = deleteTasksByName(lastShownList);

                return new CommandResult(MESSAGE_DELETE_TASKS_NAME_SUCCESS_1 + targetTaskName
                        + MESSAGE_DELETE_TASKS_NAME_SUCCESS_2 + Integer.toString(numDeletedTasks));
            }
        }
    }

    /**
     * @param lastShownList
     * @return
     * @throws CommandException
     */
    private ReadOnlyTask findTaskToDeleteByIndex(UnmodifiableObservableList<ReadOnlyTask> lastShownList)
            throws CommandException {
        if (lastShownList.size() < targetIndex) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToDelete = lastShownList.get(targetIndex - 1);
        return taskToDelete;
    }

    /**
     * @return List of tasks to search for exact task name to be deleted
     * @throws CommandException
     */
    private UnmodifiableObservableList<ReadOnlyTask> findTasksToDeleteByName() throws CommandException {
        final String[] keywords = targetTaskName.split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));

        model.updateFilteredTaskList(keywordSet);

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() == 0) {
            model.updateFilteredListToShowAll();
            throw new CommandException(MESSAGE_INVALID_TASK_NAME);
        }
        return lastShownList;
    }

    /**
     * @return List of tasks with same dates to be deleted
     * @throws CommandException
     */
    private UnmodifiableObservableList<ReadOnlyTask> findTasksToDeleteByDate() throws CommandException {
        final String[] keywords = targetDate.split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));

        model.updateFilteredTaskList(keywordSet);

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() == 0) {
            model.updateFilteredListToShowAll();
            throw new CommandException(MESSAGE_INVALID_TASK_DATE);
        }
        return lastShownList;
    }

    /**
     * @param numDeletedTasks
     * @param lastShownList
     * @return Number of tasks deleted based on task name provided by user
     */
    private int deleteTasksByName(UnmodifiableObservableList<ReadOnlyTask> lastShownList) {
        int numDeletedTasks = 0;
        try {
            numDeletedTasks = model.deleteTasksName(lastShownList, targetTaskName.trim());
        } catch (TaskNotFoundException e) {
            assert false : MESSAGE_INVALID_TASK_NAME;
        }
        return numDeletedTasks;
    }

    /**
     * @param numDeletedTasks
     * @param lastShownList
     * @return Number of tasks deleted based on date provided by user
     */
    private int deleteTasksByDate(UnmodifiableObservableList<ReadOnlyTask> lastShownList) {
        int numDeletedTasks = 0;

        try {
            numDeletedTasks = model.deleteTasksDate(lastShownList);
        } catch (TaskNotFoundException e) {
            assert false : MESSAGE_INVALID_TASK_DATE;
        }
        return numDeletedTasks;
    }

    /**
     * @param taskToDelete
     */
    private void deleteTask(ReadOnlyTask taskToDelete) {
        try {
            model.deleteTask(taskToDelete);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }
    }
}
```
###### \java\seedu\taskmanager\logic\commands\RedoCommand.java
``` java
/**
 * Redo the previous action in task manager.
 */
public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "REDO";
    public static final String MESSAGE_SUCCESS = "Previous action has been redone.";
    public static final String MESSAGE_FAILURE = "Nothing to redo.";

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            model.redoTaskManager();
            return new CommandResult(MESSAGE_SUCCESS);
        } catch (EmptyStackException ese) {
            throw new CommandException(MESSAGE_FAILURE);
        }
    }
}
```
###### \java\seedu\taskmanager\logic\commands\UndoCommand.java
``` java
/**
 * Undo the previous action in task manager.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "UNDO";
    public static final String MESSAGE_SUCCESS = "Previous action has been undone.";
    public static final String MESSAGE_FAILURE = "Nothing to undo.";

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            model.undoTaskManager();
            return new CommandResult(MESSAGE_SUCCESS);
        } catch (EmptyStackException ese) {
            throw new CommandException(MESSAGE_FAILURE);
        }
    }
}
```
###### \java\seedu\taskmanager\logic\commands\UpdateCommand.java
``` java
/**
 * Updates the details of an existing task in the task manager.
 */
public class UpdateCommand extends Command {

    public static final String COMMAND_WORD = "UPDATE";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Updates the details of the task identified "
            + "by the index number used in the last task listing. "
            + "Existing values will be overwritten by the input values.\n"
            + "Parameters: INDEX (must be a positive integer) [TASK] ON [DATE] FROM [STARTTIME] TO [ENDTIME]\n"
            + "Example: " + COMMAND_WORD + " 1 ON 04/03/17 FROM 1630 TO 1830";

    public static final String MESSAGE_BLOCKED_OUT_TIME = "This task cannot be added as time clashes with "
            + "another event";
    public static final String MESSAGE_UPDATE_TASK_SUCCESS = "Updated Task: %1$s";
    public static final String MESSAGE_NOT_UPDATED = "At least one field to edit must be provided.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";
    public static final String MESSAGE_INVALID_EVENT_PERIOD = "Invalid input of time, event start time has to"
            + " be earlier than end time.";

    public static final String EMPTY_FIELD = "EMPTY_FIELD";

    private final int filteredTaskListIndex;
    private UpdateTaskDescriptor updateTaskDescriptor;
    private final Boolean isUpdateToDeadlineTask;

    /**
     * @param filteredTaskListIndex
     *            the index of the task in the filtered task list to update
     * @param updateTaskDescriptor
     *            details to update the task with
     */
    public UpdateCommand(int filteredTaskListIndex, UpdateTaskDescriptor updateTaskDescriptor,
            Boolean isUpdateToDeadlineTask) {
        assert filteredTaskListIndex > 0;
        assert updateTaskDescriptor != null;

        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;

        this.updateTaskDescriptor = new UpdateTaskDescriptor(updateTaskDescriptor);

        this.isUpdateToDeadlineTask = isUpdateToDeadlineTask;
    }

    @Override
    public CommandResult execute() throws CommandException {

        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToUpdate = lastShownList.get(filteredTaskListIndex);

        if (!isUpdateToDeadlineTask) {
            if ((isOnlyStartUpdated() || isOnlyEndUpdated()) && taskToUpdate.isFloatingTask()) {
                throw new CommandException(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_USAGE));
            } else {
                if (isOnlyStartUpdated()) {
                    updateTaskDescriptor.setEndDate(Optional.of(taskToUpdate.getEndDate()));
                    updateTaskDescriptor.setEndTime(Optional.of(taskToUpdate.getEndTime()));
                } else {
                    if (isOnlyEndUpdated()) {
                        updateTaskDescriptor.setStartDate(Optional.of(taskToUpdate.getStartDate()));
                        updateTaskDescriptor.setStartTime(Optional.of(taskToUpdate.getStartTime()));
                    }
                }
            }
            if ((isOnlyStartTimeUpdated() || isOnlyEndTimeUpdated() || isOnlyTimeUpdated())
                    && (taskToUpdate.isFloatingTask() || taskToUpdate.isDeadlineTask())) {
                throw new CommandException(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_USAGE));
            } else {
                if (isOnlyEndTimeUpdated()) {
                    updateTaskDescriptor.setStartTime(Optional.of(taskToUpdate.getStartTime()));
                    updateTaskDescriptor.setStartDate(Optional.of(taskToUpdate.getStartDate()));
                    updateTaskDescriptor.setEndDate(Optional.of(taskToUpdate.getEndDate()));
                } else {
                    if (isOnlyStartTimeUpdated()) {
                        updateTaskDescriptor.setEndTime(Optional.of(taskToUpdate.getEndTime()));
                        updateTaskDescriptor.setStartDate(Optional.of(taskToUpdate.getStartDate()));
                        updateTaskDescriptor.setEndDate(Optional.of(taskToUpdate.getEndDate()));
                    } else {
                        if (isOnlyTimeUpdated()) {
                            updateTaskDescriptor.setStartDate(Optional.of(taskToUpdate.getStartDate()));
                            updateTaskDescriptor.setEndDate(Optional.of(taskToUpdate.getEndDate()));
                        }
                    }
                }
            }
        }

        if (isOnlyCategoriesUpdate() || isOnlyTaskNameUpdated()) {
            updateTaskDescriptor.setStartDate(Optional.of(taskToUpdate.getStartDate()));
            updateTaskDescriptor.setStartTime(Optional.of(taskToUpdate.getStartTime()));
            updateTaskDescriptor.setEndDate(Optional.of(taskToUpdate.getEndDate()));
            updateTaskDescriptor.setEndTime(Optional.of(taskToUpdate.getEndTime()));
        }

        Task updatedTask = createUpdatedTask(taskToUpdate, updateTaskDescriptor);

        try {
            if (updatedTask.isEventTask() && !DateTimeUtil.isValidEventTimePeriod(updatedTask.getStartDate().value,
                    updatedTask.getStartTime().value, updatedTask.getEndDate().value, updatedTask.getEndTime().value)) {
                throw new CommandException(MESSAGE_INVALID_EVENT_PERIOD);
            }
        } catch (IllegalValueException e) {
            throw new CommandException(MESSAGE_INVALID_EVENT_PERIOD);
        }

        try {
            if (updatedTask.isEventTask()) {
                int clashedTaskIndex = model.isBlockedOutTime(updatedTask, filteredTaskListIndex);
                if (clashedTaskIndex != -1) {
                    String clashFeedback = "Clash with task: Index " + Integer.toString(clashedTaskIndex) + "\n";
                    int updateIndex = model.updateTask(filteredTaskListIndex, updatedTask) + 1;
                    model.updateFilteredListToShowAll();
                    EventsCenter.getInstance().post(new JumpToListRequestEvent(updateIndex - 1));
                    return new CommandResult(clashFeedback + String.format(MESSAGE_UPDATE_TASK_SUCCESS, taskToUpdate)
                            + "\n" + "Task updated to index: " + Integer.toString(updateIndex));
                }
            }
            int updateIndex = model.updateTask(filteredTaskListIndex, updatedTask) + 1;
            model.updateFilteredListToShowAll();
            EventsCenter.getInstance().post(new JumpToListRequestEvent(updateIndex - 1));
            return new CommandResult(String.format(MESSAGE_UPDATE_TASK_SUCCESS, taskToUpdate) + "\n"
                    + "Task updated to index: " + Integer.toString(updateIndex));
        } catch (UniqueTaskList.DuplicateTaskException dpe) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
    }

    /**
     * Checks if only the task name field has been identified by user to be
     * updated To ensure that other task details like startTime startDate
     * endTime endDate are not lost
     *
     * @return true if only task name has been identified by user to be updated
     */
    private boolean isOnlyTaskNameUpdated() {
        return (updateTaskDescriptor.getStartDate().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getStartTime().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getEndDate().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getEndTime().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getTaskName().isPresent());
    }

    /**
     * Checks if only the time field has been identified by user to be updated
     * To ensure that user provides all the information that is required to
     * update a task.
     *
     * For instance, user is only allowed to update only startTime and endTime
     * if the task is an event and not a deadline or floating task.
     *
     * @return true if only task name has been identified by user to be updated
     */
    private boolean isOnlyTimeUpdated() {
        return (updateTaskDescriptor.getStartDate().get().toString().equals(EMPTY_FIELD)
                && !updateTaskDescriptor.getStartTime().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getEndDate().get().toString().equals(EMPTY_FIELD)
                && !updateTaskDescriptor.getEndTime().get().toString().equals(EMPTY_FIELD));
    }

    /**
     * Checks if only the category field has been identified by user to be
     * updated To ensure that other task details like startTime startDate
     * endTime endDate are not lost
     *
     * @return true if only categories are identified by user to be updated
     */
    private boolean isOnlyCategoriesUpdate() {
        return (updateTaskDescriptor.getStartDate().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getStartTime().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getEndDate().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getEndTime().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getCategories().isPresent());
    }

    /**
     * Checks if only the startTime has been identified by user to be updated To
     * ensure that other task details like startDate endTime endDate are not
     * lost
     *
     * @return true if only startTime information has been identified by user to
     *         be updated
     */
    private boolean isOnlyStartTimeUpdated() {
        return (updateTaskDescriptor.getStartDate().get().toString().equals(EMPTY_FIELD)
                && !updateTaskDescriptor.getStartTime().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getEndDate().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getEndTime().get().toString().equals(EMPTY_FIELD));
    }

    /**
     * Checks if only the endTime has been identified by user to be updated To
     * ensure that other task details like startTime startDate endDate are not
     * lost
     *
     * @return true if only endTime information has been identified by user to
     *         be updated
     */
    private boolean isOnlyEndTimeUpdated() {
        return (updateTaskDescriptor.getStartDate().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getStartTime().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getEndDate().get().toString().equals(EMPTY_FIELD)
                && !updateTaskDescriptor.getEndTime().get().toString().equals(EMPTY_FIELD));
    }

    /**
     * Checks if only the startDate and startTime has been identified by user to
     * be updated To ensure that other task details like endDate endTime are not
     * lost
     *
     * @return true if only startDate and startTime information has been
     *         identified by user to be updated
     */
    private boolean isOnlyStartUpdated() {
        return (!updateTaskDescriptor.getStartDate().get().toString().equals(EMPTY_FIELD)
                && !updateTaskDescriptor.getStartTime().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getEndDate().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getEndTime().get().toString().equals(EMPTY_FIELD));
    }

    /**
     * Checks if only the endDate and endTime has been identified by user to be
     * updated To ensure that other task details like startDate startTime are
     * not lost
     *
     * @return true if only endDate and endTime information has been identified
     *         by user to be updated
     */
    private boolean isOnlyEndUpdated() {
        return (updateTaskDescriptor.getStartDate().get().toString().equals(EMPTY_FIELD)
                && updateTaskDescriptor.getStartTime().get().toString().equals(EMPTY_FIELD)
                && !updateTaskDescriptor.getEndDate().get().toString().equals(EMPTY_FIELD)
                && !updateTaskDescriptor.getEndTime().get().toString().equals(EMPTY_FIELD));
    }

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     */
    private static Task createUpdatedTask(ReadOnlyTask taskToUpdate, UpdateTaskDescriptor updateTaskDescriptor) {
        assert taskToUpdate != null;

        TaskName updatedTaskName = updateTaskDescriptor.getTaskName().orElseGet(taskToUpdate::getTaskName);
        StartDate updatedStartDate = updateTaskDescriptor.getStartDate().orElseGet(taskToUpdate::getStartDate);
        StartTime updatedStartTime = updateTaskDescriptor.getStartTime().orElseGet(taskToUpdate::getStartTime);
        EndDate updatedEndDate = updateTaskDescriptor.getEndDate().orElseGet(taskToUpdate::getEndDate);
        EndTime updatedEndTime = updateTaskDescriptor.getEndTime().orElseGet(taskToUpdate::getEndTime);
        UniqueCategoryList updatedCategories = updateTaskDescriptor.getCategories()
                .orElseGet(taskToUpdate::getCategories);

        return new Task(updatedTaskName, updatedStartDate, updatedStartTime, updatedEndDate, updatedEndTime, false,
                updatedCategories);
    }

    /**
     * Stores the details to edit the task with. Each non-empty field value will
     * replace the corresponding field value of the task.
     */
    public static class UpdateTaskDescriptor {
        private Optional<TaskName> taskname = Optional.empty();
        private Optional<StartDate> startDate = Optional.empty();
        private Optional<StartTime> startTime = Optional.empty();
        private Optional<EndDate> endDate = Optional.empty();
        private Optional<EndTime> endTime = Optional.empty();
        private Optional<UniqueCategoryList> categories = Optional.empty();

        public UpdateTaskDescriptor() {
        }

        public UpdateTaskDescriptor(UpdateTaskDescriptor toCopy) {
            this.taskname = toCopy.getTaskName();
            this.startDate = toCopy.getStartDate();
            this.startTime = toCopy.getStartTime();
            this.endDate = toCopy.getEndDate();
            this.endTime = toCopy.getEndTime();
            this.categories = toCopy.getCategories();
        }

        /**
         * Returns true if at least one field is updated.
         */
        public boolean isAnyFieldUpdated() {
            return CollectionUtil.isAnyPresent(this.taskname, this.startDate, this.startTime, this.endDate,
                    this.endTime, this.categories);
        }

        public void setTaskName(Optional<TaskName> taskname) {
            assert taskname != null;
            this.taskname = taskname;
        }

        public Optional<TaskName> getTaskName() {
            return taskname;
        }

        public void setStartDate(Optional<StartDate> startDate) {
            assert startDate != null;
            this.startDate = startDate;
        }

        public Optional<StartDate> getStartDate() {
            return startDate;
        }

        public void setStartTime(Optional<StartTime> startTime) {
            assert startTime != null;
            this.startTime = startTime;
        }

        public Optional<StartTime> getStartTime() {
            return startTime;
        }

        public void setEndDate(Optional<EndDate> endDate) {
            assert endDate != null;
            this.endDate = endDate;
        }

        public Optional<EndDate> getEndDate() {
            return endDate;
        }

        public void setEndTime(Optional<EndTime> endTime) {
            assert endTime != null;
            this.endTime = endTime;
        }

        public Optional<EndTime> getEndTime() {
            return endTime;
        }

        public void setCategories(Optional<UniqueCategoryList> categories) {
            assert categories != null;
            this.categories = categories;
        }

        public Optional<UniqueCategoryList> getCategories() {
            return categories;
        }

    }
}
```
###### \java\seedu\taskmanager\logic\parser\ChangeSaveLocationCommandParser.java
``` java
public class ChangeSaveLocationCommandParser {

    public static final String INVALID_SAVE_LOCATION = "Invalid input for save location";

    /**
     * Parses the given {@code String} of arguments in the context of the
     * ChangeSaveLocationCommand and returns an ChangeSaveLocationCommand object
     * for execution.
     */

    public Command parse(String args) {

        // assert args != null;

        String stringSaveLocation = args.trim();
        File checkLocation = new File(args.trim());

        if (("".equals(args))) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ChangeSaveLocationCommand.MESSAGE_USAGE));
        }
        if (!checkLocation.exists()) {
            return new IncorrectCommand(INVALID_SAVE_LOCATION + "\n" + ChangeSaveLocationCommand.MESSAGE_USAGE);
        }

        if (!(stringSaveLocation.substring(stringSaveLocation.length() - 1).equals("/"))) {
            stringSaveLocation += "/";
        }

        stringSaveLocation += "taskmanager.xml";

        File saveLocation = new File(stringSaveLocation.trim());

        return new ChangeSaveLocationCommand(saveLocation);
    }

}
```
###### \java\seedu\taskmanager\logic\parser\DeleteCommandParser.java
``` java
/**
 * Parses input arguments and creates a new DeleteCommand object
 */
public class DeleteCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the
     * DeleteCommand and returns an DeleteCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;

        if (args.trim().matches(DeleteCommand.DELETE_COMMAND_VALIDATION_REGEX_1)) {
            Optional<Integer> index = ParserUtil.parseIndex(args);
            if (!index.isPresent()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
            }
            return new DeleteCommand(index.get());
        } else {
            if (args.isEmpty()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
            }
            return new DeleteCommand(args.trim());
        }
    }
}
```
###### \java\seedu\taskmanager\logic\parser\UpdateCommandParser.java
``` java
/**
 * Parses input arguments and creates a new UpdateCommand object
 */
public class UpdateCommandParser {

    public static final String ALPHABET_ONLY_STRING_REGEX = "[a-zA-Z]+";
    public static final String EMPTY_FIELD = "EMPTY_FIELD";
    public static final String INVALID_TIME = "Invalid input for time\nTime must be between 0000 and 2359";

    /**
     * Parses the given {@code String} of arguments in the context of the
     * EditCommand and returns an EditCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_ON, PREFIX_BY, PREFIX_FROM, PREFIX_TO,
                PREFIX_CATEGORY);
        argsTokenizer.tokenize(args);
        List<Optional<String>> preambleFields = ParserUtil.splitPreamble(argsTokenizer.getPreamble().orElse(""), 2);

        Optional<Integer> index = preambleFields.get(0).flatMap(ParserUtil::parseIndex);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
        }

        UpdateTaskDescriptor updateTaskDescriptor = new UpdateTaskDescriptor();

        Boolean isUpdateToDeadlineTask = false;

        try {
            Optional<String> taskName = preambleFields.get(1);
            Optional<String> onPrefixInput = argsTokenizer.getValue(PREFIX_ON);
            Optional<String> byPrefixInput = argsTokenizer.getValue(PREFIX_BY);
            Optional<String> fromPrefixInput = argsTokenizer.getValue(PREFIX_FROM);
            Optional<String> toPrefixInput = argsTokenizer.getValue(PREFIX_TO);

            updateTaskInputValidation(onPrefixInput, byPrefixInput, fromPrefixInput, toPrefixInput);

            if (byPrefixInput.isPresent()) {
                isUpdateToDeadlineTask = true;
            }

            String stringStartDate = "";
            String stringStartTime = "";
            String stringEndTime = "";
            String stringEndDate = "";

            /*
             * To validate and assign task details if user only wants to input
             * numbers
             */
            if (isPrefixNumbersOnly(fromPrefixInput) && (DateTimeUtil.isValidTime(fromPrefixInput.get()))) {
                stringStartTime = fromPrefixInput.get();
            } else {
                if (isPrefixNumbersOnly(onPrefixInput) && (DateTimeUtil.isValidTime(onPrefixInput.get()))) {
                    stringStartTime = onPrefixInput.get();
                }
            }
            if (isPrefixNumbersOnly(toPrefixInput) && (DateTimeUtil.isValidTime(toPrefixInput.get()))) {
                stringEndTime = toPrefixInput.get();
            }

            /*
             * To parse user inputs if user wants to update current task to a
             * same day event task
             */
            if (onPrefixInput.isPresent()) {
                if (isValidTimePrefixesArgLen(onPrefixInput)) {
                    String[] splited = onPrefixInput.get().trim().split("\\s+");
                    stringStartDate = splited[0];
                    stringEndDate = splited[0];
                    try {
                        stringStartTime = splited[1];
                        if (!DateTimeUtil.isValidTime(stringStartTime)) {
                            throw new IllegalValueException(INVALID_TIME);
                        }
                        if (!toPrefixInput.isPresent()) {
                            stringEndTime = DateTimeUtil.includeOneHourBuffer(stringStartTime);
                            if (Integer.parseInt(stringEndTime) < 100) {
                                if (stringEndDate.trim().matches(ALPHABET_ONLY_STRING_REGEX)) {
                                    stringEndDate = DateTimeUtil.getFutureDate(1, "days",
                                            DateTimeUtil.getNewDate(stringEndDate));
                                } else {
                                    stringEndDate = DateTimeUtil.getFutureDate(1, "days", stringEndDate);
                                }
                            }
                        } else {
                            String[] splitedEndTime = toPrefixInput.get().split("\\s+");
                            try {
                                if (!(splitedEndTime[1].isEmpty())) {
                                    throw new IllegalValueException("Incorrect input after TO prefix.\n"
                                            + "Example of Allowed Format: ADD task ON thursday 1200 TO 1400\n"
                                            + "Type HELP for user guide with detailed explanations of all commands");
                                }
                            } catch (ArrayIndexOutOfBoundsException aioobe) {
                                stringEndTime = splitedEndTime[0];
                                if (!DateTimeUtil.isValidTime(stringEndTime)) {
                                    throw new IllegalValueException(INVALID_TIME);
                                }
                            }
                        }
                    } catch (ArrayIndexOutOfBoundsException aioobe) {
                        stringStartTime = "0000";
                        if (("").equals(stringEndTime)) {
                            stringEndTime = "2359";
                        } else {
                            String[] splitedEndTime = toPrefixInput.get().split("\\s+");
                            try {
                                if (!(splitedEndTime[1].isEmpty())) {
                                    throw new IllegalValueException("Incorrect input after TO prefix.\n"
                                            + "Example of Allowed Format: ADD task ON thursday 1200 TO 1400\n"
                                            + "Type HELP for user guide with detailed explanations of all commands");
                                }
                            } catch (ArrayIndexOutOfBoundsException aiobe) {
                                stringEndTime = splitedEndTime[0];
                                if (!DateTimeUtil.isValidTime(stringEndTime)) {
                                    throw new IllegalValueException(INVALID_TIME);
                                }
                            }
                        }
                    }
                } else {
                    throw new NoSuchElementException();
                }
            }

            if (fromPrefixInput.isPresent()) {
                if (fromPrefixInput.get().trim().matches(ALPHABET_ONLY_STRING_REGEX)
                        || fromPrefixInput.get().trim().matches(STARTDATE_VALIDATION_REGEX1)) {
                    stringStartTime = "0000";
                }
                if (fromPrefixInput.get().trim().matches(ALPHABET_ONLY_STRING_REGEX)) {
                    stringStartDate = DateTimeUtil.getNewDate(fromPrefixInput.get());
                }
            }

            if (toPrefixInput.isPresent()) {
                if (toPrefixInput.get().trim().matches(ALPHABET_ONLY_STRING_REGEX)
                        || toPrefixInput.get().trim().matches(STARTDATE_VALIDATION_REGEX1)) {
                    stringEndTime = "2359";
                }
                if (toPrefixInput.get().trim().matches(ALPHABET_ONLY_STRING_REGEX)) {
                    stringEndDate = DateTimeUtil.getNewDate(toPrefixInput.get());
                }
            }

            if ((fromPrefixInput.isPresent()) && (!fromPrefixInput.get().matches("\\d+"))) {
                if (isValidTimePrefixesArgLen(fromPrefixInput)) {
                    String[] splited = fromPrefixInput.get().split("\\s+");
                    try {
                        if (splited[0].matches(STARTDATE_VALIDATION_REGEX2)) {
                            splited[0] = DateTimeUtil.getNewDate(splited[0]);
                        }
                        stringStartDate = splited[0];
                        stringStartTime = splited[1];
                        if (!DateTimeUtil.isValidTime(stringStartTime)) {
                            throw new IllegalValueException(INVALID_TIME);
                        }
                    } catch (ArrayIndexOutOfBoundsException aioobe) {
                        if (splited[0].matches(STARTDATE_VALIDATION_REGEX2)) {
                            stringStartDate = DateTimeUtil.getNewDate(splited[0]);
                        }
                    }
                    if (toPrefixInput.isPresent() && toPrefixInput.get().matches("\\d+")) {
                        throw new NoSuchElementException();
                    }
                } else {
                    throw new NoSuchElementException();
                }
            }

            if ((toPrefixInput.isPresent()) && (!toPrefixInput.get().matches("\\d+"))) {
                if (isValidTimePrefixesArgLen(toPrefixInput)) {
                    String[] splited = toPrefixInput.get().split("\\s+");
                    try {
                        if (splited[0].matches(STARTDATE_VALIDATION_REGEX2)) {
                            splited[0] = DateTimeUtil.getNewDate(splited[0]);
                        }
                        stringEndDate = splited[0];
                        stringEndTime = splited[1];
                        if (!DateTimeUtil.isValidTime(stringEndTime)) {
                            throw new IllegalValueException(INVALID_TIME);
                        }
                    } catch (ArrayIndexOutOfBoundsException aioobe) {
                        if (splited[0].matches(STARTDATE_VALIDATION_REGEX2)) {
                            stringEndDate = DateTimeUtil.getNewDate(splited[0]);
                        }
                    }
                } else {
                    throw new NoSuchElementException();
                }
            }

            /*
             * To parse deadline input if required and throws exceptions if
             * incorrect arguments of deadline are included
             */
            if (byPrefixInput.isPresent()) {
                if (isValidTimePrefixesArgLen(byPrefixInput)) {
                    String[] splited = byPrefixInput.get().trim().split("\\s+");
                    stringEndDate = splited[0];
                    try {
                        stringEndTime = splited[1];
                        if (!DateTimeUtil.isValidTime(stringEndTime)) {
                            throw new IllegalValueException(INVALID_TIME);
                        }
                    } catch (ArrayIndexOutOfBoundsException aioobe) {
                        stringEndTime = "2359";
                    } catch (NumberFormatException nfe) {
                        return new IncorrectCommand("Invalid input after prefix BY\n"
                                + "Example of Allowed Format: ADD project meeting BY thursday 1400 \n"
                                + "Type HELP for user guide with detailed explanations of all commands");
                    }
                } else {
                    throw new NoSuchElementException();
                }
            }

            Optional<String> startDate;
            Optional<String> startTime;
            Optional<String> endDate;
            Optional<String> endTime;

            if (!("").equals(stringStartTime)) {
                startTime = Optional.of(stringStartTime);
            } else {
                startTime = Optional.of(EMPTY_FIELD);
            }
            if (!("").equals(stringEndTime)) {
                endTime = Optional.of(stringEndTime);
            } else {
                endTime = Optional.of(EMPTY_FIELD);
            }
            if (!("").equals(stringStartDate)) {
                startDate = Optional.of(stringStartDate);
            } else {
                startDate = Optional.of(EMPTY_FIELD);
            }
            if (!("").equals(stringEndDate)) {
                endDate = Optional.of(stringEndDate);
            } else {
                endDate = Optional.of(EMPTY_FIELD);
            }

            if (startDate.isPresent() && startDate.get().matches(STARTDATE_VALIDATION_REGEX2)) {
                startDate = Optional.of(DateTimeUtil.getNewDate(startDate.get()));
            }
            if (endDate.isPresent() && endDate.get().matches(STARTDATE_VALIDATION_REGEX2)) {
                endDate = Optional.of(DateTimeUtil.getNewDate(endDate.get()));
            }

            updateTaskDescriptor.setTaskName(ParserUtil.parseTaskName(taskName));
            updateTaskDescriptor.setStartDate(ParserUtil.parseStartDate(startDate));
            updateTaskDescriptor.setStartTime(ParserUtil.parseStartTime(startTime));
            updateTaskDescriptor.setEndDate(ParserUtil.parseEndDate(endDate));
            updateTaskDescriptor.setEndTime(ParserUtil.parseEndTime(endTime));
            updateTaskDescriptor.setCategories(
                    parseCategoriesForUpdate(ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_CATEGORY))));

        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
        } catch (ArrayIndexOutOfBoundsException aioobe) {
            return new IncorrectCommand(
                    "Invalid command input!\nExample of Allowed Format: ADD e-mail John BY thursday 1400\n"
                            + "Type HELP for user guide with detailed explanations of all commands");
        } catch (NumberFormatException nfe) {
            return new IncorrectCommand("Invalid input after prefix TO, only input of time is allowed\n"
                    + "Example of Allowed Format: ADD project meeting ON thursday 1400 TO 1800\n"
                    + "Type HELP for user guide with detailed explanations of all commands");
        }

        if (!updateTaskDescriptor.isAnyFieldUpdated()) {
            return new IncorrectCommand(UpdateCommand.MESSAGE_NOT_UPDATED);
        }
        return new UpdateCommand(index.get(), updateTaskDescriptor, isUpdateToDeadlineTask);
    }

    /**
     * @param prefixInput
     * @return true if prefixInput is only numbers
     */
    private boolean isPrefixNumbersOnly(Optional<String> prefixInput) {
        return prefixInput.isPresent() && prefixInput.get().matches("\\d+");
    }

    /*
     * Checks to ensure correct combinations of arguments are added by user when
     * updating tasks in the task manager
     */
    private void updateTaskInputValidation(Optional<String> onPrefixInput, Optional<String> byPrefixInput,
            Optional<String> fromPrefixInput, Optional<String> toPrefixInput) throws NoSuchElementException {
        if (!onPrefixInput.isPresent() || !byPrefixInput.isPresent() || !fromPrefixInput.isPresent()
                || !toPrefixInput.isPresent()) {
            if ((onPrefixInput.isPresent()) && ((byPrefixInput.isPresent()) || (fromPrefixInput.isPresent()))) {
                throw new NoSuchElementException();
            }
            if ((byPrefixInput.isPresent())
                    && ((onPrefixInput.isPresent()) || (fromPrefixInput.isPresent()) || (toPrefixInput.isPresent()))) {
                throw new NoSuchElementException();
            }
            if (((fromPrefixInput.isPresent()) && ((onPrefixInput.isPresent()) || (byPrefixInput.isPresent())))) {
                throw new NoSuchElementException();
            }
        }
    }

    /**
     * Parses {@code Collection<String> tags} into an
     * {@code Optional<UniqueTagList>} if {@code tags} is non-empty. If
     * {@code tags} contain only one element which is an empty string, it will
     * be parsed into a {@code Optional<UniqueTagList>} containing zero tags.
     */
    private Optional<UniqueCategoryList> parseCategoriesForUpdate(Collection<String> categories)
            throws IllegalValueException {
        assert categories != null;

        if (categories.isEmpty()) {
            return Optional.empty();
        }
        Collection<String> categorySet = categories.size() == 1 && categories.contains("") ? Collections.emptySet()
                : categories;
        return Optional.of(ParserUtil.parseCategories(categorySet));
    }

    private boolean isValidTimePrefixesArgLen(Optional<String> prefixInput) {
        String[] splited = prefixInput.get().trim().split("\\s+");
        return (splited.length <= 2);
    }
}
```
###### \java\seedu\taskmanager\model\category\UniqueCategoryList.java
``` java
    /**
     * Checks if task is assigned any category
     *
     * @return true if category list is empty.
     */
    public boolean isEmptyCategoryList() {
        return (internalList.isEmpty());
    }
}
```
###### \java\seedu\taskmanager\model\Model.java
``` java
    /**
     * Deletes tasks by their date. Returns the number of tasks deleted.
     */
    int deleteTasksDate(UnmodifiableObservableList<ReadOnlyTask> targets) throws UniqueTaskList.TaskNotFoundException;

    /**
     * Deletes the task by its name. Returns the number of tasks deleted.
     */
    int deleteTasksName(UnmodifiableObservableList<ReadOnlyTask> targets, String toDeleteTaskName)
            throws UniqueTaskList.TaskNotFoundException;

```
###### \java\seedu\taskmanager\model\Model.java
``` java
    /**
     * Updates the filter of the filtered task list to filter by completed tasks
     */
    void updateFilteredTaskListForInitialView();

    void unmarkTask(int filteredTaskListIndex) throws DuplicateTaskException;

    int isBlockedOutTime(Task task) throws DuplicateTaskException;

    int isBlockedOutTime(Task t, int UpdateTaskIndex) throws DuplicateTaskException;
}
```
###### \java\seedu\taskmanager\model\ModelManager.java
``` java
    /** Re-save data when save location has changed */
    public void saveTaskManager() {
        indicateTaskManagerChanged();
    }

    /** Save a copy of task manager before data is changed. */
    private void saveInstance() {
        undoTaskManager.push(new TaskManager(taskManager));
        redoTaskManager.clear();
    }

    /** Undo previous action of task manager. */
    public void undoTaskManager() {
        TaskManager currentTaskManager = new TaskManager(taskManager);
        taskManager.resetData(undoTaskManager.peek());
        undoTaskManager.pop();
        redoTaskManager.push(currentTaskManager);
        indicateTaskManagerChanged();
    }

    /** Undo previous action of task manager. */
    public void redoTaskManager() {
        TaskManager currentTaskManager = new TaskManager(taskManager);
        taskManager.resetData(redoTaskManager.peek());
        redoTaskManager.pop();
        undoTaskManager.push(currentTaskManager);
        indicateTaskManagerChanged();
    }

```
###### \java\seedu\taskmanager\model\ModelManager.java
``` java
    /**
     * Deletes tasks by their date. Returns the number of tasks deleted.
     */
    @Override
    public synchronized int deleteTasksDate(UnmodifiableObservableList<ReadOnlyTask> targets)
            throws TaskNotFoundException {
        int numDeletedTasks = 0;
        saveInstance();
        while (targets.size() != 0) {
            try {
                ReadOnlyTask taskToDelete = targets.get(0);
                saveInstance();
                taskManager.removeTask(taskToDelete);
                numDeletedTasks++;
            } catch (TaskNotFoundException pnfe) {
                assert false : "The target task cannot be missing";
            }
        }
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
        return numDeletedTasks;
    }

    /**
     * Deletes the task by its name. Returns the number of tasks deleted.
     */
    @Override
    public synchronized int deleteTasksName(UnmodifiableObservableList<ReadOnlyTask> targets, String toDeleteTaskName)
            throws TaskNotFoundException {
        int numDeletedTasks = 0;
        saveInstance();
        for (int index = 0; targets.size() != index; index++) {
            try {
                ReadOnlyTask taskToDelete = targets.get(index);
                if (toDeleteTaskName.equals(taskToDelete.getTaskName().fullTaskName.trim())) {
                    taskManager.removeTask(taskToDelete);
                    index--;
                    numDeletedTasks++;
                }
            } catch (TaskNotFoundException pnfe) {
                assert false : "The target task cannot be missing";
            }
        }
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
        return numDeletedTasks;
    }

    @Override
    public synchronized int addTask(Task task) throws UniqueTaskList.DuplicateTaskException {
        saveInstance();
        int addIndex = taskManager.addTask(task);
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
        return addIndex;
    }

```
###### \java\seedu\taskmanager\model\ModelManager.java
``` java
    @Override
    public void updateFilteredTaskListForInitialView() {
        updateFilteredTaskList(new PredicateExpression(new CompletedQualifier(false)));
    }

    // ========== Inner classes/interfaces used for filtering
    // =================================================

    interface Expression {
        boolean satisfies(ReadOnlyTask task);

        String toString();
    }

    private class PredicateExpression implements Expression {

        private final Qualifier qualifier;

        PredicateExpression(Qualifier qualifier) {
            this.qualifier = qualifier;
        }

        @Override
        public boolean satisfies(ReadOnlyTask task) {
            return qualifier.run(task);
        }

        @Override
        public String toString() {
            return qualifier.toString();
        }
    }

    interface Qualifier {
        boolean run(ReadOnlyTask task);

        String toString();
    }

```
###### \java\seedu\taskmanager\model\ModelManager.java
``` java
    /**
     * Compares the starting date and time of 2 event tasks.
     *
     * @return true if 1st event task is earlier than the 2nd event task based
     *         on the startDate and startTime
     * @return false, if otherwise.
     */
    private boolean isAddEventEarlierAddListIndex(Task toAdd, ReadOnlyTask readOnlyTask) {
        if (toAdd.getStartDate().value.substring(toAdd.getStartDate().value.length() - 2).compareTo(
                readOnlyTask.getStartDate().value.substring(readOnlyTask.getStartDate().value.length() - 2)) < 0) {
            return true;
        } else {
            if (toAdd.getStartDate().value.substring(toAdd.getStartDate().value.length() - 2).compareTo(
                    readOnlyTask.getStartDate().value.substring(readOnlyTask.getStartDate().value.length() - 2)) == 0) {
                if (toAdd.getStartDate().value
                        .substring(toAdd.getStartDate().value.length() - 5, toAdd.getStartDate().value.length() - 3)
                        .compareTo(readOnlyTask.getStartDate().value.substring(
                                readOnlyTask.getStartDate().value.length()
                                        - 5,
                                readOnlyTask.getStartDate().value.length() - 3)) < 0) {
                    return true;
                } else {
                    if (toAdd.getStartDate().value
                            .substring(toAdd.getStartDate().value.length() - 5, toAdd.getStartDate().value.length() - 3)
                            .compareTo(readOnlyTask.getStartDate().value.substring(
                                    readOnlyTask.getStartDate().value.length()
                                            - 5,
                                    readOnlyTask.getStartDate().value.length() - 3)) == 0) {
                        if (toAdd.getStartDate().value.substring(0, toAdd.getStartDate().value.length() - 6)
                                .compareTo(readOnlyTask.getStartDate().value.substring(0,
                                        readOnlyTask.getStartDate().value.length() - 6)) < 0) {
                            return true;
                        } else {
                            if (toAdd.getStartDate().value.substring(0, toAdd.getStartDate().value.length() - 6)
                                    .compareTo(readOnlyTask.getStartDate().value.substring(0,
                                            readOnlyTask.getStartDate().value.length() - 6)) == 0) {
                                return (toAdd.getStartTime().value.compareTo(readOnlyTask.getStartTime().value) < 0);
                            } else {
                                return false;
                            }
                        }
                    } else {
                        return false;
                    }
                }
            } else {
                return false;
            }
        }
    }
}
```
###### \java\seedu\taskmanager\model\task\ReadOnlyTask.java
``` java
    /**
     * Formats the task as text, showing all contact details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getTaskName());

        if (!getStartDate().toString().equals("EMPTY_FIELD")) {
            builder.append(" Start Date: ").append(getStartDate());
        }

        if (!getStartTime().toString().equals("EMPTY_FIELD")) {
            builder.append(" Start Time: ").append(getStartTime());
        }

        if (!getEndDate().toString().equals("EMPTY_FIELD")) {
            builder.append(" End Date: ").append(getEndDate());
        }

        if (!getEndTime().toString().equals("EMPTY_FIELD")) {
            builder.append(" End Time: ").append(getEndTime());
        }

        if (!getCategories().isEmptyCategoryList()) {
            builder.append(" Categories: ");
            getCategories().forEach(builder::append);
        }

        return builder.toString();
    }

    /**
     * Checks the fields populated within the task
     *
     * @return true if task is a Event Task
     */
    boolean isEventTask();

    /**
     * Checks the fields populated within the task
     *
     * @return true if task is a Deadline Task
     */
    boolean isDeadlineTask();

    /**
     * Checks the fields populated within the task
     *
     * @return true if task is a Floating Task
     */
    boolean isFloatingTask();

```
###### \java\seedu\taskmanager\model\task\Task.java
``` java
    /**
     * Checks the fields populated within the task
     *
     * @return true if task is a Event Task
     */
    @Override
    public boolean isEventTask() {
        return !startDate.value.equals(EMPTY_FIELD) && !endDate.value.equals(EMPTY_FIELD);
    }

    /**
     * Checks the fields populated within the task
     *
     * @return true if task is a Deadline Task
     */
    @Override
    public boolean isDeadlineTask() {
        return startDate.value.equals(EMPTY_FIELD) && !endDate.value.equals(EMPTY_FIELD);
    }

    /**
     * Checks the fields populated within the task
     *
     * @return true if task is a Floating Task
     */
    @Override
    public boolean isFloatingTask() {
        return startDate.value.equals(EMPTY_FIELD) && endDate.value.equals(EMPTY_FIELD);
    }

```
###### \java\seedu\taskmanager\model\task\UniqueTaskList.java
``` java
    /**
     * Adds a task to the list.
     *
     * @throws DuplicateTaskException
     *             if the task to add is a duplicate of an existing task in the
     *             list.
     */
    public int add(Task toAdd) throws DuplicateTaskException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateTaskException();
        }

        int addIndex = findSortedPositionToAdd(toAdd);
        int numMarkedTasks = findNumMarkedTasksBeforeUpdateIndex(addIndex);

        internalList.add(addIndex, toAdd);

        return addIndex - numMarkedTasks;
    }

    /**
     * Updates the task in the list at position {@code index} with
     * {@code editedTask}.
     *
     * @throws DuplicateTaskException
     *             if updating the task's details causes the task to be
     *             equivalent to another existing task in the list.
     * @throws IndexOutOfBoundsException
     *             if {@code index} < 0 or >= the size of the list.
     */
    public int updateTask(int index, ReadOnlyTask editedTask) throws DuplicateTaskException {
        assert editedTask != null;

        Task taskToUpdate = internalList.get(index);
        if (!taskToUpdate.equals(editedTask) && internalList.contains(editedTask)) {
            throw new DuplicateTaskException();
        }

        taskToUpdate.resetData(editedTask);

        internalList.remove(index);

        int updateIndex = findSortedPositionToAdd(taskToUpdate);
        int numMarkedTasks = findNumMarkedTasksBeforeUpdateIndex(updateIndex);

        internalList.add(updateIndex, taskToUpdate);

        return updateIndex - numMarkedTasks;
    }

```
###### \java\seedu\taskmanager\model\task\UniqueTaskList.java
``` java
    /**
     * Compares the starting date and time of 2 event tasks.
     *
     * @return true if 1st event task is earlier than the 2nd event task based
     *         on the startDate and startTime
     * @return false, if otherwise.
     */
    private boolean isAddEventEarlierAddListIndex(Task toAdd, ReadOnlyTask readOnlyTask) {
        if (toAdd.getStartDate().value.substring(toAdd.getStartDate().value.length() - 2).compareTo(
                readOnlyTask.getStartDate().value.substring(readOnlyTask.getStartDate().value.length() - 2)) < 0) {
            return true;
        } else {
            if (toAdd.getStartDate().value.substring(toAdd.getStartDate().value.length() - 2).compareTo(
                    readOnlyTask.getStartDate().value.substring(readOnlyTask.getStartDate().value.length() - 2)) == 0) {
                if (toAdd.getStartDate().value
                        .substring(toAdd.getStartDate().value.length() - 5, toAdd.getStartDate().value.length() - 3)
                        .compareTo(readOnlyTask.getStartDate().value.substring(
                                readOnlyTask.getStartDate().value.length()
                                        - 5,
                                readOnlyTask.getStartDate().value.length() - 3)) < 0) {
                    return true;
                } else {
                    if (toAdd.getStartDate().value
                            .substring(toAdd.getStartDate().value.length() - 5, toAdd.getStartDate().value.length() - 3)
                            .compareTo(readOnlyTask.getStartDate().value.substring(
                                    readOnlyTask.getStartDate().value.length()
                                            - 5,
                                    readOnlyTask.getStartDate().value.length() - 3)) == 0) {
                        if (toAdd.getStartDate().value.substring(0, toAdd.getStartDate().value.length() - 6)
                                .compareTo(readOnlyTask.getStartDate().value.substring(0,
                                        readOnlyTask.getStartDate().value.length() - 6)) < 0) {
                            return true;
                        } else {
                            if (toAdd.getStartDate().value.substring(0, toAdd.getStartDate().value.length() - 6)
                                    .compareTo(readOnlyTask.getStartDate().value.substring(0,
                                            readOnlyTask.getStartDate().value.length() - 6)) == 0) {
                                return (toAdd.getStartTime().value.compareTo(readOnlyTask.getStartTime().value) < 0);
                            } else {
                                return false;
                            }
                        }
                    } else {
                        return false;
                    }
                }
            } else {
                return false;
            }
        }
    }

    /**
     * Compares the due date of 2 deadline tasks.
     *
     * @return true if 1st deadline task is earlier than the 2nd deadline task
     *         based on the endDate and endTime
     * @return false, if otherwise.
     */
    private boolean isAddDeadlineEarlierAddListIndex(Task toAdd, ReadOnlyTask readOnlyTask) {
        if (toAdd.getEndDate().value.substring(toAdd.getEndDate().value.length() - 2).compareTo(
                readOnlyTask.getEndDate().value.substring(readOnlyTask.getEndDate().value.length() - 2)) < 0) {
            return true;
        } else {
            if (toAdd.getEndDate().value.substring(toAdd.getEndDate().value.length() - 2).compareTo(
                    readOnlyTask.getEndDate().value.substring(readOnlyTask.getEndDate().value.length() - 2)) == 0) {
                if (toAdd.getEndDate().value
                        .substring(toAdd.getEndDate().value.length() - 5, toAdd.getEndDate().value.length() - 3)
                        .compareTo(
                                readOnlyTask.getEndDate().value.substring(readOnlyTask.getEndDate().value.length() - 5,
                                        readOnlyTask.getEndDate().value.length() - 3)) < 0) {
                    return true;
                } else {
                    if (toAdd.getEndDate().value
                            .substring(toAdd.getEndDate().value.length() - 5, toAdd.getEndDate().value.length() - 3)
                            .compareTo(readOnlyTask.getEndDate().value.substring(
                                    readOnlyTask.getEndDate().value.length()
                                            - 5,
                                    readOnlyTask.getEndDate().value.length() - 3)) == 0) {
                        if (toAdd.getEndDate().value.substring(0, toAdd.getEndDate().value.length() - 6)
                                .compareTo(readOnlyTask.getEndDate().value.substring(0,
                                        readOnlyTask.getEndDate().value.length() - 6)) < 0) {
                            return true;
                        } else {
                            if (toAdd.getEndDate().value.substring(0, toAdd.getEndDate().value.length() - 6)
                                    .compareTo(readOnlyTask.getEndDate().value.substring(0,
                                            readOnlyTask.getEndDate().value.length() - 6)) == 0) {
                                return (toAdd.getEndTime().value.compareTo(readOnlyTask.getEndTime().value) < 0);
                            } else {
                                return false;
                            }
                        }
                    } else {
                        return false;
                    }
                }
            } else {
                return false;
            }
        }
    }

    /**
     * Finds the sorted position to add new task to the existing list of task.
     * List of tasks is sorted firstly based on type of task and then by
     * chronological order of the task
     *
     * Event tasks sorted by startDate startTime. Deadline tasks sorted by
     * endDate endTime. Floating tasks are just added to the bottom of the list
     * as there is no time element within a floating task.
     *
     * @return The sorted position index to add the new task in the sorted list
     *         of tasks.
     */
    private int findSortedPositionToAdd(Task toAdd) {
        int addIndex = 0;

        if (!internalList.isEmpty()) {
            if (toAdd.isEventTask()) {
                addIndex = findSortedPositionToAddEvents(toAdd);
            }

            if (toAdd.isDeadlineTask()) {
                addIndex = findSortedPositionToAddDeadlines(toAdd);
            }

            if (toAdd.isFloatingTask()) {
                addIndex = internalList.size();
            }
        }
        return addIndex;
    }

    /**
     * @param toAdd
     * @param addIndex
     * @return index deadline should be added in internalList according to
     *         chronological order
     */
    private int findSortedPositionToAddDeadlines(Task toAdd) {
        int addIndex = 0;

        while (internalList.get(addIndex).isEventTask()) {
            addIndex++;
            if (addIndex == internalList.size()) {
                break;
            }
        }
        while ((addIndex != internalList.size()) && internalList.get(addIndex).isDeadlineTask()) {
            if (isAddDeadlineEarlierAddListIndex(toAdd, internalList.get(addIndex))) {
                break;
            }
            addIndex++;
            if (addIndex == internalList.size()) {
                break;
            }
        }
        return addIndex;
    }

    /**
     * @param toAdd
     * @param addIndex
     * @return index event should be added in internalList according to
     *         chronological order
     */
    private int findSortedPositionToAddEvents(Task toAdd) {
        int addIndex = 0;

        while (internalList.get(addIndex).isEventTask()) {
            if (isAddEventEarlierAddListIndex(toAdd, internalList.get(addIndex))) {
                break;
            }
            addIndex++;
            if (addIndex == internalList.size()) {
                break;
            }
        }
        return addIndex;
    }

    /**
     * Finds the number of tasks marked as completed within internalList.
     *
     * @return The number of tasks marked as completed
     */
    private int findNumMarkedTasksBeforeUpdateIndex(int index) {
        int numMarkedTasks = 0;
        for (int checkIndex = 0; checkIndex < index; checkIndex++) {
            Task task = internalList.get(checkIndex);
            if (task.getIsMarkedAsComplete()) {
                numMarkedTasks++;
            }
        }
        return numMarkedTasks;
    }
}
```
###### \java\seedu\taskmanager\ui\DeadlineTaskCard.java
``` java
public class DeadlineTaskCard extends UiPart<Region> {

    private static final String FXML = "DeadlineTaskCard.fxml";

    @FXML
    private HBox cardPane;
    @FXML
    private Label taskname;
    @FXML
    private Label id;
    @FXML
    private Label dueDateTime;
    @FXML
    private Label markedCompleted;
    @FXML
    private FlowPane categories;

    private final StringProperty empty = new SimpleStringProperty("");
    private final StringProperty completed = new SimpleStringProperty("Completed");

    public DeadlineTaskCard(ReadOnlyTask task, int displayedIndex) {
        super(FXML);
        taskname.setText(task.getTaskName().fullTaskName);
        id.setText(displayedIndex + ". ");
        setDeadlineTaskDetailsLabel(task);
        setMarkedCompletedLabel(task);
        initCategory(task);
    }

    /**
     * @param task
     */
    private void setDeadlineTaskDetailsLabel(ReadOnlyTask task) {
        dueDateTime.setText("Due By: " + task.getEndDate().value + "  " + task.getEndTime().value);
    }

    /**
     * @param task
     */
    private void setMarkedCompletedLabel(ReadOnlyTask task) {
        if (task.getIsMarkedAsComplete()) {
            markedCompleted.textProperty().bind(completed);
        } else {
            markedCompleted.textProperty().bind(empty);
        }
    }

    private void initCategory(ReadOnlyTask task) {
        if (!task.getCategories().asObservableList().isEmpty()) {
            for (int index = 0; task.getCategories().asObservableList().size() != index; index++) {
                Label label = stylePriorityCategories(task, index);
                categories.getChildren().add(label);
            }
        }
    }

    /**
     * @param task
     * @param index
     * @return
     */
    private Label stylePriorityCategories(ReadOnlyTask task, int index) {
        String category = task.getCategories().asObservableList().get(index).categoryName;
        Label label = new Label(category);
        if (category.equalsIgnoreCase("High")) {
            label.setStyle("-fx-background-color: red");
        }
        if (category.equalsIgnoreCase("Medium")) {
            label.setStyle("-fx-background-color: orange");
        }
        if (category.equalsIgnoreCase("Low")) {
            label.setStyle("-fx-background-color: lightblue");
        }
        return label;
    }
}
```
###### \java\seedu\taskmanager\ui\DeadlineTaskListPanel.java
``` java
    public void setConnections(ObservableList<ReadOnlyTask> taskList) {
        ObservableList<Pair<ReadOnlyTask, Integer>> deadlineTaskList = extractDeadlineTasks(taskList);
        deadlineTaskListView.setItems(deadlineTaskList);
        deadlineTaskListView.setCellFactory(listView -> new TaskListViewCell());
        setEventHandlerForSelectionChangeEvent();
    }

```
###### \java\seedu\taskmanager\ui\DeadlineTaskListPanel.java
``` java
    /**
     * @param taskList
     * @return ObserableList containing only deadline tasks with their respective index from original list
     */
    private ObservableList<Pair<ReadOnlyTask, Integer>> extractDeadlineTasks(ObservableList<ReadOnlyTask> taskList) {
        ObservableList<Pair<ReadOnlyTask, Integer>> deadlineTaskList = FXCollections.observableArrayList();
        for (int index = 0; taskList.size() != index; index++) {
            ReadOnlyTask taskToDelete = taskList.get(index);
            if (taskToDelete.isDeadlineTask()) {
                Pair<ReadOnlyTask, Integer> deadlineTask = new Pair<ReadOnlyTask, Integer>(taskToDelete, index);
                deadlineTaskList.add(deadlineTask);
            }
        }
        return deadlineTaskList;
    }
}
```
###### \java\seedu\taskmanager\ui\EventTaskCard.java
``` java
public class EventTaskCard extends UiPart<Region> {

    private static final String FXML = "EventTaskCard.fxml";

    @FXML
    private HBox cardPane;
    @FXML
    private Label taskname;
    @FXML
    private Label id;
    @FXML
    private Label startDateTime;
    @FXML
    private Label endDateTime;
    @FXML
    private Label markedCompleted;
    @FXML
    private FlowPane categories;

    private final StringProperty empty = new SimpleStringProperty("");
    private final StringProperty completed = new SimpleStringProperty("Completed");

    public EventTaskCard(ReadOnlyTask task, int displayedIndex) {
        super(FXML);
        taskname.setText(task.getTaskName().fullTaskName);
        id.setText(displayedIndex + ". ");

        if (isMultipleDateEvent(task)) {
            setMultipleDateEventTaskDetails(task);
        }

        if (isSameDateEvent(task)) {
            setSameDateEventTaskDetails(task);
        }

        setMarkedCompletedLabel(task);
        initCategory(task);
    }

    /**
     * @param task
     */
    private void setMarkedCompletedLabel(ReadOnlyTask task) {
        if (task.getIsMarkedAsComplete()) {
            markedCompleted.textProperty().bind(completed);
        } else {
            markedCompleted.textProperty().bind(empty);
        }
    }

    /**
     * @param task
     */
    private void setSameDateEventTaskDetails(ReadOnlyTask task) {
        startDateTime.setText("Date: " + task.getStartDate().value);
        endDateTime
                .setText("Start Time: " + task.getStartTime().value + "   " + "End Time: " + task.getEndTime().value);
    }

    /**
     * @param task
     */
    private void setMultipleDateEventTaskDetails(ReadOnlyTask task) {
        startDateTime.setText(
                "Start Date: " + task.getStartDate().value + "   " + "Start Time: " + task.getStartTime().value);
        endDateTime.setText(
                "End Date: " + "  " + task.getEndDate().value + "   " + "End Time: " + "  " + task.getEndTime().value);
    }

    private boolean isMultipleDateEvent(ReadOnlyTask task) {
        return (!task.getStartDate().value.equals(task.getEndDate().value)
                && !task.getStartDate().value.equals("EMPTY_FIELD"));
    }

    private boolean isSameDateEvent(ReadOnlyTask task) {
        return ((task.getStartDate().value).equals(task.getEndDate().value)
                && (!task.getStartDate().value.equals("EMPTY_FIELD")));
    }

    private void initCategory(ReadOnlyTask task) {
        if (!task.getCategories().asObservableList().isEmpty()) {
            for (int index = 0; task.getCategories().asObservableList().size() != index; index++) {
                Label label = stylePriorityCategories(task, index);

                categories.getChildren().add(label);
            }
        }
    }

    /**
     * @param task
     * @param index
     * @return
     */
    private Label stylePriorityCategories(ReadOnlyTask task, int index) {
        String category = task.getCategories().asObservableList().get(index).categoryName;
        Label label = new Label(category);
        if (category.equalsIgnoreCase("High")) {
            label.setStyle("-fx-background-color: red");
        }
        if (category.equalsIgnoreCase("Medium")) {
            label.setStyle("-fx-background-color: orange");
        }
        if (category.equalsIgnoreCase("Low")) {
            label.setStyle("-fx-background-color: lightblue");
        }
        return label;
    }
}
```
###### \java\seedu\taskmanager\ui\EventTaskListPanel.java
``` java
    public void setConnections(ObservableList<ReadOnlyTask> taskList) {
        ObservableList<ReadOnlyTask> eventTaskList = extractEventTasks(taskList);
        eventTaskListView.setItems(eventTaskList);
        eventTaskListView.setCellFactory(listView -> new TaskListViewCell());
        setEventHandlerForSelectionChangeEvent();
    }

    private void addToPlaceholder(AnchorPane placeHolderPane) {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        FxViewUtil.applyAnchorBoundaryParameters(getRoot(), 0.0, 0.0, 0.0, 0.0);
        placeHolderPane.getChildren().add(getRoot());
    }

    private void setEventHandlerForSelectionChangeEvent() {
        eventTaskListView.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue != null) {
                logger.fine("Selection in task list panel changed to : '" + newValue + "'");
                raise(new TaskPanelSelectionChangedEvent(newValue));
            }
        });
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            eventTaskListView.scrollTo(index);
            eventTaskListView.getSelectionModel().clearAndSelect(index);
        });
    }

    public ListView<ReadOnlyTask> getEventTaskListView() {
        return this.eventTaskListView;
    }

    class TaskListViewCell extends ListCell<ReadOnlyTask> {

        @Override
        protected void updateItem(ReadOnlyTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(new EventTaskCard(task, getIndex() + 1).getRoot());
            }
        }
    }

```
###### \java\seedu\taskmanager\ui\EventTaskListPanel.java
``` java
    /**
     * @param taskList
     * @return ObserableList containing only event tasks
     */
    private ObservableList<ReadOnlyTask> extractEventTasks(ObservableList<ReadOnlyTask> taskList) {
        ObservableList<ReadOnlyTask> eventTaskList = FXCollections.<ReadOnlyTask>observableArrayList(taskList);
        for (int index = 0; eventTaskList.size() != index; index++) {
            ReadOnlyTask taskToDelete = eventTaskList.get(index);
            if (!taskToDelete.isEventTask()) {
                eventTaskList.remove(index, index + 1);
                index--;
            }
        }
        return eventTaskList;
    }
}
```
###### \java\seedu\taskmanager\ui\FloatingTaskCard.java
``` java
public class FloatingTaskCard extends UiPart<Region> {

    private static final String FXML = "FloatingTaskCard.fxml";

    @FXML
    private HBox cardPane;
    @FXML
    private Label taskname;
    @FXML
    private Label id;
    @FXML
    private Label markedCompleted;
    @FXML
    private FlowPane categories;

    private final StringProperty empty = new SimpleStringProperty("");
    private final StringProperty completed = new SimpleStringProperty("Completed");

    public FloatingTaskCard(ReadOnlyTask task, int displayedIndex) {
        super(FXML);
        taskname.setText(task.getTaskName().fullTaskName);
        id.setText(displayedIndex + ". ");

        setMarkedCompletedLabel(task);
        initCategory(task);
    }

    /**
     * @param task
     */
    private void setMarkedCompletedLabel(ReadOnlyTask task) {
        if (task.getIsMarkedAsComplete()) {
            markedCompleted.textProperty().bind(completed);
        } else {
            markedCompleted.textProperty().bind(empty);
        }
    }

    private void initCategory(ReadOnlyTask task) {
        if (!task.getCategories().asObservableList().isEmpty()) {
            for (int index = 0; task.getCategories().asObservableList().size() != index; index++) {
                Label label = stylePriorityCategories(task, index);

                categories.getChildren().add(label);
            }
        }
    }

    /**
     * @param task
     * @param index
     * @return
     */
    private Label stylePriorityCategories(ReadOnlyTask task, int index) {
        String category = task.getCategories().asObservableList().get(index).categoryName;
        Label label = new Label(category);
        if (category.equalsIgnoreCase("High")) {
            label.setStyle("-fx-background-color: red");
        }
        if (category.equalsIgnoreCase("Medium")) {
            label.setStyle("-fx-background-color: orange");
        }
        if (category.equalsIgnoreCase("Low")) {
            label.setStyle("-fx-background-color: lightblue");
        }
        return label;
    }
}
```
###### \java\seedu\taskmanager\ui\FloatingTaskListPanel.java
``` java
    public void setConnections(ObservableList<ReadOnlyTask> taskList) {
        ObservableList<Pair<ReadOnlyTask, Integer>> floatingTaskList = extractFloatingTasks(taskList);
        floatingTaskListView.setItems(floatingTaskList);
        floatingTaskListView.setCellFactory(listView -> new TaskListViewCell());
        setEventHandlerForSelectionChangeEvent();
    }

    private void addToPlaceholder(AnchorPane placeHolderPane) {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        FxViewUtil.applyAnchorBoundaryParameters(getRoot(), 0.0, 0.0, 0.0, 0.0);
        placeHolderPane.getChildren().add(getRoot());
    }

    private void setEventHandlerForSelectionChangeEvent() {
        floatingTaskListView.getSelectionModel().selectedItemProperty()
                .addListener((observable, oldValue, newValue) -> {
                    if (newValue != null) {
                        logger.fine("Selection in task list panel changed to : '" + newValue + "'");
                        raise(new TaskPanelSelectionChangedEvent(newValue.getKey()));
                    }
                });
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            floatingTaskListView.scrollTo(index);
            floatingTaskListView.getSelectionModel().clearAndSelect(index);
        });
    }

    class TaskListViewCell extends ListCell<Pair<ReadOnlyTask, Integer>> {

        @Override
        protected void updateItem(Pair<ReadOnlyTask, Integer> task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {

                setGraphic(new FloatingTaskCard(task.getKey(), task.getValue() + 1).getRoot());
            }
        }
    }

    public ListView<Pair<ReadOnlyTask, Integer>> getFloatingTaskListView() {
        return this.floatingTaskListView;
    }

```
###### \java\seedu\taskmanager\ui\FloatingTaskListPanel.java
``` java
    /**
     * @param taskList
     * @return ObserableList containing only floating tasks with their respective index from original list
     */
    private ObservableList<Pair<ReadOnlyTask, Integer>> extractFloatingTasks(ObservableList<ReadOnlyTask> taskList) {
        ObservableList<Pair<ReadOnlyTask, Integer>> floatingTaskList = FXCollections.observableArrayList();
        for (int index = 0; taskList.size() != index; index++) {
            ReadOnlyTask taskToDelete = taskList.get(index);
            if (taskToDelete.isFloatingTask()) {
                Pair<ReadOnlyTask, Integer> floatingTask = new Pair<ReadOnlyTask, Integer>(taskToDelete, index);
                floatingTaskList.add(floatingTask);
            }
        }
        return floatingTaskList;
    }
}
```
