# A0143076J
###### \java\seedu\watodo\logic\commands\AddCommand.java
``` java
    /**
     * Creates an AddCommand using raw values and create a new Task according to the taskType
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String description, String startDate, String endDate, Set<String> tags, TaskType taskType)
            throws IllegalValueException {

        assert description != null;
        assert taskType.equals(TaskType.FLOAT) || taskType.equals(TaskType.DEADLINE) || taskType.equals(TaskType.EVENT);

        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }

        switch (taskType) {
        case FLOAT:
            this.toAdd = new Task(new Description(description), new UniqueTagList(tagSet));
            break;
        case DEADLINE:
            this.toAdd = new Task(new Description(description), new DateTime(endDate),
                    new UniqueTagList(tagSet));
            break;
        case EVENT:
            DateTime start = new DateTime(startDate);
            DateTime end = new DateTime(endDate);
            if (start.isLater(end)) { //checks if the end time is later than start time
                throw new IllegalValueException("End date must be later than start date!");
            }
            this.toAdd = new Task(new Description(description), start, end, new UniqueTagList(tagSet));
            break;
        }
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            this.undoAdd = new Task(toAdd);
            model.addTask(toAdd);
            System.out.println(undoAdd);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
    }

```
###### \java\seedu\watodo\logic\commands\AlternativeCommand.java
``` java
/**
 * Stores a map of alternatives command words, and their corresponding default
 * command word. Also stores a list of all the default command words of Watodo.
 */
public class AlternativeCommand {

    public static final Set<String> COMMANDS_WORDS = new HashSet<String>() {
        {
            add(AddCommand.COMMAND_WORD);
            add(ClearCommand.COMMAND_WORD);
            add(DeleteCommand.COMMAND_WORD);
            add(EditCommand.COMMAND_WORD);
            add(ExitCommand.COMMAND_WORD);
            add(FindCommand.COMMAND_WORD);
            add(HelpCommand.COMMAND_WORD);
            add(ListAllCommand.COMMAND_WORD);
            add(ListCommand.COMMAND_WORD);
            add(ListDayCommand.COMMAND_WORD);
            add(ListDeadlineCommand.COMMAND_WORD);
            add(ListDoneCommand.COMMAND_WORD);
            add(ListEventCommand.COMMAND_WORD);
            add(ListFloatCommand.COMMAND_WORD);
            add(ListMonthCommand.COMMAND_WORD);
            add(MarkCommand.COMMAND_WORD);
            add(UnmarkCommand.COMMAND_WORD);
            add(ShortcutCommand.COMMAND_WORD);
        }
    };
    public static HashMap<String, String> altCommands = new HashMap<String, String>() {
        {
            put("a", AddCommand.COMMAND_WORD);
            put("e", EditCommand.COMMAND_WORD);
            put("d", DeleteCommand.COMMAND_WORD);
            put("del", DeleteCommand.COMMAND_WORD);
            put("l", ListCommand.COMMAND_WORD);
            put("m", MarkCommand.COMMAND_WORD);
            put("check", MarkCommand.COMMAND_WORD);
            put("um", UnmarkCommand.COMMAND_WORD);
            put("uncheck", MarkCommand.COMMAND_WORD);
            put("f", FindCommand.COMMAND_WORD);
            put("search", FindCommand.COMMAND_WORD);
            // put("r", RedoCommand.COMMAND_WORD);
            // put("u", UndoCommand.COMMAND_WORD);
        }
    };

    /** Returns true if the given commandWord is an alternative command word. */
    public static boolean containsAlternative(String commandWord) {
        return altCommands.containsKey(commandWord);
    }

    /** Returns the standard CommandWord for the given alternative word. */
    public static String getStandardCommandWord(String commandWord) {
        return altCommands.get(commandWord);
    }

    /** Adds a new alternativeCommand format to the hashMap */
    public static void addAlternative(String shortcutKey, String commandWord) {
        altCommands.put(shortcutKey, commandWord);
    }

    /** Deletes the given shortcut key only if its corresponding standard commandWord matches what is given */
    public static boolean deleteAlternative(String shortcutKey, String commandWord) {
        return altCommands.remove(shortcutKey, commandWord);
    }
}
```
###### \java\seedu\watodo\logic\commands\ShortcutCommand.java
``` java
/**
 * Manages (adds or deletes) shortcut commands that the user can use
 * to execute one of the default commands to allow for customization of Watodo by the user.
 */
public class ShortcutCommand extends Command {

    private String operation;
    private String commandWord;
    private String shortcutKey;

    private final String SHORTCUT_ADD_OPERATION = "+";
    private final String SHORTCUT_DEL_OPERATION = "-";

    public static final String COMMAND_WORD = "shortcut";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds or removes a shortcut key to one of the "
            + "standard functionalities of the task manager. "
            + "Parameters: <+><-> COMMAND_WORD SHORTCUT_KEY" + "Example: "
            + COMMAND_WORD + " + add a/";

    public static final String MESSAGE_SUCCESS_ADDED = "New shortcut key added: %1$s";
    public static final String MESSAGE_SUCCESSS_DELETED = "Existing shortcut key deleted: %1$s";
    public static final String MESSAGE_DUPLICATE_SHORTCUT_KEY = "This shortcut key already exists!";
    public static final String MESSAGE_DELETE_INVALID_SHORTCUT_KEY = "This shortcut key does not exists!";

    /**
     * Constructs a Shortcut command object from the given args. Checks that the args are valid.
     */
    public ShortcutCommand(String operation, String commandWord, String shortcutKey) throws IllegalValueException {
        if  (!isArgsValid(operation, commandWord)) {
            throw new IllegalValueException(MESSAGE_USAGE);
        }
        this.operation = operation;
        this.commandWord = commandWord;
        this.shortcutKey = shortcutKey;
    }

    /**
     * Returns true only if the commandWord is one of the standard commandWords supported from the user guide
     * AND the operation is either '+' (add) or '-' (delete)
     */
    private boolean isArgsValid(String operation, String commandWord) {
        return (operation.equals(SHORTCUT_ADD_OPERATION) || operation.equals(SHORTCUT_DEL_OPERATION)) &&
               AlternativeCommand.COMMANDS_WORDS.contains(commandWord);
    }

    @Override
    public CommandResult execute() throws CommandException {
        if (operation.equals(SHORTCUT_ADD_OPERATION)) {
            return executeAdd();
        } else {
            return executeDel();
        }
    }

    private CommandResult executeAdd() throws CommandException {
        if (AlternativeCommand.containsAlternative(shortcutKey)) {
            throw new CommandException(MESSAGE_DUPLICATE_SHORTCUT_KEY);
        }
        AlternativeCommand.addAlternative(shortcutKey, commandWord);
        return new CommandResult(String.format(MESSAGE_SUCCESS_ADDED, shortcutKey + "->" + commandWord));
    }

    private CommandResult executeDel() throws CommandException {
        if (!AlternativeCommand.containsAlternative(shortcutKey)) {
            throw new CommandException(MESSAGE_DELETE_INVALID_SHORTCUT_KEY);
        }
        if (!AlternativeCommand.deleteAlternative(shortcutKey, commandWord)) { //shortcut key exists but is mapped to
                                                                     //a comandWord different from that given by user
            throw new CommandException(MESSAGE_DELETE_INVALID_SHORTCUT_KEY);
        }
        return new CommandResult(String.format(MESSAGE_SUCCESSS_DELETED, shortcutKey + "->" + commandWord));
    }

}

```
###### \java\seedu\watodo\logic\parser\AddCommandParser.java
``` java
/**
 * Parses input arguments and creates a new AddCommand object
 */
public class AddCommandParser {

    private DateTimeParser dateTimeParser;
    private String description;
    private Set<String> tags;

    public static final String EXTRACT_ARGS_REGEX = "\\s*" + "%1$s" + "\\s*" + "%2$s" + "\\s*";

    /** Creates an AddCommandParser object that creates a new dateTimeParser object to parse date args */
    public AddCommandParser() {
        dateTimeParser = new DateTimeParser();
        tags = new HashSet<String>();
    }

    /**
     * Parses the given {@code String} of arguments in the context of the
     * AddCommand and returns an AddCommand object for execution.
     */
    public Command parse(String args) {
        try {
            dateTimeParser.parse(args);
            String argsWithDatesExtracted = dateTimeParser.trimArgsOfDates(args);

            extractTags(argsWithDatesExtracted);
            String argsWithDatesAndTagsExtracted = trimArgsOfTags(argsWithDatesExtracted);
            description = argsWithDatesAndTagsExtracted;

            return new AddCommand(description, dateTimeParser.getStartDate(), dateTimeParser.getEndDate(),
                                  tags, dateTimeParser.getTaskType());
        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }

    }

    /**
     * Finds all instances of the PREFIX_TAG in the given arg and returns a set of all the tags
     */
    private void extractTags(String argsWithDatesExtracted) {
        ArgumentTokenizer tagsTokenizer = new ArgumentTokenizer(PREFIX_TAG);
        tagsTokenizer.tokenize(argsWithDatesExtracted);
        if (tagsTokenizer.getAllValues(PREFIX_TAG).isPresent()) {
            List<String> tags = tagsTokenizer.getAllValues(PREFIX_TAG).get();
            List<String> parsedTags = new ArrayList<String>();
            for (String tag : tags) {
                parsedTags.add(tag.split("[\\s+]", 2)[0]);  //tag name is only until the first whitespace
            }
            this.tags = ParserUtil.toSet(Optional.of(parsedTags));
        }
    }

    /**
     * Removes all instances of the PREFIX_TAG and the corresponding tag name in the arg
     * to return the resulting task description
     */
    private String trimArgsOfTags(String args) {
        String tagArgs = String.format(EXTRACT_ARGS_REGEX, PREFIX_TAG.getPrefix() + "(\\S+)", "");
        return args.replaceAll(tagArgs, " ").trim();  //to remove excess whitespace
    }

}
```
###### \java\seedu\watodo\logic\parser\DateTimeParser.java
``` java
/**
 * Parses out the startDate and endDate, if any, in a given String of args
 */
public class DateTimeParser {

    public enum TaskType { FLOAT, DEADLINE, EVENT };
    private TaskType type;

    private String startDate;
    private String endDate;

    public static final String MESSAGE_INVALID_NUM_DATETIME = "Too many/few dateTime arguments!";

    /** Constructs a DateTimeParser object with both default start and end date-times null */
    public DateTimeParser() {
        startDate = null;
        endDate = null;
    }

    /**
     * Determines if the combination of dateTime prefixes are valid, and if so, extracts out the
     * startDate and endDate if they exist
     */
    public void parse(String args) throws IllegalValueException {
        ArgumentTokenizer datesTokenizer = new ArgumentTokenizer(PREFIX_BY, PREFIX_ON,
                PREFIX_FROM, PREFIX_TO);
        datesTokenizer.tokenize(args);

        type = checkTaskType(datesTokenizer);

        if (type.equals(TaskType.DEADLINE) || type.equals(TaskType.EVENT)) {
            extractDates(datesTokenizer);
        }
    }

    /**
     * Returns the arg with the dateTime prefixes and dates removed
     */
    public String trimArgsOfDates(String arg) {

        if (startDate != null) {
            arg = arg.replaceAll(String.format(EXTRACT_ARGS_REGEX, PREFIX_FROM.getPrefix(), startDate), " ");
            arg = arg.replaceAll(String.format(EXTRACT_ARGS_REGEX, PREFIX_ON.getPrefix(), startDate), " ");
        }
        if (endDate != null) {
            arg = arg.replaceAll(String.format(EXTRACT_ARGS_REGEX, PREFIX_BY.getPrefix(), endDate), " ");
            arg = arg.replaceAll(String.format(EXTRACT_ARGS_REGEX, PREFIX_ON.getPrefix(), endDate), " ");
            arg = arg.replaceAll(String.format(EXTRACT_ARGS_REGEX, PREFIX_TO.getPrefix(), endDate), " ");
        }
        return arg.trim();
    }


    /**
     * Checks the type of task(floating, deadline or event) to be added based on
     * the dateTime prefixes entered by the user.
     *
     * @throws IllegalValueException if the combination of dateTime prefixes is not recognized             entered
     */
    private TaskType checkTaskType(ArgumentTokenizer datesTokenizer) throws IllegalValueException {

        boolean hasBy = datesTokenizer.getUniqueValue(PREFIX_BY).isPresent();
        boolean hasOn = datesTokenizer.getUniqueValue(PREFIX_ON).isPresent();
        boolean hasFrom = datesTokenizer.getUniqueValue(PREFIX_FROM).isPresent();
        boolean hasTo = datesTokenizer.getUniqueValue(PREFIX_TO).isPresent();

        if (!hasBy && !hasOn && !hasFrom && !hasTo) {
            return TaskType.FLOAT;
        }
        if ((hasBy && !hasOn && !hasFrom && !hasTo) || (!hasBy && hasOn && !hasFrom && !hasTo)) {
            return TaskType.DEADLINE;
        }
        if ((!hasBy && !hasOn && hasFrom && hasTo) || (!hasBy && hasOn && !hasFrom && hasTo)) {
            return TaskType.EVENT;
        }
        throw new IllegalValueException(MESSAGE_INVALID_NUM_DATETIME);
    }

    /**
     * Reads and validates the dates following the dateTime prefix and stores it as startDate
     * or endDate accordingly
     *
     * @throws IllegalValueException if the dates format are invalid
     */
    private void extractDates(ArgumentTokenizer datesTokenizer) throws IllegalValueException {

        List<String> argsWithDate = new ArrayList<String>();
        Collections.addAll(argsWithDate, datesTokenizer.getUniqueValue(PREFIX_BY).orElse(null),
            datesTokenizer.getUniqueValue(PREFIX_ON).orElse(null),
            datesTokenizer.getUniqueValue(PREFIX_FROM).orElse(null),
            datesTokenizer.getUniqueValue(PREFIX_TO).orElse(null));

        Parser parser = new Parser();
        List<String> datesInText = new ArrayList<String>();

        for (String arg : argsWithDate) {
            if (arg != null) {
                List<DateGroup> dateGroups = parser.parse(arg.trim());
                if (dateGroups.size() == 0 || dateGroups.get(0).getPosition() != 1) {
                    throw new IllegalValueException(DateTime.MESSAGE_DATETIME_CONSTRAINTS);
                }
                datesInText.add(dateGroups.get(0).getText().trim());
            }
        }

        if (datesInText.size() == 1) {
            endDate = datesInText.get(0);
        }
        if (datesInText.size() == 2) {
            startDate = datesInText.get(0);
            endDate = datesInText.get(1);
        }
    }

    public TaskType getTaskType() {
        return type;
    }
    public String getStartDate() {
        return startDate;
    }
    public String getEndDate() {
        return endDate;
    }

}
```
###### \java\seedu\watodo\logic\parser\EditCommandParser.java
``` java
    /**
     * Parses the given {@code String} of arguments in the context of the
     * EditCommand and returns an EditCommand object for execution.
     *
     * @throws IllegalValueException
     */
    public Command parse(String args) throws IllegalValueException {
        assert args != null;
        boolean hasEditDate = false;
        boolean hasRemoveDate = false;
        EditTaskDescriptor editTaskDescriptor = new EditTaskDescriptor();

        // get index of the task to edit
        Optional<Integer> index = ParserUtil.parseIndex(args.split(" ", 2)[0]);
        args = args.split(" ", 2)[1];
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        //check if user wants to remove dates of task
        if (args.equals("REMOVEDATES")) {
            hasRemoveDate = true;
            return new EditCommand(index.get(), editTaskDescriptor, hasEditDate, hasRemoveDate);
        }

        try {
            // get any dates arguments entered by the user
            DateTimeParser dateTimeParser = new DateTimeParser();
            dateTimeParser.parse(args);
            String argsWithDatesExtracted = dateTimeParser.trimArgsOfDates(args);
            if (dateTimeParser.getStartDate() != null || dateTimeParser.getEndDate() != null) {
                hasEditDate = true;
                if (dateTimeParser.getStartDate() != null) {
                    editTaskDescriptor.setStartDate(Optional.of(new DateTime(dateTimeParser.getStartDate())));
                }
                editTaskDescriptor.setEndDate(Optional.of(new DateTime(dateTimeParser.getEndDate())));
            }

            // get any tags arguments entered by the user
            ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_TAG);
            argsTokenizer.tokenize(argsWithDatesExtracted);
            if (argsTokenizer.getAllValues(PREFIX_TAG).isPresent()) {
                List<String> tags = argsTokenizer.getAllValues(PREFIX_TAG).get();
                List<String> parsedTags = new ArrayList<String>();
                for (String tag : tags) {
                    parsedTags.add(tag.split("[\\s+]", 2)[0]);  //tag name is only until the first whitespace
                }
                editTaskDescriptor.setTags(parseTagsForEdit(ParserUtil.toSet(Optional.of(parsedTags))));
            }

            //get any new task description entered by the user
            String tagArgs = String.format(AddCommandParser.EXTRACT_ARGS_REGEX, PREFIX_TAG.getPrefix() + "(\\S+)", "");
            Optional<String> description;
            String argsWithDatesAndTagsExtracted = argsWithDatesExtracted.replaceAll(tagArgs, " ").trim();
            if (argsWithDatesAndTagsExtracted.equals("")) {
                description = Optional.empty();
            } else {
                description = Optional.of(argsWithDatesAndTagsExtracted);
            }
            editTaskDescriptor.setTaskName(ParserUtil.parseDescription(description));

            if (!editTaskDescriptor.isAnyFieldEdited()) {
                return new IncorrectCommand(EditCommand.MESSAGE_NOT_EDITED);
            }
            return new EditCommand(index.get(), editTaskDescriptor, hasEditDate, hasRemoveDate);

        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }

    }

    /**
     * Parses {@code Collection<String> tags} into an
     * {@code Optional<UniqueTagList>} if {@code tags} is non-empty. If
     * {@code tags} contain only one element which is an empty string, it will
     * be parsed into a {@code Optional<UniqueTagList>} containing zero tags.
     */
    private Optional<UniqueTagList> parseTagsForEdit(Collection<String> tags) throws IllegalValueException {
        assert tags != null;

        if (tags.isEmpty()) {
            return Optional.empty();
        }
        Collection<String> tagSet = tags.size() == 1 && tags.contains("") ? Collections.emptySet() : tags;
        return Optional.of(ParserUtil.parseTags(tagSet));
    }
}
```
###### \java\seedu\watodo\logic\parser\ShortcutCommandParser.java
``` java
/**
 * Parses input arguments and creates a new ShortcutCommand object
 */
public class ShortcutCommandParser {

    private final Pattern SHORTCUT_ARGS_REGEX =
            Pattern.compile("(?<Operation>\\S)(\\s+)(?<CommandWord>\\S+)(\\s+)(?<ShortcutKey>\\S+)");

    /**
     * Parses the given {@code String} of arguments in the context of the ShortcutCommand
     * and returns an ShortcutCommand object for execution.
     */
    public Command parse(String args) {
        try {
            final Matcher matcher = SHORTCUT_ARGS_REGEX.matcher(args.trim());
            if (!matcher.matches()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                        ShortcutCommand.MESSAGE_USAGE));
            }
            return new ShortcutCommand(matcher.group("Operation"), matcher.group("CommandWord"),
                    matcher.group("ShortcutKey"));
        } catch (IllegalValueException e) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, e.getMessage()));
        }
    }

}
```
###### \java\seedu\watodo\model\task\DateTime.java
``` java
/**
 * Represents a Task's start time, end time or deadline in the task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidDateTime(String)}
 */
public class DateTime {

    public static final String MESSAGE_DATETIME_CONSTRAINTS = "Date and time format must be a date/day, time or both";
    public static final Parser DATE_TIME_PARSER = new Parser(TimeZone.getDefault());

    public final Date dateTime;

    /**
     * Validates given DateTime.
     *
     * @throws IllegalValueException if given dateTime string is invalid.
     */
    public DateTime(String dateTime) throws IllegalValueException {
        assert dateTime != null;
        String trimmedDateTime = dateTime.trim();
        if (!isValidDateTime(trimmedDateTime)) {
            throw new IllegalValueException(MESSAGE_DATETIME_CONSTRAINTS);
        }
        this.dateTime = convertToDateFormat(trimmedDateTime);
    }

    /**
     * Returns true if a given string is a valid date time.
     */
    public static boolean isValidDateTime(String dateTime) {
        List<DateGroup> parsedDateGroups = DATE_TIME_PARSER.parse(dateTime);
        return parsedDateGroups.size() == 1 && !parsedDateGroups.get(0).getDates().isEmpty();
    }

    /**
     * Converts the given string into a standard Date format of year, month, date, hour, minutes and seconds.
     * Precondition: the String dateTime has already been checked to be valid
     */
    private Date convertToDateFormat(String dateTime) {
        List<DateGroup> parsedDateGroups = DATE_TIME_PARSER.parse(dateTime);
        return parsedDateGroups.get(0).getDates().get(0);
    }

    /* Checks if the current DateTime is at a later date than another given DateTime */
    public boolean isLater(DateTime other) {
        return this.dateTime.after(other.dateTime);
    }

    @Override
    public String toString() {
        return dateTime.toString();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DateTime // instanceof handles nulls
                && this.dateTime.equals(((DateTime) other).dateTime)); // state check
    }

    @Override
    public int hashCode() {
        return dateTime.hashCode();
    }

}
```
