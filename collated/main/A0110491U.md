# A0110491U
###### /java/seedu/whatsleft/commons/events/ui/JumpToCalendarTaskEvent.java
``` java
    public boolean canJumpTo() {
        return (this.targetTask.getByDate().value != null && this.targetTask.getByTime().value != null);
    }

```
###### /java/seedu/whatsleft/commons/util/DateTimeNLUtil.java
``` java
/**
 * This class is a Date-Time Natural Language Utility class that supports the natural language processing
 * for the date attributes implemented by the Events and Tasks classes. Natural Language for this is defined
 * as any String that does not fully contain digits. e.g. {"\\d+"} will not be considered natural language
 *
 */
public class DateTimeNLUtil {

    public static final String MESSAGE_DATELANG_CONSTRAINTS = "natural language function only supports"
            + "modifiers like next, following as well as relative days like today, tmr as well as absolute"
            + "days like mon, tue, wed, thu, fri, sat, sun";
    LocalDate today;
    EnumMap<Modifier, Integer> modmap = new EnumMap<Modifier, Integer>(Modifier.class);
    EnumMap<RelativeDay, Integer> relativedaymap = new EnumMap<RelativeDay, Integer>(RelativeDay.class);
    EnumMap<AbsDay, String> absdaymap = new EnumMap<AbsDay, String>(AbsDay.class);

    enum Modifier {
        next, following
    }

    enum RelativeDay {
        today, tmr, tomorrow
    }

    enum AbsDay {
        mon, tue, wed, thu, fri, sat, sun, monday, tuesday, wednesday, thursday, friday, saturday,
        sunday, tues, weds, thurs
    }

    /**
     * Constructor sets up the default values in the EnumMaps for instance of this class
     */
    public DateTimeNLUtil() {
        today = LocalDate.now();
        modmap.put(Modifier.next, 1);
        modmap.put(Modifier.following, 2);
        relativedaymap.put(RelativeDay.today, 0);
        relativedaymap.put(RelativeDay.tmr, 1);
        relativedaymap.put(RelativeDay.tomorrow, 1);
        absdaymap.put(AbsDay.mon, "MONDAY");
        absdaymap.put(AbsDay.tue, "TUESDAY");
        absdaymap.put(AbsDay.wed, "WEDNESDAY");
        absdaymap.put(AbsDay.thu, "THURSDAY");
        absdaymap.put(AbsDay.fri, "FRIDAY");
        absdaymap.put(AbsDay.sat, "SATURDAY");
        absdaymap.put(AbsDay.sun, "SUNDAY");
        absdaymap.put(AbsDay.monday, "MONDAY");
        absdaymap.put(AbsDay.tuesday, "TUESDAY");
        absdaymap.put(AbsDay.wednesday, "WEDNESDAY");
        absdaymap.put(AbsDay.thursday, "THURSDAY");
        absdaymap.put(AbsDay.friday, "FRIDAY");
        absdaymap.put(AbsDay.saturday, "SATURDAY");
        absdaymap.put(AbsDay.sunday, "SUNDAY");
        absdaymap.put(AbsDay.tues, "TUESDAY");
        absdaymap.put(AbsDay.weds, "WEDNESDAY");
        absdaymap.put(AbsDay.thurs, "THURSDAY");
    }

```
###### /java/seedu/whatsleft/commons/util/DateTimeNLUtil.java
``` java
    /**
     * This method takes in a natural language String argument, and processes it to determine
     * if it has the required format to be converted to a date in String (DDMMYY)
     * @return 6 digit String in the format (DDMMYY)
     * @throws IllegalNLException if the natural language
     */
    public String getDate(String arg) throws IllegalNLException {
        arg = arg.toLowerCase();
        String[] args = arg.split(" ");
        if (args.length == 1) {
            if (isARelativeDay(args[0])) {
                int relative = relativedaymap.get(getRelativeEnum(args[0]));
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern("ddMMyy");
                String date = today.plusDays(relative).format(formatter);
                return date;
            } else if (isAnAbsDay(args[0])) {
                String day = absdaymap.get(getAbsDay(args[0]));
                DayOfWeek targetdow = DayOfWeek.valueOf(day);
                DayOfWeek currdow = today.getDayOfWeek();
                int daysleft = 0;
                while (targetdow != currdow) {
                    daysleft++;
                    currdow = currdow.plus(1);
                }
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern("ddMMyy");
                String date = today.plusDays(daysleft).format(formatter);
                return date;
            }
        } else if (args.length == 2) {
            if (isAModifier(args[0]) && isAnAbsDay(args[1])) {
                int mod = modmap.get(getModifier(args[0]));
                String day = absdaymap.get(getAbsDay(args[1]));
                DayOfWeek targetdow = DayOfWeek.valueOf(day);
                DayOfWeek currdow = today.getDayOfWeek();
                int daysleft = 0;
                while (targetdow != currdow) {
                    daysleft++;
                    currdow = currdow.plus(1);
                }
                daysleft = daysleft + (mod * 7);
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern("ddMMyy");
                String date = today.plusDays(daysleft).format(formatter);
                return date;
            }
        } else {
            throw new IllegalNLException(MESSAGE_DATELANG_CONSTRAINTS);
        }
        return null;
    }

```
###### /java/seedu/whatsleft/commons/util/DateTimeNLUtil.java
``` java
    /**
     * Determines if this String argument is in the RelativeDay Enum
     */
    public static boolean isARelativeDay(String arg) {
        for (RelativeDay each : RelativeDay.values()) {
            if (each.name().equals(arg)) {
                return true;
            }
        }
        return false;
    }

```
###### /java/seedu/whatsleft/commons/util/DateTimeNLUtil.java
``` java
    /**
     * returns the Enum value in RelativeDay Enum that matches the given String argument
     */
    public static RelativeDay getRelativeEnum(String arg) {
        for (RelativeDay each : RelativeDay.values()) {
            if (each.name().equals(arg)) {
                return each;
            }
        }
        return null;
    }

```
###### /java/seedu/whatsleft/commons/util/DateTimeNLUtil.java
``` java
    /**
     * Determines if this String argument is in the AbsDay Enum
     */
    public static boolean isAnAbsDay(String arg) {
        for (AbsDay day : AbsDay.values()) {
            if (day.name().equals(arg)) {
                return true;
            }
        }
        return false;
    }

```
###### /java/seedu/whatsleft/commons/util/DateTimeNLUtil.java
``` java
    /**
     * returns the Enum value in AbsDay Enum that matches the given String argument
     */
    public static AbsDay getAbsDay(String arg) {
        for (AbsDay day : AbsDay.values()) {
            if (day.name().equals(arg)) {
                return day;
            }
        }
        return null;
    }

```
###### /java/seedu/whatsleft/commons/util/DateTimeNLUtil.java
``` java
    /**
     * Determines if this String argument is in the Modifier Enum
     */
    public static boolean isAModifier(String arg) {
        for (Modifier mod : Modifier.values()) {
            if (mod.name().equals(arg)) {
                return true;
            }
        }
        return false;
    }

```
###### /java/seedu/whatsleft/commons/util/DateTimeNLUtil.java
``` java
    /**
     * returns the Enum value in Modifier Enum that matches the given String argument
     */
    public static Modifier getModifier(String arg) {
        for (Modifier mod : Modifier.values()) {
            if (mod.name().equals(arg)) {
                return mod;
            }
        }
        return null;
    }

```
###### /java/seedu/whatsleft/commons/util/DateTimeNLUtil.java
``` java
    /**
     * Represents the IllegalValueException for a Natural Language that was parsed
     *
     */
    public class IllegalNLException extends IllegalValueException {

        public IllegalNLException(String message) {
            super(message);
        }

    }
}
```
###### /java/seedu/whatsleft/commons/util/StringUtil.java
``` java
    /**
     * returns today's date in DDMMYY format in string
     */
    public static String getTodayDateInString() {
        String todaydate = new SimpleDateFormat("ddMMyy").format(new Date());
        return todaydate;
    }
```
###### /java/seedu/whatsleft/logic/commands/AddCommand.java
``` java
    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String description, String priority, String starttime, String startdate, String endtime,
            String enddate, String bydate, String bytime, String location, Set<String> tags)
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        if (startdate != null) {
            this.toAddEvent = new Event(
                    new Description(description),
                    new StartTime(starttime),
                    new StartDate(startdate),
                    new EndTime(endtime),
                    new EndDate(enddate),
                    new Location(location),
                    new UniqueTagList(tagSet));
            this.toAddTask = null;
            if (!Event.isValidEndDateTime(toAddEvent.getEndTime(), toAddEvent.getEndDate(),
                    toAddEvent.getStartTime(), toAddEvent.getStartDate())) {
                throw new IllegalValueException(MESSAGE_ILLEGAL_EVENT_END_DATETIME);
            }
        } else {
            this.toAddTask = new Task(
                    new Description(description),
                    new Priority(priority),
                    new ByTime(bytime),
                    new ByDate(bydate),
                    new Location(location),
                    new UniqueTagList(tagSet),
                    Task.DEFAULT_TASK_STATUS);
            this.toAddEvent = null;
        }
    }

```
###### /java/seedu/whatsleft/logic/commands/AddCommand.java
``` java
    /**
     * @return CommandResult of adding a Task
     * @throws DuplicateTaskException if duplicate task is found
     */
    private CommandResult addingTask() throws DuplicateTaskException {
        model.addTask(toAddTask);
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
        EventsCenter.getInstance().post(new JumpToTaskListRequestEvent(lastShownList.indexOf(toAddTask)));
        EventsCenter.getInstance().post(new JumpToCalendarTaskEvent(toAddTask));
        model.storePreviousCommand("add");
        return new CommandResult(String.format(MESSAGE_TASK_SUCCESS, toAddTask));
    }

```
###### /java/seedu/whatsleft/logic/commands/AddCommand.java
``` java
    /**
     * @return CommandResult of adding an Event
     * @throws DuplicateEventException if duplicate event is found
     */
    private CommandResult addingEvent() throws DuplicateEventException {
        model.addEvent(toAddEvent);

        //@@authour A0148038A
        UnmodifiableObservableList<ReadOnlyEvent> lastShownList = model.getFilteredEventList();
        EventsCenter.getInstance().post(new JumpToEventListRequestEvent(lastShownList.indexOf(toAddEvent)));

```
###### /java/seedu/whatsleft/logic/commands/AddCommand.java
``` java
        if (!toAddEvent.isOver()) {
            EventsCenter.getInstance().post(new JumpToCalendarEventEvent(toAddEvent));
        }
        model.storePreviousCommand("add");
        if (model.eventHasClash(toAddEvent)) {
            return new CommandResult(String.format(MESSAGE_SUCCESS_WITH_CLASH, toAddEvent));
        }
        return new CommandResult(String.format(MESSAGE_EVENT_SUCCESS, toAddEvent));
    }

}
```
###### /java/seedu/whatsleft/logic/commands/DeleteCommand.java
``` java
    public DeleteCommand(int targetIndex, String targetType) {
        this.targetIndex = targetIndex;
        this.targetType = targetType;
    }
```
###### /java/seedu/whatsleft/logic/commands/EditCommand.java
``` java
    /**
     * @param filteredActivityListIndex the index of the activity in the filtered activity list to edit
     * @param editEventDescriptor details to edit the event with
     * @param editTaskDescriptor details to edit the task with
     * @throws IllegalValueException
     */
    public EditCommand(int filteredActivityListIndex, EditEventDescriptor editEventDescriptor,
            EditTaskDescriptor editTaskDescriptor, String type) throws IllegalValueException {
        assert filteredActivityListIndex > 0;
        assert editEventDescriptor != null;
        assert editTaskDescriptor != null;
        assert type != null;

        // converts filteredActivityListIndex from one-based to zero-based.
        this.filteredActivityListIndex = filteredActivityListIndex - 1;
        this.type = type;
        this.editEventDescriptor = new EditEventDescriptor(editEventDescriptor);
        this.editTaskDescriptor = new EditTaskDescriptor(editTaskDescriptor);
    }

    @Override
    public CommandResult execute() throws CommandException {
```
###### /java/seedu/whatsleft/logic/commands/EditCommand.java
``` java
        if (type.equals("ev")) {
            return editingEvent();
        }

        if (type.equals("ts")) {
            return editingTask();
        }
        return new CommandResult(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_USAGE));

    }

```
###### /java/seedu/whatsleft/logic/commands/EditCommand.java
``` java
    /**
     * This method edits the event chosen
     * @return CommandResult of the editing of an event
     * @throws CommandException if invalid index or incorrect end_date/time or duplicate event
     */
    private CommandResult editingEvent() throws CommandException {
```
###### /java/seedu/whatsleft/logic/commands/EditCommand.java
``` java
            if (!editedEvent.isOver()) {
                EventsCenter.getInstance().post(new JumpToCalendarEventEvent(editedEvent));
            }
            if (model.eventHasClash(editedEvent)) {
                return new CommandResult(String.format(MESSAGE_EDIT_SUCCESS_CLASH, editedEvent));
            }
            return new CommandResult(String.format(MESSAGE_EDIT_EVENT_SUCCESS, editedEvent));
        } catch (IllegalValueException e) {
            throw new CommandException(MESSAGE_ILLEGAL_EVENT_END_DATETIME);
        }
    }

```
###### /java/seedu/whatsleft/logic/commands/EditCommand.java
``` java
    /**
     * This method edits the task chosen
     * @return CommandResult of the editing of an task
     * @throws CommandException if invalid index or duplicate task
     */
    private CommandResult editingTask() throws CommandException {
```
###### /java/seedu/whatsleft/logic/commands/EditCommand.java
``` java
        List<ReadOnlyTask> lastShownTaskList = model.getFilteredTaskList();
        if (filteredActivityListIndex >= lastShownTaskList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        Task taskToEdit = (Task) lastShownTaskList.get(filteredActivityListIndex);
        Task editedTask = createEditedTask(taskToEdit, editTaskDescriptor);
        try {
            //store for undo operation
            ReadOnlyWhatsLeft currState = model.getWhatsLeft();
            ModelManager.setPreviousState(currState);
            model.updateTask(taskToEdit, editedTask);
        } catch (UniqueTaskList.DuplicateTaskException dpe) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        model.updateFilteredListToShowAll();
        model.storePreviousCommand("edit");

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
        EventsCenter.getInstance().post(new JumpToTaskListRequestEvent(lastShownList.indexOf(editedTask)));
        EventsCenter.getInstance().post(new JumpToCalendarTaskEvent(editedTask));
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
    }

    /**
     * Creates and returns a {@code Activity} with the details of {@code activityToEdit}
     * edited with {@code editActivityDescriptor}.
     */
    private static Task createEditedTask(ReadOnlyTask taskToEdit,
                                             EditTaskDescriptor editTaskDescriptor) {
        assert taskToEdit != null;

        Description updatedDescription = editTaskDescriptor.getDescription().orElseGet(
                taskToEdit::getDescription);
        Priority updatedPriority = editTaskDescriptor.getPriority().orElseGet(taskToEdit::getPriority);
        ByTime updatedByTime = editTaskDescriptor.getByTime().orElseGet(taskToEdit::getByTime);
        ByDate updatedByDate = editTaskDescriptor.getByDate().orElseGet(taskToEdit::getByDate);
        Location updatedLocation = editTaskDescriptor.getLocation().orElseGet(taskToEdit::getLocation);
        UniqueTagList updatedTags = editTaskDescriptor.getTags().orElseGet(taskToEdit::getTags);

        if (updatedByDate.value != null && updatedByTime.value == null) {
            try {
                updatedByTime = new ByTime(DEFAULT_BY_TIME);
            } catch (IllegalValueException e) {
                e.printStackTrace();
            }
        }

        if (updatedByTime.value != null && updatedByDate.value == null) {
            updatedByDate = new ByDate(LocalDate.now());
        }
        return new Task(updatedDescription, updatedPriority, updatedByTime, updatedByDate,
                 updatedLocation, updatedTags, taskToEdit.getStatus());
    }

```
###### /java/seedu/whatsleft/logic/commands/EditCommand.java
``` java
    /**
     * Creates and returns a {@code Activity} with the details of {@code activityToEdit}
     * edited with {@code editActivityDescriptor}.
     * @throws IllegalValueException
     */
    private static Event createEditedEvent(ReadOnlyEvent eventToEdit,
                                             EditEventDescriptor editEventDescriptor) throws IllegalValueException {
        assert eventToEdit != null;

        Description updatedDescription = editEventDescriptor.getDescription().orElseGet(
                eventToEdit::getDescription);
        StartTime updatedStartTime = editEventDescriptor.getStartTime().orElseGet(eventToEdit::getStartTime);
        StartDate updatedStartDate = editEventDescriptor.getStartDate().orElseGet(eventToEdit::getStartDate);
        EndTime updatedEndTime = editEventDescriptor.getEndTime().orElseGet(eventToEdit::getEndTime);
        EndDate updatedEndDate = editEventDescriptor.getEndDate().orElseGet(eventToEdit::getEndDate);
        Location updatedLocation = editEventDescriptor.getLocation().orElseGet(eventToEdit::getLocation);
        UniqueTagList updatedTags = editEventDescriptor.getTags().orElseGet(eventToEdit::getTags);

        return new Event(updatedDescription, updatedStartTime, updatedStartDate,
                updatedEndTime, updatedEndDate, updatedLocation, updatedTags);
    }

```
###### /java/seedu/whatsleft/logic/commands/EditCommand.java
``` java
    /**
     * Stores the details to edit the activity with. Each non-empty field value will replace the
     * corresponding field value of the activity.
     */
    public static class EditEventDescriptor {
        private Optional<Description> description = Optional.empty();
        private Optional<StartTime> startTime = Optional.empty();
        private Optional<StartDate> startDate = Optional.empty();
        private Optional<EndTime> endTime = Optional.empty();
        private Optional<EndDate> endDate = Optional.empty();
        private Optional<Location> location = Optional.empty();
        private Optional<UniqueTagList> tags = Optional.empty();

        public EditEventDescriptor() {}

        public EditEventDescriptor(EditEventDescriptor toCopy) {
            this.description = toCopy.getDescription();
            this.startTime = toCopy.getStartTime();
            this.startDate = toCopy.getStartDate();
            this.endTime = toCopy.getEndTime();
            this.endDate = toCopy.getEndDate();
            this.location = toCopy.getLocation();
            this.tags = toCopy.getTags();
        }

        /**
         * Returns true if at least one field is edited.
         */
        public boolean isAnyFieldEdited() {
            return CollectionUtil.isAnyPresent(this.description, this.startTime, this.endTime,
                    this.startDate, this.endDate, this.location, this.tags);
        }

        public void setDescription(Optional<Description> description) {
            assert description != null;
            this.description = description;
        }

        public Optional<Description> getDescription() {
            return description;
        }

        public void setStartTime(Optional<StartTime> startTime) {
            this.startTime = startTime;
        }

        public Optional<StartTime> getStartTime() {
            return startTime;
        }

        public void setStartDate(Optional<StartDate> startDate) {
            this.startDate = startDate;
        }

        public Optional<StartDate> getStartDate() {
            return startDate;
        }

        public void setEndTime(Optional<EndTime> endTime) {
            this.endTime = endTime;
        }

        public Optional<EndTime> getEndTime() {
            return endTime;
        }

        public void setEndDate(Optional<EndDate> endDate) {
            this.endDate = endDate;
        }

        public Optional<EndDate> getEndDate() {
            return endDate;
        }

        public void setLocation(Optional<Location> location) {
            this.location = location;
        }

        public Optional<Location> getLocation() {
            return location;
        }

        public void setTags(Optional<UniqueTagList> tags) {
            assert tags != null;
            this.tags = tags;
        }

        public Optional<UniqueTagList> getTags() {
            return tags;
        }
    }

```
###### /java/seedu/whatsleft/logic/commands/EditCommand.java
``` java
    /**
     * Stores the details to edit the Task with. Each non-empty field value will replace the
     * corresponding field value of the activity.
     */
    public static class EditTaskDescriptor {
        private Optional<Description> description = Optional.empty();
        private Optional<Priority> priority = Optional.empty();
        private Optional<ByDate> byDate = Optional.empty();
        private Optional<ByTime> byTime = Optional.empty();
        private Optional<Location> location = Optional.empty();
        private Optional<UniqueTagList> tags = Optional.empty();

        public EditTaskDescriptor() {}

        public EditTaskDescriptor(EditTaskDescriptor toCopy) {
            this.description = toCopy.getDescription();
            this.priority = toCopy.getPriority();
            this.byDate = toCopy.getByDate();
            this.byTime = toCopy.getByTime();
            this.location = toCopy.getLocation();
            this.tags = toCopy.getTags();
        }

        /**
         * Returns true if at least one field is edited.
         */
        public boolean isAnyFieldEdited() {
            return CollectionUtil.isAnyPresent(this.description,
                    this.byDate, this.byTime, this.priority, this.location, this.tags);
        }

        public void setDescription(Optional<Description> description) {
            assert description != null;
            this.description = description;
        }

        public Optional<Description> getDescription() {
            return description;
        }

        public void setByTime(Optional<ByTime> byTime) {
            this.byTime = byTime;
        }

        public Optional<ByTime> getByTime() {
            return byTime;
        }

        public void setByDate(Optional<ByDate> byDate) {
            this.byDate = byDate;
        }

        public Optional<ByDate> getByDate() {
            return byDate;
        }

        public void setPriority(Optional<Priority> priority) {
            this.priority = priority;
        }

        public Optional<Priority> getPriority() {
            return priority;
        }

        public void setLocation(Optional<Location> location) {
            this.location = location;
        }

        public Optional<Location> getLocation() {
            return location;
        }

        public void setTags(Optional<UniqueTagList> tags) {
            assert tags != null;
            this.tags = tags;
        }

        public Optional<UniqueTagList> getTags() {
            return tags;
        }
    }
}
```
###### /java/seedu/whatsleft/logic/commands/FindCommand.java
``` java
    @Override
    public CommandResult execute() {
        model.updateFilteredEventList(keywords);
        model.updateFilteredTaskList(keywords);
        model.storePreviousCommand("");
        EventsCenter.getInstance().post(new JumpToEventListRequestEvent(0));
        EventsCenter.getInstance().post(new JumpToTaskListRequestEvent(0));
        return new CommandResult(getMessageForActivityListShownSummary(model.getFilteredEventList().size() +
                model.getFilteredTaskList().size()));
    }

}
```
###### /java/seedu/whatsleft/logic/commands/RecurCommand.java
``` java
    public RecurCommand(int targetIndex, String frequency, int occur) {
        this.targetIndex = targetIndex;
        this.frequency = frequency;
        this.occur = occur;
    }

    @Override
    public CommandResult execute() throws CommandException {

        UnmodifiableObservableList<ReadOnlyEvent> lastShownEventList = model.getFilteredEventList();
        ReadOnlyWhatsLeft currState = model.getWhatsLeft();
        ModelManager.setPreviousState(currState);

        if (lastShownEventList.size() < targetIndex) {
            throw new CommandException(Messages.MESSAGE_INVALID_EVENT_DISPLAYED_INDEX);
        }
        EventsCenter.getInstance().post(new JumpToEventListRequestEvent(targetIndex - 1));
        EventsCenter.getInstance().post(new JumpToCalendarEventEvent(lastShownEventList.get(targetIndex - 1)));
        ReadOnlyEvent selected = lastShownEventList.get(targetIndex - 1);
        LocalDate startdate = selected.getStartDate().value;
        LocalDate enddate = selected.getEndDate().value;
        LocalDate nextsd = startdate;
        LocalDate nexted = enddate;
        if (frequency.equals("daily")) {
            return recurDailyEvent(selected, nextsd, nexted);
        } else if (frequency.equals("weekly")) {
            return recurWeeklyEvent(selected, nextsd, nexted);
        }
        return new CommandResult(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_USAGE));
    }

```
###### /java/seedu/whatsleft/logic/commands/RecurCommand.java
``` java
    /**
     * Handles the weekly recurring event addition
     * @param selected event
     * @param next start date
     * @param next end date
     * @return CommandResult for successful recur
     * @throws CommandException
     */
    private CommandResult recurWeeklyEvent(ReadOnlyEvent selected, LocalDate nextsd, LocalDate nexted)
            throws CommandException {
        for (int i = 0; i < occur; i++) {
            nextsd = nextsd.plusDays(7);
            nexted = nexted.plusDays(7);
            Event nextOccur = new Event(selected.getDescription(), selected.getStartTime(),
                    new StartDate(nextsd), selected.getEndTime(), new EndDate(nexted),
                    selected.getLocation(), selected.getTags());
            try {
                model.addEvent(nextOccur);
            } catch (DuplicateEventException e) {
                throw new CommandException(MESSAGE_DUPLICATE_ACTIVITY);
            }
        }
        model.storePreviousCommand("add");
        return new CommandResult(String.format(MESSAGE_ADD_RECUR_ACTIVITY_SUCCESS, selected));
    }

```
###### /java/seedu/whatsleft/logic/commands/RecurCommand.java
``` java
    /**
     * Handles the daily recurring event addition
     * @param selected event
     * @param next start date
     * @param next end date
     * @return CommandResult for successful recur
     * @throws CommandException
     */
    private CommandResult recurDailyEvent(ReadOnlyEvent selected, LocalDate nextsd, LocalDate nexted)
            throws CommandException {
        for (int i = 0; i < occur; i++) {
            nextsd = nextsd.plusDays(1);
            nexted = nexted.plusDays(1);
            Event nextOccur = new Event(selected.getDescription(), selected.getStartTime(),
                    new StartDate(nextsd), selected.getEndTime(), new EndDate(nexted),
                    selected.getLocation(), selected.getTags());
            try {
                model.addEvent(nextOccur);
            } catch (DuplicateEventException e) {
                throw new CommandException(MESSAGE_DUPLICATE_ACTIVITY);
            }
        }
        model.storePreviousCommand("add");
        return new CommandResult(String.format(MESSAGE_ADD_RECUR_ACTIVITY_SUCCESS, selected));
    }
}


```
###### /java/seedu/whatsleft/logic/commands/SelectCommand.java
``` java
    public SelectCommand(int targetIndex, String type) {
        this.targetIndex = targetIndex;
        this.type = type;
    }

    @Override
    public CommandResult execute() throws CommandException {

        UnmodifiableObservableList<ReadOnlyEvent> lastShownEventList = model.getFilteredEventList();
        UnmodifiableObservableList<ReadOnlyTask> lastShownTaskList = model.getFilteredTaskList();
        model.storePreviousCommand("");

        if (type.equals("ev")) {
            return selectingEvent(lastShownEventList);
        }
        if (type.equals("ts")) {
            return selectingTask(lastShownTaskList);
        }
        return new CommandResult(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_USAGE));
    }

```
###### /java/seedu/whatsleft/logic/commands/SelectCommand.java
``` java
    /**
     * Handles the selection of task
     * @param lastShownTaskList
     * @return CommandResult success if the index of event is valid
     * @throws CommandException if the index given is invalid
     */
    private CommandResult selectingTask(UnmodifiableObservableList<ReadOnlyTask> lastShownTaskList)
            throws CommandException {
        if (lastShownTaskList.size() < targetIndex) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        EventsCenter.getInstance().post(new JumpToTaskListRequestEvent(targetIndex - 1));
        EventsCenter.getInstance().post(new JumpToCalendarTaskEvent(lastShownTaskList.get(targetIndex - 1)));
        ReadOnlyTask selected = lastShownTaskList.get(targetIndex - 1);
        return new CommandResult(String.format(MESSAGE_SELECT_TASK_SUCCESS, selected));
    }

```
###### /java/seedu/whatsleft/logic/commands/SelectCommand.java
``` java
    /**
     * Handles the selection of event
     * @param lastShownEventList
     * @return CommandResult success if the index of task is valid
     * @throws CommandException if the index given is invalid
     */
    private CommandResult selectingEvent(UnmodifiableObservableList<ReadOnlyEvent> lastShownEventList)
            throws CommandException {
        if (lastShownEventList.size() < targetIndex) {
            throw new CommandException(Messages.MESSAGE_INVALID_EVENT_DISPLAYED_INDEX);
        }
        EventsCenter.getInstance().post(new JumpToEventListRequestEvent(targetIndex - 1));
        if (!lastShownEventList.get(targetIndex - 1).isOver()) {
            EventsCenter.getInstance().post(new JumpToCalendarEventEvent(lastShownEventList.get(targetIndex - 1)));
        }
        ReadOnlyEvent selected = lastShownEventList.get(targetIndex - 1);
        return new CommandResult(String.format(MESSAGE_SELECT_EVENT_SUCCESS, selected));
    }

}
```
###### /java/seedu/whatsleft/logic/commands/UndoCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        String previousCommand = ModelManager.getPreviousCommand();
        if (previousCommand.equals("")) {
            return new CommandResult(MESSAGE_NOTHING_TO_UNDO);
        }
        if (!previousCommand.equals("edit") && !previousCommand.equals("delete") && !previousCommand.equals("clear")
                && !previousCommand.equals("finish") && !previousCommand.equals("add") && !previousCommand.
                equals("redo")) {
            return new CommandResult(MESSAGE_NOTHING_TO_UNDO);
        }
        ReadOnlyWhatsLeft previousState = ModelManager.getPreviousState();
        model.resetData(previousState);
        model.storePreviousCommand("");
        return new CommandResult(String.format(MESSAGE_SUCCESS, previousCommand));
    }

}
```
###### /java/seedu/whatsleft/logic/parser/AddCommandParser.java
``` java
    /**
     * Parses the given {@code String} of arguments in the context of the AddCommand
     * and returns an AddCommand object for execution.
     */
    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer(PREFIX_PRIORITY, PREFIX_LOCATION, PREFIX_STARTDATE, PREFIX_ENDDATE,
                        PREFIX_BYDATE, PREFIX_STARTTIME, PREFIX_ENDTIME, PREFIX_BYTIME, PREFIX_TAG);
        argsTokenizer.tokenize(args);
        try {
            String priority = argsTokenizer.getValue(PREFIX_PRIORITY).orElse(null);
            String location = argsTokenizer.getValue(PREFIX_LOCATION).orElse(null);
            String startdate = argsTokenizer.getValue(PREFIX_STARTDATE).orElse(null);
            String enddate = argsTokenizer.getValue(PREFIX_ENDDATE).orElse(null);
            String bydate = argsTokenizer.getValue(PREFIX_BYDATE).orElse(null);
            String starttime = argsTokenizer.getValue(PREFIX_STARTTIME).orElse(null);
            String endtime = argsTokenizer.getValue(PREFIX_ENDTIME).orElse(null);
            String bytime = argsTokenizer.getValue(PREFIX_BYTIME).orElse(null);

            //neither of the 2 compulsory attributes are given
            if (priority == null && startdate == null) {
                throw new NoSuchElementException();
            }

            //trying to add task/deadline as well as Event
            if (priority != null && startdate != null) {
                throw new IllegalValueException(MESSAGE_CAN_ONLY_ADD_ONE);
            }

            //Task/Deadline cannot have non-task/deadline attributes
            if (priority != null && (startdate != null || enddate != null ||
                    starttime != null || endtime != null)) {
                throw new IllegalValueException(MESSAGE_CAN_ONLY_ADD_ONE);
            }

            //Event cannot have non-event attributes
            if (startdate != null && (priority != null || bydate != null || bytime != null)) {
                throw new IllegalValueException(MESSAGE_CAN_ONLY_ADD_ONE);
            }

            //default enddate to same startdate
            if (startdate != null && enddate == null) {
                enddate = startdate;
            }

            //default block whole day
            if (starttime == null && endtime == null) {
                starttime = DEFAULT_START_TIME;
                endtime = DEFAULT_END_TIME;
            }

            //default block to end of day
            if (starttime != null && endtime == null) {
                endtime = DEFAULT_END_TIME;
            }

            //default block from start of day
            if (endtime != null && starttime == null) {
                starttime = DEFAULT_START_TIME;
            }

            //default task bytime if bydate is given
            if (bydate != null && bytime == null) {
                bytime = DEFAULT_BY_TIME;
            }

            //default bydate if bytime is given
            if (bytime != null && bydate == null) {
                bydate = StringUtil.getTodayDateInString();
            }

            return new AddCommand(
                    argsTokenizer.getPreamble().get(),
                    priority,
                    starttime,
                    startdate,
                    endtime,
                    enddate,
                    bydate,
                    bytime,
                    location,
                    ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG))
            );
        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        } catch (DateTimeException dte) {
            return new IncorrectCommand(dte.getLocalizedMessage());
        }
    }

}
```
###### /java/seedu/whatsleft/logic/parser/DeleteCommandParser.java
``` java
    /**
     * Parses the given {@code String} of arguments in the context of the DeleteCommand
     * and returns an DeleteCommand object for execution.
     */
    public Command parse(String args) {

        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }

        Optional<String> type = ParserUtil.parseType(args);
        if (!type.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }
        if (!type.get().equalsIgnoreCase("ev") && !type.get().equalsIgnoreCase("ts")) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }

        return new DeleteCommand(index.get(), type.get().toLowerCase());
    }

}
```
###### /java/seedu/whatsleft/logic/parser/EditCommandParser.java
``` java
    /**
     * Parses the given {@code String} of arguments in the context of the
     * EditCommand and returns an EditCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_PRIORITY, PREFIX_LOCATION, PREFIX_STARTDATE,
                PREFIX_ENDDATE, PREFIX_BYDATE, PREFIX_STARTTIME, PREFIX_ENDTIME, PREFIX_BYTIME, PREFIX_TAG);
        argsTokenizer.tokenize(args);
        List<Optional<String>> preambleFields = ParserUtil.splitPreamble(argsTokenizer.getPreamble().orElse(""), 3);

        Optional<Integer> index = preambleFields.get(1).flatMap(ParserUtil::parseIndexAlone);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        Optional<String> typeToEdit = preambleFields.get(0);
        if (!typeToEdit.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        EditEventDescriptor editEventDescriptor = new EditEventDescriptor();
        EditTaskDescriptor editTaskDescriptor = new EditTaskDescriptor();

        try {
            String type = typeToEdit.get().toLowerCase();
            boolean priorityExists = argsTokenizer.getValue(PREFIX_PRIORITY).isPresent();
            boolean startdateExists = argsTokenizer.getValue(PREFIX_STARTDATE).isPresent();
            boolean enddateExists = argsTokenizer.getValue(PREFIX_ENDDATE).isPresent();
            boolean bydateExists = argsTokenizer.getValue(PREFIX_BYDATE).isPresent();
            boolean bytimeExists = argsTokenizer.getValue(PREFIX_BYTIME).isPresent();
            boolean starttimeExists = argsTokenizer.getValue(PREFIX_STARTTIME).isPresent();
            boolean endtimeExists = argsTokenizer.getValue(PREFIX_ENDTIME).isPresent();

            // trying to morph a task/deadline into an event
            if (priorityExists && (startdateExists || enddateExists || starttimeExists || endtimeExists)) {
                throw new IllegalValueException(MESSAGE_CANNOT_CHANGE_TASK_TO_EVENT);
            }
            // trying to morph a task/deadline into an event
            if ((bydateExists || bytimeExists)
                    && (startdateExists || enddateExists || starttimeExists || endtimeExists)) {
                throw new IllegalValueException(MESSAGE_CANNOT_CHANGE_TASK_TO_EVENT);
            }
            // trying to morph an event to a task/deadline
            if ((startdateExists || enddateExists || starttimeExists || endtimeExists)
                    && (bydateExists || priorityExists || bytimeExists)) {
                throw new IllegalValueException(MESSAGE_CANNOT_CHANGE_TASK_TO_EVENT);
            }
            //decide what to do depending on whether event or task is input
            if (type.equals("ev")) {
                setEventInfo(argsTokenizer, preambleFields, editEventDescriptor);
            } else if (type.equals("ts")) {
                setTaskInfo(argsTokenizer, preambleFields, editTaskDescriptor);
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        } catch (DateTimeException dte) {
            return new IncorrectCommand(dte.getMessage());
        }

        if (!editEventDescriptor.isAnyFieldEdited() && !editTaskDescriptor.isAnyFieldEdited()) {
            return new IncorrectCommand(EditCommand.MESSAGE_NOT_EDITED);
        }
        String taskorevent = preambleFields.get(0).get().toLowerCase();
        try {
            return new EditCommand(index.get(), editEventDescriptor, editTaskDescriptor, taskorevent);
        } catch (IllegalValueException ile) {
            return new IncorrectCommand(EditCommand.MESSAGE_ILLEGAL_EVENT_END_DATETIME);
        }
    }

    /**
     * This method sets the task information using the editTaskDescriptor
     * @param argsTokenizer
     * @param preambleFields
     * @param editTaskDescriptor
     * @throws IllegalValueException
     */
    private void setTaskInfo(ArgumentTokenizer argsTokenizer, List<Optional<String>> preambleFields,
            EditTaskDescriptor editTaskDescriptor) throws IllegalValueException, DateTimeException {
        editTaskDescriptor.setDescription(ParserUtil.parseDescription(preambleFields.get(2)));
        editTaskDescriptor.setPriority(ParserUtil.parsePriority(argsTokenizer.getValue(PREFIX_PRIORITY)));
        editTaskDescriptor.setByDate(ParserUtil.parseByDate(argsTokenizer.getValue(PREFIX_BYDATE)));
        editTaskDescriptor.setByTime(ParserUtil.parseByTime(argsTokenizer.getValue(PREFIX_BYTIME)));
        editTaskDescriptor.setLocation(ParserUtil.parseLocation(argsTokenizer.getValue(PREFIX_LOCATION)));
        editTaskDescriptor.setTags(parseTagsForEdit(ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG))));
    }

    /**
     * This method sets the event information using the editEventDescriptor
     * @param argsTokenizer
     * @param preambleFields
     * @param editEventDescriptor
     * @throws IllegalValueException
     */
    private void setEventInfo(ArgumentTokenizer argsTokenizer, List<Optional<String>> preambleFields,
            EditEventDescriptor editEventDescriptor) throws IllegalValueException, DateTimeException {
        editEventDescriptor.setDescription(ParserUtil.parseDescription(preambleFields.get(2)));
        editEventDescriptor.setStartDate(ParserUtil.parseStartDate(argsTokenizer.getValue(PREFIX_STARTDATE)));
        editEventDescriptor.setEndDate(ParserUtil.parseEndDate(argsTokenizer.getValue(PREFIX_ENDDATE)));
        editEventDescriptor.setStartTime(ParserUtil.parseStartTime(argsTokenizer.getValue(PREFIX_STARTTIME)));
        editEventDescriptor.setEndTime(ParserUtil.parseEndTime(argsTokenizer.getValue(PREFIX_ENDTIME)));
        editEventDescriptor.setLocation(ParserUtil.parseLocation(argsTokenizer.getValue(PREFIX_LOCATION)));
        editEventDescriptor.setTags(parseTagsForEdit(ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG))));
    }

    /**
     * Parses {@code Collection<String> tags} into an
     * {@code Optional<UniqueTagList>} if {@code tags} is non-empty. If
     * {@code tags} contain only one element which is an empty string, it will
     * be parsed into a {@code Optional<UniqueTagList>} containing zero tags.
     */
    private Optional<UniqueTagList> parseTagsForEdit(Collection<String> tags) throws IllegalValueException {
        assert tags != null;

        if (tags.isEmpty()) {
            return Optional.empty();
        }
        Collection<String> tagSet = tags.size() == 1 && tags.contains("") ? Collections.emptySet() : tags;
        return Optional.of(ParserUtil.parseTags(tagSet));
    }

}
```
###### /java/seedu/whatsleft/logic/parser/ParserUtil.java
``` java
    /**
     * Returns the parsedIndex for recurCommand
     */
    public static Optional<Integer> parseIndexForRec(String command) {
        final Matcher matcher = INDEX_FREQ_OCCUR_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }
        String index = matcher.group("index");
        if (!StringUtil.isUnsignedInteger(index)) {
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));
    }
```
###### /java/seedu/whatsleft/logic/parser/ParserUtil.java
``` java
    /**
     * Returns the parsedFrequency for recurCommand
     */
    public static Optional<String> parseFreqForRec(String command) {
        final Matcher matcher = INDEX_FREQ_OCCUR_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }
        String freq = matcher.group("freq");
        return Optional.of(freq);
    }
```
###### /java/seedu/whatsleft/logic/parser/ParserUtil.java
``` java
    /**
     * Returns the parsedOccurance for recurCommand
     */
    public static Optional<Integer> parseOccurForRec(String command) {
        final Matcher matcher = INDEX_FREQ_OCCUR_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }
        String occur = matcher.group("occur");
        if (!StringUtil.isUnsignedInteger(occur)) {
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(occur));
    }

```
###### /java/seedu/whatsleft/logic/parser/ParserUtil.java
``` java
    /**
     * Returns the parsedIndex when it is the only argument
     */
    public static Optional<Integer> parseIndexAlone(String command) {
        final Matcher matcher = INDEX_ALONE_ARG_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("index");
        if (!StringUtil.isUnsignedInteger(index)) {
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));

    }
```
###### /java/seedu/whatsleft/logic/parser/RecurCommandParser.java
``` java
    /**
     * Parses the given {@code String} of arguments in the context of the SelectCommand
     * and returns an SelectCommand object for execution.
     */
    public Command parse(String args) {
        Optional<Integer> index = ParserUtil.parseIndexForRec(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, RecurCommand.MESSAGE_USAGE));
        }

        Optional<String> freq = ParserUtil.parseFreqForRec(args);
        if (!freq.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, RecurCommand.MESSAGE_USAGE));
        }

        Optional<Integer> occur = ParserUtil.parseOccurForRec(args);
        if (!occur.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, RecurCommand.MESSAGE_USAGE));
        }

        return new RecurCommand(index.get(), freq.get(), occur.get());
    }
```
###### /java/seedu/whatsleft/logic/parser/SelectCommandParser.java
``` java
    /**
     * Parses the given {@code String} of arguments in the context of the SelectCommand
     * and returns an SelectCommand object for execution.
     */
    public Command parse(String args) {
        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectCommand.MESSAGE_USAGE));
        }

        Optional<String> type = ParserUtil.parseType(args);
        if (!type.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectCommand.MESSAGE_USAGE));
        }

        return new SelectCommand(index.get(), type.get().toLowerCase());
    }

}
```
###### /java/seedu/whatsleft/model/activity/ByDate.java
``` java
    public static boolean isValidByDate(String args) {
        try {
            StringUtil.parseStringToDate(args);
        } catch (DateTimeException dte) {
            return false;
        }
        return true;
    }

```
###### /java/seedu/whatsleft/model/activity/ByTime.java
``` java
    /**
     * Checks if given ByTime string is valid
     * returns true if it is valid according to MESSAGE_BYTIME_CONSTRAINTS
     */
    public static boolean isValidByTime(String args) {
        try {
            StringUtil.parseStringToTime(args);
        } catch (DateTimeException dte) {
            return false;
        }
        return true;
    }

```
###### /java/seedu/whatsleft/model/activity/EndDate.java
``` java
    /**
     * Validates given end date. If given in digits, tries to parse into date. If given in non-digit
     * format, tries to process using the DateTimeNLUtil class that tries to read natural language
     *
     * @throws IllegalValueException if given start date is invalid.
     */
    public EndDate(String endDateArg) throws IllegalValueException {
        if (endDateArg == null) {
            this.value = null;
        } else {
            if (endDateArg.matches("\\d+")) {
                try {
                    this.value = StringUtil.parseStringToDate(endDateArg);
                } catch (DateTimeException illegalValueException) {
                    throw new IllegalValueException(MESSAGE_ENDDATE_CONSTRAINTS);
                }
            } else {
                DateTimeNLUtil dt = new DateTimeNLUtil();
                String nldate = dt.getDate(endDateArg);
                this.value = StringUtil.parseStringToDate(nldate);
            }
        }
    }

```
###### /java/seedu/whatsleft/model/activity/EndDate.java
``` java
    /**
     * Checks if given EndDate string is valid
     * returns true if it is valid according to MESSAGE_ENDDATE_CONSTRAINTS
     */
    public static boolean isValidEndDate(String args) {
        try {
            StringUtil.parseStringToDate(args);
        } catch (DateTimeException ive) {
            return false;
        }
        return true;
    }
```
###### /java/seedu/whatsleft/model/activity/EndTime.java
``` java
    /**
     * Checks if given EndTime string is valid
     * returns true if it is valid according to MESSAGE_ENDTIME_CONSTRAINTS
     */
    public static boolean isValidEndTime(String args) {
        try {
            StringUtil.parseStringToTime(args);
        } catch (DateTimeException ive) {
            return false;
        }
        return true;
    }
```
###### /java/seedu/whatsleft/model/activity/StartDate.java
``` java
    /**
     * Validates given start date. If given in digits, tries to parse into date. If given in non-digit
     * format, tries to process using the DateTimeNLUtil class that tries to read natural language
     *
     * @throws IllegalValueException if given start date is invalid.
     */
    public StartDate(String startDateArg) throws IllegalValueException {
        if (startDateArg.matches("\\d+")) {
            try {
                this.value = StringUtil.parseStringToDate(startDateArg);
            } catch (DateTimeException illegalValueException) {
                throw new IllegalValueException(MESSAGE_STARTDATE_CONSTRAINTS);
            }
        } else {
            DateTimeNLUtil dt = new DateTimeNLUtil();
            String nldate = dt.getDate(startDateArg);
            this.value = StringUtil.parseStringToDate(nldate);
        }
    }

```
###### /java/seedu/whatsleft/model/activity/StartDate.java
``` java
    /**
     * Checks if given StartDate string is valid
     * returns true if it is valid according to MESSAGE_STARTDATE_CONSTRAINTS
     */
    public static boolean isValidStartDate(String args) {
        try {
            StringUtil.parseStringToDate(args);
        } catch (DateTimeException ive) {
            return false;
        }
        return true;
    }
```
###### /java/seedu/whatsleft/model/activity/StartTime.java
``` java
    /**
     * Checks if given StartTime string is valid
     * returns true if it is valid according to MESSAGE_STARTTIME_CONSTRAINTS
     */
    public static boolean isValidStartTime(String args) {
        try {
            StringUtil.parseStringToTime(args);
        } catch (DateTimeException ive) {
            return false;
        }
        return true;
    }
```
###### /java/seedu/whatsleft/model/activity/UniqueEventList.java
``` java
    /**
     *
     * @param toCheck
     * @return true if the list contains an event that clashes in time with the given argument
     */
    public boolean containsTimeClash(ReadOnlyEvent toCheck) {
        assert toCheck != null;
        for (Event check : internalList) {
            LocalDateTime startdatetime;
            LocalDateTime enddatetime;
            LocalDateTime checkstartdatetime;
            LocalDateTime checkenddatetime;
            startdatetime = check.getStartDate().getValue().atTime(check.getStartTime().getValue());
            enddatetime = check.getEndDate().getValue().atTime(check.getEndTime().getValue());
            checkstartdatetime = toCheck.getStartDate().getValue().atTime(toCheck.getStartTime().getValue());
            checkenddatetime = toCheck.getEndDate().getValue().atTime(toCheck.getEndTime().getValue());
            if (check != toCheck && (startdatetime.isBefore(checkenddatetime)) && (enddatetime.
                    isAfter(checkstartdatetime))) {
                return true;
            }
        }
        return false;
    }

```
###### /java/seedu/whatsleft/model/Model.java
``` java
    /** Finds whether there is a clash of timing of event */
    boolean eventHasClash(Event toAddEvent);
}
```
###### /java/seedu/whatsleft/model/ModelManager.java
``` java
    public void storePreviousCommand(String command) {
        previousCommand = command;
    }

    public static String getPreviousCommand() {
        return previousCommand;
    }

    public static WhatsLeft getPreviousState() {
        return previousState;
    }

    public static void setPreviousState(ReadOnlyWhatsLeft state) {
        previousState = new WhatsLeft(state);
    }

    @Override
    public int findEventIndex(Event event) {
        int currIndex = 0;
        for (ReadOnlyEvent each : filteredEvents) {
            if (each.equals(event)) {
                return currIndex;
            } else {
                currIndex++;
            }
        }
        return currIndex;
    }

    @Override
    public int findTaskIndex(Task task) {
        int currIndex = 0;
        for (ReadOnlyTask each : filteredTasks) {
            if (each.equals(task)) {
                return currIndex;
            } else {
                currIndex++;
            }
        }
        return currIndex;
    }

    // =========== Filtered List Accessors

```
###### /java/seedu/whatsleft/model/ModelManager.java
``` java
    @Override
    public boolean eventHasClash(Event toAddEvent) {
        return whatsLeft.eventHasClash(toAddEvent);
    }

}
```
###### /java/seedu/whatsleft/model/WhatsLeft.java
``` java
    public boolean eventHasClash(Event toAddEvent) {
        return events.containsTimeClash(toAddEvent);
    }
}
```
###### /java/seedu/whatsleft/ui/UiManager.java
``` java
    @Subscribe
    private void handleJumpToEventListRequestEvent(JumpToEventListRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        mainWindow.getEventListPanel().scrollTo(event.targetIndex);
    }

```
###### /java/seedu/whatsleft/ui/UiManager.java
``` java
    @Subscribe
    private void handleJumpToTaskListRequestEvent(JumpToTaskListRequestEvent task) {
        logger.info(LogsCenter.getEventHandlingLogMessage(task));
        mainWindow.getTaskListPanel().scrollTo(task.targetIndex);
    }

```
