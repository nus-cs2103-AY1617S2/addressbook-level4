# A0162877N
###### \java\seedu\address\commons\exceptions\IllegalDateTimeValueException.java
``` java
/**
 * Signals that the given date cannot be parse to DateTimeParserManager.
 */
public class IllegalDateTimeValueException extends Exception {

    public static final String MESSAGE_DEADLINE_ERROR_PARSING = "Deadline provided is in the wrong format!";

    /**
     * @param message should contain relevant information on the failed constraint(s)
     */
    public IllegalDateTimeValueException() {
        super(MESSAGE_DEADLINE_ERROR_PARSING);
    }
}
```
###### \java\seedu\address\commons\exceptions\InvalidUndoCommandException.java
``` java
/**
 * Signals that some given data does not fulfill some constraints.
 */
public class InvalidUndoCommandException extends Exception {
    /**
     * @param message should contain relevant information on the failed constraint(s)
     */
    public InvalidUndoCommandException(String message) {
        super(message);
    }
}
```
###### \java\seedu\address\logic\commands\BookCommand.java
``` java
public class BookCommand extends Command {

    public static final String COMMAND_WORD = "book";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Books time slots for a task. "
            + "Parameters: TITLE [#LABEL] on DATE STARTTIME to ENDTIME, DATE STARTTIME to ENDTIME...\n"
            + "Example: " + COMMAND_WORD
            + " Meet John Doe #friends #owesMoney on 31 Mar 2017 2pm to 5pm,"
            + " 01 Oct 2017 2pm to 5pm, 30 Oct 2017 1pm to 2pm";
    public static final String MESSAGE_SUCCESS = "New booking added: %1$s";
    public static final String MESSAGE_DUPLICATE_BOOKING = "This booking already exists in the task manager";

    private final Task toAdd;

    public BookCommand(String title, Set<String> labels, String...dates)
            throws IllegalValueException, CommandException {
        final Set<Label> labelSet = new HashSet<>();
        final Set<Booking> bookingSet = new HashSet<>();
        for (String labelName : labels) {
            labelSet.add(new Label(labelName));
        }

        for (String bookingSlot : dates) {
            bookingSet.add(new Booking(bookingSlot));
        }

        this.toAdd = new Task(
                new Title(title),
                Optional.empty(),
                Optional.empty(),
                false,
                new UniqueLabelList(labelSet),
                new UniqueBookingList(bookingSet),
                false,
                Optional.empty()
        );
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            saveCurrentState();
            model.addTask(toAdd);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            throw new CommandException(MESSAGE_DUPLICATE_BOOKING);
        }
    }

    /**
     * Save the data in task manager if command is mutating the data
     */
    public void saveCurrentState() {
        if (isMutating()) {
            try {
                LogicManager.undoCommandHistory.addStorageHistory(model.getTaskManager().getImmutableTaskList(),
                        model.getTaskManager().getImmutableLabelList());
            } catch (CloneNotSupportedException e) {
                e.printStackTrace();
            }
        }
    }

    @Override
    public boolean isMutating() {
        return true;
    }

}
```
###### \java\seedu\address\logic\commands\ConfirmCommand.java
``` java
public class ConfirmCommand extends Command {

    public static final String COMMAND_WORD = "confirm";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Confirms the bookings of the task identified "
            + "by the index number used in the last task listing. "
            + "Other booking slots will be removed.\n"
            + "Parameters: INDEX (index of the task in the current task list and must be a positive integer)\n"
            + "Parameters: INDEX (index of the time slot to confirm and must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1 1";
    public static final String MESSAGE_NO_SUCH_BOOKING = "Index provided is invalid.\n" + MESSAGE_USAGE;
    public static final String MESSAGE_TASK_NO_BOOKING = "This task does not have bookings to confirm.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";
    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Confirmed Task: %1$s";

    private final int filteredTaskListIndex;
    private final int bookingSlotIndex;

    public ConfirmCommand(int filteredTaskListIndex, int bookingSlotIndex) {
        assert filteredTaskListIndex > 0;
        assert bookingSlotIndex > 0;
        this.filteredTaskListIndex = filteredTaskListIndex - 1;
        this.bookingSlotIndex = bookingSlotIndex - 1;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASKS_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = null;
        try {
            taskToEdit = lastShownList.get(filteredTaskListIndex);
            Task editedTask = confirmTaskBooking(taskToEdit, bookingSlotIndex);
            saveCurrentState();
            model.updateTask(filteredTaskListIndex, editedTask);
        } catch (UniqueTaskList.DuplicateTaskException dte) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        } catch (IllegalValueException e) {
            e.printStackTrace();
        } catch (IllegalDateTimeValueException e) {
            e.printStackTrace();
        }
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
    }

    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     * @throws IllegalDateTimeValueException
     * @throws IllegalValueException
     * @throws CommandException
     */
    private static Task confirmTaskBooking(ReadOnlyTask taskToEdit, int bookingSlotIndex)
            throws IllegalValueException, IllegalDateTimeValueException, CommandException {
        assert taskToEdit != null;
        if (!taskToEdit.getBookings().isEmpty()) {
            ObservableList<Booking> bookingList = taskToEdit.getBookings().asObservableList();
            System.out.println(bookingList.size());
            if (bookingSlotIndex >= bookingList.size()) {
                throw new CommandException(MESSAGE_NO_SUCH_BOOKING);
            }
            Booking booking = bookingList.get(bookingSlotIndex);
            Optional<Deadline> updatedStartTime = Optional.ofNullable(
                    new Deadline(booking.getBookingStartDate().toString()));
            Optional<Deadline> updatedEndTime = Optional.ofNullable(
                    new Deadline(booking.getBookingEndDate().toString()));
            return new Task(taskToEdit.getTitle(),
                    updatedStartTime,
                    updatedEndTime,
                    taskToEdit.isCompleted(),
                    taskToEdit.getLabels(),
                    new UniqueBookingList(),
                    false,
                    Optional.empty());
        } else {
            throw new CommandException(MESSAGE_TASK_NO_BOOKING);
        }
    }

    /**
     * Save the data in task manager if command is mutating the data
     */
    public void saveCurrentState() {
        if (isMutating()) {
            try {
                LogicManager.undoCommandHistory.addStorageHistory(model.getTaskManager().getImmutableTaskList(),
                        model.getTaskManager().getImmutableLabelList());
            } catch (CloneNotSupportedException e) {
                e.printStackTrace();
            }
        }
    }

    @Override
    public boolean isMutating() {
        return true;
    }

}
```
###### \java\seedu\address\logic\commands\EditBookingCommand.java
``` java
public class EditBookingCommand extends Command {

    public static final String COMMAND_WORD = "editbooking";
    public static final String MESSAGE_DUPLICATE_BOOKING = "This booking already exists in the task manager";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Edits the booking of the task identified "
            + "by the index number used in the last task listing. "
            + "Parameters: INDEX (index of the task in the current task list and must be a positive integer)\n"
            + "Parameters: [add DATE, MORE DATES] | [remove BOOKING_INDEX] | [change BOOKING_INDEX DATE]\n"
            + "Example: " + COMMAND_WORD + " 1 add tuesday 2pm to 5pm\n" + "Example: " + COMMAND_WORD + " 1 remove 1\n"
            + "Example: " + COMMAND_WORD + " 1 change 1 tuesday 1pm to 4pm\n";
    public static final String MESSAGE_NO_SUCH_BOOKING = "Index provided is invalid.\n" + MESSAGE_USAGE;
    public static final String MESSAGE_TASK_NO_BOOKING = "This task does not have bookings to update.";
    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Task: %1$s";

    private final int filteredTaskListIndex;
    private final int bookingSlotIndex;
    private final Set<Booking> bookingSet;

    public EditBookingCommand(int filteredTaskListIndex, int bookingSlotIndex) { // remove
        assert filteredTaskListIndex > 0;
        assert bookingSlotIndex > 0;
        this.filteredTaskListIndex = filteredTaskListIndex - 1;
        this.bookingSlotIndex = bookingSlotIndex - 1;
        this.bookingSet = new HashSet<>();
    }

    public EditBookingCommand(int filteredTaskListIndex, String... dates) throws CommandException { // add
        assert filteredTaskListIndex > 0;
        this.filteredTaskListIndex = filteredTaskListIndex - 1;
        bookingSlotIndex = -1;
        bookingSet = new HashSet<>();
        for (String bookingSlot : dates) {
            bookingSet.add(new Booking(bookingSlot));
        }
    }

    public EditBookingCommand(int filteredTaskListIndex, int bookingSlotIndex, String date)
            throws CommandException { // change
        assert filteredTaskListIndex > 0;
        this.filteredTaskListIndex = filteredTaskListIndex - 1;
        this.bookingSlotIndex = bookingSlotIndex - 1;
        bookingSet = new HashSet<>();
        bookingSet.add(new Booking(date));
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();
        try {
            boolean bookingSuccess = false;
            if (bookingSet.isEmpty() && bookingSlotIndex >= 0) { //remove
                bookingSuccess = removeBookingsInTasks(lastShownList);
            } else if (!bookingSet.isEmpty() && bookingSlotIndex >= 0) { //change
                bookingSuccess = changeBookingsInTasks(lastShownList);
            } else if (!bookingSet.isEmpty()) { //add got problem when user put 0
                bookingSuccess = addBookingsInTasks(lastShownList);
            } else {
                throw new CommandException(MESSAGE_TASK_NO_BOOKING);
            }

            if (!bookingSuccess) {
                throw new CommandException(MESSAGE_NO_SUCH_BOOKING);
            }

            return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, filteredTaskListIndex + 1));
        } catch (DuplicateBookingException e) {
            throw new CommandException(e.getMessage());
        }
    }

    /**
     * Replaces a specific label in all tasks
     *
     * @param lastShownList
     * @return true if the specified label exists
     * @throws DuplicateBookingException
     */
    private boolean removeBookingsInTasks(List<ReadOnlyTask> lastShownList)
            throws CommandException, DuplicateBookingException {
        boolean bookingExist = false;
        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASKS_DISPLAYED_INDEX);
        } else {
            Task task = new Task(lastShownList.get(filteredTaskListIndex));
            UniqueBookingList bookings = task.getBookings();
            if (!bookings.isEmpty()) {
                List<Booking> bookingList = bookings.toList();
                if (bookingSlotIndex >= bookingList.size()) {
                    throw new CommandException(MESSAGE_NO_SUCH_BOOKING);
                }
                bookingList.remove(bookingSlotIndex);
                Collections.sort(bookingList);
                task.setBookings(new UniqueBookingList(bookingList));
                bookingExist = true;
                try {
                    saveCurrentState();
                    model.updateTask(filteredTaskListIndex, task);
                } catch (DuplicateTaskException dpe) {
                    throw new CommandException(MESSAGE_DUPLICATE_BOOKING);
                }
            } else {
                throw new CommandException(MESSAGE_NO_SUCH_BOOKING);
            }
        }
        return bookingExist;
    }

    /**
     * Replaces a specific label in all tasks
     *
     * @param lastShownList
     * @return true if the specified label exists
     * @throws DuplicateBookingException
     */
    private boolean addBookingsInTasks(List<ReadOnlyTask> lastShownList)
            throws CommandException, DuplicateBookingException {
        boolean bookingSuccess = false;
        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASKS_DISPLAYED_INDEX);
        } else {
            Task task = new Task(lastShownList.get(filteredTaskListIndex));
            UniqueBookingList bookings = task.getBookings();
            if (!bookings.isEmpty()) {
                Set<Booking> taskBookingSet = bookings.toSet();
                List<Booking> bookingList = new ArrayList<Booking>(bookingSet);
                for (Booking booking : bookingList) {
                    taskBookingSet.add(booking);
                }
                task.setBookings(new UniqueBookingList(taskBookingSet));
                bookingSuccess = true;
                try {
                    saveCurrentState();
                    model.updateTask(filteredTaskListIndex, task);
                } catch (DuplicateTaskException dpe) {
                    throw new CommandException(MESSAGE_DUPLICATE_BOOKING);
                }
            } else {
                throw new CommandException(MESSAGE_NO_SUCH_BOOKING);
            }
        }
        return bookingSuccess;
    }

    /**
     * Replaces a specific label in all tasks
     *
     * @param allTaskList
     * @return true if the specified label exists
     * @throws DuplicateBookingException
     */
    private boolean changeBookingsInTasks(List<ReadOnlyTask> lastShownList)
            throws CommandException, DuplicateBookingException {
        boolean bookingExist = false;
        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASKS_DISPLAYED_INDEX);
        } else {
            Task task = new Task(lastShownList.get(filteredTaskListIndex));
            UniqueBookingList bookings = task.getBookings();
            if (!bookings.isEmpty()) {
                List<Booking> bookingList = bookings.toList();
                if (bookingSlotIndex >= bookingList.size() || bookingSlotIndex < 0) {
                    throw new CommandException(MESSAGE_NO_SUCH_BOOKING);
                }
                if (!bookings.contains(new ArrayList<Booking>(bookingSet).get(0))) {
                    bookingList.remove(bookingSlotIndex);
                    bookingList.add(new ArrayList<Booking>(bookingSet).get(0));
                }
                Collections.sort(bookingList);
                task.setBookings(new UniqueBookingList(bookingList));
                bookingExist = true;
                try {
                    saveCurrentState();
                    model.updateTask(filteredTaskListIndex, task);
                } catch (DuplicateTaskException dpe) {
                    throw new CommandException(MESSAGE_DUPLICATE_BOOKING);
                }
            } else {
                throw new CommandException(MESSAGE_NO_SUCH_BOOKING);
            }
        }
        return bookingExist;
    }

    /**
     * Save the data in task manager if command is mutating the data
     */
    public void saveCurrentState() {
        if (isMutating()) {
            try {
                LogicManager.undoCommandHistory.addStorageHistory(model.getTaskManager().getImmutableTaskList(),
                        model.getTaskManager().getImmutableLabelList());
            } catch (CloneNotSupportedException e) {
                e.printStackTrace();
            }
        }
    }

    @Override
    public boolean isMutating() {
        return true;
    }

}
```
###### \java\seedu\address\logic\commands\FindCommand.java
``` java
/**
 * Finds and lists all tasks in task manager whose name contains any of the
 * argument keywords. Keyword matching is case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks whose names contain any of "
            + "the specified keywords (case-insensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]... | [(by DEADLINE) | (from STARTDATE to ENDDATE)]\n"
            + "Example: " + COMMAND_WORD + " meet alice";

    public static final String DEFAULT_STARTTIME = "00:00:00";
    public static final String DEFAULT_ENDTIME = "23:59:59";

    private final Set<String> keywords;
    private final String startDate;
    private final String endDate;

    public FindCommand(Set<String> keywords) {
        this.keywords = keywords;
        this.startDate = null;
        this.endDate = null;
    }

    public FindCommand(String endDate) throws IllegalDateTimeValueException {
        this.startDate = "";
        this.endDate = endDate;
        this.keywords = null;
    }

    public FindCommand(String startDate, String endDate) throws IllegalDateTimeValueException {
        this.startDate = startDate;
        this.endDate = endDate;
        this.keywords = null;
    }

    /**
     * Returns true if a given string is a valid date.
     */
    public boolean isParsableDate(String dateTime) {
        dtParser.parse(dateTime);
        return !dtParser.parse(dateTime).isEmpty();
    }

    @Override
    public CommandResult execute() throws CommandException {
        try {
            executeFindCommandLogic();
            return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
        } catch (IllegalDateTimeValueException e) {
            throw new CommandException(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }
    }

    public void executeFindCommandLogic() throws IllegalDateTimeValueException {
        if (keywords == null) {
            if ("".equals(startDate) && isParsableDate(endDate)) { // by prefix is used by user
                executeFindEndDate();
            } else if (isParsableDate(startDate) && isParsableDate(endDate)) { // from and to prefix is used by user
                executeFindDateRange();
            } else {
                throw new IllegalDateTimeValueException();
            }
        } else { // no dates specified by user only search for keywords
            model.updateFilteredTaskList(keywords);
        }
    }

    public void executeFindDateRange() {
        Date start = null;
        Date end = null;
        if (dtParser.parse(endDate).get(0).isTimeInferred()) {
            end = dtParser.parse(endDate + " " + DEFAULT_ENDTIME).get(0).getDates().get(0);
        } else {
            end = dtParser.parse(endDate).get(0).getDates().get(0);
        }

        if (dtParser.parse(startDate).get(0).isTimeInferred()) {
            start = dtParser.parse(startDate + " " + DEFAULT_STARTTIME).get(0).getDates().get(0);
        } else {
            start = dtParser.parse(startDate).get(0).getDates().get(0);
        }

        if (end.before(start)) {
            model.updateFilteredTaskList(end, start);
        } else {
            model.updateFilteredTaskList(start, end);
        }
    }

    public void executeFindEndDate() {
        Date start = null;
        Date end = null;
        if (dtParser.parse(endDate).get(0).isTimeInferred()) {
            end = dtParser.parse(endDate + " " + DEFAULT_ENDTIME).get(0).getDates().get(0);
        } else {
            end = dtParser.parse(endDate).get(0).getDates().get(0);
        }

        start = dtParser.parse("today " + DEFAULT_STARTTIME).get(0).getDates().get(0);
        model.updateFilteredTaskList(start, end);
    }

    @Override
    public boolean isMutating() {
        return false;
    }

}
```
###### \java\seedu\address\logic\commands\ListCommand.java
``` java
/**
 * Lists all tasks in the task manager to the user.
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";
    public static final String DEFAULT_STARTTIME = "00:00:00";
    public static final String DEFAULT_ENDTIME = "23:59:59";
    public static final String MESSAGE_SUCCESS = "Listed all tasks";
    public static final String MESSAGE_USAGE = COMMAND_WORD + " [by DEADLINE] | [from STARTDATE to ENDDATE]";
    private final String endDate;
    private final String startDate;
    private final Boolean isCompleted;

    public ListCommand() {
        isCompleted = null;
        endDate = "";
        startDate = "";
    }

    public ListCommand(Boolean isCompleted) {
        this.isCompleted = isCompleted;
        endDate = "";
        startDate = "";

    }

    public ListCommand(String endDate) throws IllegalDateTimeValueException {
        isCompleted = null;
        this.endDate = endDate;
        this.startDate = "";
    }

    public ListCommand(String startDate, String endDate) throws IllegalDateTimeValueException {
        isCompleted = null;
        this.startDate = startDate;
        this.endDate = endDate;
    }

    @Override
    public CommandResult execute() {
        try {
            executeListCommandLogic();
        } catch (IllegalDateTimeValueException e) {
            e.printStackTrace();
        }
        return new CommandResult(MESSAGE_SUCCESS);
    }

    public void executeListCommandLogic() throws IllegalDateTimeValueException {
        if ("".equals(startDate) && isParsableDate(endDate)) { // by prefix is used by user
            executeListEndDate();
        } else if (isParsableDate(startDate) && isParsableDate(endDate)) { // from and to prefix is used by user
            executeListDateRange();
        } else if (isCompleted != null) {
            model.updateFilteredTaskList(isCompleted);
        } else if ("".equals(startDate) && "".equals(endDate)) {
            model.updateFilteredListToShowAll();
        } else {
            throw new IllegalDateTimeValueException();
        }
    }

    public void executeListDateRange() {
        Date start = null;
        Date end = null;

        if (dtParser.parse(endDate).get(0).isTimeInferred()) {
            end = dtParser.parse(endDate + " " + DEFAULT_ENDTIME).get(0).getDates().get(0);
        } else {
            end = dtParser.parse(endDate).get(0).getDates().get(0);
        }

        if (dtParser.parse(startDate).get(0).isTimeInferred()) {
            start = dtParser.parse(startDate + " " + DEFAULT_STARTTIME).get(0).getDates().get(0);
        } else {
            start = dtParser.parse(startDate).get(0).getDates().get(0);
        }

        if (end.before(start)) {
            model.updateFilteredTaskList(end, start);
        } else {
            model.updateFilteredTaskList(start, end);
        }
    }

    public void executeListEndDate() {
        Date start = null;
        Date end = null;
        if (dtParser.parse(endDate).get(0).isTimeInferred()) {
            end = dtParser.parse(endDate + " " + DEFAULT_ENDTIME).get(0).getDates().get(0);
        } else {
            end = dtParser.parse(endDate).get(0).getDates().get(0);
        }

        start = dtParser.parse("today " + DEFAULT_STARTTIME).get(0).getDates().get(0);
        model.updateFilteredTaskList(start, end);
    }

    /**
     * Returns true if a given string is a valid date.
     */
    public boolean isParsableDate(String dateTime) {
        return !dtParser.parse(dateTime).isEmpty();
    }

    @Override
    public boolean isMutating() {
        return false;
    }
}
```
###### \java\seedu\address\logic\commands\UndoCommand.java
``` java
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";
    public static final String MESSAGE_SUCCESS = "Undo-ed previous command successfully!\n"
            + "To Redo past command, hit the up arrow key.";
    public static final String MESSAGE_USAGE = COMMAND_WORD;
    public static final String MESSAGE_UNSUCCESSFUL_UNDO = "No previous command to undo.";

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            if (!LogicManager.undoCommandHistory.isEmpty()) {
                UndoPair<ObservableList<ReadOnlyTask>, ObservableList<Label>> pair =
                        LogicManager.undoCommandHistory.getUndoData();
                model.undoPrevious(pair.getLeft(), pair.getRight());
                return new CommandResult(String.format(MESSAGE_SUCCESS));
            } else {
                throw new InvalidUndoCommandException(MESSAGE_UNSUCCESSFUL_UNDO);
            }
        } catch (InvalidUndoCommandException e) {
            throw new CommandException(e.getMessage());
        }
    }

    @Override
    public boolean isMutating() {
        return false;
    }

}
```
###### \java\seedu\address\logic\dateparser\DateTimeManager.java
``` java
/**
* Parses input arguments to Natty
*/
public class DateTimeManager implements DateTimeParser {
    private TimeZone defaultTimeZone;
    private static final Logger logger = LoggerFactory.getLogger(Parser.class);

    /**
     * Tokens that should be removed from the end any list of tokens before
     * parsing. These are valid tokens, but could never add any meaningful
     * parsing information when located at the end of a token stream.
     */
    private static final Set<Integer> IGNORED_TRAILING_TOKENS = new HashSet<Integer>(
            Arrays.asList(new Integer[] { DateLexer.DOT, DateLexer.COLON, DateLexer.COMMA, DateLexer.DASH,
                DateLexer.SLASH, DateLexer.DOT, DateLexer.PLUS, DateLexer.SINGLE_QUOTE }));

    /**
     * Creates a new parser with default time zone set as GMT+8
     */
    public DateTimeManager() {
        defaultTimeZone = TimeZone.getTimeZone("GMT+8");
    }

    /**
     * Parses the given input value for one or more groups of date alternatives
     *
     * @param value
     * @return List of Date group
     */
    public List<DateGroup> parse(String value) {
        return parse(value, new Date());
    }

    /**
     * Parses the given input value for one or more groups of date alternatives
     * with relative dates resolved according to referenceDate
     *
     * @param value
     * @param referenceDate
     * @return
     */
    public List<DateGroup> parse(String value, Date referenceDate) {
        // lex the input value to obtain our global token stream
        ANTLRInputStream input = null;

        try {
            input = new ANTLRNoCaseInputStream(new ByteArrayInputStream(value.getBytes()));

        } catch (IOException e) {
            logger.error("could not lex input", e);
        }
        DateLexer lexer = new DateLexer(input);

        // collect all sub-token streams that may include date information
        List<TokenStream> streams = collectTokenStreams(new CommonTokenStream(lexer));

        // and parse each of them
        List<DateGroup> groups = new ArrayList<DateGroup>();
        TokenStream lastStream = null;
        for (TokenStream stream : streams) {
            lastStream = stream;
            List<Token> tokens = ((NattyTokenSource) stream.getTokenSource()).getTokens();
            DateGroup group = singleParse(stream, value, referenceDate);
            while ((group == null || group.getDates().size() == 0) && tokens.size() > 0) {
                if (group == null || group.getDates().size() == 0) {
                    List<Token> endRemovedTokens = new ArrayList<Token>(tokens);
                    while ((group == null || group.getDates().isEmpty()) && !endRemovedTokens.isEmpty()) {
                        endRemovedTokens = endRemovedTokens.subList(0, endRemovedTokens.size() - 1);
                        TokenStream newStream = new CommonTokenStream(new NattyTokenSource(endRemovedTokens));
                        group = singleParse(newStream, value, referenceDate);
                        lastStream = newStream;
                    }

                    while ((group == null || group.getDates().isEmpty()) && tokens.size() >= 1) {
                        tokens = tokens.subList(1, tokens.size());
                        Iterator<Token> iter = tokens.iterator();
                        while (iter.hasNext()) {
                            Token token = iter.next();
                            if (!DateParser.FOLLOW_empty_in_parse186.member(token.getType())) {
                                iter.remove();
                            } else {
                                break;
                            }
                        }
                        TokenStream newStream = new CommonTokenStream(new NattyTokenSource(tokens));
                        group = singleParse(newStream, value, referenceDate);
                        lastStream = newStream;
                    }
                }
            }

            // If a group with at least one date was found, we'll most likely
            // want to add it to our list,
            // but not if multiple streams were found and the group contains
            // only numeric time information.
            // For example: A full text string of '1' should parse to 1 o'clock,
            // but 'I need 1 hard drive'
            // should result in no groups found.
            if (group != null && !group.getDates().isEmpty()
                    && (streams.size() == 1 || !group.isDateInferred() || !isAllNumeric(lastStream))) {

                // Additionally, we'll only accept this group if the associated
                // text does not have an
                // alphabetic character to the immediate left or right, which
                // would indicate a portion
                // of a word was tokenized. For example, 'nightingale' will
                // result in a 'NIGHT' token,
                // but there's clearly no datetime information there.
                group.setFullText(value);
                String prefix = group.getPrefix(1);
                String suffix = group.getSuffix(1);
                if ((prefix.isEmpty() || !Character.isLetter(prefix.charAt(0)))
                        && (suffix.isEmpty() || !Character.isLetter(suffix.charAt(0)))) {

                    groups.add(group);
                }
            }
        }
        return groups;
    }

    /**
     * Determines if a token stream contains only numeric tokens
     *
     * @param stream
     * @return true if all tokens in the given stream can be parsed as an
     *         integer
     */
    private boolean isAllNumeric(TokenStream stream) {
        List<Token> tokens = ((NattyTokenSource) stream.getTokenSource()).getTokens();
        for (Token token : tokens) {
            try {
                Integer.parseInt(token.getText());
            } catch (NumberFormatException e) {
                return false;
            }
        }
        return true;
    }

    /**
     * Parses the token stream for a SINGLE date time alternative. This method
     * assumes that the entire token stream represents date and or time
     * information (no extraneous tokens)
     *
     * @param stream
     * @return
     */
    private DateGroup singleParse(TokenStream stream, String fullText, Date referenceDate) {
        DateGroup group = null;
        List<Token> tokens = ((NattyTokenSource) stream.getTokenSource()).getTokens();
        if (tokens.isEmpty()) {
            return group;
        }

        StringBuilder tokenString = new StringBuilder();
        for (Token token : tokens) {
            tokenString.append(DateParser.tokenNames[token.getType()]);
            tokenString.append(" ");
        }

        try {
            // parse
            ParseListener listener = new ParseListener();
            DateParser parser = new DateParser(stream, listener);
            DateParser.parse_return parseReturn = parser.parse();

            Tree tree = (Tree) parseReturn.getTree();

            // continue if a meaningful syntax tree has been built
            if (tree.getChildCount() > 0) {
                logger.info("PARSE: " + tokenString.toString());

                // rewrite the tree
                CommonTreeNodeStream nodes = new CommonTreeNodeStream(tree);
                TreeRewrite s = new TreeRewrite(nodes);
                tree = (CommonTree) s.downup(tree);
                nodes = new CommonTreeNodeStream(tree);
                nodes.setTokenStream(stream);
                DateWalker walker = new DateWalker(nodes);
                walker.setReferenceDate(referenceDate);
                walker.getState().setDefaultTimeZone(defaultTimeZone);
                walker.parse();
                logger.info("AST: " + tree.toStringTree());

                // run through the results and append the parse information
                group = walker.getState().getDateGroup();
                ParseLocation location = listener.getDateGroupLocation();
                group.setLine(location.getLine());
                group.setText(location.getText());
                group.setPosition(location.getStart());
                group.setSyntaxTree(tree);
                group.setParseLocations(listener.getLocations());
                group.setFullText(fullText);

                String prefix = group.getPrefix(1);
                String suffix = group.getSuffix(1);
                // ignore this result if the group's matching text has an immediate alphabetic
                // prefix or suffix
                if ((!prefix.isEmpty() && Character.isLetter(prefix.charAt(0)))
                        || (!suffix.isEmpty() && Character.isLetter(suffix.charAt(0)))) {

                    group = null;
                }

            }

        } catch (RecognitionException e) {
            logger.debug("Could not parse input", e);
        }

        return group;
    }

    /**
     * Scans the given token global token stream for a list of sub-token streams
     * representing those portions of the global stream that may contain date
     * time information
     *
     * @param stream
     * @return list of token stream
     */
    private List<TokenStream> collectTokenStreams(TokenStream stream) {

        // walk through the token stream and build a collection
        // of sub token streams that represent possible date locations
        List<Token> currentGroup = null;
        List<List<Token>> groups = new ArrayList<List<Token>>();
        Token currentToken;
        int currentTokenType;
        StringBuilder tokenString = new StringBuilder();
        while ((currentToken = stream.getTokenSource().nextToken()).getType() != DateLexer.EOF) {
            currentTokenType = currentToken.getType();
            tokenString.append(DateParser.tokenNames[currentTokenType]).append(" ");

            if (currentGroup == null) {
                // skip over white space and known tokens that cannot be the start of a date
                if (currentTokenType != DateLexer.WHITE_SPACE
                        && DateParser.FOLLOW_empty_in_parse186.member(currentTokenType)) {

                    currentGroup = new ArrayList<Token>();
                    currentGroup.add(currentToken);
                }
            } else { // collect and preserve white space
                if (currentTokenType == DateLexer.WHITE_SPACE) {
                    currentGroup.add(currentToken);
                } else {
                    // if this is an unknown token, close out the current group
                    if (currentTokenType == DateLexer.UNKNOWN) {
                        addGroup(currentGroup, groups);
                        currentGroup = null;
                    } else {
                        // token is known and add it to the current group
                        currentGroup.add(currentToken);
                    }
                }
            }
        }

        if (currentGroup != null) {
            addGroup(currentGroup, groups);
        }

        // add information to logger
        logger.info("STREAM: " + tokenString.toString());
        List<TokenStream> streams = new ArrayList<TokenStream>();
        for (List<Token> group : groups) {
            if (!group.isEmpty()) {
                StringBuilder builder = new StringBuilder();
                builder.append("GROUP: ");
                for (Token token : group) {
                    builder.append(DateParser.tokenNames[token.getType()]).append(" ");
                }
                logger.info(builder.toString());

                streams.add(new CommonTokenStream(new NattyTokenSource(group)));
            }
        }

        return streams;
    }

    /**
     * Cleans up the given group and adds it to the list of groups if still
     * valid
     *
     * @param group
     * @param groups
     */
    private void addGroup(List<Token> group, List<List<Token>> groups) {

        if (group.isEmpty()) {
            return;
        }

        // remove trailing tokens that should be ignored
        while (!group.isEmpty() && IGNORED_TRAILING_TOKENS.contains(group.get(group.size() - 1).getType())) {
            group.remove(group.size() - 1);
        }

        // if the group still has some tokens left, add it to our list of groups
        if (!group.isEmpty()) {
            groups.add(group);
        }
    }
}
```
###### \java\seedu\address\logic\dateparser\DateTimeParser.java
``` java
/**
 * The API of the DateTimeParser component.
 */
public interface DateTimeParser {

    /**
     * Parses the given input value to the DateTimeParser
     */
    List<DateGroup> parse(String value);

}
```
###### \java\seedu\address\logic\LogicManager.java
``` java
    @Override
    public CommandResult execute(String commandText) throws CommandException {
        logger.info("----------------[USER COMMAND][" + commandText + "]");
        Command command = parser.parseCommand(commandText);
        command.setData(model);
        command.setDateParser(dtParser);
        return command.execute();
    }

    @Override
    public ObservableList<ReadOnlyTask> getFilteredTaskList() {
        return model.getFilteredTaskList();
    }
}
```
###### \java\seedu\address\logic\parser\AddCommandParser.java
``` java
/**
 * Parses input arguments and creates a new AddCommand object
 */
public class AddCommandParser extends Parser {

    public static final int VALID_DATEARR_SIZE = 1;

    /**
     * Parses the given {@code String} of arguments in the context of the
     * AddCommand and returns an AddCommand object for execution.
     */
    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_LABEL);
        argsTokenizer.tokenize(args);
        try {
            String title = argsTokenizer.getPreamble().get();

            if (args.contains(PREFIX_TIMEINTERVAL_START.getPrefix())
                    && args.contains(PREFIX_TIMEINTERVAL_END.getPrefix())) {
                argsTokenizer = new ArgumentTokenizer(PREFIX_TIMEINTERVAL_START, PREFIX_TIMEINTERVAL_END, PREFIX_LABEL,
                        PREFIX_RECURRENCE);
                argsTokenizer.tokenize(args);
                String startDT = argsTokenizer.getValue(PREFIX_TIMEINTERVAL_START).get();
                String endDT = argsTokenizer.getValue(PREFIX_TIMEINTERVAL_END).get();
                Boolean isRecurring = false;

                if (isDateParseable(startDT) && isDateParseable(endDT)) {
                    title = args.substring(0, args.lastIndexOf("from"));
                    if (!args.contains(PREFIX_RECURRENCE.getPrefix())) {
                        return new AddCommand(title, startDT, endDT,
                            ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_LABEL)), isRecurring, Optional.empty());
                    } else {
                        isRecurring = true;
                        return new AddCommand(title, startDT, endDT,
                                ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_LABEL)), isRecurring,
                                    Optional.ofNullable(new Recurrence(argsTokenizer
                                            .getValue(PREFIX_RECURRENCE).get())));
                    }
                }
            }

            if (args.contains(PREFIX_DEADLINE.getPrefix())) {
                argsTokenizer = new ArgumentTokenizer(PREFIX_DEADLINE, PREFIX_LABEL, PREFIX_RECURRENCE);
                argsTokenizer.tokenize(args);
                String deadline = argsTokenizer.getValue(PREFIX_DEADLINE).get();
                Boolean isRecurring = false;

                if (isDateParseable(deadline)) {
                    title = argsTokenizer.getPreamble().get();
                    if (!args.contains(PREFIX_RECURRENCE.getPrefix())) {
                        return new AddCommand(title, deadline.trim(),
                            ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_LABEL)), isRecurring, Optional.empty());
                    } else {
                        isRecurring = true;
                        return new AddCommand(title, deadline.trim(),
                                ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_LABEL)), isRecurring,
                                Optional.ofNullable(new Recurrence(argsTokenizer.getValue(PREFIX_RECURRENCE).get())));
                    }
                }
            }
            return new AddCommand(title, ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_LABEL)));
        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        } catch (Exception e) {
            return new IncorrectCommand(e.getMessage());
        }
    }

}
```
###### \java\seedu\address\logic\parser\BookCommandParser.java
``` java
/**
* Parses input arguments and creates a new BookCommand object
*/
public class BookCommandParser extends Parser {

    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_BOOK_DATE, PREFIX_LABEL);
        argsTokenizer.tokenize(args);
        try {
            String title = argsTokenizer.getPreamble().get();
            return new BookCommand(title,
                    ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_LABEL)),
                    argsTokenizer.getValue(PREFIX_BOOK_DATE).get().split(","));
        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, BookCommand.MESSAGE_USAGE));
        } catch (Exception e) {
            return new IncorrectCommand(e.getMessage());
        }
    }
}
```
###### \java\seedu\address\logic\parser\ConfirmCommandParser.java
``` java
/**
* Parses input arguments and creates a new ConfirmCommand object
*/
public class ConfirmCommandParser extends Parser {

    private static final String DELIMITER = " ";
    private static final int ARGUMENT_LENGTH = 2;
    private static final String REGEX_INDEX = "^[0-9]*";

    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer();
        argsTokenizer.tokenize(args);
        try {
            String[] arguments = argsTokenizer.getPreamble().get().trim().split(DELIMITER);
            if (arguments.length != ARGUMENT_LENGTH) {
                throw new CommandException(ConfirmCommand.MESSAGE_USAGE);
            }

            if (arguments[0].matches(REGEX_INDEX)
                    && arguments[1].matches(REGEX_INDEX)) { //matches 0-9 for the first 2 characters
                int filteredTaskListIndex = tryParseAsIndex(arguments[0]);
                int bookingSlotIndex = tryParseAsIndex(arguments[1]);
                if (filteredTaskListIndex > 0 && bookingSlotIndex > 0) {
                    return new ConfirmCommand(filteredTaskListIndex, bookingSlotIndex);
                } else {
                    return new IncorrectCommand(
                            String.format(MESSAGE_INVALID_COMMAND_FORMAT, ConfirmCommand.MESSAGE_USAGE));
                }
            } else {
                return new IncorrectCommand(
                        String.format(MESSAGE_INVALID_COMMAND_FORMAT, ConfirmCommand.MESSAGE_USAGE));
            }
        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ConfirmCommand.MESSAGE_USAGE));
        } catch (Exception e) {
            return new IncorrectCommand(Messages.MESSAGE_INVALID_TASKS_DISPLAYED_INDEX);
        }
    }

    /**
     * Try parsing arguments as index
     */
    private int tryParseAsIndex(String args) {
        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (index.isPresent()) {
            return index.get();
        } else {
            return -1;
        }
    }
}
```
###### \java\seedu\address\logic\parser\EditBookingCommandParser.java
``` java
/**
* Parses input arguments and creates a new EditBookingCommand object
*/
public class EditBookingCommandParser {

    private static final String DATE_DELIMITER = ",";
    private static final String DELIMITER = " ";
    private static final int ARGUMENT_LENGTH = 3;
    private static final String REGEX_INDEX = "^[0-9]*";

    /**
     * Parses the given {@code String} of arguments in the context of the
     * EditLabelCommand and returns an EditLabelCommand object for execution.
     */
    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer();
        argsTokenizer.tokenize(args);
        try {
            String[] arguments = argsTokenizer.getPreamble().get().trim().split(DELIMITER);
            if (arguments.length < ARGUMENT_LENGTH) {
                throw new CommandException(ConfirmCommand.MESSAGE_USAGE);
            }

            if (arguments[0].matches(REGEX_INDEX)) {
                if (PREFIX_BOOK_ADD_DATE.getPrefix().equalsIgnoreCase(arguments[1])) {
                    argsTokenizer = new ArgumentTokenizer(PREFIX_BOOK_ADD_DATE);
                    argsTokenizer.tokenize(args);
                    String[] dates = argsTokenizer.getValue(PREFIX_BOOK_ADD_DATE).get().trim().split(DATE_DELIMITER);
                    return new EditBookingCommand(tryParseAsIndex(arguments[0]), dates);
                } else if (PREFIX_BOOK_REMOVE_DATE.getPrefix().equalsIgnoreCase(arguments[1])) {
                    if (arguments[2].matches(REGEX_INDEX)) {
                        int bookingSlotIndex = tryParseAsIndex(arguments[2]);
                        int listIndex = tryParseAsIndex(arguments[0]);
                        return new EditBookingCommand(listIndex, bookingSlotIndex);
                    }
                } else if (PREFIX_BOOK_CHANGE_DATE.getPrefix().equalsIgnoreCase(arguments[1])) {
                    if (arguments[2].matches(REGEX_INDEX)) {
                        String[] input = args.split(arguments[1] + " " + arguments[2]);
                        int bookingSlotIndex = tryParseAsIndex(arguments[2]);
                        int listIndex = tryParseAsIndex(arguments[0]);
                        if (bookingSlotIndex > 0 && listIndex > 0) {
                            return new EditBookingCommand(listIndex,
                                    bookingSlotIndex,
                                    input[1]);
                        }
                    }
                } else {
                    return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                            EditBookingCommand.MESSAGE_USAGE));
                }
            } else {
                throw new CommandException(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                        EditBookingCommand.MESSAGE_USAGE));
            }
        } catch (Exception e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    EditBookingCommand.MESSAGE_USAGE));
        }
        return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                EditBookingCommand.MESSAGE_USAGE));
    }

    /**
     * Try parsing arguments as index
     */
    private int tryParseAsIndex(String args) {
        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (index.isPresent()) {
            return index.get();
        } else {
            return -1;
        }
    }

}
```
###### \java\seedu\address\logic\parser\FindCommandParser.java
``` java
/**
 * Parses input arguments and creates a new FindCommand object
 */
public class FindCommandParser extends Parser {

    /**
     * Parses the given {@code String} of arguments in the context of the
     * FindCommand and returns an FindCommand object for execution.
     */
    public Command parse(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }

        try {
            ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_DEADLINE,
                    PREFIX_TIMEINTERVAL_START, PREFIX_TIMEINTERVAL_END);
            argsTokenizer.tokenize(args);
            if (args.trim().contains(PREFIX_TIMEINTERVAL_START.getPrefix())
                    && args.trim().contains(PREFIX_TIMEINTERVAL_END.getPrefix())) {
                return new FindCommand(argsTokenizer.getValue(PREFIX_TIMEINTERVAL_START).get(),
                        argsTokenizer.getValue(PREFIX_TIMEINTERVAL_END).get());
            } else if (args.trim().contains(PREFIX_DEADLINE.getPrefix())) {
                return new FindCommand(argsTokenizer.getValue(PREFIX_DEADLINE).get());
            }
        } catch (Exception e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindCommand(keywordSet);
    }

}
```
###### \java\seedu\address\logic\parser\ListCommandParser.java
``` java
/**
* Parses input arguments and creates a new ListCommand object
*/
public class ListCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the
     * FindCommand and returns an FindCommand object for execution.
     */
    public Command parse(String args) {
        try {
            ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_DEADLINE,
                    PREFIX_TIMEINTERVAL_START, PREFIX_TIMEINTERVAL_END, PREFIX_STATUS_COMPLETED,
                    PREFIX_STATUS_INCOMPLETE);
            argsTokenizer.tokenize(args);
            if (args.trim().contains(PREFIX_TIMEINTERVAL_START.getPrefix())
                    && args.trim().contains(PREFIX_TIMEINTERVAL_END.getPrefix())) {
                return new ListCommand(argsTokenizer.getValue(PREFIX_TIMEINTERVAL_START).get(),
                        argsTokenizer.getValue(PREFIX_TIMEINTERVAL_END).get());
            } else if (args.trim().contains(PREFIX_DEADLINE.getPrefix())) {
                return new ListCommand(argsTokenizer.getValue(PREFIX_DEADLINE).get());
            } else if (args.trim().contains(PREFIX_STATUS_COMPLETED.getPrefix())) {
                return new ListCommand(new Boolean(true));
            } else if (args.trim().contains(PREFIX_STATUS_INCOMPLETE.getPrefix())) {
                return new ListCommand(new Boolean(false));
            }
        } catch (Exception e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ListCommand.MESSAGE_USAGE));
        }

        return new ListCommand();
    }

}
```
###### \java\seedu\address\logic\parser\Parser.java
``` java
    public boolean isDateParseable(String input) {
        return !dtParser.parse(input).isEmpty();
    }

    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group("commandWord");
        final String arguments = matcher.group("arguments");
        switch (commandWord) {
        case AddCommand.COMMAND_WORD:
            return new AddCommandParser().parse(arguments);

        case EditLabelCommand.COMMAND_WORD:
            return new EditLabelCommandParser().parse(arguments);

        case EditCommand.COMMAND_WORD:
            return new EditCommandParser().parse(arguments);

        case SelectCommand.COMMAND_WORD:
            return new SelectCommandParser().parse(arguments);

        case DeleteCommand.COMMAND_WORD:
            return new DeleteCommandParser().parse(arguments);

        case ClearCommand.COMMAND_WORD:
            return new ClearCommand();

        case FindCommand.COMMAND_WORD:
            return new FindCommandParser().parse(arguments);

        case ListCommand.COMMAND_WORD:
            return new ListCommandParser().parse(arguments);

        case UndoCommand.COMMAND_WORD:
            return new UndoCommand();

        case BookCommand.COMMAND_WORD:
            return new BookCommandParser().parse(arguments);

        case EditBookingCommand.COMMAND_WORD:
            return new EditBookingCommandParser().parse(arguments);

        case ConfirmCommand.COMMAND_WORD:
            return new ConfirmCommandParser().parse(arguments);

        case ExitCommand.COMMAND_WORD:
            return new ExitCommand();

        case HelpCommand.COMMAND_WORD:
            return new HelpCommand();

        case MarkCommand.COMMAND_WORD:
            return new MarkCommandParser().parse(arguments);

        case LoadCommand.COMMAND_WORD:
            return new LoadCommand(arguments);

        case SaveAsCommand.COMMAND_WORD:
            return new SaveAsCommand(arguments);


        default:
            return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
        }
    }

}
```
###### \java\seedu\address\logic\undo\Undo.java
``` java
/**
 * Interface for undo command
 */
public interface Undo {

    /**
     * Undoes an command executed previously
     * @return UndoPair which contains the previous tasks and labels
     */
    UndoPair<ObservableList<ReadOnlyTask>, ObservableList<Label>> getUndoData();

    /**
     * Add old task state and old label state into undo storage history
     * @param currentTaskState - before execution
     * @param currentLabel - before execution
     */
    void addStorageHistory(ObservableList<ReadOnlyTask> currentTaskState, ObservableList<Label> currentLabelState);

    /**
     * Return true if the undo data structure is empty and false otherwise
     */
    boolean isEmpty();

    /**
     * Clears the data in the undo data structure
     */
    void clear();
}
```
###### \java\seedu\address\logic\undo\UndoManager.java
``` java
/**
 * A singleton UndoManager that implements a linkedlist of undoPair objects which essentially stores the data
 */
public class UndoManager implements Undo {

    private static UndoManager instance = null;
    private LinkedList<UndoPair<ObservableList<ReadOnlyTask>, ObservableList<Label>>> storageHistory;

    private UndoManager() {
        storageHistory = new LinkedList<UndoPair<ObservableList<ReadOnlyTask>, ObservableList<Label>>>();
    }

    public static UndoManager getInstance() {
        if (instance == null) {
            instance = new UndoManager();
        }
        return instance;
    }

    public void addStorageHistory(ObservableList<ReadOnlyTask> currentTasks, ObservableList<Label> currentLabels) {
        this.storageHistory.addLast(
                new UndoPair<ObservableList<ReadOnlyTask>,
                ObservableList<Label>>(currentTasks, currentLabels));
    }

    public boolean isEmpty() {
        return storageHistory.isEmpty();
    }

    public void clear() {
        storageHistory.clear();
    }

    @Override
    public UndoPair<ObservableList<ReadOnlyTask>, ObservableList<Label>> getUndoData() {
        return storageHistory.removeLast();
    }

}
```
###### \java\seedu\address\model\booking\Booking.java
``` java
/**
 * Represents a booking in DoOrDie Task Manager Application
 * Guarantees: immutable; dates are valid as declared in {@link #isDateParsable(String)}
 */
public class Booking implements Comparable<Booking> {

    public static final String MESSAGE_BOOKING_CONSTRAINTS =
            "Input dates are in the wrong format, please try again!";
    public static DateTimeParser dtParser;

    public boolean confirm;
    public Date startTime;
    public Date endTime;

    public Booking(String date) throws CommandException {
        dtParser = new DateTimeManager();
        if (isDateParseable(date)) {
            List<DateGroup> dateList = dtParser.parse(date);
            if (dateList.get(0).getDates().size() > 1) {
                this.startTime = dateList.get(0).getDates().get(0);
                this.endTime = dateList.get(0).getDates().get(1);
            } else {
                throw new CommandException(MESSAGE_BOOKING_CONSTRAINTS);
            }
        }
    }

    public Booking(Date startDate, Date endDate) {
        dtParser = new DateTimeManager();
        this.startTime = startDate;
        this.endTime = endDate;
    }

    public Date getBookingStartDate() {
        return this.startTime;
    }

    public Date getBookingEndDate() {
        return this.endTime;
    }

    public boolean isDateParseable(String date) {
        return !dtParser.parse(date).isEmpty();
    }

    /**
     * Format state as text for viewing.
     */
    public String toString() {
        SimpleDateFormat df = new SimpleDateFormat("EEE dd MMM yyyy h:mm a");
        return df.format(startTime).toString() + " to " + df.format(endTime).toString() + " ";
    }

    @Override
    public int compareTo(Booking compareObj) {
        return this.getBookingStartDate().compareTo(compareObj.getBookingStartDate());
    }

}
```
###### \java\seedu\address\model\booking\UniqueBookingList.java
``` java
/**
 * A list of bookings that enforces no nulls and uniqueness between its elements.
 *
 * Supports minimal set of list operations for the app's features.
 *
 * @see CollectionUtil#elementsAreUnique(Collection)
 */
public class UniqueBookingList implements Iterable<Booking>, Cloneable {
    private final ObservableList<Booking> internalList = FXCollections.observableArrayList();

    /**
     * Constructs empty BookingList.
     */
    public UniqueBookingList() {}

    /**
     * Creates a UniqueBookingList using given String bookings. Enforces no nulls or
     * duplicates.
     * @throws CommandException
     */
    public UniqueBookingList(String... bookings)
            throws DuplicateBookingException, IllegalValueException, CommandException {
        final List<Booking> bookingList = new ArrayList<Booking>();
        for (String booking : bookings) {
            bookingList.add(new Booking(booking));
        }
        sortBooklingList(bookingList);
        setBookings(bookingList);
    }

    /**
     * Creates a UniqueBookingList using given bookings. Enforces no nulls or
     * duplicates.
     */
    public UniqueBookingList(Booking... booking) throws DuplicateBookingException {
        assert !CollectionUtil.isAnyNull((Object[]) booking);
        final List<Booking> initialBookings = Arrays.asList(booking);
        if (!CollectionUtil.elementsAreUnique(initialBookings)) {
            throw new DuplicateBookingException();
        }
        sortBooklingList(initialBookings);
        internalList.addAll(initialBookings);
    }

    /**
     * Creates a UniqueBookingList using given bookings. Enforces no null or
     * duplicate elements.
     * @throws DuplicateBookingException
     */
    public UniqueBookingList(Collection<Booking> bookings) throws DuplicateBookingException {
        this();
        setBookings(bookings);
    }

    /**
     * Creates a UniqueBookingList using given bookings. Enforces no nulls.
     */
    public UniqueBookingList(Set<Booking> bookings) {
        assert !CollectionUtil.isAnyNull(bookings);
        final List<Booking> bookingList = new ArrayList<Booking>(bookings);
        sortBooklingList(bookingList);
        internalList.addAll(bookingList);
    }

    /**
     * Creates a copy of the given list. Insulates from changes in source.
     */
    public UniqueBookingList(UniqueBookingList source) {
        internalList.addAll(source.internalList);
    }

    /**
     * Returns all bookings in this list as a Set. This set is mutable and
     * change-insulated against the internal list.
     */
    public Set<Booking> toSet() {
        return new HashSet<>(internalList);
    }

    /**
     * Returns all bookings in this list as a List. This set is mutable and
     * change-insulated against the internal list.
     */
    public ArrayList<Booking> toList() {
        return new ArrayList<Booking>(internalList);
    }

    /**
     * Replaces the Tags in this list with those in the argument booking list.
     */
    public void setBookings(UniqueBookingList replacement) {
        this.internalList.setAll(replacement.internalList);
    }

    public void setBookings(Collection<Booking> bookings) throws DuplicateBookingException {
        assert !CollectionUtil.isAnyNull(bookings);
        if (!CollectionUtil.elementsAreUnique(bookings)) {
            throw new DuplicateBookingException();
        }
        internalList.setAll(bookings);
    }

    /**
     * Removes all bookings from the list. Warning, this cannot be undone!
     */
    public void removeAll() {
        internalList.clear();
    }

    @Override
    public UniqueBookingList clone() {
        UniqueBookingList bookingList = new UniqueBookingList();
        try {
            for (Booking booking : internalList) {
                bookingList.add(new Booking(booking.getBookingStartDate(), booking.getBookingEndDate()));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return bookingList;
    }

    /**
     * Ensures every booking in the argument list exists in this object.
     */
    public void mergeFrom(UniqueBookingList from) {
        final Set<Booking> alreadyInside = this.toSet();
        from.internalList.stream().filter(booking -> !alreadyInside.contains(booking)).forEach(internalList::add);
    }

    /**
     * Returns true if the list contains an equivalent Booking as the given
     * argument.
     */
    public boolean contains(Booking toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }

    /**
     * Returns true if the booking list contains an equivalent booking as the given
     * argument.
     */
    public boolean containsStringBooking(Booking bookingToCheck) {
        assert bookingToCheck != null;
        for (Booking booking : internalList) {
            if (booking.getBookingStartDate().equals(bookingToCheck.getBookingStartDate())
                    && booking.getBookingEndDate().equals(bookingToCheck.getBookingEndDate())) {
                return true;
            }
        }
        return false;
    }

    /**
     * Adds a booking to the list.
     *
     * @throws DuplicateBookingException
     *             if the booking to add is a duplicate of an existing booking in
     *             the list.
     */
    public void add(Booking toAdd) throws DuplicateBookingException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateBookingException();
        }
        internalList.add(toAdd);
    }

    @Override
    public Iterator<Booking> iterator() {
        return internalList.iterator();
    }

    public UnmodifiableObservableList<Booking> asObservableList() {
        return new UnmodifiableObservableList<>(internalList);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueBookingList // instanceof handles nulls
                        && this.internalList.equals(((UniqueBookingList) other).internalList));
    }

    public boolean equalsOrderInsensitive(UniqueBookingList other) {
        return this == other || new HashSet<>(this.internalList).equals(new HashSet<>(other.internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }

    public boolean isEmpty() {
        return internalList.isEmpty();
    }

    private void sortBooklingList(List<Booking> bookingList) {
        Collections.sort(bookingList);
    }

    /**
     * Signals that an operation would have violated the 'no duplicates'
     * property of the list.
     */
    public static class DuplicateBookingException extends DuplicateDataException {
        protected DuplicateBookingException() {
            super("Operation would result in duplicate bookings");
        }
    }

```
###### \java\seedu\address\model\Cloneable.java
``` java
public interface Cloneable <T> {
    public T clone();
}
```
###### \java\seedu\address\model\datastructure\PartialSearch.java
``` java
/**
 * This class will handle the partial search algorithm and the search function itself
 */
public class PartialSearch {

    private final Set<String> infixes = new HashSet<>();

    private String itemToSearch;

    public PartialSearch(String itemToSearch) {
        this.itemToSearch = itemToSearch;
        prepareSearch();
    }

    /**
     * This method prepares the infix set for search
     */
    public void prepareSearch() {
        for (int i = 0; i < itemToSearch.length(); i++) {
            for (int j = i + 1; j <= itemToSearch.length(); j++) {
                infixes.add(itemToSearch.substring(i, j).toLowerCase());
            }
        }
    }

    /**
     * This method does the search by matching the hash set for match
     * @param searchString
     * @return true if exist and false if otherwise
     */
    public boolean search(String searchString) { // O(1) search
        return infixes.contains(searchString.toLowerCase());
    }
}
```
###### \java\seedu\address\model\datastructure\UndoPair.java
``` java
/**
 * This class stores the command and the list of task as a pair
 */
public class UndoPair<Command, Data> {
    private final Command left;
    private final Data right;

    public UndoPair(Command left, Data right) {
        this.left = left;
        this.right = right;
    }

    public Command getLeft() {
        return this.left;
    }

    public Data getRight() {
        return this.right;
    }

    @Override
    public int hashCode() {
        return left.hashCode() ^ right.hashCode();
    }

    @Override
    public boolean equals(Object o) {
        if (!(o instanceof UndoPair)) {
            return false;
        }
        UndoPair pair = (UndoPair) o;
        return this.left.equals(pair.getLeft()) && this.right.equals(pair.getRight());
    }
}
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public void updateTask(int filteredTaskListIndex, ReadOnlyTask editedTask)
            throws UniqueTaskList.DuplicateTaskException {
        assert editedTask != null;
        int taskManagerIndex = filteredTasks.getSourceIndex(filteredTaskListIndex);
        taskManager.updateTask(taskManagerIndex, editedTask);
        indicateTaskManagerChanged();
    }

```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public void undoPrevious(ObservableList<ReadOnlyTask> oldTaskState, ObservableList<Label> oldLabelState)
            throws InvalidUndoCommandException {
        taskManager.undoData(oldTaskState, oldLabelState);
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
    }

    //=========== Filtered Task List Accessors =============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        sortFilteredTasks();
        return new UnmodifiableObservableList<>(filteredTasks);
    }

    @Override
    public void updateFilteredListToShowAll() {
        filteredTasks.setPredicate(null);
        sortFilteredTasks();
    }

    @Override
    public void updateFilteredTaskList(Date startDate, Date endDate) {
        updateFilteredTaskListByDate(new DateFilter(startDate, endDate));
    }

    private void updateFilteredTaskList(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
    }

    @Override
    public void updateFilteredTaskList(Set<String> keywords) {
        updateFilteredTaskList(new PredicateExpression(new NameQualifier(keywords)));
        sortFilteredTasks();
    }

    @Override
    public void updateFilteredTaskList(Boolean isCompleted) {
        updateFilteredTaskListByCompletion(new StatusFilter(isCompleted));
        sortFilteredTasks();
    }

    private void updateFilteredTaskListByDate(DateFilter dateFilter) {
        filteredTasks.setPredicate(dateFilter::run);
    }

    private void updateFilteredTaskListByCompletion(StatusFilter statusFilter) {
        filteredTasks.setPredicate(statusFilter::run);
    }

    //========== Inner classes/interfaces used for filtering =================================================

    interface Expression {
        boolean satisfies(ReadOnlyTask task);
        String toString();
    }

    private class PredicateExpression implements Expression {

        private final Qualifier qualifier;

        PredicateExpression(Qualifier qualifier) {
            this.qualifier = qualifier;
        }

        @Override
        public boolean satisfies(ReadOnlyTask task) {
            return qualifier.run(task);
        }

        @Override
        public String toString() {
            return qualifier.toString();
        }
    }

    interface Qualifier {
        boolean run(ReadOnlyTask task);
        String toString();
    }

    private class NameQualifier implements Qualifier {
        private Set<String> nameKeyWords;

        NameQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
        }

```
###### \java\seedu\address\model\ModelManager.java
``` java
        @Override
        public boolean run(ReadOnlyTask task) {
            String taskDetails = task.getAsSearchText();
            PartialSearch partialSearch = new PartialSearch(taskDetails);
            return (nameKeyWords.stream()
                    .filter(keyword -> partialSearch.search(keyword))
                    .findAny()
                    .isPresent());
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords);
        }
    }

```
###### \java\seedu\address\model\ModelManager.java
``` java
    private class DateFilter {
        private Date startTime;
        private Date endTime;

        DateFilter(Date startTime, Date endTime) {
            this.startTime = startTime;
            this.endTime = endTime;
        }

        public boolean run(ReadOnlyTask task) {
            if (task.getDeadline().isPresent() && task.getStartTime().isPresent()) {
                return (task.getDeadline().get().getDateTime().before(endTime)
                        && task.getDeadline().get().getDateTime().after(startTime))
                        || task.getDeadline().get().getDateTime().equals(endTime);
            } else if (task.getDeadline().isPresent()) {
                return task.getDeadline().get().getDateTime().before(endTime)
                        || task.getDeadline().get().getDateTime().equals(endTime);
            }
            return false;
        }
    }

```
###### \java\seedu\address\model\task\Deadline.java
``` java
    /**
     * Validates given deadline.
     *
     * @throws IllegalValueException
     *             if given deadline string is invalid.
     * @throws IllegalDateTimeValueException
     *             if given deadline could be parse to a valid date
     */
    public Deadline(String strDeadline) throws IllegalValueException, IllegalDateTimeValueException {
        assert strDeadline != null;
        if (!isValidDeadline(strDeadline)) {
            throw new IllegalValueException(MESSAGE_DEADLINE_CONSTRAINTS);
        } else {
            if (!isEmptyDeadline(strDeadline)) {
                try {
                    List<Date> dateList;
                    if (dateParser.parse(strDeadline).get(0).isTimeInferred()) {
                        dateList = dateParser.parse(strDeadline + " " + DEFAULT_ENDTIME).get(0).getDates();
                    } else {
                        dateList = dateParser.parse(strDeadline).get(0).getDates();
                    }

                    if (dateList != null && dateList.size() > 0) {
                        this.deadline = dateList.get(0);
                        this.value = deadline.toString();
                    }
                } catch (Exception e) {
                    throw new IllegalDateTimeValueException();
                }
            } else {
                value = "";
            }
        }
    }

    /**
     * Returns true if a given string is a valid deadline.
     */
    public static boolean isValidDeadline(String test) {
        return test.matches(DEADLINE_VALIDATION_REGEX);
    }

    /**
     * Returns true if a given string has no date.
     */
    public static boolean isEmptyDeadline(String test) {
        return test.equals("");
    }

    /**
     * Returns true if a given string is a valid date.
     */
    public static boolean isParsableDate(String test) {
        return !dateParser.parse(test).isEmpty();
    }

    public Date getDateTime() {
        return deadline;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        if (other instanceof Deadline) {
            if (this.deadline != null && ((Deadline) other).deadline != null) {
                return other == this // short circuit if same object
                        || (other instanceof Deadline // instanceof handles nulls
                                && this.deadline.equals(((Deadline) other).deadline)); // state check
            } else {
                return true;
            }
        }
        return false;
    }

    @Override
    public int hashCode() {
        return deadline.hashCode();
    }

}
```
###### \java\seedu\address\ui\LabelCard.java
``` java
/**
 * LabelCard controller for each individual label on the Left Panel
 */
public class LabelCard extends UiPart<Region> {

    private static final String FXML = "LabelCard.fxml";

    @FXML
    private Label labelText;

    @FXML
    private FontAwesomeIconView icon;

    @FXML
    private Label taskCountText;

    public LabelCard(seedu.address.model.label.Label labels, int count) {
        super(FXML);
        initLabel(labels, count);
    }

```
###### \java\seedu\address\ui\LeftPanel.java
``` java
    public LeftPanel(AnchorPane leftListPlaceholder,
            ObservableList<ReadOnlyTask> taskList) {
        super(FXML);
        this.taskList = taskList;
        initIcons();
        updateLabelCount();
        setTodayListView(taskList);
        setCalendarListView(taskList);
        addToPlaceholder(leftListPlaceholder);
        registerAsAnEventHandler(this);
        setEventHandlerForSelectionChangeEvent();
    }

```
###### \java\seedu\address\ui\LeftPanel.java
``` java
    @SuppressWarnings("deprecation")
    public void setTodayListView(ObservableList<ReadOnlyTask> taskList) {
        todayLabel.setText("Today");
        int count = 0;
        Date endTime = new Date(2222, 1, 1);
        Date startDate = new Date();
        endTime.setHours(23);
        endTime.setMinutes(59);
        endTime.setSeconds(59);
        startDate.setHours(0);
        startDate.setMinutes(0);
        startDate.setSeconds(0);

        // Add all tasks that is not completed and deadline is after today
        for (ReadOnlyTask task : taskList) {
            if (task.getDeadline().isPresent() && task.getStartTime().isPresent()) {
                if ((task.getDeadline().get().getDateTime().before(endTime)
                        && task.getDeadline().get().getDateTime().after(startDate))
                        || task.getDeadline().get().getDateTime().equals(endTime)) {
                    count++;
                }
            } else if (task.getDeadline().isPresent()) {
                if (task.getDeadline().get().getDateTime().before(endTime)
                        || task.getDeadline().get().getDateTime().equals(endTime)) {
                    count++;
                }
            }
        }
        todayCounterLabel.setText(Integer.toString(count));
        setEventHandlerForTodaySelectionChangeEvent();
    }

```
###### \java\seedu\address\ui\LeftPanel.java
``` java
    private void setEventHandlerForSelectionChangeEvent() {
        labelListView.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue != null) {
                logger.fine("Selection in label left list panel changed to : '" + newValue + "'");
                raise(new LeftPanelSelectionChangedEvent(newValue));
            }
        });
    }

    private void setEventHandlerForTodaySelectionChangeEvent() {
        todayHeader.setOnMouseClicked(new EventHandler<MouseEvent>() {
            @Override
            public void handle(MouseEvent event) {
                logger.fine("Selection in label left list panel changed to : 'Today'");
                raise(new LeftPanelTodaySelectionChangedEvent());
            }
        });
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            labelListView.scrollTo(index);
            labelListView.getSelectionModel().clearAndSelect(index);
        });
    }

    @Subscribe
    public void handleTaskManagerChangedEvent(TaskManagerChangedEvent tmce) {
        updateLabelCount();
        setTodayListView(taskList);
        logger.info(LogsCenter.getEventHandlingLogMessage(tmce,
                "Updating label list count and total number of tasks for today"));
    }

```
###### \resources\view\MainWindow.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Menu?>
<?import javafx.scene.control.MenuBar?>
<?import javafx.scene.control.MenuItem?>
<?import javafx.scene.control.SplitPane?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.VBox?>

<VBox xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <stylesheets>
      <URL value="@DarkTheme.css" />
      <URL value="@Extensions.css" />
   </stylesheets>
   <children>
      <MenuBar VBox.vgrow="NEVER">
         <menus>
            <Menu mnemonicParsing="false" text="File">
               <items>
                  <MenuItem mnemonicParsing="false" onAction="#handleExit" text="Exit" />
               </items>
            </Menu>
            <Menu mnemonicParsing="false" text="Help">
               <items>
                  <MenuItem fx:id="helpMenuItem" mnemonicParsing="false" onAction="#handleHelp" text="Help" />
               </items>
            </Menu>
         </menus>
      </MenuBar>
      <SplitPane id="splitPane" fx:id="contentSplitPane" dividerPositions="0.4" VBox.vgrow="ALWAYS">
         <items>
            <VBox maxWidth="-Infinity" minWidth="-Infinity" prefHeight="1300.0" prefWidth="300.0" style="-fx-max-width: 250; -fx-min-width: 250;" SplitPane.resizableWithParent="false">
               <children>
                  <AnchorPane fx:id="leftPanelPlaceholder" prefHeight="1300.0" prefWidth="100.0" />
               </children>
            </VBox>
            <VBox>
               <children>
                  <AnchorPane fx:id="commandBoxPlaceholder" styleClass="anchor-pane-with-border">
                     <padding>
                        <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
                     </padding>
                  </AnchorPane>
                   <AnchorPane fx:id="resultDisplayPlaceholder" maxHeight="100" minHeight="100" prefHeight="100" styleClass="anchor-pane-with-border">
                   </AnchorPane>
                  <VBox fx:id="taskList" prefHeight="1200.0">
                     <children>
                        <AnchorPane fx:id="taskListPanelPlaceholder" VBox.vgrow="ALWAYS" />
                     </children>
                  </VBox>
               </children>
            </VBox>
         </items></SplitPane>
      <AnchorPane fx:id="statusbarPlaceholder" />
   </children>
</VBox>
```
