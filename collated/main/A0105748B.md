# A0105748B
###### \java\seedu\bulletjournal\logic\commands\AddCommand.java
``` java
    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException
     *             if any of the raw values are invalid
     */
    public AddCommand(String taskname, String duedate, String status, String begindate, Set<String> tags)
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(new TaskName(taskname), duedate == null ?
                null : new DueDate(duedate), status == null ?
                null : new Status(status), begindate == null ?
                null : new BeginDate(begindate), new UniqueTagList(tagSet));
    }
```
###### \java\seedu\bulletjournal\logic\commands\FinishCommand.java
``` java
package seedu.bulletjournal.logic.commands;

import java.util.List;
import java.util.Optional;

import seedu.bulletjournal.commons.core.Messages;
import seedu.bulletjournal.commons.util.CollectionUtil;
import seedu.bulletjournal.logic.commands.exceptions.CommandException;
import seedu.bulletjournal.model.tag.UniqueTagList;
import seedu.bulletjournal.model.task.BeginDate;
import seedu.bulletjournal.model.task.DueDate;
import seedu.bulletjournal.model.task.ReadOnlyTask;
import seedu.bulletjournal.model.task.Status;
import seedu.bulletjournal.model.task.Task;
import seedu.bulletjournal.model.task.TaskName;
import seedu.bulletjournal.model.task.UniqueTaskList;

/**
 * Change task's status to "done".
 */
public class FinishCommand extends Command {

    public static final String COMMAND_WORD = "finish";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks the task as done identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_FINISH_TASK_SUCCESS = "Finished Task: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the todo list.";

    private final int filteredTaskListIndex;
    private final EditTaskDescriptor editTaskDescriptor;

    /**
     * @param filteredTaskListIndex
     *            the index of the task in the filtered task list to edit
     * @param editTaskDescriptor
     *            details to edit the task with
     */
    public FinishCommand(int filteredTaskListIndex, EditTaskDescriptor editTaskDescriptor) {
        assert filteredTaskListIndex > 0;
        assert editTaskDescriptor != null;

        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;

        this.editTaskDescriptor = new EditTaskDescriptor(editTaskDescriptor);
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = lastShownList.get(filteredTaskListIndex);
        Task editedTask = createEditedTask(taskToEdit, editTaskDescriptor);

        try {
            model.updateTask(filteredTaskListIndex, editedTask);
        } catch (UniqueTaskList.DuplicateTaskException dpe) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
        model.updateFilteredListToShowUndone();
        return new CommandResult(String.format(MESSAGE_FINISH_TASK_SUCCESS, taskToEdit));
    }

    /**
     * Creates and returns a {@code Task} with the details of
     * {@code taskToEdit} edited with {@code editTaskDescriptor}.
     */
    private static Task createEditedTask(ReadOnlyTask taskToEdit, EditTaskDescriptor editTaskDescriptor) {
        assert taskToEdit != null;

        TaskName updatedName = editTaskDescriptor.getTaskName().orElseGet(taskToEdit::getTaskName);
        DueDate updatedPhone = editTaskDescriptor.getPhone().orElseGet(taskToEdit::getPhone);
        Status updatedEmail = editTaskDescriptor.getStatus().orElseGet(taskToEdit::getStatus);
        BeginDate updatedAddress = editTaskDescriptor.getAddress().orElseGet(taskToEdit::getAddress);
        UniqueTagList updatedTags = editTaskDescriptor.getTags().orElseGet(taskToEdit::getTags);

        return new Task(updatedName, updatedPhone, updatedEmail, updatedAddress, updatedTags);
    }

    /**
     * Stores the details to edit the task with. Each non-empty field value
     * will replace the corresponding field value of the task.
     */
    public static class EditTaskDescriptor {
        private Optional<TaskName> taskName = Optional.empty();
        private Optional<DueDate> dueDate = Optional.empty();
        private Optional<Status> status = Optional.empty();
        private Optional<BeginDate> beginDate = Optional.empty();
        private Optional<UniqueTagList> tags = Optional.empty();

        public EditTaskDescriptor() {
        }

        public EditTaskDescriptor(EditTaskDescriptor toCopy) {
            this.taskName = toCopy.getTaskName();
            this.dueDate = toCopy.getPhone();
            this.status = toCopy.getStatus();
            this.beginDate = toCopy.getAddress();
            this.tags = toCopy.getTags();
        }

        /**
         * Returns true if at least one field is edited.
         */
        public boolean isAnyFieldEdited() {
            return CollectionUtil.isAnyPresent(this.taskName, this.dueDate, this.status, this.beginDate, this.tags);
        }

        public void setName(Optional<TaskName> taskName) {
            assert taskName != null;
            this.taskName = taskName;
        }

        public Optional<TaskName> getTaskName() {
            return taskName;
        }

        public void setPhone(Optional<DueDate> dueDate) {
            assert dueDate != null;
            this.dueDate = dueDate;
        }

        public Optional<DueDate> getPhone() {
            return dueDate;
        }

        public void setEmail(Optional<Status> status) {
            assert status != null;
            this.status = status;
        }

        public Optional<Status> getStatus() {
            return status;
        }

        public void setAddress(Optional<BeginDate> beginDate) {
            assert beginDate != null;
            this.beginDate = beginDate;
        }

        public Optional<BeginDate> getAddress() {
            return beginDate;
        }

        public void setTags(Optional<UniqueTagList> tags) {
            assert tags != null;
            this.tags = tags;
        }

        public Optional<UniqueTagList> getTags() {
            return tags;
        }
    }
}
```
###### \java\seedu\bulletjournal\logic\commands\ShowCommand.java
``` java
package seedu.bulletjournal.logic.commands;

import java.util.Set;

/**
 * Finds and lists all tasks that are done or undone.
 * Keyword matching is case insensitive.
 */
public class ShowCommand extends Command {

    public static final String COMMAND_WORD = "show";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks that are "
            + "done or undone (case-insensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD\n"
            + "Example: " + COMMAND_WORD + " done";

    private final Set<String> keywords;

    public ShowCommand(Set<String> keywords) {
        this.keywords = keywords;
        if (this.keywords.contains("undone")) {
            keywords.add("empty");
        }
    }

    @Override
    public CommandResult execute() {
        model.updateMatchedTaskList(keywords);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

}
```
###### \java\seedu\bulletjournal\logic\LogicManager.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getUndoneTaskList() {
        return model.getUndoneTaskList();
    }
}
```
###### \java\seedu\bulletjournal\logic\parser\AddCommandParser.java
``` java
    /**
     * Parses the given {@code String} of arguments in the context of the AddCommand
     * and returns an AddCommand object for execution.
     */
    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer(PREFIX_DEADLINE, PREFIX_STATUS, PREFIX_BEGINTIME, PREFIX_TAG);
        argsTokenizer.tokenize(args);
        try {
            return new AddCommand(
                    argsTokenizer.getPreamble().get(),
                    argsTokenizer.getValue(PREFIX_DEADLINE).isPresent() ?
                            argsTokenizer.getValue(PREFIX_DEADLINE).get() : null,
                    argsTokenizer.getValue(PREFIX_STATUS).isPresent() ?
                            argsTokenizer.getValue(PREFIX_STATUS).get() : null,
                    argsTokenizer.getValue(PREFIX_BEGINTIME).isPresent() ?
                            argsTokenizer.getValue(PREFIX_BEGINTIME).get() : null,
                    ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG))
            );
        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

}
```
###### \java\seedu\bulletjournal\logic\parser\CliSyntax.java
``` java
    /* Prefix definitions */
    public static final Prefix PREFIX_DEADLINE = new Prefix("d/");
    public static final Prefix PREFIX_STATUS = new Prefix("s/");
    public static final Prefix PREFIX_BEGINTIME = new Prefix("b/");
    public static final Prefix PREFIX_TAG = new Prefix("t/");

    /* Patterns definitions */
    public static final Pattern KEYWORDS_ARGS_FORMAT =
            Pattern.compile("(?<keywords>\\S+(?:\\s+\\S+)*)"); // one or more keywords separated by whitespace

```
###### \java\seedu\bulletjournal\logic\parser\CliSyntax.java
``` java
    /* Patterns definition for show command */
    public static final Pattern KEYWORDS_SHOW_FORMAT =
            Pattern.compile("(done|undone)", Pattern.CASE_INSENSITIVE);

    /* Patterns definition for finish command args */
    public static final Pattern FINISH_ARGS_FORMAT =
            Pattern.compile("^\\d+$");
}
```
###### \java\seedu\bulletjournal\logic\parser\DateParser.java
``` java
package seedu.bulletjournal.logic.parser;

import java.util.Date;
import java.util.List;
import java.util.TimeZone;

import com.joestelmach.natty.DateGroup;
import com.joestelmach.natty.Parser;

/**
 * A Parser class that implements natty library to convert string objects into
 * dates. Returns a null date object if the argument is not recognized as a
 * date.
 */
public class DateParser {

    private static Parser dateParser = new Parser(TimeZone.getDefault());

    /**
     * Parses date object from a string. Only parses first recognised date
     * instance.
     */
    public static Date parse(String date) {
        List<DateGroup> parsedDates = dateParser.parse(date);

        if (parsedDates != null && !parsedDates.isEmpty()) {
            return parsedDates.get(0).getDates().get(0);
        } else {
            return null;
        }
    }
}
```
###### \java\seedu\bulletjournal\logic\parser\FinishCommandParser.java
``` java
package seedu.bulletjournal.logic.parser;

import static seedu.bulletjournal.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.bulletjournal.logic.parser.CliSyntax.FINISH_ARGS_FORMAT;
import static seedu.bulletjournal.logic.parser.CliSyntax.PREFIX_BEGINTIME;
import static seedu.bulletjournal.logic.parser.CliSyntax.PREFIX_DEADLINE;
import static seedu.bulletjournal.logic.parser.CliSyntax.PREFIX_STATUS;
import static seedu.bulletjournal.logic.parser.CliSyntax.PREFIX_TAG;

import java.util.List;
import java.util.Optional;
import java.util.regex.Matcher;

import seedu.bulletjournal.commons.exceptions.IllegalValueException;
import seedu.bulletjournal.logic.commands.Command;
import seedu.bulletjournal.logic.commands.FinishCommand;
import seedu.bulletjournal.logic.commands.FinishCommand.EditTaskDescriptor;
import seedu.bulletjournal.logic.commands.IncorrectCommand;

/**
 * Parses input arguments and creates a new FinishCommand object
 */
public class FinishCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the
     * FinishCommand and returns an FinishCommand object for execution.
     */
    public Command parse(String idx) {
        assert idx != null;
        final Matcher matcher = FINISH_ARGS_FORMAT.matcher(idx.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, FinishCommand.MESSAGE_USAGE));
        }
        String newArgs = idx + " s/done";
        ArgumentTokenizer argsTokenizer
            = new ArgumentTokenizer(PREFIX_DEADLINE, PREFIX_STATUS, PREFIX_BEGINTIME, PREFIX_TAG);
        argsTokenizer.tokenize(newArgs);
        List<Optional<String>> preambleFields = ParserUtil.splitPreamble(argsTokenizer.getPreamble().orElse(""), 2);

        Optional<Integer> index = preambleFields.get(0).flatMap(ParserUtil::parseIndex);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FinishCommand.MESSAGE_USAGE));
        }

        EditTaskDescriptor editTaskDescriptor = new EditTaskDescriptor();
        try {
            editTaskDescriptor.setEmail(ParserUtil.parseEmail(argsTokenizer.getValue(PREFIX_STATUS)));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }

        return new FinishCommand(index.get(), editTaskDescriptor);
    }
}
```
###### \java\seedu\bulletjournal\logic\parser\ShowCommandParser.java
``` java
package seedu.bulletjournal.logic.parser;

import static seedu.bulletjournal.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.bulletjournal.logic.parser.CliSyntax.KEYWORDS_SHOW_FORMAT;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Matcher;

import seedu.bulletjournal.logic.commands.Command;
import seedu.bulletjournal.logic.commands.IncorrectCommand;
import seedu.bulletjournal.logic.commands.ShowCommand;

/**
 * Parses input arguments and creates a new ShowCommand object
 */
public class ShowCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the ShowCommand
     * and returns an ShowCommand object for execution.
     */
    public Command parse(String args) {
        final Matcher matcher = KEYWORDS_SHOW_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ShowCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group().split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new ShowCommand(keywordSet);
    }

}
```
###### \java\seedu\bulletjournal\model\Model.java
``` java
    /** Returns the undone task list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */

    UnmodifiableObservableList<ReadOnlyTask> getUndoneTaskList();

    /** Updates the filter of the filtered task list to show all tasks */
    void updateFilteredListToShowAll();

    /** Updates the filter of the filtered task list to show undone tasks */
    void updateFilteredListToShowUndone();

    /**
     * Updates the filter of the filtered task list to filter by the given
     * keywords
     */
    void updateFilteredTaskList(Set<String> keywords);

    /**
     * Updates the filter of the filtered task list to filter by the given
     * keywords
     */
    void updateMatchedTaskList(Set<String> keywords);

    /** Updates the file path for current storage manager of the model. */
    void changeDirectory(String filePath);

}
```
###### \java\seedu\bulletjournal\model\ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getUndoneTaskList() {
        String[] keywords = new String[2];
        keywords[0] = "undone";
        keywords[1] = "empty";
        Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        updateMatchedTaskList(keywordSet);
        return new UnmodifiableObservableList<>(filteredTasks);
    }

    @Override
    public void updateFilteredListToShowUndone() {
        String[] keywords = new String[2];
        keywords[0] = "undone";
        keywords[1] = "empty";
        Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        updateMatchedTaskList(keywordSet);
    }

    @Override
    public void updateFilteredListToShowAll() {
        filteredTasks.setPredicate(null);
    }

    @Override
    public void updateFilteredTaskList(Set<String> keywords) {
        updateFilteredTaskList(new PredicateExpression(new NameQualifier(keywords)));
    }

    private void updateFilteredTaskList(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
    }

```
###### \java\seedu\bulletjournal\model\ModelManager.java
``` java
    @Override
    public void updateMatchedTaskList(Set<String> keywords) {
        updateMatchedTaskList(new PredicateExpression(new StatusQualifier(keywords)));
    }

    private void updateMatchedTaskList(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
    }
```
###### \java\seedu\bulletjournal\model\ModelManager.java
``` java

    private class NameQualifier implements Qualifier {
        private Set<String> nameKeyWords;

        NameQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(task.getTaskName().fullName, keyword))
                    .findAny().isPresent();
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords);
        }
    }

    private class StatusQualifier implements Qualifier {
        private Set<String> statusKeyWords;

        StatusQualifier(Set<String> nameKeyWords) {
            this.statusKeyWords = nameKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return statusKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(
                            task.getStatus() == null ? "empty" : task.getStatus().value, keyword))
                    .findAny().isPresent();
        }

        @Override
        public String toString() {
            return "status=" + String.join(", ", statusKeyWords);
        }
    }

    @Override
    public void changeDirectory(String filePath) {
        raise(new FilePathChangedEvent(filePath));
    }

}
```
###### \java\seedu\bulletjournal\model\task\BeginDate.java
``` java
package seedu.bulletjournal.model.task;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

import seedu.bulletjournal.commons.exceptions.IllegalValueException;
import seedu.bulletjournal.logic.parser.DateParser;

/**
 * Represents a Task's begin date in the bullet journal.
 * Guarantees: immutable; is valid as declared in {@link #isValidBeginDate(String)}
 */
public class BeginDate {

    public static final String MESSAGE_BEGINDATE_CONSTRAINTS =
            "Unrecognised date and time for begin date!";

    private static DateFormat outputFormatter = new SimpleDateFormat("dd-MMM-yyyy, HH:mm (EEE)");

    /*
     * The first character of the begin date must not be a whitespace,
     * otherwise " " (a blank string) becomes a valid input.
     */
    public static final String BEGINDATE_VALIDATION_REGEX = "[^\\s].*";

    public final Date value;

    /**
     * Validates given begin date.
     *
     * @throws IllegalValueException if given address string is invalid.
     */
    public BeginDate(String beginDate) throws IllegalValueException {
        assert beginDate != null;
        if (!isValidBeginDate(beginDate)) {
            throw new IllegalValueException(MESSAGE_BEGINDATE_CONSTRAINTS);
        }
        this.value = DateParser.parse(beginDate);
        if (this.value == null) {
            throw new IllegalValueException(MESSAGE_BEGINDATE_CONSTRAINTS);
        }
    }

    /**
     * Returns true if a given string is a valid task begin date.
     */
    public static boolean isValidBeginDate(String test) {
        return test.matches(BEGINDATE_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        String beginDateString = outputFormatter.format(value);
        return beginDateString;
    }

```
###### \java\seedu\bulletjournal\model\task\DueDate.java
``` java
package seedu.bulletjournal.model.task;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

import seedu.bulletjournal.commons.exceptions.IllegalValueException;
import seedu.bulletjournal.logic.parser.DateParser;

/**
 * Represents a Task's due date in the todo list.
 * Guarantees: immutable; is valid as declared in {@link #isValidDueDate(String)}
 */
public class DueDate {

    public static final String MESSAGE_DUEDATE_CONSTRAINTS =
            "Unrecognised date and time for due date!";

    private static DateFormat outputFormatter = new SimpleDateFormat("dd-MMM-yyyy, HH:mm (EEE)");

    /*
     * The first character of the due date must not be a whitespace,
     * otherwise " " (a blank string) becomes a valid input.
     */
    public static final String DUEDATE_VALIDATION_REGEX = "[^\\s].*";

    public final Date value;

    /**
     * Validates given due date.
     *
     * @throws IllegalValueException if given due date string is invalid.
     */
    public DueDate(String due) throws IllegalValueException {
        assert due != null;
        String trimmedDue = due.trim();
        if (!isValidDueDate(trimmedDue)) {
            throw new IllegalValueException(MESSAGE_DUEDATE_CONSTRAINTS);
        }
        this.value = DateParser.parse(trimmedDue);
        if (this.value == null) {
            throw new IllegalValueException(MESSAGE_DUEDATE_CONSTRAINTS);
        }
    }

    /**
     * Returns true if a given string is a valid task phone number.
     */
    public static boolean isValidDueDate(String test) {
        return test.matches(DUEDATE_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        String dueDateString = outputFormatter.format(value);
        return dueDateString;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DueDate // instanceof handles nulls
                && this.value.equals(((DueDate) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### \java\seedu\bulletjournal\model\task\ReadOnlyTask.java
``` java
    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getTaskName().equals(this.getTaskName()) // state checks here onwards
                && (other.getPhone() == null ?
                        "" : other.getPhone()).equals(this.getPhone() == null ?
                                "" : this.getPhone())
                && (other.getStatus() == null ?
                        "" : other.getStatus()).equals(this.getStatus() == null ?
                                "" : this.getStatus())
                && (other.getAddress() == null ?
                        "" : other.getAddress()).equals(this.getAddress() == null ?
                                "" : this.getAddress()));
    }
```
###### \java\seedu\bulletjournal\model\task\Status.java
``` java
package seedu.bulletjournal.model.task;


import seedu.bulletjournal.commons.exceptions.IllegalValueException;

/**
 * Email morphed into completion status of task
 * Represents a Task's status in the task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidStatus(String)}
 */
public class Status {

    public static final String MESSAGE_STATUS_CONSTRAINTS =
            "Task status should be done/undone.";
    public static final String STATUS_VALIDATION_REGEX = "(done|undone)";

    public final String value;

    /**
     * Validates given status.
     *
     * @throws IllegalValueException if given status string is invalid.
     */
    public Status(String status) throws IllegalValueException {
        assert status != null;
        String trimmedEmail = status.trim().toLowerCase();
        if (!isValidStatus(trimmedEmail)) {
            throw new IllegalValueException(MESSAGE_STATUS_CONSTRAINTS);
        }
        this.value = trimmedEmail;
    }
```
###### \java\seedu\bulletjournal\storage\XmlAdaptedTask.java
``` java
package seedu.bulletjournal.storage;

import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.annotation.XmlElement;

import seedu.bulletjournal.commons.exceptions.IllegalValueException;
import seedu.bulletjournal.model.tag.Tag;
import seedu.bulletjournal.model.tag.UniqueTagList;
import seedu.bulletjournal.model.task.BeginDate;
import seedu.bulletjournal.model.task.DueDate;
import seedu.bulletjournal.model.task.ReadOnlyTask;
import seedu.bulletjournal.model.task.Status;
import seedu.bulletjournal.model.task.Task;
import seedu.bulletjournal.model.task.TaskName;

/**
 * JAXB-friendly version of the Task.
 */
public class XmlAdaptedTask {

    @XmlElement(required = true)
    private String name;
    @XmlElement(required = false)
    private String phone;
    @XmlElement(required = false)
    private String email;
    @XmlElement(required = false)
    private String address;

    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();

    /**
     * Constructs an XmlAdaptedTask.
     * This is the no-arg constructor that is required by JAXB.
     */
    public XmlAdaptedTask() {}


    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        name = source.getTaskName().fullName;
        phone = source.getPhone() == null ? null : source.getPhone().toString();
        email = source.getStatus() == null ? null : source.getStatus().value;
        address = source.getAddress() == null ? null : source.getAddress().toString();
        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        final TaskName taskName = new TaskName(this.name);
        final DueDate dueDate = this.phone == null ? null : new DueDate(this.phone);
        final Status status = this.email == null ? null : new Status(this.email);
        final BeginDate beginDate = this.address == null ? null : new BeginDate(this.address);
        final UniqueTagList tags = new UniqueTagList(taskTags);
        return new Task(taskName, dueDate, status, beginDate, tags);
    }
}
```
###### \java\seedu\bulletjournal\ui\MainWindow.java
``` java
    /**
     * Decides what to show on main window when the application initializes.
     */
    public void fillInnerPartsAtStart() {
        browserPanel = new BrowserPanel(browserPlaceholder);
        taskListPanel = new TaskListPanel(getTaskListPlaceholder(), logic.getUndoneTaskList());
        new ResultDisplay(getResultDisplayPlaceholder());
        new StatusBarFooter(getStatusbarPlaceholder(), config.getBulletJournalFilePath());
        new CommandBox(getCommandBoxPlaceholder(), logic);
    }
```
###### \java\seedu\bulletjournal\ui\TaskCard.java
``` java

    public TaskCard(ReadOnlyTask task, int displayedIndex) {
        super(FXML);
        name.setText(task.getTaskName().fullName);
        id.setText(displayedIndex + ". ");
        phone.setText(task.getPhone() == null ? "" : task.getPhone().toString());
        address.setText(task.getAddress() == null ? "" : task.getAddress().toString());
        email.setText(task.getStatus() == null ? "" : task.getStatus().value);
        initTags(task);
    }

    private void initTags(ReadOnlyTask task) {
        task.getTags().forEach(tag -> tags.getChildren().add(new Label(tag.tagName)));
    }
}
```
