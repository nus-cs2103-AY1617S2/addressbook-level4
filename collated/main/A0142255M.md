# A0142255M
###### \java\seedu\tache\commons\events\storage\DataFileLocationChangedEvent.java
``` java

package seedu.tache.commons.events.storage;

import seedu.tache.commons.events.BaseEvent;

/**
 * Indicates that the directory of the data file has been changed.
 */
public class DataFileLocationChangedEvent extends BaseEvent {

    public String newLocation;

    public DataFileLocationChangedEvent(String newLocation) {
        assert newLocation != null;
        this.newLocation = newLocation;
    }

    @Override
    public String toString() {
        return newLocation;
    }

}
```
###### \java\seedu\tache\commons\events\ui\CalendarNextRequestEvent.java
``` java
package seedu.tache.commons.events.ui;

import seedu.tache.commons.events.BaseEvent;

/**
 * Indicates a request to view the next day / week / month at the calendar.
 */
public class CalendarNextRequestEvent extends BaseEvent {

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\seedu\tache\commons\events\ui\CalendarPreviousRequestEvent.java
``` java
package seedu.tache.commons.events.ui;

import seedu.tache.commons.events.BaseEvent;

/**
 * Indicates a request to view the previous day / week / month at the calendar.
 */
public class CalendarPreviousRequestEvent extends BaseEvent {

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\seedu\tache\commons\events\ui\CalendarViewRequestEvent.java
``` java
package seedu.tache.commons.events.ui;

import seedu.tache.commons.events.BaseEvent;

/**
 * Indicates a request to view events at the calendar in a day / week / month view.
 */
public class CalendarViewRequestEvent extends BaseEvent {

    public final String view;

    public CalendarViewRequestEvent(String view) {
        this.view = view;
    }

    public String getView() {
        return view;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\seedu\tache\commons\events\ui\FilteredTaskListUpdatedEvent.java
``` java
package seedu.tache.commons.events.ui;

import javafx.collections.ObservableList;
import seedu.tache.commons.events.BaseEvent;
import seedu.tache.model.task.ReadOnlyTask;

/**
 * Indicates that the filtered list is changed.
 * For example, the user types "list completed" to show all completed tasks only.
 */
public class FilteredTaskListUpdatedEvent extends BaseEvent {

    public final ObservableList<ReadOnlyTask> filteredTaskList;

    public FilteredTaskListUpdatedEvent(ObservableList<ReadOnlyTask> filteredTaskList) {
        this.filteredTaskList = filteredTaskList;
    }

    public ObservableList<ReadOnlyTask> getFilteredTaskList() {
        return filteredTaskList;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\tache\commons\events\ui\TaskListTypeChangedEvent.java
``` java
package seedu.tache.commons.events.ui;

import seedu.tache.commons.events.BaseEvent;

/**
 * Indicates that the task list type is changed.
 */
public class TaskListTypeChangedEvent extends BaseEvent {

    public final String newTaskListType;

    public TaskListTypeChangedEvent(String newTaskListType) {
        this.newTaskListType = newTaskListType;
    }

    public String getTaskListType() {
        return newTaskListType;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\tache\logic\commands\FindCommand.java
``` java
    @Override
    public CommandResult execute() {
        model.updateFilteredTaskList(keywords);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

}
```
###### \java\seedu\tache\logic\commands\HelpCommand.java
``` java
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Shows usage instructions of specific commands. "
            + "Help window will be displayed if no command is specified.\n"
            + "Parameters (Optional): add, clear, complete, delete, edit etc.\n"
            + "Example: " + COMMAND_WORD + " add";
```
###### \java\seedu\tache\logic\commands\NextCommand.java
``` java

package seedu.tache.logic.commands;

import seedu.tache.commons.core.EventsCenter;
import seedu.tache.commons.events.ui.CalendarNextRequestEvent;

/**
 * Displays the next day / week/ month at the calendar.
 */
public class NextCommand extends Command {

    public static final String COMMAND_WORD = "next";
    public static final String SHORT_COMMAND_WORD = "n";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ":Displays the next day/week/month at the calendar.\n"
            + "Example: " + COMMAND_WORD;

    public static final String MESSAGE_SUCCESS = "Next day/week/month displayed at the calendar.";

    @Override
    public CommandResult execute() {
        EventsCenter.getInstance().post(new CalendarNextRequestEvent());
        return new CommandResult(MESSAGE_SUCCESS);
    }

}

```
###### \java\seedu\tache\logic\commands\PrevCommand.java
``` java

package seedu.tache.logic.commands;

import seedu.tache.commons.core.EventsCenter;
import seedu.tache.commons.events.ui.CalendarPreviousRequestEvent;

/**
 * Displays the previous day / week/ month at the calendar.
 */
public class PrevCommand extends Command {

    public static final String COMMAND_WORD = "prev";
    public static final String SHORT_COMMAND_WORD = "p";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ":Displays the previous day/week/month at the calendar.\n"
            + "Example: " + COMMAND_WORD;

    public static final String MESSAGE_SUCCESS = "Previous day/week/month displayed at the calendar.";

    @Override
    public CommandResult execute() {
        EventsCenter.getInstance().post(new CalendarPreviousRequestEvent());
        return new CommandResult(MESSAGE_SUCCESS);
    }

}

```
###### \java\seedu\tache\logic\commands\ViewCommand.java
``` java

package seedu.tache.logic.commands;

import seedu.tache.commons.core.EventsCenter;
import seedu.tache.commons.events.ui.CalendarViewRequestEvent;

/**
 * Shows events (timed tasks) in the calendar in a day / week / month view.
 */
public class ViewCommand extends Command {

    public static final String COMMAND_WORD = "view";
    public static final String SHORT_COMMAND_WORD = "v";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ":Navigates calendar to a day / week / month view. \n"
            + "Example: " + COMMAND_WORD + " week";

    public static final String MESSAGE_SUCCESS = "Calendar view switched to %s view.";

    private String view;

    public ViewCommand(String view) {
        assert view != null;
        this.view = view;
    }

    @Override
    public CommandResult execute() {
        EventsCenter.getInstance().post(new CalendarViewRequestEvent(view));
        return new CommandResult(String.format(MESSAGE_SUCCESS, view));
    }

}

```
###### \java\seedu\tache\logic\Logic.java
``` java
    /**
     * Returns type of filtered task list in a String
     */
    String getFilteredTaskListType();
}
```
###### \java\seedu\tache\logic\LogicManager.java
``` java
    @Override
    public String getFilteredTaskListType() {
        return model.getFilteredTaskListType();
    }

}
```
###### \java\seedu\tache\logic\parser\CliSyntax.java
``` java
    public static final String FILTER_TIMED = "timed";
    public static final String FILTER_FLOATING = "floating";
```
###### \java\seedu\tache\logic\parser\CliSyntax.java
``` java
    /* Calendar show view options */
    public static final String VIEW_DAY = "day";
    public static final String VIEW_WEEK = "week";
    public static final String VIEW_MONTH = "month";
```
###### \java\seedu\tache\logic\parser\ViewCommandParser.java
``` java
package seedu.tache.logic.parser;

import static seedu.tache.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;
import static seedu.tache.logic.parser.CliSyntax.VIEW_DAY;
import static seedu.tache.logic.parser.CliSyntax.VIEW_MONTH;
import static seedu.tache.logic.parser.CliSyntax.VIEW_WEEK;

import seedu.tache.logic.commands.Command;
import seedu.tache.logic.commands.IncorrectCommand;
import seedu.tache.logic.commands.ViewCommand;


/**
 * Parses input arguments and creates a new ViewCommand object
 */
public class ViewCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the ViewCommand
     * and returns a ViewCommand object for execution.
     */
    public Command parse(String args) {
        String trimmedArgs = args.trim();
        if (!trimmedArgs.equals("")) {
            switch(trimmedArgs) {
            case VIEW_DAY:
            case VIEW_WEEK:
            case VIEW_MONTH:
                return new ViewCommand(trimmedArgs);
            default:
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ViewCommand.MESSAGE_USAGE));
            }
        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ViewCommand.MESSAGE_USAGE));
        }
    }

}
```
###### \java\seedu\tache\model\Model.java
``` java
    /** Updates the filter of the filtered task list to show all timed tasks */
    void updateFilteredListToShowTimed();

```
###### \java\seedu\tache\model\ModelManager.java
``` java
    public static final String TASK_LIST_TYPE_ALL = "All Tasks";
    public static final String TASK_LIST_TYPE_COMPLETED = "Completed Tasks";
    public static final String TASK_LIST_TYPE_UNCOMPLETED = "Uncompleted Tasks";
    public static final String TASK_LIST_TYPE_TIMED = "Timed Tasks";
    public static final String TASK_LIST_TYPE_FLOATING = "Floating Tasks";
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    private String filteredTaskListType = TASK_LIST_TYPE_ALL;
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    @Override
    public void resetData(ReadOnlyTaskManager newData) {
        assert newData != null;
        taskManager.resetData(newData);
        updateFilteredListToShowAll();
        updateFilteredTaskListType(TASK_LIST_TYPE_ALL);
        indicateTaskManagerChanged();
    }
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    /**
     * Raises events to indicate that the model has changed.
     */
    private void indicateTaskManagerChanged() {
        raise(new TaskManagerChangedEvent(taskManager));
        raise(new FilteredTaskListUpdatedEvent(getFilteredTaskList()));
        raise(new PopulateRecurringGhostTaskEvent(getAllUncompletedRecurringGhostTasks(),
                                getAllCompletedRecurringGhostTasks()));
    }
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    @Override
    public synchronized void addTask(Task task) throws DuplicateTaskException {
        assert task != null;
        taskManager.addTask(task);
        indicateTaskManagerChanged();
    }

```
###### \java\seedu\tache\model\ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowAll() {
        filteredTasks.setPredicate(null);
        updateFilteredTaskListType(TASK_LIST_TYPE_ALL);
        raise(new FilteredTaskListUpdatedEvent(getFilteredTaskList()));
    }

```
###### \java\seedu\tache\model\ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowTimed() {
        updateFilteredTaskListType(TASK_LIST_TYPE_TIMED);
        updateFilteredTaskList(new PredicateExpression(new ActiveTimedQualifier(true)));
    }

    @Override
    public void updateFilteredListToShowFloating() {
        updateFilteredTaskListType(TASK_LIST_TYPE_FLOATING);
        updateFilteredTaskList(new PredicateExpression(new ActiveTimedQualifier(false)));
    }

```
###### \java\seedu\tache\model\ModelManager.java
``` java
    /**
     * Provides functionality for find command and raises TaskListTypeChangedEvent to update UI.
     * Set<String> is converted to ArrayList<String> so that String can be retrieved.
     */
    @Override
    public void updateFilteredTaskList(Set<String> keywords) {
        assert keywords != null;
        updateFilteredTaskListType(TASK_LIST_TYPE_FOUND);
        updateFilteredTaskList(new PredicateExpression(new MultiQualifier(keywords)));
        retainLatestKeywords(keywords);
        raise(new TaskListTypeChangedEvent("Find \"" + StringUtil.generateStringFromKeywords(keywords) + "\""));
    }

    private void updateFilteredTaskList(Expression expression) {
        assert expression != null;
        filteredTasks.setPredicate(expression::satisfies);
        raise(new FilteredTaskListUpdatedEvent(getFilteredTaskList()));
    }

    @Override
    public String getFilteredTaskListType() {
        return filteredTaskListType;
    }

    private void updateFilteredTaskListType(String newFilteredTaskListType) {
        assert newFilteredTaskListType != null;
        assert !newFilteredTaskListType.equals("");
        if (!filteredTaskListType.equals(newFilteredTaskListType)) {
            raise(new TaskListTypeChangedEvent(newFilteredTaskListType));
        }
        filteredTaskListType = newFilteredTaskListType;
    }

```
###### \java\seedu\tache\model\ModelManager.java
``` java
    private class TimedQualifier implements Qualifier {
        private boolean isTimed;

        TimedQualifier(boolean isTimed) {
            this.isTimed = isTimed;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            assert task != null;
            if (isTimed) {
                return task.getTimedStatus();
            } else {
                return !task.getTimedStatus();
            }
        }

        @Override
        public String toString() {
            return "timed=" + isTimed;
        }
    }

```
###### \java\seedu\tache\model\ReadOnlyTaskManager.java
``` java
    /**
     * Returns a string that contains the no. of tasks and no. of tags.
     */
    String toString();

}
```
###### \java\seedu\tache\model\tag\UniqueTagList.java
``` java
    public String toString() {
        final StringBuilder builder = new StringBuilder();
        forEach(builder::append);
        return builder.toString();
    }

    /**
     * Signals that an operation would have violated the 'no duplicates' property of the list.
     */
    public static class DuplicateTagException extends DuplicateDataException {
        protected DuplicateTagException() {
            super("Operation would result in duplicate tags");
        }
    }

}
```
###### \java\seedu\tache\model\task\DateTime.java
``` java
    /**
     * Returns a String which represents a moment to be parsed by FullCalendar.
     * A moment (FullCalendar terminology) refers to a point in time.
     */
    public String getDateTimeForFullCalendar() {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
        return sdf.format(date);
    }

    public Date getDate() {
        return date;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DateTime // instanceof handles nulls
                && this.date.equals(((DateTime) other).getDate())); // state check
    }

    /**
     * Returns true if the date is earlier than today.
     */
    public boolean hasPassed() {
        Date today = new Date();
        return this.date.before(today);
    }

```
###### \java\seedu\tache\model\task\ReadOnlyTask.java
``` java
    /**
     * Returns true if both ReadOnlyTasks have the same state. (interfaces cannot override .equals)
     * This means that the details (e.g. name, end date) of the tasks will be identical.
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        assert other != null;
        boolean start = true;
        boolean end = true;
        if (other.getStartDateTime().isPresent() && this.getStartDateTime().isPresent()) {
            start = other.getStartDateTime().equals(this.getStartDateTime());
        }
        if (other.getEndDateTime().isPresent() && this.getEndDateTime().isPresent()) {
            end = other.getEndDateTime().equals(this.getEndDateTime());
        }
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getName().equals(this.getName())
                && start && end
                && (other.getActiveStatus() == this.getActiveStatus())
                && (other.getTimedStatus() == this.getTimedStatus())
                && (other.getRecurState().equals(this.getRecurState())));
    }
```
###### \java\seedu\tache\model\task\Task.java
``` java
    @Override
    public boolean getTimedStatus() {
        if (startDateTime.isPresent() || endDateTime.isPresent()) {
            return true;
        } else {
            return false;
        }
    }

```
###### \java\seedu\tache\model\TaskManager.java
``` java
    /**
     * Returns a string showing all tasks and their details.
     */
    @Override
    public String toString() {
        final StringBuilder builder = new StringBuilder();
        for (Task task : tasks) {
            builder.append(task.toString() + "\n");
        }
        return builder.toString();
    }
```
###### \java\seedu\tache\model\util\SampleDataUtil.java
``` java
    /**
     * Returns an array of Tasks for a sample task manager.
     */
    public static Task[] getSampleTasks() {
        try {
            Task eggsAndBread = new Task(new Name("Buy Eggs and Bread"), new UniqueTagList("HighPriority"));
            eggsAndBread.setStartDateTime(Optional.of(new DateTime("01-04-17 19:55:12")));
            Task readBook = new Task(new Name("Read Book about Software Engineering"),
                    new UniqueTagList("LowPriority"));
            readBook.setEndDateTime(Optional.of(new DateTime("21-04-17 23:59:59")));
            Task visitGrandma = new Task(new Name("Visit Grandma"), new UniqueTagList("MediumPriority"));
            visitGrandma.setStartDateTime(Optional.of(new DateTime("15-04-17 16:00:00")));
            visitGrandma.setEndDateTime(Optional.of(new DateTime("21-04-17 19:00:00")));
            return new Task[] {
                eggsAndBread, readBook, visitGrandma,
                new Task(new Name("Pay David 20 for cab"), new UniqueTagList("LowPriority")),
                new Task(new Name("Get Fit"), new UniqueTagList("LowPriority")),
                new Task(new Name("Find a girlfriend"), new UniqueTagList("LowPriority")),
                new Task(new Name("Walk the Dog"), Optional.of(new DateTime("14 April 2017")),
                            Optional.of(new DateTime("14 April 2017")), new UniqueTagList("MediumPriority"),
                            true, RecurInterval.NONE, new ArrayList<Date>()),
                new Task(new Name("Buy Medicine"), Optional.of(new DateTime("15 April 2017")),
                            Optional.empty(), new UniqueTagList("LowPriority"), true,
                            RecurInterval.NONE, new ArrayList<Date>()),
                new Task(new Name("Submit Project Proposal"), Optional.empty(),
                            Optional.of(new DateTime("17 April 2017")), new UniqueTagList("HighPriority"),
                            true, RecurInterval.NONE, new ArrayList<Date>()),
            };
        } catch (IllegalValueException e) {
            throw new AssertionError("sample data cannot be invalid", e);
        }
    }
```
###### \java\seedu\tache\storage\StorageManager.java
``` java
    /**
     * Updates the default file path of the task manager.
     * Raises a DataFileLocationChangedEvent to inform other components of this change.
     */
    @Override
    public void setTaskManagerFilePath(String newPath) {
        assert newPath != null;
        this.taskManagerStorage.setTaskManagerFilePath(newPath);
        logger.fine("File path set as: " + newPath);
        raise(new DataFileLocationChangedEvent(newPath));
    }
```
###### \java\seedu\tache\storage\XmlSerializableTaskManager.java
``` java
    /**
     * Returns a String containing the tasks and their details.
     */
    @Override
    public String toString() {
        final StringBuilder builder = new StringBuilder();
        for (ReadOnlyTask task : getTaskList()) {
            builder.append(task.toString() + "\n");
        }
        return builder.toString();
    }

}
```
###### \java\seedu\tache\ui\CalendarPanel.java
``` java
    /**
     * Executes the script when the calendar finishes loading.
     *
     * @param script    Script to be executed.
     */
    private void loadAndExecuteScript(String script) {
        assert script != null;
        assert !script.equals("");
        WebEngine engine = calendar.getEngine();
        ReadOnlyObjectProperty<Worker.State> webViewState = engine.getLoadWorker().stateProperty();
        if (webViewState.get() == Worker.State.SUCCEEDED) {
            engine.executeScript(script);
        } else {
            engine.getLoadWorker().stateProperty().addListener(new ChangeListener<Worker.State>() {
                @Override
                public void changed(ObservableValue<? extends Worker.State> observable,
                        Worker.State oldValue, Worker.State newValue) {
                    if (newValue != Worker.State.SUCCEEDED) {
                        return;
                    }
                    engine.executeScript(script);
                }
            });
        }
    }

    /**
     * Initializes the calendar, then adds all timed events.
     *
     * @param taskList    List of all tasks (including timed tasks).
     */
    private void loadCalendar(ObservableList<ReadOnlyTask> taskList) {
        assert taskList != null;
        String calendarURL = MainApp.class.getResource("/html/calendar.html").toExternalForm();
        WebEngine engine = calendar.getEngine();
        engine.load(calendarURL);
        ReadOnlyObjectProperty<Worker.State> webViewState = engine.getLoadWorker().stateProperty();
        if (webViewState.get() == Worker.State.SUCCEEDED) {
            addAllEvents(taskList);
        } else {
            engine.getLoadWorker().stateProperty().addListener(new ChangeListener<Worker.State>() {
                @Override
                public void changed(ObservableValue<? extends Worker.State> observable,
                        Worker.State oldValue, Worker.State newValue) {
                    if (newValue != Worker.State.SUCCEEDED) {
                        return;
                    }
                    addAllEvents(taskList);
                }
            });
        }
        logger.fine("Calendar loaded.");
    }

    /**
     * Returns the String that can be executed by the calendar WebEngine to add an event into the calendar.
     *
     * @param task    Task to be added as a calendar event.
     * @return    Script for calendar to add event.
     */
    private String getLoadTaskExecuteScript(ReadOnlyTask task) {
        assert task != null;
        String title = task.getName().toString();
        String start = "0";
        String end = "0"; // invalid format of datetime
        Optional<DateTime> startDateTime = task.getStartDateTime();
        Optional<DateTime> endDateTime = task.getEndDateTime();
        if (task.getStartDateTime().isPresent()) {
            start = startDateTime.get().getDateTimeForFullCalendar();
        }
        if (task.getEndDateTime().isPresent()) {
            end = endDateTime.get().getDateTimeForFullCalendar();
        }
        String status = "uncompleted";
        if (task.getActiveStatus() == false) {
            status = "completed";
        } else if (task.getEndDateTime().isPresent()) {
            if (task.getEndDateTime().get().hasPassed()) {
                status = "overdue";
            }
        } else if (task.getStartDateTime().isPresent()) {
            if (task.getStartDateTime().get().hasPassed()) {
                status = "overdue";
            }
        }
        return "add_event('" + title + "', '" + start + "', '" + end + "', '" + status + "')";
    }

    /**
     * Updates the events in the calendar whenever the task manager is modified.
     *
     * @param event    TaskManagerChangedEvent which contains the updated task list.
     */
    @Subscribe
    public void handleTaskManagerChangedEvent(TaskManagerChangedEvent event) {
        ObservableList<ReadOnlyTask> taskList = event.data.getTaskList();
        refreshCalendar(taskList);
        logger.fine("Calendar refreshed.");
    }

    /**
     * Changes the reference position of the calendar to the date associated with the selected task.
     * If the start date of the task is not present, the end date is used as reference instead.
     *
     * @param event    TaskPanelSelectionChangedEvent which contains the task selected.
     */
    @Subscribe
    public void handleTaskPanelSelectionChangedEvent(TaskPanelSelectionChangedEvent event) {
        Optional<DateTime> startDateTime = event.getNewSelection().getStartDateTime();
        Optional<DateTime> endDateTime = event.getNewSelection().getEndDateTime();
        if (startDateTime.isPresent()) {
            changeReferenceDate(startDateTime.get().getDateTimeForFullCalendar());
        } else if (endDateTime.isPresent()) {
            changeReferenceDate(endDateTime.get().getDateTimeForFullCalendar());
        }
    }

    /**
     * Changes the view of the calendar according to the task list type of the task panel.
     *
     * @param event    TaskListTypeChangedEvent which contains the updated task list type.
     */
    @Subscribe
    public void handleTaskListTypeChangedEvent(TaskListTypeChangedEvent event) {
        String taskListType = event.getTaskListType();
        if (taskListType.equals("Tasks Due Today") || taskListType.equals("Tasks Due This Week")) {
            Date today = new Date();
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
            String referenceDate = sdf.format(today);
            changeReferenceDate(referenceDate);
            if (taskListType.equals("Tasks Due Today")) {
                changeView("day");
            } else {
                changeView("week");
            }
        } else {
            changeView("month");
        }
    }

    /**
     * Moves the calendar back (by a day / week / month).
     */
    @Subscribe
    public void handleCalendarPreviousRequestEvent(CalendarPreviousRequestEvent event) {
        loadAndExecuteScript("prev()");
        logger.fine("Calendar moved back.");
    }

    /**
     * Moves the calendar forward (by a day / week / month).
     */
    @Subscribe
    public void handleCalendarNextRequestEvent(CalendarNextRequestEvent event) {
        loadAndExecuteScript("next()");
        logger.fine("Calendar moved forward.");
    }

    /**
     * Changes the view of the calendar to day / week / month view.
     *
     * @param event    CalendarViewRequestEvent which contains the new view.
     */
    @Subscribe
    public void handleCalendarViewRequestEvent(CalendarViewRequestEvent event) {
        changeView(event.getView());
    }


    private void changeView(String view) {
        assert view != null;
        assert !view.equals("");
        loadAndExecuteScript("change_view('" + view + "')");
        logger.fine("Calendar view changed to: " + view);
    }

    /**
     * Moves the calendar to the referenceDate.
     */
    private void changeReferenceDate(String referenceDate) {
        assert referenceDate != null;
        assert !referenceDate.equals("");
        loadAndExecuteScript("change_reference_date('" + referenceDate + "')");
        logger.fine("Calendar reference date changed to: " + referenceDate);
    }

    private void addCurrentEvent(ReadOnlyTask task) {
        loadAndExecuteScript(getLoadTaskExecuteScript(task));
    }

    /**
     * Clears the calendar of all previous events, then adds all timed events from the latest taskList.
     *
     * @param taskList    Updated list of all tasks.
     */
    private void refreshCalendar(ObservableList<ReadOnlyTask> taskList) {
        assert taskList != null;
        WebEngine engine = calendar.getEngine();
        ReadOnlyObjectProperty<Worker.State> webViewState = engine.getLoadWorker().stateProperty();
        if (webViewState.get() == Worker.State.SUCCEEDED) {
            removeAllEvents();
            addAllEvents(taskList);
        } else {
            engine.getLoadWorker().stateProperty().addListener(new ChangeListener<Worker.State>() {
                @Override
                public void changed(ObservableValue<? extends Worker.State> observable,
                        Worker.State oldValue, Worker.State newValue) {
                    if (newValue != Worker.State.SUCCEEDED) {
                        return;
                    }
                    removeAllEvents();
                    addAllEvents(taskList);
                }
            });
        }
    }

    /**
     * Clears the calendar of all events.
     */
    private void removeAllEvents() {
        WebEngine engine = calendar.getEngine();
        engine.executeScript("remove_all()");
    }

    /**
     * Inputs all timed tasks into the calendar.
     * For deadline tasks (only have end but no start date/time), convert end date/time to start date/time.
     *
     * @param taskList    List which contains all tasks (including timed tasks).
     */
    public void addAllEvents(ObservableList<ReadOnlyTask> taskList) {
        assert taskList != null;
        for (ReadOnlyTask task : taskList) {
            if (task.getTimedStatus()) {
                if (!task.getStartDateTime().isPresent()) {
                    Task newTask = new Task(task);
                    newTask.setStartDateTime(newTask.getEndDateTime());
                    newTask.setEndDateTime(Optional.empty());
                    task = newTask;
                }
                if (task.getRecurState().isMasterRecurring()) {
                    continue;
                }
                addCurrentEvent(task);
            }
        }
    }
```
###### \java\seedu\tache\ui\CommandBox.java
``` java
    private static ArrayList<String> userInputs = new ArrayList<String>();
    private static int currentUserInputIndex = userInputs.size();
```
###### \java\seedu\tache\ui\CommandBox.java
``` java
    /**
     * Executes the user command and adds it to the list of previous commands for retrieval.
     * Handles command success as well as command failure.
     */
    @FXML
    private void handleCommandInputChanged() {
        try {
            String userInput = commandTextField.getText();
            userInputs.add(userInput);
            currentUserInputIndex = userInputs.size();
            CommandResult commandResult = logic.execute(userInput);

            // process result of the command
            setStyleToIndicateCommandSuccess();
            commandTextField.setText("");
            logger.info("Result: " + commandResult.feedbackToUser);
            raise(new NewResultAvailableEvent(commandResult.feedbackToUser));

        } catch (CommandException e) {
            // handle command failure
            setStyleToIndicateCommandFailure();
            logger.info("Invalid command: " + commandTextField.getText());
            raise(new NewResultAvailableEvent(e.getMessage()));
        }
    }

    /**
     * Sets autocomplete functionality for user commands.
     * Uses ControlsFX Autocomplete TextField function.
     */
    private void setAutocomplete() {
        String[] possibleCommands = {"add ", "clear", "complete ", "delete ", "edit ", "exit", "find ",
                                        "help", "list", "save ", "select ", "load ", "undo", "next", "prev", "view " };
        AutoCompletionBinding<String> binding = TextFields.bindAutoCompletion(commandTextField, sr -> {
            ArrayList<String> commands = new ArrayList<String>();
            for (String str : possibleCommands) {
                String userInput = sr.getUserText();
                if ((!userInput.equals("") && str.startsWith(userInput) && !userInput.equals(str))) {
                    commands.add(str);
                }
            }
            return commands;
        });
        binding.setMaxWidth(100);
        binding.setDelay(50);
    }

    /**
     * Keeps track of previous commands executed and retrieves them with Up and Down keys.
     * Sets the caret of the text field right at the end of the command retrieved.
     */
    private void setSaveCommandHistory() {
        commandTextField.setOnKeyPressed(new EventHandler<KeyEvent>() {
            @Override
            public void handle(KeyEvent event) {
                String userInput;
                if (userInputs.isEmpty()) {
                    return;
                }
                if (event.getCode() == KeyCode.UP && currentUserInputIndex >= 0) {
                    currentUserInputIndex--;
                    userInput = userInputs.get(currentUserInputIndex);
                    setTextAndCaret(userInput);
                }
                if (event.getCode() == KeyCode.DOWN && currentUserInputIndex < userInputs.size() - 1) {
                    currentUserInputIndex++;
                    userInput = userInputs.get(currentUserInputIndex);
                    setTextAndCaret(userInput);
                }
            }

            private void setTextAndCaret(String userInput) {
                if (userInput.length() > 0) {
                    commandTextField.setText(userInput);
                    Platform.runLater(new Runnable() {
                        @Override
                        public void run() {
                            commandTextField.positionCaret(userInput.length());
                        }
                    });
                }
            }
        });
    }
```
###### \java\seedu\tache\ui\MainWindow.java
``` java
    @FXML
    private AnchorPane taskListTypePlaceholder;

    @FXML
    private AnchorPane taskCountPlaceholder;
```
###### \java\seedu\tache\ui\MainWindow.java
``` java
    /**
     * Initializes all UI components using information from logic and config.
     */
    void fillInnerParts() {
        calendarPanel = new CalendarPanel(getCalendarPlaceholder(), logic.getFullTaskList());
        taskListPanel = new TaskListPanel(getTaskListPlaceholder(), logic.getFilteredTaskList());
        new TaskListType(getTaskListTypePlaceholder(), logic.getFilteredTaskListType());
        new TaskCount(getTaskCountPlaceholder(), logic);
        new ResultDisplay(getResultDisplayPlaceholder());
        new StatusBarFooter(getStatusbarPlaceholder(), config.getTaskManagerFilePath());
        new CommandBox(getCommandBoxPlaceholder(), logic);
    }

    private AnchorPane getCalendarPlaceholder() {
        return calendarPlaceholder;
    }
```
###### \java\seedu\tache\ui\MainWindow.java
``` java
    private AnchorPane getTaskCountPlaceholder() {
        return taskCountPlaceholder;
    }

    private AnchorPane getTaskListTypePlaceholder() {
        return taskListTypePlaceholder;
    }
```
###### \java\seedu\tache\ui\StatusBarFooter.java
``` java
    public String getSaveLocation() {
        return this.saveLocationStatus.getText();
    }

    public String getSyncStatus() {
        return this.syncStatus.getText();
    }
```
###### \java\seedu\tache\ui\StatusBarFooter.java
``` java
    /**
     * Updates the save location status bar when the data file location is changed.
     *
     * @param event    Event which contains the new data file path.
     */
    @Subscribe
    public void handleDataFileLocationChangedEvent(DataFileLocationChangedEvent event) {
        assert event != null;
        String newLocation = event.toString();
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Setting new data file location to" + newLocation));
        setSaveLocation("New Location: " + newLocation);
    }
}
```
###### \java\seedu\tache\ui\TaskCard.java
``` java
    private static final String INDICATOR_START_DATE = "Start Date: ";
    private static final String INDICATOR_START_TIME = "Start Time: ";
    private static final String INDICATOR_END_DATE = "End Date: ";
    private static final String INDICATOR_END_TIME = "End Time: ";
    private static final String FXML = "TaskListCard.fxml";

    private static final String INDICATOR_COMPLETED = "completed";
    private static final String INDICATOR_OVERDUE = "overdue";
    private static final String INDICATOR_UNCOMPLETED = "uncompleted";

    private final Logger logger = LogsCenter.getLogger(TaskCard.class);

    private String statusOfTask = INDICATOR_UNCOMPLETED;
    private boolean isMasterRecurring = false;
```
###### \java\seedu\tache\ui\TaskCard.java
``` java
    public TaskCard(ReadOnlyTask task, int displayedIndex) {
        super(FXML);
        assert task != null;
        assert displayedIndex > 0;
        id.setText(Integer.toString(displayedIndex) + ". ");
        id.setId("id"); // set property id for Label named id
        name.setText(task.getName().toString());
        name.setWrapText(true); // spill over to next line if task name is too long
        setStatusOfTask(task);
        setIsMasterRecurring(task);
        setSymbol();
        setBorderColour();
        initDatesAndTimes(task);
        initTags(task);
    }

    /**
     * Sets task status as completed, overdue or uncompleted.
     * Task status will be used to set border colour and symbol of task card later.
     */
    private void setStatusOfTask(ReadOnlyTask task) {
        assert task != null;
        if (task.getActiveStatus() == false) {
            statusOfTask = INDICATOR_COMPLETED;
        } else if (task.getEndDateTime().isPresent()) {
            DateTime taskDate = task.getEndDateTime().get();
            if (taskDate.hasPassed()) {
                statusOfTask = INDICATOR_OVERDUE;
            }
        }
    }

    /**
     * Checks if this task is the master task, if it is recurring.
     * Sets value of isMasterRecurring as true or false.
     */
    private void setIsMasterRecurring(ReadOnlyTask task) {
        assert task != null;
        isMasterRecurring = task.getRecurState().isMasterRecurring();
    }

    /**
     * Sets border colour of task card according to task status.
     */
    private void setBorderColour() {
        if (statusOfTask.equals(INDICATOR_UNCOMPLETED)) {
            cardPane.setStyle("-fx-border-color: #5f77bd"); // blue
        } else if (statusOfTask.equals(INDICATOR_OVERDUE)) {
            cardPane.setStyle("-fx-border-color: #ef044b"); // red
        } else {
            cardPane.setStyle("-fx-border-color: #14b66c"); // green
        }
    }

    /**
     * Sets symbol of task card according to task status.
     */
    private void setSymbol() {
        if (isMasterRecurring) {
            symbol.setImage(new Image(MainApp.class.getResource("/images/recurring.png").toExternalForm()));
        } else {
            if (statusOfTask.equals(INDICATOR_COMPLETED)) {
                symbol.setImage(new Image(MainApp.class.getResource("/images/tick.png").toExternalForm()));
            } else if (statusOfTask.equals(INDICATOR_OVERDUE)) {
                symbol.setImage(new Image(MainApp.class.getResource("/images/cross.png").toExternalForm()));
            }
        }
        symbol.setId("symbol");
    }

    /**
     * Sets start datetime and end datetime of  task.
     */
    private void initDatesAndTimes(ReadOnlyTask task) {
        assert task != null;
        if (task.getStartDateTime().isPresent()) {
            DateTime start = task.getStartDateTime().get();
            Label startDateLabel = new Label(INDICATOR_START_DATE + start.getDateOnly());
            startDateLabel.setId("startdate");
            datesAndTimes.getChildren().add(startDateLabel);
            Label startTimeLabel = new Label(INDICATOR_START_TIME + start.getTimeOnly());
            startTimeLabel.setId("starttime");
            datesAndTimes.getChildren().add(startTimeLabel);
            logger.fine("Start date and time added in Labels for " + task.getName().toString());
        }
        if (task.getEndDateTime().isPresent()) {
            DateTime end = task.getEndDateTime().get();
            Label endDateLabel = new Label(INDICATOR_END_DATE + end.getDateOnly());
            endDateLabel.setId("enddate");
            datesAndTimes.getChildren().add(endDateLabel);
            Label endTimeLabel = new Label(INDICATOR_END_TIME + end.getTimeOnly());
            endTimeLabel.setId("endtime");
            datesAndTimes.getChildren().add(endTimeLabel);
            logger.fine("End date and time added in Labels for " + task.getName().toString());
        }
    }

    private void initTags(ReadOnlyTask task) {
        assert task != null;
        task.getTags().forEach(tag -> tags.getChildren().add(new Label(tag.tagName)));
    }
}
```
###### \java\seedu\tache\ui\TaskCount.java
``` java
package seedu.tache.ui;

import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;

import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Region;
import seedu.tache.commons.core.LogsCenter;
import seedu.tache.commons.events.ui.FilteredTaskListUpdatedEvent;
import seedu.tache.commons.util.FxViewUtil;
import seedu.tache.logic.Logic;
import seedu.tache.model.task.ReadOnlyTask;

/**
 * Count of timed and floating tasks.
 */
public class TaskCount extends UiPart<Region> {
    private static final Logger logger = LogsCenter.getLogger(TaskCount.class);
    private static final String FXML = "TaskCount.fxml";

    @FXML
    private Label timedTaskCount;
    @FXML
    private Label floatingTaskCount;

    public TaskCount(AnchorPane taskCountPlaceholder, Logic logic) {
        super(FXML);
        setTimedTaskCount(logic.getFilteredTaskList());
        setFloatingTaskCount(logic.getFilteredTaskList());
        addToPlaceholder(taskCountPlaceholder);
        registerAsAnEventHandler(this);
    }

    private void addToPlaceholder(AnchorPane placeHolder) {
        FxViewUtil.applyAnchorBoundaryParameters(getRoot(), 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(getRoot());
    }

    private void setTimedTaskCount(ObservableList<ReadOnlyTask> taskList) {
        assert taskList != null;
        String count = getTimedTaskCount(taskList);
        this.timedTaskCount.setText(count);
    }

    /**
     * Returns a String representing the number of timed tasks.
     *
     * @param taskList    Filtered task list displayed at task list panel.
     * @return    No. of timed tasks.
     */
    private String getTimedTaskCount(ObservableList<ReadOnlyTask> taskList) {
        assert taskList != null;
        int count = 0;
        for (ReadOnlyTask task : taskList) {
            if (task.getTimedStatus() == true) {
                count++;
            }
        }
        return Integer.toString(count);
    }

    private void setFloatingTaskCount(ObservableList<ReadOnlyTask> taskList) {
        assert taskList != null;
        String count = getFloatingTaskCount(taskList);
        this.floatingTaskCount.setText(count);
    }

    /**
     * Returns a String representing the number of floating tasks.
     *
     * @param taskList    Filtered task list displayed at task list panel.
     * @return    No. of floating tasks.
     */
    private String getFloatingTaskCount(ObservableList<ReadOnlyTask> taskList) {
        assert taskList != null;
        int count = 0;
        for (ReadOnlyTask task : taskList) {
            if (task.getTimedStatus() == false) {
                count++;
            }
        }
        return Integer.toString(count);
    }

    /**
     * Recalculates and sets the counts of timed and floating tasks.
     *
     * @param event    FilteredTaskListUpdatedEvent which contains updated task list.
     */
    @Subscribe
    public void handleFilteredTaskListUpdatedEvent(FilteredTaskListUpdatedEvent event) {
        ObservableList<ReadOnlyTask> taskList = event.getFilteredTaskList();
        String oldTimedCount = this.timedTaskCount.getText();
        String newTimedCount = getTimedTaskCount(taskList);
        if (oldTimedCount != newTimedCount) {
            this.timedTaskCount.setText(newTimedCount);
            logger.fine("Timed task list count changed to : '" + newTimedCount + "'");
        }
        String oldFloatingCount = this.floatingTaskCount.getText();
        String newFloatingCount = getFloatingTaskCount(taskList);
        if (oldFloatingCount != newFloatingCount) {
            this.floatingTaskCount.setText(newFloatingCount);
            logger.fine("Floating task list count changed to : '" + newFloatingCount + "'");
        }
    }

}
```
###### \java\seedu\tache\ui\TaskListType.java
``` java
package seedu.tache.ui;

import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;

import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Region;
import seedu.tache.commons.core.LogsCenter;
import seedu.tache.commons.events.ui.TaskListTypeChangedEvent;
import seedu.tache.commons.util.FxViewUtil;

/**
 * A UI containing the type of tasks shown in task list.
 */
public class TaskListType extends UiPart<Region> {
    private final Logger logger = LogsCenter.getLogger(TaskListType.class);
    private static final String FXML = "TaskListType.fxml";

    @FXML
    private Label taskListType;

    public TaskListType(AnchorPane taskListTypePlaceholder, String typeOfTasks) {
        super(FXML);
        taskListType.setText(typeOfTasks);
        addToPlaceholder(taskListTypePlaceholder);
        registerAsAnEventHandler(this);
    }

    private void addToPlaceholder(AnchorPane placeHolder) {
        FxViewUtil.applyAnchorBoundaryParameters(getRoot(), 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(getRoot());
    }

    /**
     * Updates task list type.
     *
     * @param event    TaskListTypeChangedEvent which contains new task list type.
     */
    @Subscribe
    public void handleTaskListTypeChangedEvent(TaskListTypeChangedEvent event) {
        String oldTaskListType = this.taskListType.getText();
        String newTaskListType = event.getTaskListType();
        if (oldTaskListType != newTaskListType) {
            this.taskListType.setText(newTaskListType);
            logger.fine("Task list type changed to : '" + newTaskListType + "'");
        }
    }

}
```
###### \resources\html\calendar.html
``` html
<style>
    * {
        font-family: "Segoe UI Semibold";
    }

    .fc button {
        color: #5f77bd;
    }

    .fc-toolbar h2 {
        color: #5f77bd;
    }

    .fc-day-number {
        color: #5f77bd;
    }

    .fc-day-header {
        color: #5f77bd;
    }

    .fc-unthemed td.fc-today {
        background: #c3cfe2;
    }
}
</style>

<body>
    <div id='calendar'></div>
</body>

<script>

$(document).ready(function() {
    $('#calendar').fullCalendar({
        contentHeight: 'auto',
        header: {
            left: 'prev, next, today',
            center: 'title',
            right: 'month, basicWeek, basicDay'
        },
        navLinks: true, // can click day/week names to navigate views
        timeFormat: 'HH:mm',
        selectable: true,
        allDaySlot: false,
        dayClick: function(date, jsEvent, view) {
            $('#calendar').fullCalendar( 'changeView', 'agendaDay' );
            $('#calendar').fullCalendar( 'gotoDate', date );
        }
    });
    $('#calendar').fullCalendar('render');
});

function add_event(title, start, end, status) {
    $(document).ready(function() {
        var color = 'white';
        if (status === "uncompleted") {
            color = '#5f77bd';
        } else if (status === "overdue") {
            color = '#ef044b';
        } else {
            color = '#d9d9d9';
        }
        var event = {
            title: title,
            start: start,
            color: color
        };
        if (end !== "'0'") {
            event.end = end;
        }
        $('#calendar').fullCalendar( 'renderEvent', event, true );
    });
}

function remove_all() {
    $(document).ready(function() {
        $('#calendar').fullCalendar( 'removeEvents' );
    });
}

function change_view(view) {
    var newView;
    if (view === "day") {
        newView = 'agendaDay';
    } else if (view === "week") {
        newView = 'agendaWeek';
    } else {
        newView = 'month';
    }
    $(document).ready(function() {
        $('#calendar').fullCalendar( 'changeView', newView );
    });
}

function change_reference_date(date) {
    $(document).ready(function() {
        $('#calendar').fullCalendar( 'gotoDate', date );
        $('#calendar').fullCalendar( 'select', date );
    });
}

function prev() {
    $('#calendar').fullCalendar( 'prev' );
}

function next() {
    $('#calendar').fullCalendar( 'next' );
}
</script>
```
###### \resources\view\MainWindow.fxml
``` fxml
      <SplitPane id="splitPane" fx:id="splitPane" dividerPositions="0.3" VBox.vgrow="ALWAYS">
         <items>
            <SplitPane dividerPositions="0.3" maxWidth="300.0" orientation="VERTICAL">
              <items>
                <AnchorPane maxHeight="90.0">
                     <children>
                      <AnchorPane fx:id="taskListTypePlaceholder" minWidth="230.0" AnchorPane.leftAnchor="0.0" AnchorPane.topAnchor="0.0">
                           <padding>
                              <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
                           </padding>
                        </AnchorPane>
                      <AnchorPane fx:id="taskCountPlaceholder" minHeight="90.0" maxWidth="60.0" prefWidth="60.0" AnchorPane.leftAnchor="210.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                           <padding>
                              <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
                           </padding>
                        </AnchorPane>
                     </children>
                  </AnchorPane>
                <AnchorPane minWidth="300.0" prefWidth="300.0">
                     <children>
                        <VBox fx:id="taskList" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                           <padding>
                                <Insets bottom="10.0" left="10.0" right="10.0" top="10.0"/>
                           </padding>
                           <children>
                              <AnchorPane fx:id="taskListPanelPlaceholder" VBox.vgrow="ALWAYS" />
                           </children>
                        </VBox>
                     </children>
                  </AnchorPane>
              </items>
            </SplitPane>
            <AnchorPane fx:id="calendarPlaceholder" minWidth="380.0" prefWidth="380.0" VBox.vgrow="NEVER">
```
###### \resources\view\TacheTheme.css
``` css
.text-field {
    -fx-background-color: #5f77bd;
    -fx-font-size: 12pt;
    -fx-font-family: "Segoe UI Semibold";
    -fx-prompt-text-fill: black;
    -fx-text-fill: white;
    -fx-highlight-fill: #06314c;
}

.split-pane {
    -fx-border-radius: 1;
    -fx-border-width: 1;
    -fx-background-color: white;
}

.anchor-pane {
     -fx-background-color: white;
}

.anchor-pane-with-border {
     -fx-background-color: white;
     -fx-border-color: #039ed3;
     -fx-border-width: 3px;
}

.result-display {
    -fx-text-fill: #5f77bd;
    -fx-font-family: Segoe UI Light;
    -fx-font-size: 15px;
}

.status-bar-footer {
    -fx-background-color: white;
}

.status-bar .label {
    -fx-text-fill: #5f77bd;
    -fx-font-size: 15px;
}

.menu-bar {
    -fx-background-color: white;
}

.menu-item:focused {
    -fx-background-color: #c3cfe2;
}

.menu-bar .label {
    -fx-font-size: 14pt;
    -fx-font-family: "Segoe UI Semibold";
    -fx-text-fill: #5f77bd;
}

.menu:hover {
    -fx-background-color: #c3cfe2;
}

.task-list-header {
    -fx-background-color: white;
}

.task-list-header .label {
    -fx-font-size: 15pt;
    -fx-font-family: "Segoe UI Semibold";
    -fx-text-fill: #5f77bd;
    -fx-alignment: center;
}

.task-card-id-and-name .label {
    -fx-text-fill: #5f77bd;
    -fx-font-size: 12pt;
}

.task-card-date-time .label {
    -fx-font-size: 10pt;
    -fx-font-family: "Segoe UI Light";
    -fx-text-fill: black;
}

.list-cell:selected {
    -fx-background-color: #c3cfe2;
}

#cardPane {
    -fx-border-width: 3 3 3 3;
}

#cardPane:active {
    -fx-background-color: gray;
}

#tags {
    -fx-hgap: 7;
    -fx-vgap: 3;
}

#tags .label {
    -fx-text-fill: white;
    -fx-background-color: #5f77bd;
    -fx-padding: 1 3 1 3;
    -fx-border-radius: 2;
    -fx-background-radius: 2;
    -fx-font-size: 11;
}


.error {
    -fx-background-color: #ef044b;
}

```
###### \resources\view\TaskCount.fxml
``` fxml

<?import javafx.scene.control.Label?>
<?import javafx.scene.image.Image?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.layout.AnchorPane?>

<AnchorPane maxWidth="60.0" minHeight="70.0" prefHeight="70.0" prefWidth="60.0" styleClass="task-list-header"
       xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <ImageView fitHeight="35.0" fitWidth="35.0" pickOnBounds="true" preserveRatio="true" AnchorPane.leftAnchor="0.0" AnchorPane.topAnchor="0.0">
         <image>
            <Image url="@../images/clock.png" />
         </image>
      </ImageView>
      <Label fx:id="timedTaskCount" minHeight="35.0" minWidth="25.0" prefHeight="35.0" prefWidth="25.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" />
      <ImageView fitHeight="35.0" fitWidth="35.0" pickOnBounds="true" preserveRatio="true" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0">
         <image>
            <Image url="@../images/task.png" />
         </image>
      </ImageView>
      <Label fx:id="floatingTaskCount" minHeight="35.0" minWidth="25.0" prefHeight="35.0" prefWidth="25.0" AnchorPane.bottomAnchor="0.0" AnchorPane.rightAnchor="0.0" />
   </children>
</AnchorPane>
```
###### \resources\view\TaskListCard.fxml
``` fxml
                        <HBox alignment="CENTER_LEFT" spacing="5" styleClass="task-card-id-and-name">
                            <children>
                                <HBox>
                                    <Label fx:id="id" minWidth="28.0" />
                                    <AnchorPane prefWidth="200.0" minWidth="200.0">
                                       <children>
                                         <Label fx:id="name" maxWidth="170.0" text="\$first" />
                                         <AnchorPane minHeight="15.0" minWidth="15.0" prefHeight="20.0" prefWidth="20.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                                       <children>
                                         <ImageView fx:id="symbol" fitHeight="15.0" fitWidth="15.0" pickOnBounds="true" preserveRatio="true" AnchorPane.rightAnchor="5.0" AnchorPane.topAnchor="0.0" />
                                    </children>
                                 </AnchorPane>
                              </children>
                           </AnchorPane>
                                </HBox>
                            </children>
                        </HBox>
                        <FlowPane fx:id="tags" />
                        <FlowPane fx:id="datesAndTimes" styleClass="task-card-date-time" maxWidth = "100.0"/>
```
###### \resources\view\TaskListType.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.AnchorPane?>

<AnchorPane fx:id="taskListTypePlaceholder" styleClass="task-list-header" xmlns="http://javafx.com/javafx/8.0.111"
    xmlns:fx="http://javafx.com/fxml/1">
    <stylesheets>
        <URL value="@TacheTheme.css" />
    </stylesheets>
    <Label fx:id="taskListType" maxWidth="200" prefWidth="200" minHeight="80"/>
</AnchorPane>
```
