# A0142255M
###### \java\seedu\tache\commons\events\storage\DataFileLocationChangedEvent.java
``` java

package seedu.tache.commons.events.storage;

import seedu.tache.commons.events.BaseEvent;

/**
 * Indicates that the directory of the data file has been changed
 */
public class DataFileLocationChangedEvent extends BaseEvent {

    public String newLocation;

    public DataFileLocationChangedEvent(String newLocation) {
        assert newLocation != null;
        this.newLocation = newLocation;
    }

    @Override
    public String toString() {
        return newLocation;
    }

}
```
###### \java\seedu\tache\commons\events\ui\FilteredTaskListUpdatedEvent.java
``` java
package seedu.tache.commons.events.ui;

import javafx.collections.ObservableList;
import seedu.tache.commons.events.BaseEvent;
import seedu.tache.model.task.ReadOnlyTask;

/**
 * Indicates that the filtered list is changed.
 * For example, the user types "list completed" to show all completed tasks only.
 */
public class FilteredTaskListUpdatedEvent extends BaseEvent {

    public final ObservableList<ReadOnlyTask> filteredTaskList;

    public FilteredTaskListUpdatedEvent(ObservableList<ReadOnlyTask> filteredTaskList) {
        this.filteredTaskList = filteredTaskList;
    }

    public ObservableList<ReadOnlyTask> getFilteredTaskList() {
        return filteredTaskList;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\tache\commons\events\ui\TaskListTypeChangedEvent.java
``` java
package seedu.tache.commons.events.ui;

import seedu.tache.commons.events.BaseEvent;

/**
 * Indicates that the task list type is changed.
 */
public class TaskListTypeChangedEvent extends BaseEvent {

    public final String newTaskListType;

    public TaskListTypeChangedEvent(String newTaskListType) {
        this.newTaskListType = newTaskListType;
    }

    public String getTaskListType() {
        return newTaskListType;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\tache\logic\Logic.java
``` java
    /**
     * Returns type of filtered task list in a String
     */
    String getFilteredTaskListType();
}
```
###### \java\seedu\tache\logic\LogicManager.java
``` java
    @Override
    public String getFilteredTaskListType() {
        return model.getFilteredTaskListType();
    }

}
```
###### \java\seedu\tache\logic\parser\CliSyntax.java
``` java
    public static final String TIMED_FILTER = "timed";
    public static final String FLOATING_FILTER = "floating";
```
###### \java\seedu\tache\model\Model.java
``` java
    /** Updates the filter of the filtered task list to show all uncompleted tasks */
    void updateFilteredListToShowTimed();

```
###### \java\seedu\tache\model\ModelManager.java
``` java
    public static final String ALL_TASK_LIST_TYPE = "All Tasks";
    public static final String COMPLETED_TASK_LIST_TYPE = "Completed Tasks";
    public static final String UNCOMPLETED_TASK_LIST_TYPE = "Uncompleted Tasks";
    public static final String TIMED_TASK_LIST_TYPE = "Timed Tasks";
    public static final String FLOATING_TASK_LIST_TYPE = "Floating Tasks";
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    private String filteredTaskListType = ALL_TASK_LIST_TYPE;
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    @Override
    public void resetData(ReadOnlyTaskManager newData) {
        taskManager.resetData(newData);
        updateFilteredListToShowAll();
        updateFilteredTaskListType(ALL_TASK_LIST_TYPE);
        indicateTaskManagerChanged();
    }
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    /** Raises an event to indicate the model has changed */
    private void indicateTaskManagerChanged() {
        raise(new TaskManagerChangedEvent(taskManager));
        raise(new FilteredTaskListUpdatedEvent(filteredTasks));
    }
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    @Override
    public synchronized void addTask(Task task) throws DuplicateTaskException {
        taskManager.addTask(task);
        indicateTaskManagerChanged();
    }
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowAll() {
        filteredTasks.setPredicate(null);
        raise(new FilteredTaskListUpdatedEvent(getFilteredTaskList()));
        updateFilteredTaskListType(ALL_TASK_LIST_TYPE);
    }
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowTimed() {
        updateFilteredTaskList(new PredicateExpression(new ActiveTimedQualifier(true)));
        updateFilteredTaskListType(TIMED_TASK_LIST_TYPE);
    }

    @Override
    public void updateFilteredListToShowFloating() {
        updateFilteredTaskList(new PredicateExpression(new ActiveTimedQualifier(false)));
        updateFilteredTaskListType(FLOATING_TASK_LIST_TYPE);
    }

```
###### \java\seedu\tache\model\ModelManager.java
``` java
    /**
     * Provides functionality for find command and raises TaskListTypeChangedEvent to update UI.
     * Set<String> is converted to ArrayList<String> so that String can be retrieved.
     */
    @Override
    public void updateFilteredTaskList(Set<String> keywords) {
        updateFilteredTaskList(new PredicateExpression(new MultiQualifier(keywords)));
        ArrayList<String> keywordsList = new ArrayList<String>(keywords);
        updateFilteredTaskListType(FOUND_TASK_LIST_TYPE);
        retainLatestKeywords(keywords);
        raise(new TaskListTypeChangedEvent("Find \"" + keywordsList.get(0) + "\""));
    }

    private void updateFilteredTaskList(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
        raise(new FilteredTaskListUpdatedEvent(getFilteredTaskList()));
    }

    @Override
    public String getFilteredTaskListType() {
        return filteredTaskListType;
    }

    private void updateFilteredTaskListType(String newFilteredTaskListType) {
        if (!filteredTaskListType.equals(newFilteredTaskListType)) {
            raise(new TaskListTypeChangedEvent(newFilteredTaskListType));
        }
        filteredTaskListType = newFilteredTaskListType;
    }
```
###### \java\seedu\tache\model\ModelManager.java
``` java
    private class TimedQualifier implements Qualifier {
        private boolean isTimed;

        TimedQualifier(boolean isTimed) {
            this.isTimed = isTimed;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            if (isTimed) {
                return task.getTimedStatus();
            } else {
                return !task.getTimedStatus();
            }
        }

        @Override
        public String toString() {
            return "timed=" + isTimed;
        }
    }

```
###### \java\seedu\tache\model\ReadOnlyTaskManager.java
``` java
    /**
     * Returns a string that contains the no. of tasks and no. of tags.
     */
    String toString();

}
```
###### \java\seedu\tache\model\task\DateTime.java
``` java
    public String getDateTimeForFullCalendar() {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
        return sdf.format(date);
    }

    public Date getDate() {
        return date;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DateTime // instanceof handles nulls
                && this.date.equals(((DateTime) other).getDate())); // state check
    }

    public boolean hasPassed() {
        Date today = new Date();
        return this.date.before(today);
    }

```
###### \java\seedu\tache\model\task\ReadOnlyTask.java
``` java
    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        boolean start = true;
        boolean end = true;
        if (other.getStartDateTime().isPresent() && this.getStartDateTime().isPresent()) {
            start = other.getStartDateTime().equals(this.getStartDateTime());
        }
        if (other.getEndDateTime().isPresent() && this.getEndDateTime().isPresent()) {
            end = other.getEndDateTime().equals(this.getEndDateTime());
        }
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getName().equals(this.getName())
                && start && end
                && (other.getActiveStatus() == this.getActiveStatus())
                && (other.getTimedStatus() == this.getTimedStatus())
                && (other.getRecurringStatus() == this.getRecurringStatus())
                && other.getRecurInterval().equals(this.getRecurInterval())); // state checks here onwards
    }
```
###### \java\seedu\tache\model\task\Task.java
``` java
    @Override
    public boolean getTimedStatus() {
        return isTimed;
    }

    public void setTimedStatus(boolean isTimed) {
        this.isTimed = isTimed;
    }

```
###### \java\seedu\tache\model\TaskManager.java
``` java
    @Override
    public String toString() {
        final StringBuilder builder = new StringBuilder();
        for (Task task : tasks) {
            builder.append(task.toString() + "\n");
        }
        return builder.toString();
    }
```
###### \java\seedu\tache\model\util\SampleDataUtil.java
``` java
    public static Task[] getSampleTasks() {
        try {
            Task eggsAndBread = new Task(new Name("Buy Eggs and Bread"), new UniqueTagList("HighPriority"));
            eggsAndBread.setStartDateTime(Optional.of(new DateTime("01-04-17 19:55:12")));
            Task readBook = new Task(new Name("Read Book about Software Engineering"),
                    new UniqueTagList("LowPriority"));
            readBook.setEndDateTime(Optional.of(new DateTime("21-04-17 23:59:59")));
            Task visitGrandma = new Task(new Name("Visit Grandma"), new UniqueTagList("MediumPriority"));
            visitGrandma.setStartDateTime(Optional.of(new DateTime("15-04-17 16:00:00")));
            visitGrandma.setEndDateTime(Optional.of(new DateTime("21-04-17 19:00:00")));
            return new Task[] {
                eggsAndBread, readBook, visitGrandma,
                new Task(new Name("Pay David 20 for cab"), new UniqueTagList("LowPriority")),
                new Task(new Name("Get Fit"), new UniqueTagList("LowPriority")),
                new Task(new Name("Find a girlfriend"), new UniqueTagList("LowPriority")),
                new Task(new Name("Walk the Dog"), Optional.of(new DateTime("14 April 2017")),
                            Optional.of(new DateTime("14 April 2017")), new UniqueTagList("MediumPriority"),
                                true, true, false, RecurInterval.NONE),
                new Task(new Name("Buy Medicine"), Optional.of(new DateTime("15 April 2017")),
                            Optional.empty(), new UniqueTagList("LowPriority"), true, true, false, RecurInterval.NONE),
                new Task(new Name("Submit Project Proposal"), Optional.empty(),
                            Optional.of(new DateTime("17 April 2017")), new UniqueTagList("HighPriority"),
                                true, true, false, RecurInterval.NONE),
            };
        } catch (IllegalValueException e) {
            throw new AssertionError("sample data cannot be invalid", e);
        }
    }
```
###### \java\seedu\tache\storage\StorageManager.java
``` java
    @Override
    public void setTaskManagerFilePath(String newPath) {
        this.taskManagerStorage.setTaskManagerFilePath(newPath);
        raise(new DataFileLocationChangedEvent(newPath));
    }
```
###### \java\seedu\tache\storage\XmlSerializableTaskManager.java
``` java
    @Override
    public String toString() {
        final StringBuilder builder = new StringBuilder();
        for (ReadOnlyTask task : getTaskList()) {
            builder.append(task.toString() + "\n");
        }
        return builder.toString();
    }

}
```
###### \java\seedu\tache\ui\CalendarPanel.java
``` java
    private void loadCalendar(ObservableList<ReadOnlyTask> taskList) {
        String calendarURL = MainApp.class.getResource("/html/calendar.html").toExternalForm();
        WebEngine engine = calendar.getEngine();
        engine.load(calendarURL);
        ReadOnlyObjectProperty<Worker.State> webViewState = engine.getLoadWorker().stateProperty();
        if (webViewState.get() == Worker.State.SUCCEEDED) {
            addAllEvents(taskList);
        } else {
            engine.getLoadWorker().stateProperty().addListener(new ChangeListener<Worker.State>() {
                @Override
                public void changed(ObservableValue<? extends Worker.State> observable,
                        Worker.State oldValue, Worker.State newValue) {
                    if (newValue != Worker.State.SUCCEEDED) {
                        return;
                    }
                    addAllEvents(taskList);
                }
            });
        }
    }

    private String getLoadTaskExecuteScript(ReadOnlyTask task) {
        String title = task.getName().toString();
        String start = "0";
        String end = "0"; // invalid format of datetime
        Optional<DateTime> startDateTime = task.getStartDateTime();
        Optional<DateTime> endDateTime = task.getEndDateTime();
        if (task.getStartDateTime().isPresent()) {
            start = startDateTime.get().getDateTimeForFullCalendar();
        }
        if (task.getEndDateTime().isPresent()) {
            end = endDateTime.get().getDateTimeForFullCalendar();
        }
        String status = "uncompleted";
        if (task.getActiveStatus() == false) {
            status = "completed";
        } else if (task.getEndDateTime().isPresent()) {
            DateTime taskDate = task.getEndDateTime().get();
            if (taskDate.hasPassed()) {
                status = "overdue";
            }
        }
        return "add_event('" + title + "', '" + start + "', '" + end + "', '" + status + "')";
    }

    @Subscribe
    public void handleTaskManagerChangedEvent(TaskManagerChangedEvent event) {
        ObservableList<ReadOnlyTask> taskList = event.data.getTaskList();
        refreshCalendar(taskList);
    }

    @Subscribe
    public void handleTaskPanelSelectionChangedEvent(TaskPanelSelectionChangedEvent event) {
        Optional<DateTime> startDateTime = event.getNewSelection().getStartDateTime();
        Optional<DateTime> endDateTime = event.getNewSelection().getEndDateTime();
        if (startDateTime.isPresent()) {
            changeReferenceDate(startDateTime.get().getDateTimeForFullCalendar());
        } else if (endDateTime.isPresent()) {
            changeReferenceDate(endDateTime.get().getDateTimeForFullCalendar());
        }
    }

    @Subscribe
    public void handleTaskListTypeChangedEvent(TaskListTypeChangedEvent event) {
        String taskListType = event.getTaskListType();
        if (taskListType.equals("Tasks Due Today") || taskListType.equals("Tasks Due This Week")) {
            Date today = new Date();
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
            String referenceDate = sdf.format(today);
            changeReferenceDate(referenceDate);
        }
    }

    private void changeReferenceDate(String referenceDate) {
        WebEngine engine = calendar.getEngine();
        ReadOnlyObjectProperty<Worker.State> webViewState = engine.getLoadWorker().stateProperty();
        if (webViewState.get() == Worker.State.SUCCEEDED) {
            engine.executeScript("change_reference_date('" + referenceDate + "')");
        } else {
            engine.getLoadWorker().stateProperty().addListener(new ChangeListener<Worker.State>() {
                @Override
                public void changed(ObservableValue<? extends Worker.State> observable,
                        Worker.State oldValue, Worker.State newValue) {
                    if (newValue != Worker.State.SUCCEEDED) {
                        return;
                    }
                    engine.executeScript("change_reference_date('" + referenceDate + "')");
                }
            });
        }
    }

    private String getRemoveAllTaskScript() {
        return "remove_all()";
    }

    private void refreshCalendar(ObservableList<ReadOnlyTask> taskList) {
        WebEngine engine = calendar.getEngine();
        ReadOnlyObjectProperty<Worker.State> webViewState = engine.getLoadWorker().stateProperty();
        if (webViewState.get() == Worker.State.SUCCEEDED) {
            removeAllEvents();
            addAllEvents(taskList);
        } else {
            engine.getLoadWorker().stateProperty().addListener(new ChangeListener<Worker.State>() {
                @Override
                public void changed(ObservableValue<? extends Worker.State> observable,
                        Worker.State oldValue, Worker.State newValue) {
                    if (newValue != Worker.State.SUCCEEDED) {
                        return;
                    }
                    removeAllEvents();
                    addAllEvents(taskList);
                }
            });
        }
    }

    private void removeAllEvents() {
        WebEngine engine = calendar.getEngine();
        engine.executeScript(getRemoveAllTaskScript());
    }

    /**
     * Inputs all timed events in task list to calendar.
     * For deadline tasks (only have end but no start date/time), convert end date/time to start date/time.
     */
    private void addAllEvents(ObservableList<ReadOnlyTask> taskList) {
        for (ReadOnlyTask task : taskList) {
<<<<<<< HEAD
            if (!task.getStartDateTime().isPresent()) {
                Task newTask = new Task(task);
                newTask.setStartDateTime(newTask.getEndDateTime());
                newTask.setEndDateTime(Optional.empty());
                task = newTask;
            }
            addCurrentEvent(task);
=======
            if (task.getTimedStatus()) {
                if (!task.getStartDateTime().isPresent()) {
                    Task newTask = new Task(task);
                    newTask.setStartDateTime(newTask.getEndDateTime());
                    newTask.setEndDateTime(Optional.empty());
                    task = newTask;
                }
                addCurrentEvent(task);
            }
>>>>>>> 897f3600ff687e025ba940bcb9e26c2be45ac68a
        }
    }

    private void addCurrentEvent(ReadOnlyTask task) {
        WebEngine engine = calendar.getEngine();
        ReadOnlyObjectProperty<Worker.State> webViewState = engine.getLoadWorker().stateProperty();
        if (webViewState.get() == Worker.State.SUCCEEDED) {
            engine.executeScript(getLoadTaskExecuteScript(task));
        } else {
            engine.getLoadWorker().stateProperty().addListener(new ChangeListener<Worker.State>() {
                @Override
                public void changed(ObservableValue<? extends Worker.State> observable,
                        Worker.State oldValue, Worker.State newValue) {
                    if (newValue != Worker.State.SUCCEEDED) {
                        return;
                    }
                    engine.executeScript(getLoadTaskExecuteScript(task));
                }
            });
        }
    }
```
###### \java\seedu\tache\ui\CommandBox.java
``` java
    /**
     * Sets autocomplete functionality for user commands.
     * Uses ControlsFX Autocomplete TextField function.
     */
    private void setAutocomplete() {
        String[] possibleCommands = {"add ", "clear", "complete ", "delete ", "edit ", "exit", "find ",
                                        "help", "list", "save ", "select ", "load ", "undo" };
        AutoCompletionBinding<String> binding = TextFields.bindAutoCompletion(commandTextField, possibleCommands);
        binding.setMaxWidth(100);
    }
```
###### \java\seedu\tache\ui\MainWindow.java
``` java
    @FXML
    private AnchorPane taskListTypePlaceholder;

    @FXML
    private AnchorPane taskCountPlaceholder;
```
###### \java\seedu\tache\ui\MainWindow.java
``` java
    void fillInnerParts() {
        calendarPanel = new CalendarPanel(getCalendarPlaceholder(), logic.getFilteredTaskList());
        taskListPanel = new TaskListPanel(getTaskListPlaceholder(), logic.getFilteredTaskList());
        new TaskListType(getTaskListTypePlaceholder(), logic.getFilteredTaskListType());
        new TaskCount(getTaskCountPlaceholder(), logic);
        new ResultDisplay(getResultDisplayPlaceholder());
        new StatusBarFooter(getStatusbarPlaceholder(), config.getTaskManagerFilePath());
        new CommandBox(getCommandBoxPlaceholder(), logic);
    }

    private AnchorPane getCalendarPlaceholder() {
        return calendarPlaceholder;
    }
```
###### \java\seedu\tache\ui\MainWindow.java
``` java
    private AnchorPane getTaskCountPlaceholder() {
        return taskCountPlaceholder;
    }

    private AnchorPane getTaskListTypePlaceholder() {
        return taskListTypePlaceholder;
    }
```
###### \java\seedu\tache\ui\MainWindow.java
``` java
    void viewTaskEvent(ReadOnlyTask task) {
        //browserPanel.viewEvent(task);
    }
```
###### \java\seedu\tache\ui\StatusBarFooter.java
``` java
    public String getSaveLocation() {
        return this.saveLocationStatus.getText();
    }

    public String getSyncStatus() {
        return this.syncStatus.getText();
    }
```
###### \java\seedu\tache\ui\StatusBarFooter.java
``` java
    @Subscribe
    public void handleDataFileLocationChangedEvent(DataFileLocationChangedEvent abce) {
        assert abce != null;
        String newLocation = abce.toString();
        logger.info(LogsCenter.getEventHandlingLogMessage(abce, "Setting new data file location to" + newLocation));
        setSaveLocation("New Location: " + newLocation);
    }
}
```
###### \java\seedu\tache\ui\TaskCard.java
``` java
    private static final String START_DATE_INDICATOR = "Start Date: ";
    private static final String START_TIME_INDICATOR = "Start Time: ";
    private static final String END_DATE_INDICATOR = "End Date: ";
    private static final String END_TIME_INDICATOR = "End Time: ";
    private static final String FXML = "TaskListCard.fxml";

    private static final String COMPLETED_INDICATOR = "completed";
    private static final String OVERDUE_INDICATOR = "overdue";
    private static final String UNCOMPLETED_INDICATOR = "uncompleted";

    private final Logger logger = LogsCenter.getLogger(TaskCard.class);

    private String statusOfTask = UNCOMPLETED_INDICATOR;
```
###### \java\seedu\tache\ui\TaskCard.java
``` java
    public TaskCard(ReadOnlyTask task, int displayedIndex) {
        super(FXML);
        assert task != null;
        assert displayedIndex > 0;
        id.setText(Integer.toString(displayedIndex) + ". ");
        name.setText(task.getName().toString());
        name.setWrapText(true); // spill over to next line if task name is too long
        setStatusOfTask(task);
        setTickOrCross();
        setBorderColour();
        initDatesAndTimes(task);
        initTags(task);
    }

    private void setStatusOfTask(ReadOnlyTask task) {
        if (task.getActiveStatus() == false) {
            statusOfTask = COMPLETED_INDICATOR;
        } else if (task.getEndDateTime().isPresent()) {
            DateTime taskDate = task.getEndDateTime().get();
            if (taskDate.hasPassed()) {
                statusOfTask = OVERDUE_INDICATOR;
            }
        }
    }

    private void setBorderColour() {
        if (statusOfTask.equals(UNCOMPLETED_INDICATOR)) {
            cardPane.setStyle("-fx-border-color: #5f77bd");
        } else if (statusOfTask.equals(OVERDUE_INDICATOR)) {
            cardPane.setStyle("-fx-border-color: #ef044b");
        }
    }

    private void setTickOrCross() {
        if (statusOfTask.equals(COMPLETED_INDICATOR)) {
            tickOrCross.setImage(new Image(MainApp.class.getResource("/images/tick.png").toExternalForm()));
        } else if (statusOfTask.equals(OVERDUE_INDICATOR)) {
            tickOrCross.setImage(new Image(MainApp.class.getResource("/images/cross.png").toExternalForm()));
        }
    }

    private void initDatesAndTimes(ReadOnlyTask task) {
        if (task.getStartDateTime().isPresent()) {
            DateTime start = task.getStartDateTime().get();
            Label startDateLabel = new Label(START_DATE_INDICATOR + start.getDateOnly());
            startDateLabel.setId("startdate");
            datesAndTimes.getChildren().add(startDateLabel);
            Label startTimeLabel = new Label(START_TIME_INDICATOR + start.getTimeOnly());
            startTimeLabel.setId("starttime");
            datesAndTimes.getChildren().add(startTimeLabel);
            logger.fine("Start date and time added in Labels for " + task.getName().toString());
        }
        if (task.getEndDateTime().isPresent()) {
            DateTime end = task.getEndDateTime().get();
            Label endDateLabel = new Label(END_DATE_INDICATOR + end.getDateOnly());
            endDateLabel.setId("enddate");
            datesAndTimes.getChildren().add(endDateLabel);
            Label endTimeLabel = new Label(END_TIME_INDICATOR + end.getTimeOnly());
            endTimeLabel.setId("endtime");
            datesAndTimes.getChildren().add(endTimeLabel);
            logger.fine("End date and time added in Labels for " + task.getName().toString());
        }
    }
```
###### \java\seedu\tache\ui\TaskCount.java
``` java
package seedu.tache.ui;

import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;

import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Region;
import seedu.tache.commons.core.LogsCenter;
import seedu.tache.commons.events.ui.FilteredTaskListUpdatedEvent;
import seedu.tache.commons.util.FxViewUtil;
import seedu.tache.logic.Logic;
import seedu.tache.model.task.ReadOnlyTask;

/**
 * Count of timed and floating tasks.
 */
public class TaskCount extends UiPart<Region> {
    private static final Logger logger = LogsCenter.getLogger(TaskCount.class);
    private static final String FXML = "TaskCount.fxml";

    @FXML
    private Label timedTaskCount;
    @FXML
    private Label floatingTaskCount;

    public TaskCount(AnchorPane taskCountPlaceholder, Logic logic) {
        super(FXML);
        setTimedTaskCount(logic.getFilteredTaskList());
        setFloatingTaskCount(logic.getFilteredTaskList());
        addToPlaceholder(taskCountPlaceholder);
        registerAsAnEventHandler(this);
    }

    private void addToPlaceholder(AnchorPane placeHolder) {
        FxViewUtil.applyAnchorBoundaryParameters(getRoot(), 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(getRoot());
    }

```
###### \java\seedu\tache\ui\TaskCount.java
``` java
    private void setTimedTaskCount(ObservableList<ReadOnlyTask> taskList) {
        assert taskList != null;
        String count = getTimedTaskCount(taskList);
        this.timedTaskCount.setText(count);
    }

    private String getTimedTaskCount(ObservableList<ReadOnlyTask> taskList) {
        assert taskList != null;
        int count = 0;
        for (ReadOnlyTask task : taskList) {
            if (task.getTimedStatus() == true) {
                count++;
            }
        }
        return Integer.toString(count);
    }

    private void setFloatingTaskCount(ObservableList<ReadOnlyTask> taskList) {
        assert taskList != null;
        String count = getFloatingTaskCount(taskList);
        this.floatingTaskCount.setText(count);
    }

    private String getFloatingTaskCount(ObservableList<ReadOnlyTask> taskList) {
        assert taskList != null;
        int count = 0;
        for (ReadOnlyTask task : taskList) {
            if (task.getTimedStatus() == false) {
                count++;
            }
        }
        return Integer.toString(count);
    }

    @Subscribe
    public void handleFilteredTaskListUpdatedEvent(FilteredTaskListUpdatedEvent event) {
        assert event != null;
        ObservableList<ReadOnlyTask> taskList = event.getFilteredTaskList();
        String oldTimedCount = this.timedTaskCount.getText();
        String newTimedCount = getTimedTaskCount(taskList);
        if (oldTimedCount != newTimedCount) {
            this.timedTaskCount.setText(newTimedCount);
            logger.fine("Timed task list count changed to : '" + newTimedCount + "'");
        }
        String oldFloatingCount = this.floatingTaskCount.getText();
        String newFloatingCount = getFloatingTaskCount(taskList);
        if (oldFloatingCount != newFloatingCount) {
            this.floatingTaskCount.setText(newFloatingCount);
            logger.fine("Floating task list count changed to : '" + newFloatingCount + "'");
        }
    }

}
```
###### \java\seedu\tache\ui\TaskListType.java
``` java
package seedu.tache.ui;

import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;

import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Region;
import seedu.tache.commons.core.LogsCenter;
import seedu.tache.commons.events.ui.TaskListTypeChangedEvent;
import seedu.tache.commons.util.FxViewUtil;

/**
 * Panel containing: type of tasks shown in task list, no. of detailed tasks and no. of floating tasks.
 */
public class TaskListType extends UiPart<Region> {
    private final Logger logger = LogsCenter.getLogger(TaskListType.class);
    private static final String FXML = "TaskListType.fxml";

    @FXML
    private Label taskListType;

    public TaskListType(AnchorPane taskListTypePlaceholder, String typeOfTasks) {
        super(FXML);
        taskListType.setText(typeOfTasks);
        addToPlaceholder(taskListTypePlaceholder);
        registerAsAnEventHandler(this);
    }

    private void addToPlaceholder(AnchorPane placeHolder) {
        FxViewUtil.applyAnchorBoundaryParameters(getRoot(), 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(getRoot());
    }

    @Subscribe
    public void handleTaskListTypeChangedEvent(TaskListTypeChangedEvent event) {
        String oldTaskListType = this.taskListType.getText();
        String newTaskListType = event.getTaskListType();
        if (oldTaskListType != newTaskListType) {
            this.taskListType.setText(newTaskListType);
            logger.fine("Task list type changed to : '" + newTaskListType + "'");
        }
    }

}
```
###### \resources\view\MainWindow.fxml
``` fxml
      <SplitPane id="splitPane" fx:id="splitPane" dividerPositions="0.3" VBox.vgrow="ALWAYS">
         <items>
            <SplitPane dividerPositions="0.3" maxWidth="300.0" orientation="VERTICAL">
              <items>
                <AnchorPane maxHeight="90.0">
                     <children>
                      <AnchorPane fx:id="taskListTypePlaceholder" minWidth="230.0" AnchorPane.leftAnchor="0.0" AnchorPane.topAnchor="0.0">
                           <padding>
                              <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
                           </padding>
                        </AnchorPane>
                      <AnchorPane fx:id="taskCountPlaceholder" minHeight="90.0" maxWidth="60.0" prefWidth="60.0" AnchorPane.leftAnchor="210.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                           <padding>
                              <Insets bottom="5.0" left="10.0" right="10.0" top="5.0" />
                           </padding>
                        </AnchorPane>
                     </children>
                  </AnchorPane>
                <AnchorPane minWidth="300.0" prefWidth="300.0">
                     <children>
                        <VBox fx:id="taskList" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                           <padding>
                                <Insets bottom="10.0" left="10.0" right="10.0" top="10.0"/>
                           </padding>
                           <children>
                              <AnchorPane fx:id="taskListPanelPlaceholder" VBox.vgrow="ALWAYS" />
                           </children>
                        </VBox>
                     </children>
                  </AnchorPane>
              </items>
            </SplitPane>
            <AnchorPane fx:id="calendarPlaceholder" minWidth="380.0" prefWidth="380.0">
```
###### \resources\view\TacheTheme.css
``` css
.text-field {
    -fx-background-color: #5f77bd;
    -fx-font-size: 12pt;
    -fx-font-family: "Segoe UI Semibold";
    -fx-prompt-text-fill: black;
    -fx-text-fill: white;
    -fx-highlight-fill: #06314c;
}

.split-pane {
    -fx-border-radius: 1;
    -fx-border-width: 1;
    -fx-background-color: white;
}

.anchor-pane {
     -fx-background-color: white;
}

.anchor-pane-with-border {
     -fx-background-color: white;
     -fx-border-color: #039ed3;
     -fx-border-width: 3px;
}

.result-display {
    -fx-text-fill: #5f77bd;
    -fx-font-family: Segoe UI Light;
    -fx-font-size: 15px;
}

.status-bar-footer {
    -fx-background-color: white;
}

.status-bar .label {
    -fx-text-fill: #5f77bd;
    -fx-font-size: 15px;
}

.menu-bar {
    -fx-background-color: white;
}

.menu-bar .label {
    -fx-font-size: 14pt;
    -fx-font-family: "Segoe UI Semibold";
    -fx-text-fill: #5f77bd;
}

.task-list-header {
    -fx-background-color: white;
}

.task-list-header .label {
    -fx-font-size: 15pt;
    -fx-font-family: "Segoe UI Semibold";
    -fx-text-fill: #5f77bd;
    -fx-alignment: center;
}

.task-card-id-and-name .label {
    -fx-text-fill: #5f77bd;
    -fx-font-size: 12pt;
}

.task-card-date-time .label {
    -fx-font-size: 10pt;
    -fx-font-family: "Segoe UI Light";
    -fx-text-fill: black;
}

#cardPane {
    -fx-border-width: 3 3 3 3;
}

#tags {
    -fx-hgap: 7;
    -fx-vgap: 3;
}

#tags .label {
    -fx-text-fill: white;
    -fx-background-color: #5f77bd;
    -fx-padding: 1 3 1 3;
    -fx-border-radius: 2;
    -fx-background-radius: 2;
    -fx-font-size: 11;
}


.error {
    -fx-background-color: #ef044b;
}

```
###### \resources\view\TaskCount.fxml
``` fxml

<?import javafx.scene.control.Label?>
<?import javafx.scene.image.Image?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.layout.AnchorPane?>

<AnchorPane maxWidth="60.0" minHeight="70.0" prefHeight="70.0" prefWidth="60.0" styleClass="task-list-header"
       xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <ImageView fitHeight="35.0" fitWidth="35.0" pickOnBounds="true" preserveRatio="true" AnchorPane.leftAnchor="0.0" AnchorPane.topAnchor="0.0">
         <image>
            <Image url="@../images/clock.png" />
         </image>
      </ImageView>
      <Label fx:id="timedTaskCount" minHeight="35.0" minWidth="25.0" prefHeight="35.0" prefWidth="25.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" />
      <ImageView fitHeight="35.0" fitWidth="35.0" pickOnBounds="true" preserveRatio="true" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0">
         <image>
            <Image url="@../images/task.png" />
         </image>
      </ImageView>
      <Label fx:id="floatingTaskCount" minHeight="35.0" minWidth="25.0" prefHeight="35.0" prefWidth="25.0" AnchorPane.bottomAnchor="0.0" AnchorPane.rightAnchor="0.0" />
   </children>
</AnchorPane>
```
###### \resources\view\TaskListCard.fxml
``` fxml
                        <HBox alignment="CENTER_LEFT" spacing="5" styleClass="task-card-id-and-name">
                            <children>
                                <HBox>
                                    <Label fx:id="id" minWidth="28.0" />
                                    <AnchorPane prefWidth="200.0" minWidth="200.0">
                                       <children>
                                         <Label fx:id="name" maxWidth="170.0" text="\$first" />
                                         <AnchorPane minHeight="15.0" minWidth="15.0" prefHeight="20.0" prefWidth="20.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                                       <children>
                                         <ImageView fx:id="tickOrCross" fitHeight="15.0" fitWidth="15.0" pickOnBounds="true" preserveRatio="true" AnchorPane.rightAnchor="5.0" AnchorPane.topAnchor="0.0" />
                                    </children>
                                 </AnchorPane>
                              </children>
                           </AnchorPane>
                                </HBox>
                            </children>
                        </HBox>
                        <FlowPane fx:id="tags" />
                        <FlowPane fx:id="datesAndTimes" styleClass="task-card-date-time" maxWidth = "100.0"/>
```
###### \resources\view\TaskListType.fxml
``` fxml

<?import java.net.URL?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.AnchorPane?>

<AnchorPane fx:id="taskListTypePlaceholder" styleClass="task-list-header" xmlns="http://javafx.com/javafx/8.0.111"
    xmlns:fx="http://javafx.com/fxml/1">
    <stylesheets>
        <URL value="@TacheTheme.css" />
    </stylesheets>
    <Label fx:id="taskListType" maxWidth="200" prefWidth="200" minHeight="80"/>
</AnchorPane>
```
