# A0140042A
###### \java\seedu\address\commons\events\storage\FileStorageChangedEvent.java
``` java
/**
 * Loads the storage file in the given file path
 */
public class FileStorageChangedEvent extends BaseEvent {

    private String filePath;

    public FileStorageChangedEvent(String filePath) {
        this.filePath = filePath;
    }

    @Override
    public String toString() {
        return filePath;
    }

    public String getFilePath() {
        return filePath;
    }

}
```
###### \java\seedu\address\commons\events\storage\ForceSaveEvent.java
``` java
/**
 * Saves current state into the filePath
 */
public class ForceSaveEvent extends BaseEvent {

    private String filePath;

    public ForceSaveEvent(String filePath) {
        this.filePath = filePath;
    }

    @Override
    public String toString() {
        return filePath;
    }

    public String getFilePath() {
        return filePath;
    }

}
```
###### \java\seedu\address\logic\autocomplete\AutocompleteDataStructure.java
``` java
/**
 * Interface for data structures for auto complete manager
 */
public interface AutocompleteDataStructure {

    /**
     * Loads phrases used for auto completion into the data structure
     */
    public void load(String... phrases);

    /**
     * Finds a list of completions that can be made using the current prefix
     * @param prefix - to match against
     * @return a list of strings with auto completed suggestions
     */
    public List<String> findCompletions(String prefix);
}
```
###### \java\seedu\address\logic\autocomplete\AutocompleteManager.java
``` java
/**
 * Handles the auto-completion of the input
 */
public class AutocompleteManager {
    private final Logger logger = LogsCenter.getLogger(AutocompleteManager.class);
    public static final String[] AUTOCOMPLETE_DATA = { "help", "add", "by", "repeat", "list"
            , "edit", "find", "delete", "select", "book"
            , "confirm", "editlabel", "undo", "clear", "push"
            , "pull", "export", "exit", "to", "from", "on"
            , "hourly", "daily", "weekly", "monthly", "yearly"
            , "overdue", "outstanding", "completed", "today", "yesterday"
            , "tomorrow", "bookings", "incomplete", "confirm", "load", "saveas"
            , "remove", "change", "editbooking", "days", "months"
            , "years", "every", "mark", "unmark"};

    private AutocompleteDataStructure data;

    /**
     * Initializes auto-complete object with default auto-complete data
     */
    public AutocompleteManager() {
        this(AUTOCOMPLETE_DATA);
    }

    /**
     * Initializes auto-complete object with specified auto-complete data
     */
    public AutocompleteManager(String... data) {
        this.data = new Trie();
        this.data.load(data);
    }

    /**
     * Adds more strings for auto completion
     */
    public void addData(String... phrases) {
        data.load(phrases);
    }

    /**
     * Find auto-complete suggestions given a search term
     * @param term - search term
     * @return a list of suggestions for the given term
     */
    public AutocompleteResponse getSuggestions(AutocompleteRequest request) {
        String wordAtCursor = getWordAtCursor(request);
        List<String> suggestions = data.findCompletions(wordAtCursor);
        AutocompleteResponse response = new AutocompleteResponse(request, suggestions);
        return processRequest(response);
    }

    /**
     * Generates a new AutocompleteResponse with the new phrase, caretPosition and list of suggestions
     */
    private AutocompleteResponse processRequest(AutocompleteResponse response) {
        //if empty or matches all (AKA no match)
        if (response.getSuggestions().isEmpty() ||
                response.getSuggestions().size() == AutocompleteManager.AUTOCOMPLETE_DATA.length) {
            return response;
        }

        logger.info("Suggestions: " + response.getSuggestions());

        String longestString = getLongestString(response.getSuggestions());
        int commonSubstringIndex = getCommonSubstringEndIndexFromStart(response.getSuggestions());
        String commonSubstring = longestString.substring(0, commonSubstringIndex);

        //Append a space IF AND ONLY IF the auto-completed word is the last word of the command
        String appendCharacter = "";
        int cursorWordEndIndex = getEndIndexOfWordAtCursor(response);
        boolean endHasSpace = false;
        if (cursorWordEndIndex == response.getPhrase().trim().length() && response.getSuggestions().size() == 1) {
            //Append a space if there is a space at the end already
            if (response.getPhrase().charAt(response.getPhrase().length() - 1) != ' ') {
                appendCharacter = " ";
            }
            endHasSpace = true;
        }

        //Move position caret to after auto completed word
        String currentWord = getWordAtCursor(response);
        int newPositionCaret = cursorWordEndIndex
                               - currentWord.length()
                               + commonSubstring.length()
                               + (endHasSpace ? 1 : 0);

        response.setPhrase(replacePhraseWithSuggestion(response, commonSubstring, appendCharacter));
        response.setCaretPosition(newPositionCaret);
        return response;
    }

    /**
     * Replaces the phrase's word at the caret position with the suggestion provided
     * Appends toAppend if there is any character to append after that
     */
    private String replacePhraseWithSuggestion(AutocompleteResponse response, String suggestion, String toAppend) {
        StringBuffer commandAutocompleted = new StringBuffer(response.getPhrase());

        commandAutocompleted.replace(getStartIndexOfWordAtCursor(response),
                                        getEndIndexOfWordAtCursor(response),
                                        (suggestion + toAppend));

        return commandAutocompleted.toString();
    }


    /**
     * Returns the character index at which the characters in the list of suggestions start to differ
     */
    private int getCommonSubstringEndIndexFromStart(List<String> suggestions) {
        String longestString = getLongestString(suggestions);
        int commonSubstringIndex = 0;
        char currentChar;
        commonSubstring:
        for (int charIndex = 0; charIndex < longestString.length(); charIndex++) {
            currentChar = longestString.charAt(charIndex);
            for (String suggestion : suggestions) {
                if (suggestion.length() <= charIndex || suggestion.charAt(charIndex) != currentChar) {
                    break commonSubstring;
                }
            }
            commonSubstringIndex++;
        }
        return commonSubstringIndex;
    }

    /**
     * Returns the longest string in the list, empty string otherwise
     */
    private String getLongestString(List<String> suggestions) {
        String longest = "";
        for (String suggestion : suggestions) {
            if (suggestion.length() >= longest.length()) {
                longest = suggestion;
            }
        }
        return longest;
    }

    /**
     * Extracts the word at the current the caretPosition in commandTextField
     */
    private String getWordAtCursor(AutocompleteRequest request) {
        if (request.getPhrase() != null && !request.getPhrase().trim().equals("")) {
            int startIndex = getStartIndexOfWordAtCursor(request);
            int endIndex = getEndIndexOfWordAtCursor(request);
            return request.getPhrase().substring(startIndex, endIndex);
        } else {
            return request.getPhrase();
        }

    }

    /**
     * Gets the start index of the phrase at the caretPosition of the request
     */
    private int getStartIndexOfWordAtCursor(AutocompleteRequest request) {
        if (request.getPhrase().isEmpty()) {
            return 0;
        }

        int currentPosition = request.getCaretPosition();
        int startIndex;
        currentPosition = currentPosition - 1 < 0 ? 0 : currentPosition - 1;
        while (currentPosition > 0  &&
                currentPosition < request.getPhrase().length() &&
                !Character.isWhitespace(request.getPhrase().charAt(currentPosition))) {
            currentPosition--;
        }

        //Increment index by 1 if whitespace is met
        if (Character.isWhitespace(request.getPhrase().charAt(currentPosition))) {
            currentPosition++;
        }

        startIndex = currentPosition;
        return startIndex;
    }

    /**
     * Gets the end index of the phrase at the caretPosition of the request
     */
    private int getEndIndexOfWordAtCursor(AutocompleteRequest request) {
        if (request.getPhrase().isEmpty()) {
            return 0;
        }

        int currentPosition = request.getCaretPosition();
        int endIndex;
        while (currentPosition >= 0  &&
                currentPosition < request.getPhrase().length() &&
                !Character.isWhitespace(request.getPhrase().charAt(currentPosition))) {
            currentPosition++;
        }
        endIndex = currentPosition;
        return endIndex;
    }

    @Override
    public boolean equals(Object other) {
        if (other instanceof AutocompleteManager) {
            AutocompleteManager compare = (AutocompleteManager) other;
            AutocompleteRequest request = new AutocompleteRequest("", 0);
            return getSuggestions(request).equals(compare.getSuggestions(request));
        } else {
            return false;
        }
    }

}
```
###### \java\seedu\address\logic\autocomplete\AutocompleteRequest.java
``` java
/**
 * A request class to request for an auto complete at the cursor position
 */
public class AutocompleteRequest {
    protected String phrase;
    protected int caretPosition; //The caret always represents the character on the left of it

    /**
     * Initializes the request with the phrase and the caretPosition
     */
    public AutocompleteRequest(String phrase, int caretPosition) {
        setPhrase(phrase);
        setCaretPosition(caretPosition);
    }

    /**
     * Returns the phrase
     */
    public String getPhrase() {
        return phrase;
    }

    /**
     * Sets the phrase
     */
    public void setPhrase(String phrase) {
        this.phrase = phrase;
    }

    /**
     * Sets the caretPosition
     */
    public int getCaretPosition() {
        return caretPosition;
    }

    /**
     * Sets the caretPosition if valid (between 0 to phrase.length - 1)
     */
    public void setCaretPosition(int caretPosition) {
        assert caretPosition >= 0;
        this.caretPosition = caretPosition;
    }

    @Override
    public boolean equals(Object other) {
        if (other instanceof AutocompleteRequest) {
            AutocompleteRequest otherRequest = (AutocompleteRequest) other;
            return (this.caretPosition == otherRequest.caretPosition) &&
                   (this.phrase.equals(otherRequest.phrase));
        } else {
            return false;
        }
    }
}
```
###### \java\seedu\address\logic\autocomplete\AutocompleteResponse.java
``` java
/**
 * A response class that extends request class to contain suggestions and the replaced phrase
 */
public class AutocompleteResponse extends AutocompleteRequest {
    private List<String> suggestions;

    /**
     * Initializes a response with phrase, caretPosition and a list of suggestions
     */
    public AutocompleteResponse(String phrase, int caretPosition, List<String> suggestions) {
        super(phrase, caretPosition);
        setSuggestions(suggestions);
    }

    /**
     * Initializes a response from the {@link AutocompleteRequest}
     */
    public AutocompleteResponse(AutocompleteRequest request, List<String> suggestions) {
        this(request.getPhrase(), request.getCaretPosition(), suggestions);
    }

    /**
     * Returns the suggestions
     */
    public List<String> getSuggestions() {
        return suggestions;
    }

    /**
     * Sets the suggestions list
     */
    public void setSuggestions(List<String> suggestions) {
        this.suggestions = suggestions;
    }

    @Override
    public boolean equals(Object other) {
        if (other instanceof AutocompleteResponse) {
            AutocompleteResponse otherResponse = (AutocompleteResponse) other;
            boolean sameCaret = this.caretPosition == otherResponse.caretPosition;
            boolean samePhrase = this.phrase.equals(otherResponse.phrase);
            boolean sameSuggestions = (suggestions == otherResponse.suggestions);
            if (this.suggestions != null && otherResponse.suggestions != null) {
                sameSuggestions = suggestions.containsAll(otherResponse.getSuggestions());
            }
            return sameCaret && samePhrase && sameSuggestions;
        } else {
            return false;
        }
    }
}
```
###### \java\seedu\address\logic\commandhistory\CommandHistory.java
``` java
/**
 * Interface for iterating through the command history
 */
public interface CommandHistory {

    /**
     * Adds a command which has been executed previously
     * @param command - previously executed
     */
    void addCommand(String command);

    /**
     * Returns a previously executed command
     */
    String previous();

    /**
     * Returns the next command (if any) if the user has previously iterated through his commands before
     */
    String next();
}
```
###### \java\seedu\address\logic\commandhistory\CommandHistoryManager.java
``` java
/**
 * Class to keep track of previous command executions
 * Singleton pattern is used as creating multiple instances of CommandHistory would mess up the history of the execution
 */
public class CommandHistoryManager implements CommandHistory {
    private static CommandHistoryManager instance;
    private LinkedList<String> history;
    private ListIterator<String> cursor;
    private boolean hasDirection = false;
    private boolean isTraversingBack = true;

    /**
     * Gets the instance of the CommandHistory
     */
    public static CommandHistoryManager getInstance() {
        if (instance == null) {
            instance = new CommandHistoryManager();
        }
        return instance;
    }

    private CommandHistoryManager() {
        history = new LinkedList<String>();
        resetIterator();
    }

    @Override
    public void addCommand(String command) {
        history.addFirst(command);
        resetIterator();
    }

    @Override
    public String previous() {
        if (cursor.hasNext()) {
            if (hasDirection && !isTraversingBack) {
                cursor.next();
            }

            if (cursor.hasNext()) {
                hasDirection = true;
                isTraversingBack = true;
                return cursor.next();
            }
        }
        return null;
    }

    @Override
    public String next() {
        if (cursor.hasPrevious()) {
            if (hasDirection && isTraversingBack) {
                cursor.previous();
            }
            if (cursor.hasPrevious()) {
                hasDirection = true;
                isTraversingBack = false;
                return cursor.previous();
            } else if (hasDirection && isTraversingBack) {
                //Reset the cursor to where it was before
                cursor.next();
            }
        }
        resetIterator();
        return null;
    }

    /**
     * Brings cursor back to the front
     */
    public void resetIterator() {
        cursor = history.listIterator(0);
        hasDirection = false;
    }
}
```
###### \java\seedu\address\logic\commands\DeleteLabelCommand.java
``` java
/**
 * Edits a label in all tasks that exists in task manager
 */
public class DeleteLabelCommand extends Command {

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Label %1$s deleted from all tasks";
    public static final String MESSAGE_LABEL_NOT_EXIST = "Specified label does not exist in any task saved";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";
    public static final String MESSAGE_LABEL_INVALID = "Label name is invalid";

    private Label labelToDelete;

    public DeleteLabelCommand(String labelToDelete) throws IllegalValueException {
        this.labelToDelete = new Label(labelToDelete);
    }

    @Override
    public CommandResult execute() throws CommandException {
        model.updateFilteredListToShowAll();
        List<ReadOnlyTask> allTaskList = model.getFilteredTaskList();
        boolean labelExist = deleteLabelInTasks(allTaskList);

        if (!labelExist) {
            throw new CommandException(MESSAGE_LABEL_NOT_EXIST);
        }

        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, labelToDelete));
    }

    /**
     * Deletes a specific label in all tasks
     * @param allTaskList
     * @return true if the specified label exists
     */
    private boolean deleteLabelInTasks(List<ReadOnlyTask> allTaskList) throws CommandException {
        boolean labelExist = false;
        saveCurrentState();
        for (int i = 0; i < allTaskList.size(); i++) {
            Task task = new Task(allTaskList.get(i));
            UniqueLabelList labels = task.getLabels();
            if (labels.contains(labelToDelete)) {
                Set<Label> labelSet = labels.toSet();
                labelSet.remove(labelToDelete);
                task.setLabels(new UniqueLabelList(labelSet));

                labelExist = true;

                try {
                    model.updateTask(i, task);
                } catch (DuplicateTaskException dpe) {
                    throw new CommandException(MESSAGE_DUPLICATE_TASK);
                }
            }
        }

        if (!labelExist) {
            deleteCurrentState();
        }

        return labelExist;
    }

    /**
     * Save the data in task manager if command is mutating the data
     */
    public void saveCurrentState() {
        if (isMutating()) {
            try {
                LogicManager.undoCommandHistory.addStorageHistory(model.getTaskManager().getImmutableTaskList(),
                        model.getTaskManager().getImmutableLabelList());
            } catch (CloneNotSupportedException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * Deletes the data in task manager if command is mutating the data
     */
    public void deleteCurrentState() {
        UndoManager.getInstance().getUndoData();
    }

    @Override
    public boolean isMutating() {
        return true;
    }

}
```
###### \java\seedu\address\logic\commands\EditLabelCommand.java
``` java
/**
 * Edits a label in all tasks that exists in Task Manager
 */
public class EditLabelCommand extends Command {

    public static final String COMMAND_WORD = "editlabel";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Edits a label to another label \n"
            + "Existing label will be overwritten by the new label.\n"
            + "Parameters: LABEL_TO_EDIT NEW_LABEL \n"
            + "Example: " + COMMAND_WORD + " school schoolwork";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Labels changed from %1$s to %2$s";
    public static final String MESSAGE_LABEL_NOT_EXIST = "Specified label does not exist in any task saved";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";
    public static final String MESSAGE_LABEL_INVALID = "Label name is invalid";

    private Label labelToChange;
    private Label newLabel;

    public EditLabelCommand(String labelToChange, String newLabel) throws IllegalValueException {
        this.labelToChange = new Label(labelToChange);
        this.newLabel = new Label(newLabel);
    }

    @Override
    public CommandResult execute() throws CommandException {
        model.updateFilteredListToShowAll();
        List<ReadOnlyTask> allTaskList = model.getFilteredTaskList();
        boolean labelExist = replaceLabelInTasks(allTaskList);

        if (!labelExist) {
            throw new CommandException(MESSAGE_LABEL_NOT_EXIST);
        }

        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, labelToChange, newLabel));
    }

    /**
     * Replaces a specific label in all tasks
     * @param allTaskList
     * @return true if the specified label exists
     */
    private boolean replaceLabelInTasks(List<ReadOnlyTask> allTaskList) throws CommandException {
        boolean labelExist = false;
        for (int i = 0; i < allTaskList.size(); i++) {
            Task task = new Task(allTaskList.get(i));
            UniqueLabelList labels = task.getLabels();
            if (labels.contains(labelToChange)) {
                Set<Label> labelSet = labels.toSet();
                labelSet.remove(labelToChange);
                labelSet.add(newLabel);
                task.setLabels(new UniqueLabelList(labelSet));

                labelExist = true;

                try {
                    saveCurrentState();
                    model.updateTask(i, task);
                } catch (DuplicateTaskException dpe) {
                    throw new CommandException(MESSAGE_DUPLICATE_TASK);
                }
            }
        }
        return labelExist;
    }

    /**
     * Save the data in task manager if command is mutating the data
     */
    public void saveCurrentState() {
        if (isMutating()) {
            try {
                LogicManager.undoCommandHistory.addStorageHistory(model.getTaskManager().getImmutableTaskList(),
                        model.getTaskManager().getImmutableLabelList());
            } catch (CloneNotSupportedException e) {
                e.printStackTrace();
            }
        }
    }

    @Override
    public boolean isMutating() {
        return true;
    }

}
```
###### \java\seedu\address\logic\commands\LoadCommand.java
``` java
/**
* Loads the Task Manager data from a specific path
*/
public class LoadCommand extends Command {
    public static final String COMMAND_WORD = "load";

    public static final String MESSAGE_USAGE = COMMAND_WORD +
            ": Loads data from a new file relative to DoOrDie Task Manager " +
            "Parameters: FILE_PATH_RELATIVE_TO_JAR_FILE\n" +
            "Example: " + COMMAND_WORD + " data/taskmanager.xml";

    public static final String MESSAGE_SUCCESS = "Loaded data from %1$s, now using %1$s as storage file";
    public static final String MESSAGE_DOES_NOT_END_WITH_XML = "File must end in .xml";
    public static final String MESSAGE_FILE_DOES_NOT_EXIST = "File does not exist";

    private String storagePath;

    public LoadCommand(String storagePath) {
        this.storagePath = storagePath.trim();
    }

    @Override
    public CommandResult execute() throws CommandException {
        File file = new File(storagePath);
        if (!FileUtil.isFileExists(file)) {
            return new CommandResult(MESSAGE_FILE_DOES_NOT_EXIST);
        } else if (storagePath.endsWith(".xml")) {
            EventsCenter.getInstance().post(new FileStorageChangedEvent(storagePath));
            return new CommandResult(String.format(MESSAGE_SUCCESS, storagePath));
        } else {
            return new CommandResult(MESSAGE_DOES_NOT_END_WITH_XML);
        }
    }

    @Override
    public boolean isMutating() {
        return false;
    }
}
```
###### \java\seedu\address\logic\commands\SaveAsCommand.java
``` java
/**
 * Saves the Task Manager data to a specific path
 */
public class SaveAsCommand extends Command {
    public static final String COMMAND_WORD = "saveas";

    public static final String MESSAGE_USAGE = COMMAND_WORD +
            ": Save data to a new filepath relative to DoOrDie Task Manager" +
            "Parameters: FILE_PATH_RELATIVE_TO_JAR_FILE\n" +
            "Example: " + COMMAND_WORD + " data/taskmanager2.xml";

    public static final String MESSAGE_SUCCESS = "Saved to path : %1$s";
    public static final String MESSAGE_DOES_NOT_END_WITH_XML = "File must end in .xml";

    private String storagePath;

    public SaveAsCommand(String storagePath) {
        this.storagePath = storagePath.trim();
    }

    @Override
    public CommandResult execute() throws CommandException {
        if (storagePath.endsWith(".xml")) {
            EventsCenter.getInstance().post(new ForceSaveEvent(storagePath));
            EventsCenter.getInstance().post(new FileStorageChangedEvent(storagePath));
            return new CommandResult(String.format(MESSAGE_SUCCESS, storagePath));
        } else {
            return new CommandResult(MESSAGE_DOES_NOT_END_WITH_XML);
        }
    }

    @Override
    public boolean isMutating() {
        return false;
    }
}
```
###### \java\seedu\address\logic\parser\DeleteCommandParser.java
``` java
/**
 * Parses input arguments and creates a new DeleteCommand object
 */
public class DeleteCommandParser {

    private static final String DELIMITER = " ";
    private static final int ARGUMENT_LABEL_TO_DELETE_INDEX = 0;
    private static final int ARGUMENT_LENGTH = 1;
    private static final String REGEX_INDEX = "^[0-9\\+\\-][0-9]*$";

    /**
     * Parses the given {@code String} of arguments in the context of the DeleteCommand
     * and returns an DeleteCommand object for execution.
     */
    public Command parse(String args) {

        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer();
        argsTokenizer.tokenize(args);

        try {
            String[] arguments = argsTokenizer.getPreamble().get().split(DELIMITER);
            if (arguments.length != ARGUMENT_LENGTH) {
                throw new CommandException(DeleteCommand.MESSAGE_USAGE);
            }

            String parameter = arguments[ARGUMENT_LABEL_TO_DELETE_INDEX];
            if (parameter.matches(REGEX_INDEX)) { //matches 0-9 or + or - for the first character
                return tryParseAsIndex(args);
            } else {
                return new DeleteLabelCommand(arguments[ARGUMENT_LABEL_TO_DELETE_INDEX]);
            }
        } catch (Exception e) { }
        return new IncorrectCommand(
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
    }

    /**
     * Try parsing arguments as index
     */
    private Command tryParseAsIndex(String args) {
        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (index.isPresent()) {
            return new DeleteCommand(index.get());
        } else {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }
    }

}
```
###### \java\seedu\address\logic\parser\EditLabelCommandParser.java
``` java
/**
* Parses input arguments and creates a new EditLabelCommand object
*/
public class EditLabelCommandParser {

    private static final String DELIMITER = " ";
    private static final int ARGUMENT_NEW_LABEL_INDEX = 1;
    private static final int ARGUMENT_LABEL_TO_CHANGE_INDEX = 0;
    private static final int ARGUMENT_LENGTH = 2;

    /**
     * Parses the given {@code String} of arguments in the context of the
     * EditLabelCommand and returns an EditLabelCommand object for execution.
     */
    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer = new ArgumentTokenizer();
        argsTokenizer.tokenize(args);

        try {
            String[] arguments = argsTokenizer.getPreamble().get().split(DELIMITER);
            if (arguments.length != ARGUMENT_LENGTH) {
                throw new CommandException(EditLabelCommand.MESSAGE_USAGE);
            }

            return new EditLabelCommand(arguments[ARGUMENT_LABEL_TO_CHANGE_INDEX], arguments[ARGUMENT_NEW_LABEL_INDEX]);
        } catch (IllegalValueException e) {
            return new IncorrectCommand(String.format(EditLabelCommand.MESSAGE_LABEL_INVALID));
        } catch (Exception e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditLabelCommand.MESSAGE_USAGE));
        }
    }
}
```
###### \java\seedu\address\MainApp.java
``` java
    /**
     * Load all fonts in the resources/fonts folder
     */
    private void loadFonts() {
        Font.loadFont(getClass().getResourceAsStream("/fonts/YouMurdererBB-Regular.otf"), 10);
        Font.loadFont(getClass().getResourceAsStream("/fonts/Roboto-Condensed.ttf"), 10);
        Font.loadFont(getClass().getResourceAsStream("/fonts/Roboto-Regular.ttf"), 10);
        Font.loadFont(getClass().getResourceAsStream("/fonts/FontAwesome-Regular.otf"), 10);
    }
```
###### \java\seedu\address\MainApp.java
``` java
    /**
     * Handles FileStorageChangedEvent to load the data from the new location
     * @throws Exception
     */
    @Subscribe
    public void handleFileStorageChangedEvent(FileStorageChangedEvent event) throws Exception {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        //Update & save the config file
        config.setTaskManagerFilePath(event.getFilePath());
        try {
            ConfigUtil.saveConfig(config, configPath);
        } catch (IOException e) {
            e.printStackTrace();
        }

        //Reinitialize components
        storage.setTaskManagerFilePath(event.getFilePath());
        model = initModelManager(storage, userPrefs);
        logic = new LogicManager(model, storage);
        //Set the Ui to the new logic & model since we don't want to destroy the old UI
        ui.setModel(model);
        ui.setLogic(logic);
        //Update UI to show all tasks since we have loaded the new Task Manager in
        model.updateFilteredListToShowAll();

        //Restart the undo manager
        UndoManager.getInstance().clear();

        //Save all current data into the new location
        storage.saveTaskManager(model.getTaskManager(), event.getFilePath());
    }

    /**
     * Handles ForceSaveEvent to save the config to a location
     * @throws Exception
     */
    @Subscribe
    public void handleForceSaveEvent(ForceSaveEvent event) throws Exception {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        storage.saveTaskManager(model.getTaskManager(), event.getFilePath());
    }
```
###### \java\seedu\address\model\datastructure\Trie.java
``` java
/**
 * Data structure used to store auto complete data
 */
public class Trie implements AutocompleteDataStructure {
    private TrieNode rootNode;

    /**
     * Initializes a new Trie data structure with an empty root node
     */
    public Trie() {
        super();
        rootNode = new TrieNode(' ');
    }

    /**
     * Loads phrases used for auto completion into the Trie
     * @param phrases
     */
    @Override
    public void load(String... phrases) {
        for (String phrase : phrases) {
            loadRecursive(rootNode, phrase + "$");
        }
    }

    /**
     * Loads phrases character by character into the Trie
     * @param node - root to add the phrase from
     * @param phrase - phrase to add
     */
    private void loadRecursive(TrieNode node, String phrase) {
        if (StringUtils.isBlank(phrase)) {
            return;
        }
        char firstChar = phrase.charAt(0);
        node.add(firstChar);
        TrieNode childNode = node.getChildNode(firstChar);
        if (childNode != null) {
            loadRecursive(childNode, phrase.substring(1));
        }
    }

    /**
     * Checks recursively if each node contains a specific prefix
     * @param node - The node to check
     * @param prefix - the string to match
     * @return true if the node or any of its children contains the prefix
     */
    private TrieNode matchPrefixRecursive(TrieNode node, String prefix) {
        if (StringUtils.isBlank(prefix)) {
            return node;
        }
        char firstChar = prefix.charAt(0);
        TrieNode childNode = node.getChildNode(firstChar);
        if (childNode == null) {
            // no match at this char, exit
            return null;
        } else {
            // go deeper
            return matchPrefixRecursive(childNode, prefix.substring(1));
        }
    }

    /**
     * Finds a list of completions that can be made using the current prefix
     * @param prefix - to match against
     * @return a list of strings with auto completed suggestions
     */
    @Override
    public List<String> findCompletions(String prefix) {
        TrieNode matchedNode = matchPrefixRecursive(rootNode, prefix);
        List<String> completions = new LinkedList<String>();
        findCompletionsRecursive(matchedNode, prefix, completions);
        return completions;
    }

    /**
     * Finds a list of completions that can be made using the current prefix recursively
     * @param node - current node to check
     * @param prefix - to match against
     * @param completions - List of completions that are currently matched
     */
    private void findCompletionsRecursive(TrieNode node, String prefix, List<String> completions) {
        if (node == null) {
            // our prefix did not match anything, just return
            return;
        }
        if (node.getNodeValue() == '$') {
            /*
             * end reached, append prefix into completions list. Do not append
             * the trailing $, that is only to distinguish words like ann and
             * anne into separate branches of the tree.
             */
            completions.add(prefix.substring(0, prefix.length() - 1));
            return;
        }
        Collection<TrieNode> childNodes = node.getChildren();
        for (TrieNode childNode : childNodes) {
            char childChar = childNode.getNodeValue();
            findCompletionsRecursive(childNode, prefix + childChar, completions);
        }
    }
}
```
###### \java\seedu\address\model\datastructure\TrieNode.java
``` java
/**
 * Nodes that are contained in data structure {@link Trie}
 */
public class TrieNode {

    private Character character;
    private HashMap<Character, TrieNode> children;

    public TrieNode(char c) {
        super();
        this.character = new Character(c);
        children = new HashMap<Character, TrieNode>();
    }

    /**
     * Gets the value of the node
     */
    public char getNodeValue() {
        return character.charValue();
    }

    /**
     * Get the children of the current node
     */
    public Collection<TrieNode> getChildren() {
        return children.values();
    }

    /**
     * Gets the values of the children of the current node
     */
    public Set<Character> getChildrenNodeValues() {
        return children.keySet();
    }

    /**
     * Adds a child to the current node
     */
    public void add(char c) {
        if (children.get(new Character(c)) == null) {
            // children does not contain c, add a TrieNode
            children.put(new Character(c), new TrieNode(c));
        }
    }

    /**
     * Gets a child node
     * @param c - the key whose associated value is to be returned
     * @return - the value to which the specified key is mapped, or null if this map contains no mapping for the key
     */
    public TrieNode getChildNode(char c) {
        return children.get(new Character(c));
    }

    /**
     * Checks if the child has such a character
     * @param c - the key whose associated value is to be returned
     * @return - true if there is a match
     */
    public boolean contains(char c) {
        return (children.get(new Character(c)) != null);
    }

    @Override
    public int hashCode() {
        return character.hashCode();
    }

    @Override
    public boolean equals(Object obj) {
        if (!(obj instanceof TrieNode)) {
            return false;
        }
        TrieNode that = (TrieNode) obj;
        return (this.getNodeValue() == that.getNodeValue());
    }
}
```
###### \java\seedu\address\model\label\Label.java
``` java
/**
 * Represents a Label in DoOrDie Task Manager Application
 * Guarantees: immutable; name is valid as declared in {@link #isValidLabelName(String)}
 */
public class Label implements Comparable<Label> {

    public static final String MESSAGE_LABEL_CONSTRAINTS =
            "Label names should be alphanumeric, first character of label should be alphabetical";
    public static final String LABEL_VALIDATION_REGEX = "^[a-zA-Z][a-zA-Z0-9]+$";

    public final String labelName;

    /**
     * Validates given label name.
     *
     * @throws IllegalValueException if the given label name string is invalid.
     */
    public Label(String name) throws IllegalValueException {
        assert name != null;
        String trimmedName = name.trim();
        if (!isValidLabelName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_LABEL_CONSTRAINTS);
        }
        this.labelName = trimmedName;
    }

    /**
     * Returns true if a given string is a valid label name.
     */
    public static boolean isValidLabelName(String test) {
        return test.matches(LABEL_VALIDATION_REGEX);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Label // instanceof handles nulls
                        && this.labelName.equals(((Label) other).labelName)); // state check
    }

    @Override
    public int hashCode() {
        return labelName.hashCode();
    }

    /**
     * Returns labelName in String
     */
    public String getLabelName() {
        return labelName;
    }

    /**
     * Format state as text for viewing.
     */
    public String toString() {
        return '[' + labelName + ']';
    }

    @Override
    public int compareTo(Label o) {
        return this.labelName.compareTo(o.labelName);
    }

}
```
###### \java\seedu\address\model\label\UniqueLabelList.java
``` java
/**
 * A list of labels that enforces no nulls and uniqueness between its elements.
 *
 * Supports minimal set of list operations for the app's features.
 *
 * @see Label#equals(Object)
 * @see CollectionUtil#elementsAreUnique(Collection)
 */
public class UniqueLabelList implements Iterable<Label> {

    private final ObservableList<Label> internalList = FXCollections.observableArrayList();

    /**
     * Constructs empty LabelList.
     */
    public UniqueLabelList() {}

    /**
     * Creates a UniqueLabelList using given String labels. Enforces no nulls or
     * duplicates.
     */
    public UniqueLabelList(String... labels) throws DuplicateLabelException, IllegalValueException {
        final List<Label> labelList = new ArrayList<Label>();
        for (String label : labels) {
            labelList.add(new Label(label));
        }
        setLabels(labelList);
    }

    /**
     * Creates a UniqueLabelList using given labels. Enforces no nulls or
     * duplicates.
     */
    public UniqueLabelList(Label... labels) throws DuplicateLabelException {
        assert !CollectionUtil.isAnyNull((Object[]) labels);
        final List<Label> initialLabels = Arrays.asList(labels);
        if (!CollectionUtil.elementsAreUnique(initialLabels)) {
            throw new DuplicateLabelException();
        }
        internalList.addAll(initialLabels);
    }

    /**
     * Creates a UniqueLabelList using given labels. Enforces no null or
     * duplicate elements.
     */
    public UniqueLabelList(Collection<Label> labels) throws DuplicateLabelException {
        this();
        setLabels(labels);
    }

    /**
     * Creates a UniqueLabelList using given labels. Enforces no nulls.
     */
    public UniqueLabelList(Set<Label> labels) {
        assert !CollectionUtil.isAnyNull(labels);
        internalList.addAll(labels);
    }

    /**
     * Creates a copy of the given list. Insulates from changes in source.
     */
    public UniqueLabelList(UniqueLabelList source) {
        internalList.addAll(source.internalList); // insulate internal list from
                                                  // changes in argument
    }

    /**
     * Returns all labels in this list as a Set. This set is mutable and
     * change-insulated against the internal list.
     */
    public Set<Label> toSet() {
        return new HashSet<>(internalList);
    }

    /**
     * Replaces the Tags in this list with those in the argument label list.
     */
    public void setLabels(UniqueLabelList replacement) {
        this.internalList.setAll(replacement.internalList);
    }

    public void setLabels(Collection<Label> labels) throws DuplicateLabelException {
        assert !CollectionUtil.isAnyNull(labels);
        if (!CollectionUtil.elementsAreUnique(labels)) {
            throw new DuplicateLabelException();
        }
        internalList.setAll(labels);
    }

    /**
     * Removes all labels from the list. Warning, this cannot be undone!
     */
    public void removeAll() {
        internalList.clear();
    }

    @Override
    public UniqueLabelList clone() {
        UniqueLabelList labelList = new UniqueLabelList();
        try {

            for (Label label : internalList) {
                labelList.add(new Label(label.getLabelName()));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return labelList;
    }

    /**
     * Ensures every label in the argument list exists in this object.
     */
    public void mergeFrom(UniqueLabelList from) {
        final Set<Label> alreadyInside = this.toSet();
        from.internalList.stream().filter(label -> !alreadyInside.contains(label)).forEach(internalList::add);
    }

    /**
     * Returns true if the list contains an equivalent Label as the given
     * argument.
     */
    public boolean contains(Label toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }

    /**
     * Returns true if the list contains an equivalent Label as the given
     * argument.
     */
    public boolean containsStringLabel(String labelToCheck) {
        assert labelToCheck != null;
        // return internalList.contains(toCheck);
        for (Label label : internalList) {
            if (label.getLabelName().equalsIgnoreCase(labelToCheck)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Adds a Label to the list.
     *
     * @throws DuplicateLabelException
     *             if the Label to add is a duplicate of an existing Label in
     *             the list.
     */
    public void add(Label toAdd) throws DuplicateLabelException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateLabelException();
        }
        internalList.add(toAdd);
    }

    @Override
    public Iterator<Label> iterator() {
        return internalList.iterator();
    }

    public UnmodifiableObservableList<Label> asObservableList() {
        return new UnmodifiableObservableList<>(internalList);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueLabelList // instanceof handles nulls
                        && this.internalList.equals(((UniqueLabelList) other).internalList));
    }

    public boolean equalsOrderInsensitive(UniqueLabelList other) {
        return this == other || new HashSet<>(this.internalList).equals(new HashSet<>(other.internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }

    /**
     * Signals that an operation would have violated the 'no duplicates'
     * property of the list.
     */
    public static class DuplicateLabelException extends DuplicateDataException {
        protected DuplicateLabelException() {
            super("Operation would result in duplicate labels");
        }
    }

}
```
###### \java\seedu\address\ui\CommandBox.java
``` java
    /**
     * Hijacks the tab character for auto-completion, up/down for iterating through the command
     */
    @FXML
    private void handleOnKeyPressed(KeyEvent ke) {
        if (ke.getCode() == KeyCode.TAB) {
            //Extract the command as well as the caret position
            String command = commandTextField.getText();
            int caretPosition = commandTextField.getCaretPosition();

            //Create a auto complete request
            AutocompleteRequest request = new AutocompleteRequest(command, caretPosition);
            //Get the response using the auto complete manager
            AutocompleteResponse response = autocompleteManager.getSuggestions(request);

            //Update fields with the response
            updateAutocompleteFeedback(response);
            commandTextField.setText(response.getPhrase());
            commandTextField.positionCaret(response.getCaretPosition());

            //Consume the event so the text field will not go to the next ui component
            ke.consume();
        } else if (ke.getCode() == KeyCode.UP) {
            getPreviousCommand();
            ke.consume();
        } else if (ke.getCode() == KeyCode.DOWN) {
            getNextCommand();
            ke.consume();
        }
    }

    /**
     * Gets the next executed command from the current command (if iterated through before)
     */
    private void getNextCommand() {
        String command = commandHistory.next();
        setCommandAndCursorToEnd(command);
    }

    /**
     * Gets the previously executed command from the current command
     */
    private void getPreviousCommand() {
        String command = commandHistory.previous();
        setCommandAndCursorToEnd(command);
    }

    /**
     * Sets the command to the string input given along with the cursor at the end
     */
    private void setCommandAndCursorToEnd(String command) {
        command = command == null ? commandTextField.getText() : command;
        commandTextField.setText(command);
        moveCursorToEndOfField();
    }

    /**
     * Moves the cursor in commandTextField to the end of the string
     */
    private void moveCursorToEndOfField() {
        commandTextField.positionCaret(commandTextField.getLength());
    }

    /**
     * Updates the output window to either nothing or a list of suggestions
     */
    private void updateAutocompleteFeedback(AutocompleteResponse response) {
        if (response.getSuggestions().size() > 1) { //Show list of suggestions if more than 1
            raise(new NewResultAvailableEvent(response.getSuggestions().toString()));
        } else {
            raise(new NewResultAvailableEvent(""));
        }
    }

    /**
     * Sets the command box style to indicate a successful command.
     */
    private void setStyleToIndicateCommandSuccess() {
        commandTextField.getStyleClass().remove(ERROR_STYLE_CLASS);
    }

    /**
     * Sets the command box style to indicate a failed command.
     */
    private void setStyleToIndicateCommandFailure() {
        commandTextField.getStyleClass().add(ERROR_STYLE_CLASS);
    }

    public void setLogic(Logic logic) {
        this.logic = logic;
    }
}
```
###### \java\seedu\address\ui\LabelCard.java
``` java
    private void initLabel(seedu.address.model.label.Label labelToSet, int count) {
        icon.setIcon(FontAwesomeIcon.TAG);
        labelText.setText(labelToSet.getLabelName());
        taskCountText.setText(Integer.toString(count));
    }
}
```
###### \java\seedu\address\ui\LeftPanel.java
``` java
    public void updateLabelCount() {
        labelCount = new HashMap<Label, Integer>();

        for (ReadOnlyTask task : taskList) {
            for (Label label : task.getLabels()) {
                int currentCount = labelCount.get(label) == null ? 0 : labelCount.get(label);
                labelCount.put(label, currentCount + 1);
            }
        }

        setConnections(labelCount);
    }

    private void initIcons() {
        todayIconLabel.setIcon(FontAwesomeIcon.CALENDAR_ALT);
        calendarIconLabel.setIcon(FontAwesomeIcon.CALENDAR);
        labelIconLabel.setIcon(FontAwesomeIcon.HASHTAG);
        labelArrow.setIcon(FontAwesomeIcon.ANGLE_UP);
    }

```
###### \java\seedu\address\ui\LeftPanel.java
``` java
    public void setCalendarListView(ObservableList<ReadOnlyTask> taskList) {
        calendarLabel.setText("Calendar");
    }

    public void setConnections(HashMap<Label, Integer> labelList) {
        labels = getLabelsWithCount(labelList);
        labelCounterLabel.setText(Integer.toString(labelList.size()));
        labelListView.setItems(labels);
        labelListView.setCellFactory(listView -> new LabelListViewCell());
    }

    /**
     * Returns labels with count more than 0, ignoring all empty labels
     */
    private ObservableList<Label> getLabelsWithCount(HashMap<Label, Integer> labelList) {
        labels = FXCollections.observableArrayList();
        for (Entry<Label, Integer> entry : labelList.entrySet()) {
            if (entry.getValue() > 0) {
                labels.add(entry.getKey());
            }
        }
        FXCollections.sort(labels);
        return labels;
    }

    /**
     * Sets the task list to the given task list
     */
    public void setTaskList(ObservableList<ReadOnlyTask> taskList) {
        this.taskList = taskList;
    }

    @FXML
    private void toggleLabelList() {
        labelListView.setVisible(!labelListView.isVisible());
        if (labelListView.isVisible()) {
            labelArrow.setIcon(FontAwesomeIcon.ANGLE_UP);
        } else {
            labelArrow.setIcon(FontAwesomeIcon.ANGLE_DOWN);
        }
    }

    private void addToPlaceholder(AnchorPane placeHolderPane) {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        FxViewUtil.applyAnchorBoundaryParameters(getRoot(), 0.0, 0.0, 0.0, 0.0);
        placeHolderPane.getChildren().add(getRoot());
    }

```
###### \java\seedu\address\ui\LeftPanel.java
``` java
    class LabelListViewCell extends ListCell<Label> {

        @Override
        protected void updateItem(Label label, boolean empty) {
            super.updateItem(label, empty);
            if (empty || label == null) {
                setGraphic(null);
                setText(null);
            } else {
                Integer newCount = labelCount.get(label);
                if (newCount == null) {
                    newCount = 1;
                }
                setGraphic(new LabelCard(label, newCount).getRoot());
            }
        }
    }
}
```
###### \java\seedu\address\ui\MainWindow.java
``` java
    /**
     * Fill up components in the main window,
     * but only update appropriate components if already initialized
     */
    public void fillInnerParts() {
        //browserPanel = new BrowserPanel(browserPlaceholder);

        if (taskListPanel == null) {
            taskListPanel = new TaskListPanel(getTaskListPlaceholder(), logic.getFilteredTaskList());
        } else {
            //Update the logic only
            taskListPanel.setConnections(logic.getFilteredTaskList());
        }

        if (leftPanel == null) {
            leftPanel = new LeftPanel(getleftPanelPlaceholder(), model.getTaskManager().getTaskList());
        } else {
            leftPanel.setTaskList(model.getTaskManager().getTaskList());
            leftPanel.updateLabelCount();
            leftPanel.setTodayListView(model.getTaskManager().getTaskList());
        }

        if (resultDisplay == null) {
            resultDisplay = new ResultDisplay(getResultDisplayPlaceholder());
        }

        if (statusBarFooter == null) {
            statusBarFooter = new StatusBarFooter(getStatusbarPlaceholder(), config.getTaskManagerFilePath());
        } else {
            statusBarFooter.setSaveLocation(config.getTaskManagerFilePath());
        }

        if (commandBox == null) {
            commandBox = new CommandBox(getCommandBoxPlaceholder(), logic);
        } else {
            commandBox.setLogic(logic);
        }
    }
```
###### \java\seedu\address\ui\StatusBarFooter.java
``` java
    /**
     * Creates and add a label to the saveLocationStatus bar for right alignment
     */
    private void initializeSaveLocationLabel() {
        saveLocationLabel = new Label();
        saveLocationLabel.setId("saveLocationLabel");
        saveLocationStatus.setText("");
        saveLocationStatus.getRightItems().add(saveLocationLabel);
    }

    private void addToPlaceholder(AnchorPane placeHolder) {
        FxViewUtil.applyAnchorBoundaryParameters(getRoot(), 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(getRoot());
    }

    public void setSaveLocation(String location) {
        this.saveLocationLabel.setText(location);
    }
```
###### \resources\view\CommandBox.fxml
``` fxml

<?import de.jensd.fx.glyphs.fontawesome.FontAwesomeIconView?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.HBox?>

<AnchorPane styleClass="anchor-pane" stylesheets="@DarkTheme.css" xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
   <HBox fx:id="commandTextFieldContainer" prefWidth="1920.0" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
      <children>
         <FontAwesomeIconView fx:id="commandTextFieldBeforeLabel" fill="WHITE" glyphName="ANGLE_RIGHT" size="26">
            <HBox.margin>
               <Insets left="10.0" top="3" />
            </HBox.margin>
         </FontAwesomeIconView>
         <TextField fx:id="commandTextField" onAction="#handleCommandInputChanged" onKeyPressed="#handleOnKeyPressed" prefWidth="1920.0" promptText="Enter command here..." />
      </children>
   </HBox>
</AnchorPane>
```
###### \resources\view\DarkTheme.css
``` css
.background {
    -fx-background-color: #fafafa;
}

MenuBar {
    -fx-accent: #c03231;
    -fx-focus-color: #c03231;
}

Vbox, SplitPane {
    -fx-border-width: 0;
    -fx-border-insets: 0;
    -fx-padding: 0;
}

.label {
    -fx-font-size: 11pt;
    -fx-font-family: "Roboto";
    -fx-text-fill: #555555;
    -fx-opacity: 0.9;
}

.label-bright {
    -fx-font-size: 11pt;
    -fx-font-family: "Roboto";
    -fx-text-fill: white;
    -fx-opacity: 1;
}

.label-header {
    -fx-font-size: 32pt;
    -fx-font-family: "Roboto";
    -fx-text-fill: white;
    -fx-opacity: 1;
}

.text-field {
    -fx-font-size: 12pt;
    -fx-font-family: "Roboto";
}

.tab-pane {
    -fx-padding: 0 0 0 1;
}

.tab-pane .tab-header-area {
    -fx-padding: 0 0 0 0;
    -fx-min-height: 0;
    -fx-max-height: 0;
}

.table-view {
    -fx-base: #fafafa;
    -fx-control-inner-background: #fafafa;
    -fx-background-color: #fafafa;
    -fx-table-cell-border-color: transparent;
    -fx-table-header-border-color: transparent;
    -fx-padding: 5;
}

.table-view .column-header-background {
    -fx-background-color: transparent;
}

.table-view .column-header, .table-view .filler {
    -fx-size: 35;
    -fx-border-width: 0 0 1 0;
    -fx-background-color: transparent;
    -fx-border-color:
        transparent
        transparent
        derive(-fx-base, 80%)
        transparent;
    -fx-border-insets: 0 10 1 0;
}

.table-view .column-header .label {
    -fx-font-size: 20pt;
    -fx-font-family: "Segoe UI Light";
    -fx-text-fill: white;
    -fx-alignment: center-left;
    -fx-opacity: 1;
}

.table-view:focused .table-row-cell:filled:focused:selected {
    -fx-background-color: -fx-focus-color;
}

.split-pane:horizontal .split-pane-divider {
    -fx-border-width: 0 1 0 0;
    -fx-border-color: derive(#bdbdbd, 70%);
    -fx-background-color: transparent;
    -fx-cursor: default;
}

.split-pane {
    -fx-border-radius: 1;
    -fx-border-width: 0;
    -fx-background-color: derive(#fafafa, 20%);
    -fx-text-box-border: none;
    -fx-focus-color: transparent;
    -fx-faint-focus-color: transparent;
}

.split-pane > .split-pane-divider {
    -fx-padding: 0 0 0 0;
}

.list-cell {
    -fx-label-padding: 0 0 0 0;
    -fx-graphic-text-gap : 0;
    -fx-padding: 0 0 0 0;
    -fx-border-width: 0;
    -fx-background-color: #ffffff;
}

.list-cell .label {
    -fx-text-fill: #010504;
}

.cell_big_label {
    -fx-font-size: 16px;
    -fx-text-fill: #010504;
}

.cell_small_label {
    -fx-font-size: 11px;
    -fx-text-fill: #010504;
}

.anchor-pane {
     -fx-background-color: derive(#1d1d1d, 20%);
}

.anchor-pane-with-border {
    /*
     -fx-background-color: derive(#1d1d1d, 20%);
     -fx-border-color: derive(#1d1d1d, 10%);
     -fx-border-top-width: 1px;
    */
}

.status-bar {
    -fx-background-color: derive(#1d1d1d, 20%);
    -fx-text-fill: black;
}

.result-display .label {
    -fx-text-fill: black !important;
}

.status-bar .label {
    -fx-text-fill: white;
}

.status-bar-with-border {
    -fx-background-color: derive(#1d1d1d, 30%);
    -fx-border-color: derive(#1d1d1d, 25%);
    -fx-border-width: 1px;
}

.status-bar-with-border .label {
    -fx-text-fill: white;
}

.grid-pane {
    -fx-background-color: derive(#1d1d1d, 30%);
    -fx-border-color: derive(#1d1d1d, 30%);
    -fx-border-width: 1px;
}

.grid-pane .anchor-pane {
    -fx-background-color: derive(#1d1d1d, 30%);
}

.context-menu {
    -fx-background-color: derive(#1d1d1d, 20%);
}

.context-menu .label {
    -fx-text-fill: white;
}

.menu-bar {
    -fx-background-color: derive(#1d1d1d, 20%);
}

.menu-bar .label {
    -fx-font-size: 10pt;
    -fx-font-family: "Roboto";
    -fx-text-fill: white;
    -fx-opacity: 0.9;
}

.menu .left-container {
    -fx-background-color: black;
}

/*
 * Metro style Push Button
 * Author: Pedro Duque Vieira
 * http://pixelduke.wordpress.com/2012/10/23/jmetro-windows-8-controls-on-java/
 */
.button {
    -fx-padding: 5 22 5 22;
    -fx-border-color: #e2e2e2;
    -fx-border-width: 2;
    -fx-background-radius: 0;
    -fx-background-color: #1d1d1d;
    -fx-font-family: "Segoe UI", Helvetica, Arial, sans-serif;
    -fx-font-size: 11pt;
    -fx-text-fill: #d8d8d8;
    -fx-background-insets: 0 0 0 0, 0, 1, 2;
}

.button:hover {
    -fx-background-color: #3a3a3a;
}

.button:pressed, .button:default:hover:pressed {
  -fx-background-color: white;
  -fx-text-fill: #1d1d1d;
}

.button:focused {
    -fx-border-color: white, white;
    -fx-border-width: 1, 1;
    -fx-border-style: solid, segments(1, 1);
    -fx-border-radius: 0, 0;
    -fx-border-insets: 1 1 1 1, 0;
}

.button:disabled, .button:default:disabled {
    -fx-opacity: 0.4;
    -fx-background-color: #1d1d1d;
    -fx-text-fill: white;
}

.button:default {
    -fx-background-color: -fx-focus-color;
    -fx-text-fill: #ffffff;
}

.button:default:hover {
    -fx-background-color: derive(-fx-focus-color, 30%);
}

.dialog-pane {
    -fx-background-color: #1d1d1d;
}

.dialog-pane > *.button-bar > *.container {
    -fx-background-color: #1d1d1d;
}

.dialog-pane > *.label.content {
    -fx-font-size: 14px;
    -fx-font-weight: bold;
    -fx-text-fill: white;
}

.dialog-pane:header *.header-panel {
    -fx-background-color: derive(#1d1d1d, 25%);
}

.dialog-pane:header *.header-panel *.label {
    -fx-font-size: 18px;
    -fx-font-style: italic;
    -fx-fill: #FFFFFF;
    -fx-text-fill: white;
}

.scroll-bar .thumb {
    -fx-background-color: derive(#1d1d1d, 50%);
    -fx-background-insets: 3;
}

.scroll-bar .increment-button, .scroll-bar .decrement-button {
    -fx-background-color: transparent;
    -fx-padding: 0 0 0 0;
}

.scroll-bar .increment-arrow, .scroll-bar .decrement-arrow {
    -fx-shape: " ";
    -fx-padding: 0;
    -fx-border-width: 0;
}

.scroll-bar:vertical .increment-arrow, .scroll-bar:vertical .decrement-arrow {
    -fx-padding: 0 5 0 5;
}

.scroll-bar:horizontal .increment-arrow, .scroll-bar:horizontal .decrement-arrow {
    -fx-padding: 5 0 5 0;
}

#cardPane {
    -fx-background-color: transparent;
    -fx-border-color: #d6d6d6;
    -fx-border-width: 0 0 1 0;
}

#taskListView .track, #labelListView .track {
    -fx-border-color: #fafafa;
    -fx-background-color: #fafafa;
}

#taskListView, #taskList, #taskListPanelPlaceHolder, .list-cell {
    -fx-border-width: 0;
    -fx-background-insets: 0;
    -fx-padding: 1 0 0 0;
}

.list-view .scroll-bar:horizontal .increment-arrow,
.list-view .scroll-bar:horizontal .decrement-arrow,
.list-view .scroll-bar:horizontal .increment-button,
.list-view .scroll-bar:horizontal .decrement-button {
    -fx-padding:0;
}

#taskListView .list-cell:filled:selected:focused, #taskListView .list-cell:filled:selected {
    -fx-background-color: #ffebee;
    /* Up Right Down Left */
    -fx-border-width: 0 0 0 5;
    -fx-border-color: #a93a38;
}

#commandTypeLabel {
    -fx-font-size: 11px;
    -fx-text-fill: #F70D1A;
}

#filterField, #taskListPanel, #taskWebpage {
    -fx-effect: innershadow(gaussian, black, 10, 0, 0, 0);
}

#labels {
    -fx-hgap: 7;
    -fx-vgap: 3;
}

#labels .label {
    -fx-text-fill: #000000;
    -fx-background-color: #ffa8a1;
    -fx-padding: 0 1 0 1;
    -fx-border-width: 0 0 2 0;
    -fx-border-color: #dd4b39;
    -fx-border-radius: 2;
    -fx-background-radius: 2;
    -fx-font-size: 12;
    -fx-text-alignment: center;
    -fx-alignment: bottom-center;
}

#resultDisplayPlaceholder, #resultDisplay .content, #resultDisplay, #mainPane {
    -fx-font-family: "Roboto";
    -fx-font-size: 16;
    -fx-background-color: #dd4b39;
    -fx-background-radius: 0 0 0 0;
    -fx-focus-color: #dd4b39;
    -fx-faint-focus-color: #dd4b39;
    -fx-border-radius: 0 0 0 0;
    -fx-border-width: 0 0 0 0;
}

#resultDisplay .track {
    -fx-background-color: #dd4b39;
}

#resultDisplay .thumb {
    -fx-background-color: #FFFFFF;
}

#commandTextField, #commandBoxPlaceholder {
    -fx-background-color: #c03231;
    -fx-text-fill: #FFFFFF;
    -fx-font-family: "Roboto";
}

#commandTextFieldContainer {
    /* Up Right Down Left */
    -fx-border-width: 0 0 2 0;
    -fx-border-color: #FFFFFF;
}

#taskListPanelPlaceholder {
    -fx-border-width: 0 0 0 0;
}

#appTitleLabel {
    -fx-text-fill: #831313;
    -fx-font-family: "YouMurderer BB";
    -fx-font-size: 68px;
    -fx-text-alignment: center;
    -fx-padding: 10;
    -fx-alignment: center;
    -fx-pref-height: 50;
    -fx-pref-width: 500;
}

#labelTitle, #calendarLabel, #todayLabel {
    -fx-padding: 20 20 20 10;
    -fx-font-family: "Roboto";
    -fx-text-fill: #000000;
}

#todayCounterLabel, #labelCounterLabel {
    -fx-font-family: "Roboto";
    -fx-alignment: center-right;
    -fx-text-alignment: right;
    -fx-padding: 20 20 0 0;
    -fx-opacity: 0.54;
}

#labelListView, #labelListView .list-cell {
    -fx-background-color: transparent;
}

#labelListCard {
    -fx-opacity: 0.75;
    -fx-padding: 0 0 0 45;
}

#labelText {
    -fx-padding: 10 0 10 5;
}

#taskCountText {
    -fx-padding: 10 20 0 0;
    -fx-opacity: 0.54;
}

.sidePanel:hover, #labelListCard:hover {
    -fx-background-color: #ffebee;
}

#saveLocationStatus {
    -fx-text-alignment: right;
    -fx-alignment: center-right;
}

#syncStatus, #saveLocationLabel {
    -fx-font-family: "Roboto";
}
```
###### \resources\view\LabelCard.fxml
``` fxml

<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import javafx.geometry.Insets?>
<?import de.jensd.fx.glyphs.fontawesome.FontAwesomeIconView?>

<AnchorPane fx:id="labelListCard" xmlns:fx="http://javafx.com/fxml/1">
    <HBox maxHeight="100.0" prefWidth="245">
        <children>
            <FontAwesomeIconView fx:id="icon" size="18" >
                <HBox.margin>
                    <Insets left="45" top="12.0" />
                </HBox.margin>
            </FontAwesomeIconView>
            <Label fx:id="labelText" styleClass="cell_big_label" />
            <Pane HBox.hgrow="ALWAYS" />
            <Label fx:id="taskCountText" />
        </children>
    </HBox>
</AnchorPane>

```
###### \resources\view\LeftPanel.fxml
``` fxml

<?import de.jensd.fx.glyphs.fontawesome.FontAwesomeIconView?>
<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.ListView?>
<?import javafx.scene.layout.AnchorPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.Pane?>
<?import javafx.scene.layout.VBox?>

<AnchorPane xmlns="http://javafx.com/javafx/8.0.111" xmlns:fx="http://javafx.com/fxml/1">
    <stylesheets>
        <URL value="@DarkTheme.css" />
        <URL value="@Extensions.css" />
    </stylesheets>
   <children>
      <VBox prefHeight="200.0" prefWidth="100.0" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
         <children>
            <Label fx:id="appTitleLabel" text="Do Or Die" />
            <HBox maxHeight="100.0" styleClass="sidePanel" fx:id="todayHeader">
               <children>
                   <FontAwesomeIconView fx:id="todayIconLabel" size="20">
                     <HBox.margin>
                        <Insets left="20.0" top="17.0" />
                     </HBox.margin></FontAwesomeIconView>
                  <Label fx:id="todayLabel" text="Today" />
                  <Pane HBox.hgrow="ALWAYS" />
                  <Label fx:id="todayCounterLabel" text="0" />
               </children>
            </HBox>
            <HBox maxHeight="100.0" styleClass="sidePanel" fx:id="calendarHeader">
               <children>
                  <FontAwesomeIconView fx:id="calendarIconLabel" size="20">
                     <HBox.margin>
                        <Insets left="20.0" top="17.0" />
                     </HBox.margin></FontAwesomeIconView>
                  <Label fx:id="calendarLabel" text="Calendar" />
               </children>
            </HBox>
            <HBox maxHeight="100.0" fx:id="labelListHeader" onMouseClicked="#toggleLabelList" styleClass="sidePanel">
               <children>
                  <FontAwesomeIconView fx:id="labelIconLabel" size="20">
                     <HBox.margin>
                        <Insets left="20.0" top="17.0" />
                     </HBox.margin></FontAwesomeIconView>
                  <Label fx:id="labelTitle" text="Labels" />
                  <Pane HBox.hgrow="ALWAYS" />
                  <Label fx:id="labelCounterLabel" text="0" />
                  <FontAwesomeIconView fx:id="labelArrow" opacity="0.54" size="22">
                     <HBox.margin>
                        <Insets right="20" top="17.0" />
                     </HBox.margin></FontAwesomeIconView>
               </children>
            </HBox>
            <ListView fx:id="labelListView" maxHeight="1200.0" prefHeight="1200.0" />
         </children>
      </VBox>
   </children>
</AnchorPane>
```
