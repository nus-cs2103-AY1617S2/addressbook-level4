# A0164103W
###### /java/seedu/task/logic/commands/RedoCommand.java
``` java
package seedu.task.logic.commands;


import seedu.task.logic.commands.exceptions.CommandException;
import seedu.task.logic.history.TaskMemento;
import seedu.task.model.task.Task;

/**
 *Redoes the last undone command
 */
public class RedoCommand extends UndoRedoCommand {
    public static final String COMMAND_WORD = "redo";

    public static final String MESSAGE_SUCCESS = "Command redone";
    public static final String MESSAGE_NO_HISTORY = "No commands to redo";

    public RedoCommand() {
        super(MESSAGE_SUCCESS);
    }

    @Override
    TaskMemento getMemento() throws CommandException {
        return mementos.getRedoMemento().orElseThrow(
            () -> new CommandException(MESSAGE_NO_HISTORY));
    }

    @Override
    Task getMementoTask() throws CommandException {
        return memento.newTask;
    }

}
```
###### /java/seedu/task/logic/commands/UndoCommand.java
``` java
package seedu.task.logic.commands;


import seedu.task.logic.commands.exceptions.CommandException;
import seedu.task.logic.history.TaskMemento;
import seedu.task.model.task.Task;

/**
 * Undo previous commands executed
 */
public class UndoCommand extends UndoRedoCommand {
    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_SUCCESS = "Command undone";
    public static final String MESSAGE_NO_HISTORY = "No commands to undo";

    public UndoCommand() {
        super(MESSAGE_SUCCESS);
    }

    @Override
    TaskMemento getMemento() throws CommandException {
        return mementos.getUndoMemento().orElseThrow(
            () -> new CommandException(MESSAGE_NO_HISTORY));
    }

    @Override
    Task getMementoTask() throws CommandException {
        return memento.oldTask;
    }

}

```
###### /java/seedu/task/logic/commands/UndoRedoCommand.java
``` java
package seedu.task.logic.commands;

import seedu.task.logic.commands.exceptions.CommandException;
import seedu.task.logic.history.TaskMemento;
import seedu.task.model.task.Task;
import seedu.task.model.task.TaskId;
import seedu.task.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.task.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Used to implement undo and redo commands.
 * This class contains all the logic required to replace a current task in model with a memento,
 * the undo or redo command needs to specify which memento to replace the task with.
 */
public abstract class UndoRedoCommand extends Command {
    protected static String MESSAGE_SUCCESS;

    TaskMemento memento;

    /**
     * @param noHistory UI message to show when there are no command to redo or undo
     * @param success UI message to show when the redo or undo command was successful
     */
    UndoRedoCommand(String success) {
        MESSAGE_SUCCESS = success;
    }

    /**
     * Replaces the appropriate task in model with memento task, deletes the task in model,
     * or adds the memento task to the model
     */
    @Override
    public CommandResult execute() throws CommandException {
        memento = getMemento();
        final Task mementoTask = getMementoTask();
        final TaskId mementoTaskId = memento.taskId;
        Task taskToBeReplaced = model.getTaskList().getTaskById(mementoTaskId);

        assert !(mementoTask == null && taskToBeReplaced == null);

        if (mementoTask == null && taskToBeReplaced != null) {
            try {
                model.deleteTask(taskToBeReplaced);
            } catch (TaskNotFoundException e) {
                assert false : "The target task cannot be missing";
            }
        }

        if (taskToBeReplaced == null && mementoTask != null) {
            try {
                model.addTask(mementoTask);
            } catch (DuplicateTaskException e) {
                assert false : "Adding duplicate task";
            }
        }

        if (taskToBeReplaced != null && mementoTask != null) {
            try {
                model.updateTaskById(mementoTaskId, mementoTask);
            } catch (DuplicateTaskException e) {
                assert false : "duplicate task";
            }
        }
        return new CommandResult(MESSAGE_SUCCESS);
    }

    abstract TaskMemento getMemento() throws CommandException;

    abstract Task getMementoTask() throws CommandException;

}
```
###### /java/seedu/task/model/task/DueDate.java
``` java
package seedu.task.model.task;

import java.util.Calendar;

import seedu.task.commons.exceptions.IllegalValueException;
import seedu.task.model.util.DateParser;

public class DueDate {
/**
 * Represents a Task's due date in the task list.
 * Guarantees: immutable; is valid as declared in {@link #isValidDueDate(String)}
 */
    public final Calendar dueDate;

    /**
     * Validates given description.
     *
     * @throws IllegalValueException if given description string is invalid.
     */
    public DueDate(String inputDueDate) throws IllegalValueException {
        this.dueDate = DateParser.parse(inputDueDate);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DueDate // instanceof handles nulls
                && this.dueDate.equals(((DueDate) other).dueDate)); // state check
    }


    @Override
    public String toString() {
        return DateParser.toString(dueDate);
    }

    @Override
    public int hashCode() {
        return dueDate.hashCode();
    }

}
```
###### /java/seedu/task/model/util/DateParser.java
``` java
    private static int parsedDate[] = new int[3];
    private static final int INDEX_DAY = 0;
    private static final int INDEX_MONTH = 1;
    private static final int INDEX_YEAR = 2;
    private static final int INDEX_SUN = 1;
    private static final int INDEX_MON = 2;
    private static final int INDEX_TUE = 3;
    private static final int INDEX_WED = 4;
    private static final int INDEX_THU = 5;
    private static final int INDEX_FRI = 6;
    private static final int INDEX_SAT = 7;

```
###### /java/seedu/task/model/util/DateParser.java
``` java
    /**
     * Returns date in integers given string format of date
     *
     * @param date in string format
     * @return array containing day, month, and year at INDEX_DAY, INDEX_MONTH, INDEX_YEAR respectively
     * @throws IllegalValueException if illegal values are entered
     */
    private static int[] getDate(String date) throws IllegalValueException {
        Calendar calDate = Calendar.getInstance();
        int dayOfWeek = calDate.get(Calendar.DAY_OF_WEEK);
        String firstWord;
        if (date.indexOf(" ") == -1) {
            firstWord = date;
        } else {
            firstWord = date.substring(0, date.indexOf(" "));
        }

        if (date.substring(0, 1).matches("[0-9]")) { //Date given in number format
            parsedDate[INDEX_DAY] = Integer.parseInt(date.substring(0, 2));
            parsedDate[INDEX_MONTH] = Integer.parseInt(date.substring(3, 5)) - MONTH_OFFSET;

            int l = firstWord.length();
            if (l == 5) { //No year given
                parsedDate[INDEX_YEAR] = calDate.get(Calendar.YEAR);
            } else if (l == 10) {
                parsedDate[INDEX_YEAR] = Integer.parseInt(date.substring(6, 10));
            } else {
                throw new IllegalValueException(DATE_STRING_ILLEGAL_FORMAT);
            }
        } else {
            switch (firstWord.toLowerCase()) { //Date given in recognized keyword
            case "today" : {
                break;
            }
            case "tomorrow" : {
                calDate.add(Calendar.DATE, 1);
                break;
            }
            case "monday" :
            case "mon": {
                calDate.add(Calendar.DATE, compareDayOfWeek(dayOfWeek, INDEX_MON));
                break;
            }
            case "tuesday" :
            case "tues" :
            case "tue": {
                calDate.add(Calendar.DATE, compareDayOfWeek(dayOfWeek, INDEX_TUE));
                break;
            }
            case "wednesday" :
            case "wed": {
                calDate.add(Calendar.DATE, compareDayOfWeek(dayOfWeek, INDEX_WED));
                break;
            }
            case "thursday" :
            case "thurs" :
            case "thu": {
                calDate.add(Calendar.DATE, compareDayOfWeek(dayOfWeek, INDEX_THU));
                break;
            }
            case "friday" :
            case "fri": {
                calDate.add(Calendar.DATE, compareDayOfWeek(dayOfWeek, INDEX_FRI));
                break;
            }
            case "saturday" :
            case "sat": {
                calDate.add(Calendar.DATE, compareDayOfWeek(dayOfWeek, INDEX_SAT));
                break;
            }
            case "sunday" :
            case "sun": {
                calDate.add(Calendar.DATE, compareDayOfWeek(dayOfWeek, INDEX_SUN));
                break;
            }
            default:
                throw new IllegalValueException(DATE_STRING_ILLEGAL_FORMAT);
            }
            parsedDate[INDEX_DAY] = calDate.get(Calendar.DAY_OF_MONTH);
            parsedDate[INDEX_MONTH] = calDate.get(Calendar.MONTH);
            parsedDate[INDEX_YEAR] = calDate.get(Calendar.YEAR);
        }

        return parsedDate;
    }

    private static int compareDayOfWeek(int day1, int day2) {
        return day2 - day1 < 0 ?
                day2 - day1 + 7 :
                day2 - day1;
    }

    private static int getHour(String date) {
        if (date.indexOf(" ") == -1) {
            return 0;
        } else {
            String time = date.substring(date.indexOf(" ") + 1);
            return Integer.parseInt(time.substring(0, 2));
        }
    }

    private static int getMinute(String date) {
        if (date.indexOf(" ") == -1) {
            return 0;
        } else {
            String time = date.substring(date.indexOf(" ") + 1);
            return Integer.parseInt(time.substring(3));
        }
    }
}
```
