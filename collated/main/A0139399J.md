# A0139399J
###### /java/seedu/doit/logic/commands/MarkCommand.java
``` java
package seedu.doit.logic.commands;

import seedu.doit.commons.core.Messages;
import seedu.doit.commons.core.UnmodifiableObservableList;
import seedu.doit.logic.commands.exceptions.CommandException;
import seedu.doit.model.item.ReadOnlyTask;
import seedu.doit.model.item.UniqueTaskList;

public class MarkCommand extends Command {
    public static final String COMMAND_WORD = "mark";
    public static final String COMMAND_PARAMETER = "INDEX";
    public static final String COMMAND_RESULT = "Marks task at specified index as completed";
    public static final String COMMAND_EXAMPLE = "mark 20";
    public static final String MESSAGE_USAGE = COMMAND_WORD
        + ": Marks the task identified by the index number used in the last task list as completed.\n"
        + "Parameters: INDEX (must be a positive integer)\n"
        + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_MARK_TASK_SUCCESS = "Marked Task: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";

    public final int filteredTaskListIndex;

    public MarkCommand(int filteredTaskListIndex) {
        assert filteredTaskListIndex > 0;
        this.filteredTaskListIndex = filteredTaskListIndex;
    }

    @Override
    public CommandResult execute() throws CommandException {

        UnmodifiableObservableList<ReadOnlyTask> lastShownTaskList = this.model.getFilteredTaskList();

        if (this.filteredTaskListIndex <= lastShownTaskList.size()) {
            ReadOnlyTask taskToMark = lastShownTaskList.get(this.filteredTaskListIndex - 1);

            try {
                this.model.markTask(this.filteredTaskListIndex - 1, taskToMark);
            } catch (UniqueTaskList.TaskNotFoundException pnfe) {
                assert false : "The target task cannot be missing";
            } catch (UniqueTaskList.DuplicateTaskException dpe) {
                throw new CommandException(MESSAGE_DUPLICATE_TASK);
            }

            return new CommandResult(String.format(MESSAGE_MARK_TASK_SUCCESS, taskToMark));
        } else {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
    }

    public static String getName() {
        return COMMAND_WORD;
    }

    public static String getParameter() {
        return COMMAND_PARAMETER;
    }

    public static String getResult() {
        return COMMAND_RESULT;
    }

    public static String getExample() {
        return COMMAND_EXAMPLE;
    }
}
```
###### /java/seedu/doit/logic/commands/UnmarkCommand.java
``` java
package seedu.doit.logic.commands;

import seedu.doit.commons.core.EventsCenter;
import seedu.doit.commons.core.Messages;
import seedu.doit.commons.core.UnmodifiableObservableList;
import seedu.doit.commons.events.ui.JumpToListRequestEvent;
import seedu.doit.logic.commands.exceptions.CommandException;
import seedu.doit.model.item.ReadOnlyTask;
import seedu.doit.model.item.UniqueTaskList;

public class UnmarkCommand extends Command {
    public static final String COMMAND_WORD = "unmark";
    public static final String COMMAND_PARAMETER = "INDEX";
    public static final String COMMAND_RESULT = "Marks task at specified index as uncompleted";
    public static final String COMMAND_EXAMPLE = "unmark 6";

    public static final String MESSAGE_USAGE = COMMAND_WORD
        + ": Changes the task identified by the index number used in the last task list to uncompleted.\n"
        + "Parameters: INDEX (must be a positive integer)\n"
        + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_UNMARK_TASK_SUCCESS = "Unmarked Task: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";

    public final int filteredTaskListIndex;

    public UnmarkCommand(int filteredTaskListIndex) {
        assert filteredTaskListIndex > 0;
        this.filteredTaskListIndex = filteredTaskListIndex;
    }

    @Override
    public CommandResult execute() throws CommandException {

        UnmodifiableObservableList<ReadOnlyTask> lastShownTaskList = this.model.getFilteredTaskList();

        if (this.filteredTaskListIndex <= lastShownTaskList.size()) {
            ReadOnlyTask taskToUnmark = lastShownTaskList.get(this.filteredTaskListIndex - 1);

            try {
                this.model.unmarkTask(this.filteredTaskListIndex - 1, taskToUnmark);
            } catch (UniqueTaskList.TaskNotFoundException pnfe) {
                assert false : "The target task cannot be missing";
            } catch (UniqueTaskList.DuplicateTaskException dpe) {
                throw new CommandException(MESSAGE_DUPLICATE_TASK);
            }
            EventsCenter.getInstance().post(new JumpToListRequestEvent(
                    this.model.getFilteredTaskList().indexOf(taskToUnmark)));
            return new CommandResult(String.format(MESSAGE_UNMARK_TASK_SUCCESS, taskToUnmark));
        } else {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
    }

    public static String getName() {
        return COMMAND_WORD;
    }

    public static String getParameter() {
        return COMMAND_PARAMETER;
    }

    public static String getResult() {
        return COMMAND_RESULT;
    }

    public static String getExample() {
        return COMMAND_EXAMPLE;
    }
}
```
###### /java/seedu/doit/logic/parser/CommandParser.java
``` java
package seedu.doit.logic.parser;

import seedu.doit.logic.commands.Command;

public interface CommandParser {

    /**
     * Parses the given {@code String} of arguments
     * and returns a Command object for execution.
     */
    Command parse(String args);

}
```
###### /java/seedu/doit/logic/parser/UnmarkCommandParser.java
``` java
package seedu.doit.logic.parser;

import static seedu.doit.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Optional;

import seedu.doit.logic.commands.Command;
import seedu.doit.logic.commands.IncorrectCommand;
import seedu.doit.logic.commands.UnmarkCommand;


/**
 * Parses input arguments and creates a new MarkCommand object
 */
public class UnmarkCommandParser implements CommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the MarkCommand
     * and returns an MarkCommand object for execution.
     */
    @Override
    public Command parse(String args) {

        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnmarkCommand.MESSAGE_USAGE));
        }

        return new UnmarkCommand(index.get());
    }

}
```
###### /java/seedu/doit/model/comparators/EndTimeComparator.java
``` java
package seedu.doit.model.comparators;

import seedu.doit.model.item.ReadOnlyTask;

/**
 * Compares ReadOnlyTasks by their endTime
 */
public class EndTimeComparator implements TaskComparator {

    private static final int CURR_BIGGER_THAN_OTHER = 1;
    private static final int CURR_SMALLER_THAN_OTHER = -1;

    @Override
    public int compare(ReadOnlyTask t1, ReadOnlyTask t2) {
        return compareDone(t1, t2);
    }

    /**
     * Compares the current task with another Task other.
     * The current item is considered to be less than the other item
     * if it is done and the other is not done.
     */
    private int compareDone(ReadOnlyTask curr, ReadOnlyTask other) {
        if (curr.getIsDone() && !other.getIsDone()) {
            return CURR_BIGGER_THAN_OTHER;
        } else if (!curr.getIsDone() && other.getIsDone()) {
            return CURR_SMALLER_THAN_OTHER;
        }
        return compareItems(curr, other);
    }

    /**
     * Compares the current item with another item other. returns -1 if other
     * item is greater than current item return 0 is both items are equal return
     * 1 if other item is smaller than current item The ranking are as follows
     * from highest: 1) tasks 2) events 3) floating tasks If both have same
     * rankings, then compare endTime or name if endTime == null
     */
    private int compareItems(ReadOnlyTask curr, ReadOnlyTask other) {
        Integer currType = curr.getItemType();
        Integer otherType = other.getItemType();
        int compareInt = currType.compareTo(otherType);

        if (compareInt == 0) {
            switch(currType) {
            case 1:
                //fallthrough
            case 2:
                return compareEndTime(curr, other);
            default:
                return compareName(curr, other);
            }
        }
        return compareInt;
    }

    private int compareEndTime(ReadOnlyTask curr, ReadOnlyTask other) {
        return curr.getDeadline().compareTo(other.getDeadline());
    }

    private int compareName(ReadOnlyTask curr, ReadOnlyTask other) {
        return curr.getName().toString().compareToIgnoreCase(other.getName().toString());
    }

}
```
###### /java/seedu/doit/model/comparators/PriorityComparator.java
``` java
package seedu.doit.model.comparators;

import seedu.doit.model.item.ReadOnlyTask;

/**
 * Compares ReadOnlyTasks by their priority
 */
public class PriorityComparator implements TaskComparator {

    private static final int CURR_BIGGER_THAN_OTHER = 1;
    private static final int CURR_SMALLER_THAN_OTHER = -1;

    @Override
    public int compare(ReadOnlyTask t1, ReadOnlyTask t2) {
        return compareDone(t1, t2);
    }

    /**
     * Compares the current task with another Task other.
     * The current item is considered to be less than the other item
     * if it is done and the other is not done.
     */
    private int compareDone(ReadOnlyTask curr, ReadOnlyTask other) {
        if (curr.getIsDone() && !other.getIsDone()) {
            return CURR_BIGGER_THAN_OTHER;
        } else if (!curr.getIsDone() && other.getIsDone()) {
            return CURR_SMALLER_THAN_OTHER;
        }
        return compareItems(curr, other);
    }

    /**
     * Compares the current item with another item other. returns -1 if other
     * item is greater than current item return 0 is both items are equal return
     * 1 if other item is smaller than current item The ranking are as follows
     * from highest: 1) tasks 2) events 3) floating tasks If both have same
     * rankings, then compare priority
     */
    private int compareItems(ReadOnlyTask curr, ReadOnlyTask other) {
        Integer currType = curr.getItemType();
        Integer otherType = other.getItemType();
        int compareInt = currType.compareTo(otherType);

        if (compareInt == 0) {
            return comparePriority(curr, other);
        }
        return compareInt;
    }

    private int comparePriority(ReadOnlyTask curr, ReadOnlyTask other) {
        return curr.getPriority().compareTo(other.getPriority());
    }

}
```
###### /java/seedu/doit/model/comparators/StartTimeComparator.java
``` java
package seedu.doit.model.comparators;

import seedu.doit.model.item.ReadOnlyTask;

/**
 * Compares ReadOnlyTasks by their startTime
 */
public class StartTimeComparator implements TaskComparator {

    private static final int CURR_BIGGER_THAN_OTHER = 1;
    private static final int CURR_SMALLER_THAN_OTHER = -1;

    @Override
    public int compare(ReadOnlyTask t1, ReadOnlyTask t2) {
        return compareDone(t1, t2);
    }

    /**
     * Compares the current task with another Task other.
     * The current item is considered to be less than the other item
     * if it is done and the other is not done.
     */
    private int compareDone(ReadOnlyTask curr, ReadOnlyTask other) {
        if (curr.getIsDone() && !other.getIsDone()) {
            return CURR_BIGGER_THAN_OTHER;
        } else if (!curr.getIsDone() && other.getIsDone()) {
            return CURR_SMALLER_THAN_OTHER;
        }
        return compareItems(curr, other);
    }

    /**
     * Compares the current item with another item other. returns -1 if other
     * item is greater than current item return 0 is both items are equal return
     * 1 if other item is smaller than current item The ranking are as follows
     * from highest: 1) tasks 2) events 3) floating tasks If both have same
     * rankings, then compare startTime or name if startTime == null
     */
    private int compareItems(ReadOnlyTask curr, ReadOnlyTask other) {
        Integer currType = curr.getItemType();
        Integer otherType = other.getItemType();
        int compareInt = currType.compareTo(otherType);

        if (compareInt == 0) {
            switch(currType) {
            case 2:
                return compareStartTime(curr, other);
            default:
                return compareName(curr, other);
            }
        }
        return compareInt;
    }

    private int compareStartTime(ReadOnlyTask curr, ReadOnlyTask other) {
        return curr.getStartTime().compareTo(other.getStartTime());
    }

    private int compareName(ReadOnlyTask curr, ReadOnlyTask other) {
        return curr.getName().toString().compareToIgnoreCase(other.getName().toString());
    }

}
```
###### /java/seedu/doit/model/comparators/TaskComparator.java
``` java
package seedu.doit.model.comparators;

import java.util.Comparator;

import seedu.doit.model.item.ReadOnlyTask;

/**
 * Provides an interface for all TaskComparator classes to compare ReadOnlyTasks
 */
public interface TaskComparator extends Comparator<ReadOnlyTask> {

    @Override
    public int compare(ReadOnlyTask t1, ReadOnlyTask t2);

}
```
###### /java/seedu/doit/model/comparators/TaskNameComparator.java
``` java
package seedu.doit.model.comparators;

import seedu.doit.model.item.ReadOnlyTask;

/**
 * Compares ReadOnlyTasks by their names in lexicographical order
 */
public class TaskNameComparator implements TaskComparator {

    private static final int CURR_BIGGER_THAN_OTHER = 1;
    private static final int CURR_SMALLER_THAN_OTHER = -1;

    @Override
    public int compare(ReadOnlyTask t1, ReadOnlyTask t2) {
        return compareDone(t1, t2);
    }

    /**
     * Compares the current task with another Task other.
     * The current item is considered to be less than the other item
     * if it is done and the other is not done.
     */
    private int compareDone(ReadOnlyTask curr, ReadOnlyTask other) {
        if (curr.getIsDone() && !other.getIsDone()) {
            return CURR_BIGGER_THAN_OTHER;
        } else if (!curr.getIsDone() && other.getIsDone()) {
            return CURR_SMALLER_THAN_OTHER;
        }
        return compareItems(curr, other);
    }

    /**
     * Compares the current item with another item other. returns -1 if other
     * item is greater than current item return 0 is both items are equal return
     * 1 if other item is smaller than current item The ranking are as follows
     * from highest: 1) tasks 2) events 3) floating tasks If both have same
     * rankings, then compare names
     */
    private int compareItems(ReadOnlyTask curr, ReadOnlyTask other) {
        Integer currType = curr.getItemType();
        Integer otherType = other.getItemType();
        int compareInt = currType.compareTo(otherType);

        if (compareInt == 0) {
            return compareName(curr, other);
        }
        return compareInt;
    }

    private int compareName(ReadOnlyTask curr, ReadOnlyTask other) {
        return curr.getName().toString().compareToIgnoreCase(other.getName().toString());
    }
}
```
###### /java/seedu/doit/model/item/Description.java
``` java
package seedu.doit.model.item;

import seedu.doit.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's description in the task manager. Guarantees: immutable;
 * is valid as declared in {@link #isValidDescription(String)}
 */
public class Description {
    public static final String MESSAGE_DESCRIPTION_CONSTRAINTS =
        "Task description can take in any string";
    /*
     *  Any String is a valid description
     */
    public static final String DESCRIPTION_VALIDATION_REGEX = ".*";

    public final String value;

    /**
     * Validates given description.
     *
     * @throws IllegalValueException
     *             if given description string is invalid or null.
     */
    public Description(String description) throws IllegalValueException {
        if (description == null || !isValidDescription(description)) {
            throw new IllegalValueException(MESSAGE_DESCRIPTION_CONSTRAINTS);
        }
        this.value = description;
    }

    /**
     * Returns true if a given string is a valid task description.
     */
    public static boolean isValidDescription(String test) {
        return test.matches(DESCRIPTION_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof Description // instanceof handles nulls
            && this.value.equals(((Description) other).value)); // state check
    }

}
```
###### /java/seedu/doit/model/item/EndTime.java
``` java
package seedu.doit.model.item;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import seedu.doit.commons.exceptions.IllegalValueException;
import seedu.doit.logic.parser.DateTimeParser;

/**
 * Represents a Item's end time in the item manager. Guarantees: immutable; is
 * valid as declared in {@link #isValidEndTime(String)}
 */
public class EndTime implements Comparable<EndTime> {

    public static final String NO_END_TIME = "";
    public static final String MESSAGE_ENDTIME_CONSTRAINTS = "End Date/Time should be in "
        + "DD/MM/YY HH:MM Format or relative date today, tomorrow, next wednesday";
    public static final String ENDTIME_VALIDATION_REGEX = "^$|^([0-2][0-9]||3[0-1]$)/([0-9]||0[0-9]||1[0-2])"
        + "/([0-9][0-9])?[0-9][0-9] [0-2]\\d:[0-6]\\d$";

    public final String value;
    private final LocalDateTime dateObject;


    /**
     * Gives a NO_END_TIME which represents there is no end time.
     */
    public EndTime() {
        this.value = NO_END_TIME;
        this.dateObject = null;
    }

    /**
     * Validates given endTime.
     *
     * @throws IllegalValueException if given endTime string is invalid.
     */
    public EndTime(String endTime) throws IllegalValueException {
        if (endTime.equals(NO_END_TIME)) {
            this.value = NO_END_TIME;
            this.dateObject = null;
        } else {
            String trimmedEndTime = endTime.trim();

            dateObject = DateTimeParser.parseDateTime(trimmedEndTime)
                .orElseThrow(() -> new IllegalValueException(MESSAGE_ENDTIME_CONSTRAINTS));

            String dateInString = formatDate(dateObject);

            if (!isValidEndTime(dateInString)) {
                throw new IllegalValueException(MESSAGE_ENDTIME_CONSTRAINTS);
            }
            this.value = dateInString;
        }
    }

    /**
     * Returns if a given string is a valid item end time.
     */
    public static boolean isValidEndTime(String test) {
        return test.matches(ENDTIME_VALIDATION_REGEX);
    }

    private static String formatDate(LocalDateTime input) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yy HH:mm");
        return input.format(formatter);
    }

    @Override
    public String toString() {
        return this.value;
    }

    @Override
    public boolean equals(Object other) {
        return (other == this // short circuit if same object
            ) || ((other instanceof EndTime // instanceof handles nulls
            ) && this.value.equals(((EndTime) other).value)); // state check
    }

    @Override
    public int compareTo(EndTime other) {
        return this.value.compareTo(other.value);
    }

    public LocalDateTime getDateTimeObject() {
        return this.dateObject;
    }

}
```
###### /java/seedu/doit/model/item/Name.java
``` java
package seedu.doit.model.item;

import seedu.doit.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's name in the task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}
 */
public class Name {

    public static final String MESSAGE_NAME_CONSTRAINTS =
        "Task names should only contain alphanumeric characters and spaces, and it should not be blank";

    /*
     * The first character of the task must not be a whitespace,
     * otherwise " " (a blank string) becomes a valid input.
     */
    public static final String NAME_VALIDATION_REGEX = "^[^-\\s][a-zA-Z0-9_\\s-]+$";

    public final String fullName;

    /**
     * Validates given name.
     *
     * @throws IllegalValueException if given name string is invalid.
     */
    public Name(String name) throws IllegalValueException {
        assert name != null;
        String trimmedName = name.trim();
        if (!isValidName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
        }
        this.fullName = trimmedName;
    }

    /**
     * Returns true if a given string is a valid task name.
     */
    public static boolean isValidName(String test) {
        return test.matches(NAME_VALIDATION_REGEX);
    }


    @Override
    public String toString() {
        return fullName;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof Name // instanceof handles nulls
            && this.fullName.equals(((Name) other).fullName)); // state check
    }

}
```
###### /java/seedu/doit/model/item/Priority.java
``` java
package seedu.doit.model.item;

import seedu.doit.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's priority in the task manager.
 * Guarantees: immutable; is valid as declared in {@link #isValidPriority(String)}
 */
public class Priority implements Comparable<Priority> {

    public static final String MESSAGE_PRIORITY_CONSTRAINTS = "Task priority should only be low med high";
    public static final String PRIORITY_VALIDATION_REGEX = "(low)|(med)|(high)";
    public static final String PRIORITY_LOW = "low";
    public static final String PRIORITY_MED = "med";

    public final String value;

    /**
     * Validates given priority.
     *
     * @throws IllegalValueException if given priority string is invalid.
     */
    public Priority(String priority) throws IllegalValueException {
        assert priority != null;
        String trimmedPriority = priority.trim();
        if (!isValidPriority(trimmedPriority)) {
            throw new IllegalValueException(MESSAGE_PRIORITY_CONSTRAINTS);
        }
        this.value = trimmedPriority;
    }

    /**
     * Returns true if a given string is a valid task priority.
     */
    public static boolean isValidPriority(String test) {
        return test.matches(PRIORITY_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof Priority // instanceof handles nulls
            && this.value.equals(((Priority) other).value)); // state check
    }

    private int getPriorityValue() {
        if (PRIORITY_LOW.equals(value)) {
            return 3;
        } else if (PRIORITY_MED.equals(value)) {
            return 2;
        } else {
            return 1;
        }
    }

    @Override
    public int compareTo(Priority other) {
        Integer currPriorityValue = getPriorityValue();
        Integer otherPriorityValue = other.getPriorityValue();
        return currPriorityValue.compareTo(otherPriorityValue);
    }

}
```
###### /java/seedu/doit/model/item/ReadOnlyTask.java
``` java
package seedu.doit.model.item;

import seedu.doit.model.tag.UniqueTagList;

/**
 * A read-only immutable interface for a Task in the task manager.
 * Implementations should guarantee: details are present and not null, field values are validated.
 */
public interface ReadOnlyTask {

    Name getName();

    Priority getPriority();

    Description getDescription();

    StartTime getStartTime();

    EndTime getDeadline();

    boolean getIsDone();

    /**
     * The returned TagList is a deep copy of the internal TagList, changes on
     * the returned list will not affect the task's internal tags.
     */
    UniqueTagList getTags();

    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
            || (other != null // this is first to avoid NPE below
            && other.getName().equals(this.getName()) // state checks here onwards
            && other.getPriority().equals(this.getPriority())
            && other.getDescription().equals(this.getDescription())
            && (other.getIsDone() == this.getIsDone()));
    }

```
###### /java/seedu/doit/model/item/StartTime.java
``` java
package seedu.doit.model.item;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import seedu.doit.commons.exceptions.IllegalValueException;
import seedu.doit.logic.parser.DateTimeParser;

/**
 * Represents a Item's start time in the task manager. Guarantees: immutable; is
 * valid as declared in {@link #isValidStartTime(String)}
 */
public class StartTime implements Comparable<StartTime> {

    public static final String NO_START_TIME = "";
    public static final String MESSAGE_STARTTIME_CONSTRAINTS = "Start Date/Time should be in "
        + "DD/MM/YY HH:MM Format or relative date today, tomorrow, next wednesday";
    public static final String STARTTIME_VALIDATION_REGEX = "^$|^([0-2][0-9]||3[0-1])/([0-9]||0[0-9]||1[0-2])"
        + "/([0-9][0-9])?[0-9][0-9] [0-2]\\d:[0-6]\\d$";

    public final String value;
    private final LocalDateTime dateObject;

    /**
     * Gives a NO_START_TIME which represents there is no start time.
     */
    public StartTime() {
        this.value = NO_START_TIME;
        this.dateObject = null;
    }

    /**
     * Validates given startTime.
     *
     * @throws IllegalValueException if given startTime string is invalid.
     */
    public StartTime(String startTime) throws IllegalValueException {
        if (startTime.equals(NO_START_TIME)) {
            this.value = NO_START_TIME;
            this.dateObject = null;
        } else {
            String trimmedStartTime = startTime.trim();

            dateObject = DateTimeParser.parseDateTime(trimmedStartTime)
                .orElseThrow(() -> new IllegalValueException(MESSAGE_STARTTIME_CONSTRAINTS));

            String dateInString = formatDate(dateObject);

            if (!isValidStartTime(dateInString)) {
                throw new IllegalValueException(MESSAGE_STARTTIME_CONSTRAINTS);
            }

            this.value = dateInString;
        }
    }

    /**
     * Returns if a given string is a valid task start time.
     */
    public static boolean isValidStartTime(String test) {
        return test.matches(STARTTIME_VALIDATION_REGEX);
    }

    private static String formatDate(LocalDateTime input) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yy HH:mm");
        return input.format(formatter);

    }

    @Override
    public String toString() {
        return this.value;
    }

    @Override
    public boolean equals(Object other) {
        return (other == this // short circuit if same object
            ) || ((other instanceof StartTime// instanceof handles nulls
            ) && this.value.equals(((StartTime) other).value)); // state check
    }

    @Override
    public int compareTo(StartTime other) {
        return this.value.compareTo(other.value);
    }

    public LocalDateTime getDateTimeObject() {
        return this.dateObject;
    }

}
```
###### /java/seedu/doit/model/item/Task.java
``` java
package seedu.doit.model.item;

import java.util.Objects;

import seedu.doit.commons.util.CollectionUtil;
import seedu.doit.model.tag.UniqueTagList;

/**
 * Represents a Task in the task manager. Guarantees: details are present and
 * not null, field values are validated.
 */
public class Task implements ReadOnlyTask {

    private Name name;
    private Priority priority;
    private StartTime startTime;
    private EndTime endTime;
    private Description description;
    private boolean isDone;
    private UniqueTagList tags;

    // ================ Constructor methods ==============================

    /**
     * Event Constructor where every field must be present and not null.
     */
    public Task(Name name, Priority priority, StartTime startTime, EndTime endTime, Description description,
            UniqueTagList tags, boolean isDone) {
        assert !CollectionUtil.isAnyNull(name, startTime, endTime);
        this.name = name;
        this.priority = priority;
        this.startTime = startTime;
        this.endTime = endTime;
        this.description = description;
        this.isDone = isDone;
        this.tags = new UniqueTagList(tags); // protect internal tags from
                                             // changes in the arg list
    }

    /**
     * Event Constructor where every field must be present except isDone.
     */
    public Task(Name name, Priority priority, StartTime startTime, EndTime endTime, Description description,
            UniqueTagList tags) {
        this(name, priority, startTime, endTime, description, tags, false);
    }

    /**
     * Task Constructor every field must be present except for startTime and
     * isDone.
     */
    public Task(Name name, Priority priority, EndTime endTime, Description description, UniqueTagList tags,
            boolean isDone) {
        this(name, priority, new StartTime(), endTime, description, tags, isDone);
    }

    /**
     * Task Constructor every field must be present except for startTime.
     */
    public Task(Name name, Priority priority, EndTime endTime, Description description, UniqueTagList tags) {
        this(name, priority, new StartTime(), endTime, description, tags);
        assert !CollectionUtil.isAnyNull(name, endTime);
    }

    /**
     * FloatingTask Constructor every field must be present except for
     * startTime, endTime and isDone.
     */
    public Task(Name name, Priority priority, Description description, UniqueTagList tags, boolean isDone) {
        this(name, priority, new StartTime(), new EndTime(), description, tags, isDone);
    }

    /**
     * FloatingTask Constructor every field must be present except for startTime
     * and endTime.
     */
    public Task(Name name, Priority priority, Description description, UniqueTagList tags) {
        this(name, priority, new StartTime(), new EndTime(), description, tags);
        assert !CollectionUtil.isAnyNull(name);
    }

    /**
     * Creates a copy of the given ReadOnlyTask.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getPriority(), source.getDescription(), source.getTags());
        this.startTime = source.getStartTime();
        this.endTime = source.getDeadline();
        this.isDone = source.getIsDone();

    }

    // ================ Getter and Setter methods ==============================

    @Override
    public Name getName() {
        return this.name;
    }

    public void setName(Name name) {
        assert name != null;
        this.name = name;
    }

    @Override
    public Priority getPriority() {
        return this.priority;
    }

    public void setPriority(Priority priority) {
        assert priority != null;
        this.priority = priority;
    }

    @Override
    public boolean getIsDone() {
        return this.isDone;
    }

    public void setIsDone(boolean isDone) {
        this.isDone = isDone;
    }

    @Override
    public StartTime getStartTime() {
        return this.startTime;
    }

    public void setStartTime(StartTime startTime) {
        assert startTime != null;
        this.startTime = startTime;
    }

    @Override
    public EndTime getDeadline() {
        return this.endTime;
    }

    public void setEndTime(EndTime endTime) {
        assert endTime != null;
        this.endTime = endTime;
    }

    @Override
    public Description getDescription() {
        return this.description;
    }

    public void setDescription(Description description) {
        assert description != null;
        this.description = description;
    }

    @Override
    public boolean hasStartTime() {
        if (this.startTime == null) {
            return false;
        } else if (this.startTime.value.equals("")) {
            return false;
        }
        return true;
    }

    @Override
    public boolean hasEndTime() {
        if (this.endTime == null) {
            return false;
        } else if (this.endTime.value.equals("")) {
            return false;
        }
        return true;
    }

    @Override
    public UniqueTagList getTags() {
        return new UniqueTagList(this.tags);
    }

    /**
     * Replaces this task's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        this.tags.setTags(replacement);
    }

    /**
     * Indicates if this item is an event
     */
    @Override
    public boolean isEvent() {
        return (hasStartTime());
    }

    /**
     * Indicates if this item is a floatingTask
     */
    @Override
    public boolean isFloatingTask() {
        return (!hasStartTime() && !hasEndTime());
    }

    /**
     * Indicates if this item is a task
     */
    @Override
    public boolean isTask() {
        return (!hasStartTime() && hasEndTime());
    }

    /**
     * Returns 1 for task
     * 2 for event
     * 3 for floating tasks
     */
    @Override
    public int getItemType() {
        if (isTask()) {
            return 1;
        } else if (isEvent()) {
            return 2;
        } else {
            return 3;
        }
    }

    // ================ Misc methods ==============================

    /**
     * Updates this task with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        this.setName(replacement.getName());
        this.setPriority(replacement.getPriority());
        this.setStartTime(replacement.getStartTime());
        this.setEndTime(replacement.getDeadline());
        this.setIsDone(replacement.getIsDone());
        this.setDescription(replacement.getDescription());
        this.setTags(replacement.getTags());
    }


    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing
        // your own
        return Objects.hash(this.name, this.priority, this.description, this.tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }

    @Override
    public boolean equals(Object other) {
        return (other == this // short circuit if same object
                    ) || ((other instanceof ReadOnlyTask // instanceof handles nulls
                    ) && this.isSameStateAs((ReadOnlyTask) other));
    }

}
```
###### /java/seedu/doit/model/item/UniqueTaskList.java
``` java
package seedu.doit.model.item;

import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import seedu.doit.commons.core.UnmodifiableObservableList;
import seedu.doit.commons.exceptions.DuplicateDataException;
import seedu.doit.commons.util.CollectionUtil;
import seedu.doit.model.comparators.TaskNameComparator;

/**
 * A list of tasks that enforces uniqueness between its elements and does not allow nulls.
 * <p>
 * Supports a minimal set of list operations.
 *
 * @see Task#equals(Object)
 * @see CollectionUtil#elementsAreUnique(Collection)
 */
public class UniqueTaskList implements Iterable<Task> {

    private final ObservableList<Task> internalList = FXCollections.observableArrayList();
    private Comparator<ReadOnlyTask> taskComparator = new TaskNameComparator();

    /**
     * Returns true if the list contains an equivalent task as the given argument.
     */
    public boolean contains(ReadOnlyTask toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }

    /**
     * Adds a task to the list.
     *
     * @throws DuplicateTaskException if the task to add is a duplicate of an existing task in the list.
     */
    public void add(Task toAdd) throws DuplicateTaskException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateTaskException();
        }
        internalList.add(toAdd);
        internalList.sort(taskComparator);
    }

    /**
     * Updates the task in the list at position {@code index} with {@code editedTask}.
     *
     * @throws DuplicateTaskException    if updating the task's details causes the task to be equivalent to
     *                                   another existing task in the list.
     * @throws IndexOutOfBoundsException if {@code index} < 0 or >= the size of the list.
     */
    public void updateTask(int index, ReadOnlyTask editedTask) throws DuplicateTaskException {
        assert editedTask != null;

        Task taskToUpdate = internalList.get(index);
        if (!taskToUpdate.equals(editedTask) && internalList.contains(editedTask)) {
            throw new DuplicateTaskException();
        }

        taskToUpdate.resetData(editedTask);
        internalList.set(index, taskToUpdate);
        internalList.sort(taskComparator);
    }

    /**
     * Marks the equivalent task in the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     * @throws DuplicateTaskException
     */
    public void mark(int taskIndex, ReadOnlyTask toMark) throws TaskNotFoundException, DuplicateTaskException {
        assert toMark != null;
        Task markedTask = new Task(toMark);
        markedTask.setIsDone(true);
        updateTask(taskIndex, markedTask);
        internalList.sort(taskComparator);
    }

    /**
     * Marks the equivalent task in the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     * @throws DuplicateTaskException
     */
    public void unmark(int taskIndex, ReadOnlyTask toMark) throws TaskNotFoundException, DuplicateTaskException {
        assert toMark != null;
        Task markedTask = new Task(toMark);
        markedTask.setIsDone(false);
        updateTask(taskIndex, markedTask);
        internalList.sort(taskComparator);
    }

    /**
     * Removes the equivalent task from the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public boolean remove(ReadOnlyTask toRemove) {
        assert toRemove != null;
        final boolean taskFoundAndDeleted = internalList.remove(toRemove);
        internalList.sort(taskComparator);
        return taskFoundAndDeleted;
    }

    /**
     * Removes the equivalent tasks from the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public boolean remove(Set<ReadOnlyTask> tasksToRemove) {
        assert tasksToRemove != null;
        final boolean taskFoundAndDeleted = internalList.removeAll(tasksToRemove);
        internalList.sort(taskComparator);
        return taskFoundAndDeleted;
    }

    public void setTasks(UniqueTaskList replacement) {
        this.internalList.setAll(replacement.internalList);
        internalList.sort(taskComparator);
    }

    public void setTasks(List<? extends ReadOnlyTask> tasks) throws DuplicateTaskException {
        final UniqueTaskList replacement = new UniqueTaskList();
        for (final ReadOnlyTask task : tasks) {
            replacement.add(new Task(task));
        }
        setTasks(replacement);
    }


    /**
     * Sets the comparator by which tasks from the list will be sorted by.
     */
    public void setTaskComparator(Comparator<ReadOnlyTask> taskComparator) {
        this.taskComparator = taskComparator;
        internalList.sort(taskComparator);
    }

    public UnmodifiableObservableList<Task> asObservableList() {
        return new UnmodifiableObservableList<>(internalList);
    }

    @Override
    public Iterator<Task> iterator() {
        return internalList.iterator();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof UniqueTaskList // instanceof handles nulls
            && this.internalList.equals(
            ((UniqueTaskList) other).internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }

    /**
     * Signals that an operation would have violated the 'no duplicates' property of the list.
     */
    public static class DuplicateTaskException extends DuplicateDataException {
        protected DuplicateTaskException() {
            super("Operation would result in duplicate tasks");
        }
    }

    /**
     * Signals that an operation targeting a specified task in the list would fail because
     * there is no such matching task in the list.
     */
    public static class TaskNotFoundException extends Exception {
    }

}
```
###### /java/seedu/doit/model/Model.java
``` java
package seedu.doit.model;

import java.util.Set;

import seedu.doit.commons.core.UnmodifiableObservableList;
import seedu.doit.commons.exceptions.EmptyTaskManagerStackException;
import seedu.doit.logic.commands.exceptions.CommandExistedException;
import seedu.doit.logic.commands.exceptions.NoSuchCommandException;
import seedu.doit.model.item.ReadOnlyTask;
import seedu.doit.model.item.Task;
import seedu.doit.model.item.UniqueTaskList;
import seedu.doit.model.item.UniqueTaskList.DuplicateTaskException;
import seedu.doit.model.item.UniqueTaskList.TaskNotFoundException;

/**
 * The API of the Model component.
 */
public interface Model {
    /**
     * Clears existing backing model and replaces with the provided new data.
     */
    void resetData(ReadOnlyTaskManager newData);

    /**
     * Returns the TaskManager
     */
    ReadOnlyTaskManager getTaskManager();

    /**
     * Deletes the given task.
     */
    void deleteTasks(Set<ReadOnlyTask> targets);

    /**
     * Adds the given task
     */
    void addTask(Task task) throws DuplicateTaskException;

    /**
     * Marks the given task as completed
     */
    void markTask(int taskIndex, ReadOnlyTask taskToDone)
            throws UniqueTaskList.TaskNotFoundException, DuplicateTaskException;

    /**
     * Marks the given task as uncompleted
     */
    void unmarkTask(int filteredTaskListIndex, ReadOnlyTask taskToDone)
            throws TaskNotFoundException, DuplicateTaskException;

    /**
     * Updates the task located at {@code filteredTaskListIndex} with
     * {@code editedTask}.
     *
     * @throws DuplicateTaskException
     *             if updating the task's details causes the task to be
     *             equivalent to another existing task in the list.
     * @throws IndexOutOfBoundsException
     *             if {@code filteredTaskListIndex} < 0 or >= the size of the
     *             filtered list.
     */
    void updateTask(int filteredTaskListIndex, ReadOnlyTask editedTask) throws DuplicateTaskException;

    /**
     * Returns the filtered task list as an
     * {@code UnmodifiableObservableList<ReadOnlyTask>}
     */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList();

    /**
     * Updates the filter of the filtered task list to show all undone tasks
     */
    void updateFilteredListToShowAll();

    /**
     * Updates the filter of the filtered task list to show all done tasks
     */
    void updateFilteredListToShowDone();

    /**
     * Updates the filter of the filtered task list to filter by the given
     * keywords
     */
    void updateFilteredTaskList(Set<String> nameKeywords, Set<String> priorityKeywords, Set<String> descriptionKeywords,
            Set<String> tagKeywords, Set<String> startTimekeywords, Set<String> endTimekeywords);

    /**
     * Set how the tasks are sorted
     */
    void sortBy(String sortType);

```
###### /java/seedu/doit/model/ModelManager.java
``` java
package seedu.doit.model;

import java.util.Set;
import java.util.function.Predicate;
import java.util.logging.Logger;

import javafx.collections.transformation.FilteredList;
import seedu.doit.commons.core.CommandSettings;
import seedu.doit.commons.core.ComponentManager;
import seedu.doit.commons.core.LogsCenter;
import seedu.doit.commons.core.UnmodifiableObservableList;
import seedu.doit.commons.events.model.TaskManagerChangedEvent;
import seedu.doit.commons.exceptions.EmptyTaskManagerStackException;
import seedu.doit.commons.util.CollectionUtil;
import seedu.doit.logic.commands.exceptions.CommandExistedException;
import seedu.doit.logic.commands.exceptions.NoSuchCommandException;
import seedu.doit.model.comparators.EndTimeComparator;
import seedu.doit.model.comparators.PriorityComparator;
import seedu.doit.model.comparators.StartTimeComparator;
import seedu.doit.model.comparators.TaskNameComparator;
import seedu.doit.model.item.ReadOnlyTask;
import seedu.doit.model.item.Task;
import seedu.doit.model.item.UniqueTaskList;
import seedu.doit.model.item.UniqueTaskList.DuplicateTaskException;
import seedu.doit.model.item.UniqueTaskList.TaskNotFoundException;
import seedu.doit.model.predicates.AlwaysTruePredicate;
import seedu.doit.model.predicates.DescriptionPredicate;
import seedu.doit.model.predicates.DonePredicate;
import seedu.doit.model.predicates.EndTimePredicate;
import seedu.doit.model.predicates.NamePredicate;
import seedu.doit.model.predicates.PriorityPredicate;
import seedu.doit.model.predicates.StartTimePredicate;
import seedu.doit.model.predicates.TagPredicate;

/**
 * Represents the in-memory model of the task manager data. All changes to any
 * model should be synchronized.
 */
public class ModelManager extends ComponentManager implements Model {
    private static final Logger logger = LogsCenter.getLogger(ModelManager.class);

    private TaskManager taskManager;
    private FilteredList<ReadOnlyTask> filteredTasks;

    private static final TaskManagerStack taskManagerStack = TaskManagerStack.getInstance();

    /**
     * Initializes a ModelManager with the given taskManager and userPrefs.
     */
    public ModelManager(ReadOnlyTaskManager taskManager, UserPrefs userPrefs) {
        super();
        assert !CollectionUtil.isAnyNull(taskManager, userPrefs);

        logger.fine("Initializing with task manager: " + taskManager + " and user prefs " + userPrefs);

        this.taskManager = new TaskManager(taskManager);
        updateFilteredTasks();
        updateFilteredListToShowAll();

    }

```
###### /java/seedu/doit/model/ModelManager.java
``` java
    public ModelManager() {
        this(new TaskManager(), new UserPrefs());
    }

    @Override
    public void resetData(ReadOnlyTaskManager newData) {
        this.taskManager.resetData(newData);
        indicateTaskManagerChanged();
    }

    @Override
    public void resetDataWithoutSaving(ReadOnlyTaskManager newData) {
        this.taskManager.resetData(newData);
    }

    @Override
    public void loadData(ReadOnlyTaskManager newData) {
        this.resetDataWithoutSaving(newData);
        taskManagerStack.clearRedoStack();
        taskManagerStack.clearUndoStack();
    }

```
###### /java/seedu/doit/model/ModelManager.java
``` java
    @Override
    public ReadOnlyTaskManager getTaskManager() {
        return this.taskManager;
    }

    /**
     * Raises an event to indicate the model has changed
     */
    private void indicateTaskManagerChanged() {
        raise(new TaskManagerChangedEvent(this.taskManager));
    }

    /**
     * Removes the equivalent task from the task list.
     *
     * @throws TaskNotFoundException
     *             if no such task could be found in the task list.
     */
    @Override
    public synchronized void deleteTasks(Set<ReadOnlyTask> targets) {
        logger.info("delete task(s) in model manager");
        taskManagerStack.addToUndoStack(this.getTaskManager());
        taskManagerStack.clearRedoStack();
        this.taskManager.removeTask(targets);
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
    }

    /**
     * Removes the equivalent tasks from the task list.
     *
     * @throws TaskNotFoundException
     *             if a task could be found in the task list.
     */
    @Override
    public synchronized void addTask(Task task) throws DuplicateTaskException {
        logger.info("add task in model manager");
        taskManagerStack.addToUndoStack(this.getTaskManager());
        taskManagerStack.clearRedoStack();
        this.taskManager.addTask(task);
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void markTask(int filteredTaskListIndex, ReadOnlyTask taskToDone)
            throws UniqueTaskList.TaskNotFoundException, DuplicateTaskException {
        logger.info("marked a task in model manager as done");
        taskManagerStack.addToUndoStack(this.getTaskManager());
        taskManagerStack.clearRedoStack();
        int taskManagerIndex = this.filteredTasks.getSourceIndex(filteredTaskListIndex);
        this.taskManager.markTask(taskManagerIndex, taskToDone);
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
    }

    @Override
    public synchronized void unmarkTask(int filteredTaskListIndex, ReadOnlyTask taskToDone)
            throws UniqueTaskList.TaskNotFoundException, DuplicateTaskException {
        logger.info("marked a task in model manager as done");
        taskManagerStack.addToUndoStack(this.getTaskManager());
        taskManagerStack.clearRedoStack();
        int taskManagerIndex = this.filteredTasks.getSourceIndex(filteredTaskListIndex);
        this.taskManager.unmarkTask(taskManagerIndex, taskToDone);
        updateFilteredListToShowAll();
        indicateTaskManagerChanged();
    }

    @Override
    public void updateTask(int filteredTaskListIndex, ReadOnlyTask editedTask) throws DuplicateTaskException {
        assert editedTask != null;
        logger.info("update task in model manager");
        taskManagerStack.addToUndoStack(this.getTaskManager());
        taskManagerStack.clearRedoStack();
        int taskManagerIndex = this.filteredTasks.getSourceIndex(filteredTaskListIndex);
        this.taskManager.updateTask(taskManagerIndex, editedTask);
        indicateTaskManagerChanged();
    }

    @Override
    public void sortBy(String sortType) {
        switch (sortType) {
        case "start time":
            this.taskManager.setTaskComparator(new StartTimeComparator());
            break;
        case "end time":
            this.taskManager.setTaskComparator(new EndTimeComparator());
            break;
        case "priority":
            this.taskManager.setTaskComparator(new PriorityComparator());
            break;
        case "name":
            // fallthrough
        default:
            this.taskManager.setTaskComparator(new TaskNameComparator());
            break;
        }
    }

```
###### /java/seedu/doit/model/ModelManager.java
``` java
    // =========== Filtered Task List Accessors
    // ============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        return new UnmodifiableObservableList<>(this.filteredTasks);
    }

    @Override
    public void updateFilteredListToShowAll() {
        this.filteredTasks.setPredicate(null);
        this.filteredTasks.setPredicate(new DonePredicate(false));
        indicateTaskManagerChanged();
    }

    @Override
    public void updateFilteredListToShowDone() {
        this.filteredTasks.setPredicate(null);
        this.filteredTasks.setPredicate(new DonePredicate(true));
        indicateTaskManagerChanged();
    }

    @Override
    public void updateFilteredTaskList(Set<String> nameKeywords, Set<String> priorityKeywords,
            Set<String> descriptionKeywords, Set<String> tagKeywords, Set<String> startTimekeywords,
            Set<String> endTimekeywords) {
        Predicate<ReadOnlyTask> combined = new AlwaysTruePredicate();

        if (!nameKeywords.isEmpty()) {
            Predicate<ReadOnlyTask> namePredicate = new NamePredicate(nameKeywords);
            combined = combined.and(namePredicate);
        }
        if (!priorityKeywords.isEmpty()) {
            Predicate<ReadOnlyTask> priorityPredicate = new PriorityPredicate(priorityKeywords);
            combined = combined.and(priorityPredicate);
        }
        if (!descriptionKeywords.isEmpty()) {
            Predicate<ReadOnlyTask> descriptionPredicate = new DescriptionPredicate(descriptionKeywords);
            combined = combined.and(descriptionPredicate);
        }
        if (!tagKeywords.isEmpty()) {
            Predicate<ReadOnlyTask> tagPredicate = new TagPredicate(tagKeywords);
            combined = combined.and(tagPredicate);
        }
        if (!startTimekeywords.isEmpty()) {
            Predicate<ReadOnlyTask> startTimePredicate = new StartTimePredicate(startTimekeywords);
            combined = combined.and(startTimePredicate);
        }
        if (!endTimekeywords.isEmpty()) {
            Predicate<ReadOnlyTask> endTimePredicate = new EndTimePredicate(endTimekeywords);
            combined = combined.and(endTimePredicate);
        }

        this.filteredTasks.setPredicate(combined);
    }
}
```
###### /java/seedu/doit/model/predicates/AlwaysTruePredicate.java
``` java
package seedu.doit.model.predicates;

import java.util.function.Predicate;

import seedu.doit.model.item.ReadOnlyTask;

/**
 * A utility Predicate that will always return true
 */
public class AlwaysTruePredicate implements Predicate<ReadOnlyTask> {
    @Override
    public boolean test(ReadOnlyTask task) {
        return true;
    }
}
```
###### /java/seedu/doit/model/predicates/DescriptionPredicate.java
``` java
package seedu.doit.model.predicates;

import java.util.Set;
import java.util.function.Predicate;

import seedu.doit.commons.util.StringUtil;
import seedu.doit.model.item.ReadOnlyTask;

/**
 * A predicate that will return true if the ReadOnlyTask description matches the
 * descriptionKeyWords
 */
public class DescriptionPredicate implements Predicate<ReadOnlyTask> {
    private Set<String> descriptionKeyWords;

    public DescriptionPredicate(Set<String> descriptionKeyWords) {
        this.descriptionKeyWords = descriptionKeyWords;
    }

    @Override
    public boolean test(ReadOnlyTask task) {
        return this.descriptionKeyWords.stream()
                .allMatch(keyword -> StringUtil.containsWordIgnoreCase(task.getDescription().value, keyword));
    }
}
```
###### /java/seedu/doit/model/predicates/DonePredicate.java
``` java
package seedu.doit.model.predicates;

import java.util.function.Predicate;

import seedu.doit.model.item.ReadOnlyTask;

/**
 * A predicate that will return true if the ReadOnlyTask isDone matches the
 * showDone boolean
 */
public class DonePredicate implements Predicate<ReadOnlyTask> {
    private boolean showDone;

    public DonePredicate(boolean showDone) {
        this.showDone = showDone;
    }

    @Override
    public boolean test(ReadOnlyTask task) {
        return (task.getIsDone() == showDone);
    }
}
```
###### /java/seedu/doit/model/predicates/EndTimePredicate.java
``` java
package seedu.doit.model.predicates;

import java.util.Set;
import java.util.function.Predicate;

import seedu.doit.commons.util.StringUtil;
import seedu.doit.model.item.ReadOnlyTask;

public class EndTimePredicate implements Predicate<ReadOnlyTask> {
    private Set<String> endTimeKeyWords;

    public EndTimePredicate(Set<String> endTimeKeyWords) {
        this.endTimeKeyWords = endTimeKeyWords;
    }

    @Override
    public boolean test(ReadOnlyTask task) {
        if (task.hasEndTime()) {
            return this.endTimeKeyWords.stream()
                    .anyMatch(keyword -> StringUtil.containsWordIgnoreCase(task.getDeadline().value, keyword));
        } else {
            return false;
        }
    }
}
```
###### /java/seedu/doit/model/predicates/NamePredicate.java
``` java
package seedu.doit.model.predicates;

import java.util.Set;
import java.util.function.Predicate;

import seedu.doit.commons.util.StringUtil;
import seedu.doit.model.item.ReadOnlyTask;

/**
* A predicate that will return true if the ReadOnlyTask name matches the
* nameKeyWords
*/
public class NamePredicate implements Predicate<ReadOnlyTask> {
    private Set<String> nameKeyWords;

    public NamePredicate(Set<String> nameKeyWords) {
        this.nameKeyWords = nameKeyWords;
    }

    @Override
    public boolean test(ReadOnlyTask task) {
        return this.nameKeyWords.stream()
                .allMatch(keyword -> StringUtil.containsWordIgnoreCase(task.getName().fullName, keyword));
    }
}
```
###### /java/seedu/doit/model/predicates/PriorityPredicate.java
``` java
package seedu.doit.model.predicates;

import java.util.Set;
import java.util.function.Predicate;

import seedu.doit.commons.util.StringUtil;
import seedu.doit.model.item.ReadOnlyTask;

/**
* A predicate that will return true if the ReadOnlyTask priority matches the
* priorityKeyWords
*/
public class PriorityPredicate implements Predicate<ReadOnlyTask> {
    private Set<String> priorityKeyWords;

    public PriorityPredicate(Set<String> priorityKeyWords) {
        this.priorityKeyWords = priorityKeyWords;
    }

    @Override
    public boolean test(ReadOnlyTask task) {
        return this.priorityKeyWords.stream()
                .anyMatch(keyword -> StringUtil.containsWordIgnoreCase(task.getPriority().value, keyword));
    }
}
```
###### /java/seedu/doit/model/predicates/StartTimePredicate.java
``` java
package seedu.doit.model.predicates;

import java.util.Set;
import java.util.function.Predicate;

import seedu.doit.commons.util.StringUtil;
import seedu.doit.model.item.ReadOnlyTask;

public class StartTimePredicate implements Predicate<ReadOnlyTask> {
    private Set<String> startTimeKeyWords;

    public StartTimePredicate(Set<String> endTimeKeyWords) {
        this.startTimeKeyWords = endTimeKeyWords;
    }

    @Override
    public boolean test(ReadOnlyTask task) {
        if (task.hasStartTime()) {
            return this.startTimeKeyWords.stream()
                    .anyMatch(keyword -> StringUtil.containsWordIgnoreCase(task.getStartTime().value, keyword));
        } else {
            return false;
        }
    }
}
```
###### /java/seedu/doit/model/predicates/TagPredicate.java
``` java
package seedu.doit.model.predicates;

import java.util.Set;
import java.util.function.Predicate;

import seedu.doit.commons.exceptions.IllegalValueException;
import seedu.doit.model.item.ReadOnlyTask;
import seedu.doit.model.tag.Tag;

/**
* A predicate that will return true if any of the ReadOnlyTask tags matches the
* tagKeywords
*/
public class    TagPredicate implements Predicate<ReadOnlyTask> {
    private Set<String> tagKeywords;

    public TagPredicate(Set<String> tagKeywords) {
        this.tagKeywords = tagKeywords;
    }

    @Override
    public boolean test(ReadOnlyTask task) {
        return this.tagKeywords.stream().allMatch(keyword -> {
            try {
                return (task.getTags().contains(new Tag(keyword)));
            } catch (IllegalValueException e) {
                e.printStackTrace();
                return false;
            }
        });
    }
}
```
###### /java/seedu/doit/model/ReadOnlyTaskManager.java
``` java
package seedu.doit.model;

import javafx.collections.ObservableList;
import seedu.doit.model.item.ReadOnlyTask;
import seedu.doit.model.tag.Tag;

/**
 * Unmodifiable view of an task manager
 */
public interface ReadOnlyTaskManager {

    /**
     * Returns an unmodifiable view of the task s list.
     * This list will not contain any duplicate task s.
     */
    ObservableList<ReadOnlyTask> getTaskList();

    /**
     * Returns an unmodifiable view of the tags list.
     * This list will not contain any duplicate tags.
     */
    ObservableList<Tag> getTagList();

}
```
###### /java/seedu/doit/model/tag/Tag.java
``` java
package seedu.doit.model.tag;

import seedu.doit.commons.exceptions.IllegalValueException;

/**
 * Represents a Tag in the task manager. Guarantees: immutable; name is valid as
 * declared in {@link #isValidTagName(String)}
 */
public class Tag {

    public static final String MESSAGE_TAG_CONSTRAINTS = "Tags names should be alphanumeric";
    public static final String TAG_VALIDATION_REGEX = "\\p{Alnum}+";

    public final String tagName;

    /**
     * Validates given tag name.
     *
     * @throws IllegalValueException
     *             if the given tag name string is invalid.
     */
    public Tag(String name) throws IllegalValueException {
        assert name != null;
        String trimmedName = name.trim();
        if (!isValidTagName(trimmedName)) {
            throw new IllegalValueException(MESSAGE_TAG_CONSTRAINTS);
        }
        this.tagName = trimmedName;
    }

    /**
     * Returns true if a given string is a valid tag name.
     */
    public static boolean isValidTagName(String test) {
        return test.matches(TAG_VALIDATION_REGEX);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof Tag // instanceof handles nulls
            && this.tagName.equals(((Tag) other).tagName)); // state check
    }

    @Override
    public int hashCode() {
        return tagName.hashCode();
    }

    /**
     * Format state as text for viewing.
     */
    @Override
    public String toString() {
        return '[' + tagName + ']';
    }

}
```
###### /java/seedu/doit/model/tag/UniqueTagList.java
``` java
package seedu.doit.model.tag;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import seedu.doit.commons.core.UnmodifiableObservableList;
import seedu.doit.commons.exceptions.DuplicateDataException;
import seedu.doit.commons.exceptions.IllegalValueException;
import seedu.doit.commons.util.CollectionUtil;

/**
 * A list of tags that enforces no nulls and uniqueness between its elements.
 * <p>
 * Supports minimal set of list operations for the app's features.
 *
 * @see Tag#equals(Object)
 * @see CollectionUtil#elementsAreUnique(Collection)
 */
public class UniqueTagList implements Iterable<Tag> {

    private final ObservableList<Tag> internalList = FXCollections.observableArrayList();

    /**
     * Constructs empty TagList.
     */
    public UniqueTagList() {
    }

    /**
     * Creates a UniqueTagList using given String tags.
     * Enforces no nulls or duplicates.
     */
    public UniqueTagList(String... tags) throws DuplicateTagException, IllegalValueException {
        final List<Tag> tagList = new ArrayList<Tag>();
        for (String tag : tags) {
            tagList.add(new Tag(tag));
        }
        setTags(tagList);
    }

    /**
     * Creates a UniqueTagList using given tags.
     * Enforces no nulls or duplicates.
     */
    public UniqueTagList(Tag... tags) throws DuplicateTagException {
        assert !CollectionUtil.isAnyNull((Object[]) tags);
        final List<Tag> initialTags = Arrays.asList(tags);
        if (!CollectionUtil.elementsAreUnique(initialTags)) {
            throw new DuplicateTagException();
        }
        internalList.addAll(initialTags);
    }

    /**
     * Creates a UniqueTagList using given tags.
     * Enforces no null or duplicate elements.
     */
    public UniqueTagList(Collection<Tag> tags) throws DuplicateTagException {
        this();
        setTags(tags);
    }

    /**
     * Creates a UniqueTagList using given tags.
     * Enforces no nulls.
     */
    public UniqueTagList(Set<Tag> tags) {
        assert !CollectionUtil.isAnyNull(tags);
        internalList.addAll(tags);
    }

    /**
     * Creates a copy of the given list.
     * Insulates from changes in source.
     */
    public UniqueTagList(UniqueTagList source) {
        internalList.addAll(source.internalList); // insulate internal list from changes in argument
    }

    /**
     * Returns all tags in this list as a Set.
     * This set is mutable and change-insulated against the internal list.
     */
    public Set<Tag> toSet() {
        return new HashSet<>(internalList);
    }

    /**
     * Replaces the Tags in this list with those in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        this.internalList.setAll(replacement.internalList);
    }

    public void setTags(Collection<Tag> tags) throws DuplicateTagException {
        assert !CollectionUtil.isAnyNull(tags);
        if (!CollectionUtil.elementsAreUnique(tags)) {
            throw new DuplicateTagException();
        }
        internalList.setAll(tags);
    }

    /**
     * Ensures every tag in the argument list exists in this object.
     */
    public void mergeFrom(UniqueTagList from) {
        final Set<Tag> alreadyInside = this.toSet();
        from.internalList.stream()
            .filter(tag -> !alreadyInside.contains(tag))
            .forEach(internalList::add);
    }

    /**
     * Returns true if the list contains an equivalent Tag as the given argument.
     */
    public boolean contains(Tag toCheck) {
        assert toCheck != null;
        return internalList.contains(toCheck);
    }

    /**
     * Adds a Tag to the list.
     *
     * @throws DuplicateTagException if the Tag to add is a duplicate of an existing Tag in the list.
     */
    public void add(Tag toAdd) throws DuplicateTagException {
        assert toAdd != null;
        if (contains(toAdd)) {
            throw new DuplicateTagException();
        }
        internalList.add(toAdd);
    }

    @Override
    public Iterator<Tag> iterator() {
        return internalList.iterator();
    }

    public UnmodifiableObservableList<Tag> asObservableList() {
        return new UnmodifiableObservableList<>(internalList);
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof UniqueTagList // instanceof handles nulls
            && this.internalList.equals(
            ((UniqueTagList) other).internalList));
    }

    public boolean equalsOrderInsensitive(UniqueTagList other) {
        return this == other || new HashSet<>(this.internalList).equals(new HashSet<>(other.internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }

    /**
     * Signals that an operation would have violated the 'no duplicates' property of the list.
     */
    public static class DuplicateTagException extends DuplicateDataException {
        protected DuplicateTagException() {
            super("Operation would result in duplicate tags");
        }
    }

}
```
###### /java/seedu/doit/model/TaskManager.java
``` java
package seedu.doit.model;

import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import javafx.collections.ObservableList;
import seedu.doit.commons.core.UnmodifiableObservableList;
import seedu.doit.model.item.ReadOnlyTask;
import seedu.doit.model.item.Task;
import seedu.doit.model.item.UniqueTaskList;
import seedu.doit.model.item.UniqueTaskList.DuplicateTaskException;
import seedu.doit.model.item.UniqueTaskList.TaskNotFoundException;
import seedu.doit.model.tag.Tag;
import seedu.doit.model.tag.UniqueTagList;

/**
 * Wraps all data at the task manager level
 * Duplicates are not allowed (by .equals comparison)
 */
public class TaskManager implements ReadOnlyTaskManager {

    private final UniqueTaskList taskList;
    private final UniqueTagList tagList;

    /*
     * The 'unusual' code block below is an non-static initialization block, sometimes used to avoid duplication
     * between constructors. See https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html
     *
     * Note that non-static init blocks are not recommended to use. There are other ways to avoid duplication
     *   among constructors.
     */ {
        taskList = new UniqueTaskList();
        tagList = new UniqueTagList();
    }

    public TaskManager() {
    }

    /**
     * Creates an TaskManager using the Tasks and Tags in the {@code toBeCopied}
     */
    public TaskManager(ReadOnlyTaskManager toBeCopied) {
        this();
        resetData(toBeCopied);
    }

//// list overwrite operations

    public void setTasks(List<? extends ReadOnlyTask> tasks)
        throws UniqueTaskList.DuplicateTaskException {
        this.taskList.setTasks(tasks);
    }

    public void setTags(Collection<Tag> tags) throws UniqueTagList.DuplicateTagException {
        this.tagList.setTags(tags);
    }

    public void resetData(ReadOnlyTaskManager newData) {
        assert newData != null;
        try {
            setTasks(newData.getTaskList());
        } catch (UniqueTaskList.DuplicateTaskException e) {
            assert false : "Task Manager should not have duplicate taskList";
        }
        try {
            setTags(newData.getTagList());
        } catch (UniqueTagList.DuplicateTagException e) {
            assert false : "Task Manager should not have duplicate tagList";
        }
        syncMasterTagListWith(taskList);
    }

    public void setTaskComparator(Comparator<ReadOnlyTask> taskComparator) {
        taskList.setTaskComparator(taskComparator);
    }

//// task-level operations

    /**
     * Adds a task to the task manager.
     * Also checks the new task's tagList and updates {@link #tagList} with any new tagList found,
     * and updates the Tag objects in the task to point to those in {@link #tagList}.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     */
    public void addTask(Task p) throws UniqueTaskList.DuplicateTaskException {
        syncMasterTagListWith(p);
        taskList.add(p);
    }

    /**
     * Updates the task in the list at position {@code index} with {@code editedReadOnlyTask}.
     * {@code TaskManager}'s tag list will be updated with the tagList of {@code editedReadOnlyTask}.
     *
     * @throws DuplicateTaskException    if updating the task's details causes the task to be equivalent to
     *                                   another existing task in the list.
     * @throws IndexOutOfBoundsException if {@code index} < 0 or >= the size of the list.
     * @see #syncMasterTagListWith(Task)
     */
    public void updateTask(int index, ReadOnlyTask editedReadOnlyTask)
        throws UniqueTaskList.DuplicateTaskException {
        assert editedReadOnlyTask != null;

        Task editedTask = new Task(editedReadOnlyTask);
        syncMasterTagListWith(editedTask);
        // TODO: the tagList master list will be updated even though the below line fails.
        // This can cause the tagList master list to have additional tagList that are not tagged to any task
        // in the task list.
        taskList.updateTask(index, editedTask);
    }

    /**
     * Marks an existing task in the to-do list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     * @throws DuplicateTaskException
     */
    public void markTask(int taskIndex, ReadOnlyTask taskToDone)
            throws UniqueTaskList.TaskNotFoundException, DuplicateTaskException {
        taskList.mark(taskIndex, taskToDone);
    }


    /**
     * Marks an existing task in the to-do list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     * @throws DuplicateTaskException
     */
    public void unmarkTask(int taskIndex, ReadOnlyTask taskToDone)
            throws UniqueTaskList.TaskNotFoundException, DuplicateTaskException {
        taskList.unmark(taskIndex, taskToDone);
    }

    /**
     * Ensures that every tag in this task:
     * - exists in the master list {@link #tagList}
     * - points to a Tag object in the master list
     */
    private void syncMasterTagListWith(Task task) {
        final UniqueTagList taskTags = task.getTags();
        tagList.mergeFrom(taskTags);

        // Create map with values = tag object references in the master list
        // used for checking task tag references
        final Map<Tag, Tag> masterTagObjects = new HashMap<>();
        tagList.forEach(tag -> masterTagObjects.put(tag, tag));

        // Rebuild the list of task tagList to point to the relevant tagList in the master tag list.
        final Set<Tag> correctTagReferences = new HashSet<>();
        taskTags.forEach(tag -> correctTagReferences.add(masterTagObjects.get(tag)));
        task.setTags(new UniqueTagList(correctTagReferences));
    }

    /**
     * Ensures that every tag in these taskList:
     * - exists in the master list {@link #tagList}
     * - points to a Tag object in the master list
     *
     * @see #syncMasterTagListWith(Task)
     */
    private void syncMasterTagListWith(UniqueTaskList tasks) {
        tasks.forEach(this::syncMasterTagListWith);
    }

    /**
     * Removes the equivalent task from the UniqueTaskList.
     *
     */
    public void removeTask(ReadOnlyTask task) {
        taskList.remove(task);
    }

    /**
     * Removes the equivalent taskList from the UniqueTaskList.
     *
     */
    public void removeTask(Set<ReadOnlyTask> tasks) {
        taskList.remove(tasks);
    }

    //// tag-level operations

    public void addTag(Tag t) throws UniqueTagList.DuplicateTagException {
        tagList.add(t);
    }

//// util methods

    @Override
    public String toString() {
        return taskList.asObservableList().size() + " taskList, " + tagList.asObservableList().size() + " tagList";
        // TODO: refine later
    }

    @Override
    public ObservableList<ReadOnlyTask> getTaskList() {
        return new UnmodifiableObservableList<>(taskList.asObservableList());
    }

    @Override
    public ObservableList<Tag> getTagList() {
        return new UnmodifiableObservableList<>(tagList.asObservableList());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
            || (other instanceof TaskManager // instanceof handles nulls
            && this.taskList.equals(((TaskManager) other).taskList)
            && this.tagList.equalsOrderInsensitive(((TaskManager) other).tagList));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(taskList, tagList);
    }
}
```
###### /java/seedu/doit/model/UserPrefs.java
``` java
package seedu.doit.model;

import seedu.doit.commons.core.CommandSettings;
import seedu.doit.commons.core.GuiSettings;

/**
 * Represents User's preferences.
 */
public class UserPrefs {

    private GuiSettings guiSettings;

    private CommandSettings commandSettings;

    public UserPrefs() {
        this.setGuiSettings(1100, 650, 150, 40);
        this.commandSettings = CommandSettings.getInstance();
    }

    public GuiSettings getGuiSettings() {
        return this.guiSettings == null ? new GuiSettings() : this.guiSettings;
    }

```
###### /java/seedu/doit/model/util/SampleDataUtil.java
``` java
package seedu.doit.model.util;

import seedu.doit.commons.exceptions.IllegalValueException;
import seedu.doit.model.ReadOnlyTaskManager;
import seedu.doit.model.TaskManager;
import seedu.doit.model.item.Description;
import seedu.doit.model.item.EndTime;
import seedu.doit.model.item.Name;
import seedu.doit.model.item.Priority;
import seedu.doit.model.item.Task;
import seedu.doit.model.item.UniqueTaskList.DuplicateTaskException;
import seedu.doit.model.tag.UniqueTagList;

/**
 * Represents sample data of tasks that will be loaded into TaskManager if the
 * data file is not found on startup
 */
public class SampleDataUtil {
    public static Task[] getSampleTasks() {
        try {
            return new Task[] {
                new Task(new Name("Refactor"), new Priority("low"), new EndTime("04/04/14"),
                    new Description("Refactor all mentions of task / taskManager"),
                    new UniqueTagList("Huanhui")),
                new Task(new Name("pass Travis"), new Priority("med"), new EndTime("04/04/14"),
                    new Description("Remove trailing whitespaces in md files for Travis to pass"),
                    new UniqueTagList("keanwai", "z")),
                new Task(new Name("help"), new Priority("high"), new EndTime("04/04/14"),
                    new Description("Update help command"),
                    new UniqueTagList("ChiaSin")),
                new Task(new Name("merge"), new Priority("med"), new EndTime("04/04/14"),
                    new Description("Fix the master branch merge conflicts"),
                    new UniqueTagList("JinShun")),
                new Task(new Name("help botton"), new Priority("high"), new EndTime("04/04/14"),
                    new Description("Update Help button to our user guide"),
                    new UniqueTagList("ChiaSin")),
                new Task(new Name("UI interface"), new Priority("low"), new EndTime("04/04/14"),
                    new Description("have 3 lists"),
                    new UniqueTagList("Huanhui")),
            };
        } catch (IllegalValueException e) {
            throw new AssertionError("sample data cannot be invalid", e);
        }
    }

    public static ReadOnlyTaskManager getSampleTaskManager() {
        try {
            TaskManager sampleAB = new TaskManager();
            for (Task sampleTask : getSampleTasks()) {
                sampleAB.addTask(sampleTask);
            }
            return sampleAB;
        } catch (DuplicateTaskException e) {
            throw new AssertionError("sample data cannot contain duplicate tasks", e);
        }
    }
}
```
