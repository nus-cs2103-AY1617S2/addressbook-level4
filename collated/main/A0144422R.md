# A0144422R
###### /java/seedu/today/logic/commands/AddCommand.java
``` java
/**
 * Adds a task to the task manager.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_SUCCESS_STATUS_BAR = "New task added successfully.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager";

    private final Task toAdd;

    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException
     *             if any of the raw values are invalid
     */
    public AddCommand(String name, String tags[]) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName.trim()));
        }
        this.toAdd = new FloatingTask(new Name(name), new UniqueTagList(tagSet), false, false);
        this.toAdd.setAnimation(2);
    }

    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException
     *             if any of the raw values are invalid
     */
    public AddCommand(String name, Date deadline, String tags[]) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName.trim()));
        }
        System.out.print("deadline: " + deadline);
        this.toAdd = new DeadlineTask(new Name(name), new UniqueTagList(tagSet), deadline, false, false);
        this.toAdd.setAnimation(2);
    }

    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException
     *             if any of the raw values are invalid
     */
    public AddCommand(String name, Date deadline, Date startingTime, String tags[]) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName.trim()));
        }
        this.toAdd = new EventTask(new Name(name), new UniqueTagList(tagSet), deadline, startingTime, false, false);
        this.toAdd.setAnimation(2);
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            model.addTask(toAdd);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd), MESSAGE_SUCCESS_STATUS_BAR);
        } catch (UniqueTaskList.DuplicateTaskException e) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
    }

    // For testing
    public Task getTask() {
        return toAdd;
    }

}
```
###### /java/seedu/today/logic/commands/EditCommand.java
``` java
/**
 * Edits the details of an existing task in the task manager.
 */
public class EditCommand extends Command {

    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Task: %1$s";
    public static final String MESSAGE_NOT_EDITED = "At least one field to edit must be provided.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";
    public static final String MESSAGE_SUCCESS_STATUS_BAR = "Task edited successfully.";

    private final int filteredTaskListIndex;
    private final EditTaskDescriptor editTaskDescriptor;

    /**
     * @param filteredTaskListIndex
     *            the index of the task in the filtered task list to edit
     * @param editTaskDescriptor
     *            details to edit the task with
     */
    public EditCommand(int filteredTaskListIndex, EditTaskDescriptor editTaskDescriptor) {
        assert filteredTaskListIndex > 0;
        assert editTaskDescriptor != null;

        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;

        this.editTaskDescriptor = new EditTaskDescriptor(editTaskDescriptor);
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        assert filteredTaskListIndex < lastShownList.size();

        ReadOnlyTask taskToEdit = lastShownList.get(filteredTaskListIndex);
        Task editedTask;
        if (editTaskDescriptor.isAnyFieldEdited()) {
            try {
                editedTask = createEditedTask(taskToEdit, editTaskDescriptor);
                editedTask.setAnimation(2);
            } catch (IllegalValueException e) {
                throw new CommandException(e.getMessage());
            }

            try {
                model.updateTask(filteredTaskListIndex, editedTask);
            } catch (UniqueTaskList.DuplicateTaskException dpe) {
                throw new CommandException(MESSAGE_DUPLICATE_TASK);
            }
            model.updateFilteredListToShowAll();
        }
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit), MESSAGE_SUCCESS_STATUS_BAR);
    }

```
###### /java/seedu/today/logic/commands/EditCommand.java
``` java
        public void setStartingTime(Optional<DateTime> startingTime) {
            this.startingTime = startingTime;
        }

        public Optional<DateTime> getStartingTime() {
            return this.startingTime;
        }

        public void setDeadline(Optional<DateTime> deadline) {
            this.deadline = deadline;
        }

        public Optional<DateTime> getDeadline() {
            return this.deadline;
        }
    }
}
```
###### /java/seedu/today/logic/commands/FindCommand.java
``` java
/**
 * Finds and lists all tasks in task manager whose name contains any of the
 * argument keywords. Keyword matching is case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";

    public static final String MESSAGE_SUCCESS_STATUS_BAR = "%1$s task(s) found.";

    private final Set<String> keywords;
    private final Date date;
    private final Set<String> tagKeys;

    public FindCommand(Set<String> keywords, List<DateGroup> dates, Set<String> tagKeys) {
        this.keywords = keywords;
        if (dates != null && dates.size() > 0 && dates.get(0).getDates().size() > 0) {
            this.date = dates.get(0).getDates().get(0);
        } else {
            this.date = null;
        }
        this.tagKeys = tagKeys;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskList(keywords, date, tagKeys);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().filtered(t -> {
            return !t.isDone();
        }).size()), String.format(MESSAGE_SUCCESS_STATUS_BAR, model.getFilteredTaskList().filtered(t -> {
            return !t.isDone();
        }).size()));
    }

}
```
###### /java/seedu/today/logic/parser/AddCommandParser.java
``` java
/**
 * Parses input arguments and creates a new AddCommand object
 */
public class AddCommandParser extends SeperableParser {

    /**
     * Parses the given {@code String} of arguments in the context of the
     * AddCommand and returns an AddCommand object for execution.
     */
    public Command parse(String arguments) {

        this.args = arguments;

        // find and remove tags
        String[] tags = getTags();

        // find and remove starting time and deadline if the syntax is "<name>
        // from <starting time> to <deadline>"
        List<Date> startingTimeAndDeadline = getStartingTimeAndDeadline();
        if (startingTimeAndDeadline != null) {
            try {
                return new AddCommand(args.trim(), startingTimeAndDeadline.get(CliSyntax.DEADLINE_INDEX),
                        startingTimeAndDeadline.get(CliSyntax.STARTING_INDEX), tags);
            } catch (IllegalValueException e) {
                return new IncorrectCommand(MESSAGE_INVALID_COMMAND_FORMAT);
            }
        }

        // find and remove starting time and deadline if the syntax is "<name>
        // due <deadline>"
        Date deadline = getDeadline();
        if (deadline != null) {
            try {
                return new AddCommand(args.trim(), deadline, tags);
            } catch (IllegalValueException e) {
                return new IncorrectCommand(MESSAGE_INVALID_COMMAND_FORMAT);
            }
        }
        try {
            return new AddCommand(args.trim(), tags);
        } catch (IllegalValueException e) {
            return new IncorrectCommand(MESSAGE_INVALID_COMMAND_FORMAT);
        }
    }

}
```
###### /java/seedu/today/logic/parser/CliSyntax.java
``` java
/**
 * Contains Command Line Interface (CLI) syntax definitions common to multiple
 * commands
 */
public class CliSyntax {

    /* Patterns definitions */
    public static final Pattern KEYWORDS_ARGS_FORMAT = Pattern
            .compile("(?<keywords>\\S+(?:\\s+\\S+)*)");
    public static final String DATE = "^|\\s(\\d{1,2}/\\d{1,2}/\\d{2,4})(?=$|\\s)";
```
###### /java/seedu/today/logic/parser/CliSyntax.java
``` java
    /* Add Command key words */
    public static final String WILDCARD = ".*";
    public static final String END_OF_A_WORD = "\\b";
    public static final String END_OF_A_WORD_REVERSE = "b\\";

    public static final String DEADLINE_ONLY = "due";

    public static final String[] STARTINGTIME_AND_DEADLINE = { "from", "to" };
    public static final int INDEX_OF_STARTINGTIME = 1;
    public static final int INDEX_OF_DEADLINE = 0;
    public static final String STARTINGTIME_AND_DEADLINE_REVERSE_REGEX = "(?<rest>.*)\\b+from\\b+"
            + "(?<startingTime>.*)\\b+to\\b+(?<deadline>.*)";
    public static final String[] CAPTURE_GROUPS_OF_EVENT = { "deadline",
        "startingTime" };

    public static final String STARTING_TIME = "from";
    public static final String DEADLINE = "to";

    public static final int DEADLINE_INDEX = 1;
    public static final int STARTING_INDEX = 0;

    public static final String TAGS = "(?:^|\\s)(#\\S*)";

    public static final String DEFAULT_DEADLINE = " at 2359";
    public static final String DEFAULT_STARTING_TIME = " at 0000";

    /* Find Command Keywords */
    public static final String FIND_NAME = "title";
    public static final String FIND_DEADLINE = "due";
    public static final String FIND_PERIOD = "during";
    public static final String FIND_TAG = "tag";
}
```
###### /java/seedu/today/logic/parser/EditCommandParser.java
``` java
/**
 * Parses input arguments and creates a new EditCommand object
 */
public class EditCommandParser extends SeperableParser {

    /**
     * Parses the given {@code String} of arguments in the context of the
     * EditCommand and returns an EditCommand object for execution.
     */
    public Command parse(String args, LogicManager logic) {
        assert args != null;
        this.args = args.trim();
        String[] indexAndArguments = this.args.split("\\s+", 2);
        if (indexAndArguments.length < 2) {
            return new IncorrectCommand(MESSAGE_INVALID_COMMAND_FORMAT);
        }

        EditTaskDescriptor editTaskDescriptor = new EditTaskDescriptor();
        Optional<String> index = ParserUtil.parseIndex(indexAndArguments[0]);
        if (!index.isPresent()) {
            return new IncorrectCommand(MESSAGE_INVALID_COMMAND_FORMAT);
        }
        this.args = indexAndArguments[1];
        String tags[] = getTags();
        try {
            editTaskDescriptor.setTags(parseTagsForEdit(Arrays.asList(tags)));
        } catch (IllegalValueException e1) {
            return new IncorrectCommand(MESSAGE_INVALID_COMMAND_FORMAT);
        }
        // find and remove tags

        // find and remove starting time and deadline if the syntax is "<name>
        // from <starting time> to <deadline>"
        List<Date> startingTimeAndDeadline = getStartingTimeAndDeadline();
        if (startingTimeAndDeadline != null) {
            editTaskDescriptor
                    .setStartingTime(Optional.of(new DateTime(startingTimeAndDeadline.get(CliSyntax.STARTING_INDEX))));
            editTaskDescriptor
                    .setDeadline(Optional.of(new DateTime(startingTimeAndDeadline.get(CliSyntax.DEADLINE_INDEX))));
        } else {
            // find and remove starting time and deadline if the syntax is
            // "<name> due <deadline>"
            Date deadline = getDeadline();
            if (deadline != null) {
                editTaskDescriptor.setDeadline(Optional.of(new DateTime(deadline)));
            }
        }
        if (!this.args.trim().equals("")) {
            try {
                editTaskDescriptor.setName(Optional.of(new Name(this.args.trim())));
            } catch (IllegalValueException e) {
                return new IncorrectCommand(e.getMessage());
            }
        }
        if (!logic.isValidUIIndex(index.get())) {
            return new IncorrectCommand(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        return new EditCommand(logic.parseUIIndex(index.get()), editTaskDescriptor);
    }

    /**
     * Parses {@code Collection<String> tags} into an
     * {@code Optional<UniqueTagList>} if {@code tags} is non-empty. If
     * {@code tags} contain only one element which is an empty string, it will
     * be parsed into a {@code Optional<UniqueTagList>} containing zero tags.
     */
    private Optional<UniqueTagList> parseTagsForEdit(Collection<String> tags) throws IllegalValueException {
        assert tags != null;

        if (tags.isEmpty()) {
            return Optional.empty();
        }
        Collection<String> tagSet = tags.size() == 1 && tags.contains("") ? Collections.emptySet() : tags;
        return Optional.of(ParserUtil.parseTags(tagSet));
    }

}
```
###### /java/seedu/today/logic/parser/FindCommandParser.java
``` java
/**
 * Parses input arguments and creates a new FindCommand object
 */
public class FindCommandParser {

    public static final String NO_ARGUMENT_ERROR = "Find command found no arguments";
    public static final String DATE_FORMAT_ERROR = "Wrong date time format";

    /**
     * Parses the given {@code String} of arguments in the context of the
     * FindCommand and returns an FindCommand object for execution.
     */
    public Command parse(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(MESSAGE_INVALID_COMMAND_FORMAT);
        }

        // keywords delimited by whitespace
        final String key = matcher.group("keywords");
        final String[] keywords = key.split("\\s+", 2);
        if (keywords.length == 0) {
            return new IncorrectCommand(NO_ARGUMENT_ERROR);
        }
        final Set<String> keywordSet;
        List<DateGroup> dates;
        if (keywords[0].equals(CliSyntax.FIND_DEADLINE)) {
            dates = new PrettyTimeParser().parseSyntax(ParserUtil.correctDateFormat(key));
            if (dates.get(0).getText().equals(keywords[1].trim())) {
                return new FindCommand(null, dates, null);
            }
        }
        keywordSet = new HashSet<>(Arrays.asList(key.split("\\s+")));
        dates = new PrettyTimeParser().parseSyntax(key);
        return new FindCommand(keywordSet, dates, keywordSet);
    }

}
```
###### /java/seedu/today/logic/parser/ParserUtil.java
``` java
    /**
     * change DD(-/)MM(-/)YYYY to MM/DD/YYYY
     */
    public static String correctDateFormat(String original) {
        assert original != null;
        original = original.trim();
        Pattern pattern = Pattern.compile(
                "(?<=^|\\s)(\\d{1,2})(-|/)(\\d{1,2})(-|/)(\\d{2,4})(?=$|\\s)");
        Matcher matcher = pattern.matcher(original);
        original = matcher.replaceAll("$3/$1/$5");
        if (original.endsWith(" later") || original.endsWith(" ago")) {
            original = original.substring(0, original.lastIndexOf(" "));
        }
        return original;
    }
}
```
###### /java/seedu/today/logic/parser/SeperableParser.java
``` java
public class SeperableParser {

    protected static final int NUMBER_OF_ARGUMENTS_IN_STARTING_TIME_AND_DEADLINE = 2;
    String args;

    protected String[] getTags() {
        Pattern pattern = Pattern.compile(CliSyntax.TAGS);
        Matcher matcher = pattern.matcher(args);
        ArrayList<String> tags = new ArrayList<String>();
        while (matcher.find()) {
            assert matcher.group().length() > 0;
            tags.add(matcher.group().trim().substring(1));
        }
        args = matcher.replaceAll("");
        return (tags.toArray(new String[0]));
    }

    protected String getArgument(String key) {
        String reverseString = new StringBuilder(args).reverse().toString();
        String reverseKey = new StringBuilder(key).reverse().toString();
        Pattern pattern = Pattern.compile(
                CliSyntax.END_OF_A_WORD + reverseKey + CliSyntax.END_OF_A_WORD);
        Matcher matcher = pattern.matcher(reverseString);
        if (matcher.find()) {
            String arg = args
                    .substring(reverseString.length() - matcher.start());
            args = args.substring(0, reverseString.length() - matcher.end());
            return arg.trim();
        } else {
            return null;
        }
    }

    protected List<String> getMoreThanOneArguments(String regex,
            String[] captureGroups) {
        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(args);
        if (matcher.matches()) {
            List<String> arguments = new ArrayList<String>();
            for (String captureGroup : captureGroups) {
                arguments.add(matcher.group(captureGroup).trim());
            }
            args = matcher.group("rest").trim();
            return arguments;
        } else {
            return null;
        }
    }

    protected List<Date> getStartingTimeAndDeadline() {
        String tmpArgs = args;
        String correctDateTime = "";
        List<String> datesString = getMoreThanOneArguments(
                CliSyntax.STARTINGTIME_AND_DEADLINE_REVERSE_REGEX,
                CliSyntax.CAPTURE_GROUPS_OF_EVENT);
        if (datesString == null) {
            args = tmpArgs;
            return null;
        }
        assert datesString
                .size() == NUMBER_OF_ARGUMENTS_IN_STARTING_TIME_AND_DEADLINE;
        List<Date> dates = new ArrayList<Date>();
        for (int i = 0; i < NUMBER_OF_ARGUMENTS_IN_STARTING_TIME_AND_DEADLINE; i++) {
            List<DateGroup> group = new PrettyTimeParser().parseSyntax(
                    ParserUtil.correctDateFormat(datesString.get(i))

                            + (i == 1 ? CliSyntax.DEFAULT_STARTING_TIME
                                    : CliSyntax.DEFAULT_DEADLINE));

            if (group == null || group.size() > 2 || (!group.get(0).getText()
                    .equals(datesString.get(i))
                    && (!group.get(0).getText().equals(
                            ParserUtil.correctDateFormat(datesString.get(i))
                                    + (i == 1 ? CliSyntax.DEFAULT_STARTING_TIME
                                            : CliSyntax.DEFAULT_DEADLINE))
                            && !group.get(0).getText().equals(ParserUtil
                                    .correctDateFormat(datesString.get(i)))))) {
                args = tmpArgs;
                return null;
            } else {
                dates.addAll(group.get(0).getDates());

                correctDateTime = ((i == 1 ? "from " : "to ")
                        + group.get(0).getText() + " ") + correctDateTime;
            }
        }
        if (dates.get(CliSyntax.INDEX_OF_STARTINGTIME)
                .after(dates.get(CliSyntax.INDEX_OF_DEADLINE))) {
            args = tmpArgs;
            return null;
        }
        dates = new PrettyTimeParser().parse(correctDateTime);
        return dates;
    }

    protected Date getDeadline() {
        String tmpArgs = args;
        String deadlineString = getArgument(CliSyntax.DEADLINE_ONLY);
        if (deadlineString == null) {
            args = tmpArgs;
            return null;
        }
        List<DateGroup> group = new PrettyTimeParser()
                .parseSyntax(ParserUtil.correctDateFormat(
                        deadlineString + CliSyntax.DEFAULT_DEADLINE));
        if (group == null || group.get(0).getPosition() != 0 || group.size() > 2
                || group.get(0).getDates().size() > 1) {
            args = tmpArgs;
            return null;
        } else {
            return group.get(0).getDates().get(0);
        }
    }
}
```
###### /java/seedu/today/model/ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowAll() {
        filteredTasks.setPredicate(null);
    }

    @Override
    public void updateFilteredTaskList(Set<String> keywords, Date date, Set<String> tagKeys) {
        Predicate<ReadOnlyTask> predicate = t -> false;
        if (keywords != null) {
            predicate = predicate.or(isTitleContainsKeyword(keywords));
        }
        if (date != null) {
            predicate = predicate.or(isDueOnThisDate(date));
        }
        if (tagKeys != null) {
            predicate = predicate.or(isTagsContainKeyword(tagKeys));
        }
        filteredTasks.setPredicate(predicate);
        indicateTaskManagerChanged(MESSAGE_ON_UPDATELIST);
    }
    // author
    // ========== Inner classes/interfaces used for filtering
    // =================================================

    public Predicate<ReadOnlyTask> isTitleContainsKeyword(Set<String> keywords) {
        assert !keywords.isEmpty() : "no keywords provided for a keyword search";
        return t -> {
            return keywords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(t.getName().toString(), keyword)).findAny()
                    .isPresent();
        };
    }

    public Predicate<ReadOnlyTask> isTagsContainKeyword(Set<String> keywords) {
        assert !keywords.isEmpty() : "no keywords provided for a tag search";
        return t -> {
            return keywords.stream().filter(keyword -> {
                boolean f = false;
                for (Tag tag : t.getTags()) {
                    f = f || StringUtil.containsWordIgnoreCase(tag.getTagName(), keyword);
                }
                return f;
            }).findAny().isPresent();
        };
    }

```
###### /java/seedu/today/model/task/DateTime.java
``` java
/**
 * Represents a Task's date and time for a deadline or a starting time in the
 * task manager.
 */
public class DateTime implements Comparable<DateTime> {

    PrettyTime dateTime = new PrettyTime();

    public DateTime(Date date) {
        dateTime.setReference(date);
    }

    /**
     * Set the time and date to this deadline
     *
     * @param date
     *            the new Date object this StartingTime instance to be
     *            referenced to
     * @param isMissingTime
     *            whether the default starting time to be used
     * @param isMissingDate
     *            whether the default starting date to be used
     */
    public void set(Date date) {
        dateTime.setReference(date);
    }

    /**
     * @return a PrettyTime object
     */
    public PrettyTime getDateTime() {
        return this.dateTime;
    }

    /**
     * @return a copy of Date object referenced by this instance
     */
    public Date getDate() {
        return new Date(dateTime.getReference().getTime());
    }

    /**
     * @return the date & time in String
     */
    @Override
    public String toString() {
        return new PrettyTime().format(this.dateTime.getReference());
    }

    /**
     * get the duration between this date time and the specified date time
     *
     * @param date
     *            the other end of date
     * @return the duration in plain English
     */
    public String getDuration(Date date) {
        PrettyTime duration = new PrettyTime();
        return duration.format(this.dateTime.calculatePreciseDuration(date));
    }

```
###### /java/seedu/today/model/task/DeadlineTask.java
``` java
/**
 * Represents a Task in the task manager with deadline only. not null, field
 * values are validated.
 */
public class DeadlineTask extends Task {
    static final String MESSAGE_DATETIME_CONSTRAINTS = "Deadline should be after starting time.";

    DateTime deadline;

    public DeadlineTask(Name name, UniqueTagList tags, Date date, boolean isDone, boolean manualToday)
            throws IllegalValueException {
        super(name, tags, isDone, manualToday);
        this.deadline = new DateTime(date);
    }

    /**
     * return the overdue status of the task
     *
     * @return true for overdue, false otherwise
     */
    @Override
    public boolean isOverdue() {
        return deadline.getDate().compareTo(new Date()) <= 0;
    }

    /**
     * @return the duration from now to the deadline (may be negative)
     */
    public String timeTilDeadline() {
        return deadline.getDuration(new Date());
    }

    @Override
    public String getTaskDateTime() {
        return "Due: " + deadline.toString();
    }

    @Override
    public boolean isToday() {
        SimpleDateFormat fmt = new SimpleDateFormat("yyyyMMdd");
        return isManualToday() || fmt.format(this.deadline.getDate()).equals(fmt.format(new Date())) || isOverdue();
    }

```
###### /java/seedu/today/model/task/DeadlineTask.java
``` java

    @Override
    public Optional<DateTime> getDeadline() {
        return Optional.of(new DateTime(deadline.getDate()));
    }

    @Override
    public Optional<DateTime> getStartingTime() {
        return Optional.empty();
    }
}
```
###### /java/seedu/today/model/task/EventTask.java
``` java
/**
 * Represents a Task in the task manager with deadline and starting time, also
 * known as an event. not null, field values are validated.
 */
public class EventTask extends Task {
    static final String MESSAGE_DATETIME_CONSTRAINTS = "Deadline should be after starting time.";

    DateTime deadline;
    DateTime startingTime;

    /**
     * starting time may be null
     */
    public EventTask(Name name, UniqueTagList tags, Date date1, Date date2, boolean isDone, boolean manualToday)
            throws IllegalValueException {
        super(name, tags, isDone, manualToday);
        this.deadline = new DateTime(date1);
        this.startingTime = new DateTime(date2);
        validateDateTime();
    }

    /**
     * validates deadline and starting time
     *
     * @throws IllegalValueException
     */
    private void validateDateTime() throws IllegalValueException {
        if (this.startingTime != null && this.startingTime.getDate().after(this.deadline.getDate())) {
            throw new IllegalValueException(MESSAGE_DATETIME_CONSTRAINTS);
        }
    }

    /**
     * return the overdue status of the task
     *
     * @return true for overdue, false otherwise
     */
    @Override
    public boolean isOverdue() {
        return deadline.getDate().compareTo(new Date()) <= 0;
    }

    /**
     * @return the duration from now to the deadline (may be negative)
     */
    public String timeTilDeadline() {
        return deadline.getDuration(new Date());
    }

    @Override
    public String getTaskDateTime() {
        return "Begin: " + startingTime.toString() + "; Due: " + deadline.toString();
    }

```
###### /java/seedu/today/model/task/EventTask.java
``` java

    @Override
    public Optional<DateTime> getDeadline() {
        return Optional.of(new DateTime(deadline.getDate()));
    }

    @Override
    public Optional<DateTime> getStartingTime() {
        return Optional.of(new DateTime(startingTime.getDate()));
    }

    @Override
    public String getTaskAbsoluteDateTime() {
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
        return "Begin: " + dateFormat.format(startingTime.getDate()) + "\n   End: "
                + dateFormat.format(deadline.getDate());
    }

}
```
###### /java/seedu/today/model/task/FloatingTask.java
``` java
/**
 * Represents a Task in the task manager without deadline or starting time. not
 * null, field values are validated.
 */
public class FloatingTask extends Task {
    public FloatingTask(Name name, UniqueTagList tags, boolean isDone, boolean manualToday) {
        super(name, tags, isDone, manualToday);
    }

    public FloatingTask(ReadOnlyTask source) {
        super(source);
    }

    @Override
    public String getTaskDateTime() {
        return "";
    }

    @Override
    public String getTaskAbsoluteDateTime() {
        return "";
    }

```
###### /java/seedu/today/model/task/FloatingTask.java
``` java
    @Override
    public Optional<DateTime> getStartingTime() {
        return Optional.empty();
    }

    @Override
    public boolean isToday() {
        return isManualToday() || isOverdue();
    }

    @Override
    public boolean isOverdue() {
        return false;
    }
}
```
###### /java/seedu/today/model/task/Task.java
``` java
/**
 * Represents a Task in the task manager. not null, field values are validated.
 */
public abstract class Task implements ReadOnlyTask {

    public static final String ONLY_STARTING_DATE_AVAILABLE_ERROR = "Task should not contain"
            + " a starting time without a deadline";

    private Name name;
    private String id;
    private UniqueTagList tags;
    private int isAnimated;
    private boolean done;
    private boolean isManualToday = false;

    /**
     * Every field must be present and not null.
     */
    public Task(Name name, UniqueTagList tags, boolean done, boolean manualToday) {
        assert !CollectionUtil.isAnyNull(name, tags);
        this.name = name;
        this.tags = new UniqueTagList(tags); // protect internal tags from
                                             // changes in the arg list
        this.done = done;
        this.isManualToday = manualToday;
        this.id = "";
    }

    /**
     * Creates a copy of the given ReadOnlyTask.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getTags(), source.isDone(), source.isManualToday());
    }

```
###### /java/seedu/today/model/task/Task.java
``` java
    public void setToday(boolean manualToday) {
        this.isManualToday = manualToday;
    }

    @Override
    public boolean isManualToday() {
        return isManualToday;
    }

    @Override
    public abstract boolean isToday();

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                        && this.isSameStateAs((ReadOnlyTask) other));
    }

```
