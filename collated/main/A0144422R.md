# A0144422R
###### \java\seedu\address\logic\commands\AddCommand.java
``` java
/**
 * Adds a task to the task manager.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Adds a task to the task manager. "
            + "Parameters: NAME [t/TAG]...\n" + "Example: " + COMMAND_WORD
            + " CS2103 Refactoring Task t/CS2103";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_SUCCESS_STATUS_BAR = "New task added successfully.";
    public static final String MESSAGE_DUPLICATE_PERSON = "This task already exists in the task manager";

    private final Task toAdd;

    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException
     *             if any of the raw values are invalid
     */
    public AddCommand(String name, String tags[]) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName.trim()));
        }
        this.toAdd = new FloatingTask(new Name(name), new UniqueTagList(tagSet),
                false, false);
        this.toAdd.setAnimation(true);
    }

    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException
     *             if any of the raw values are invalid
     */
    public AddCommand(String name, Date deadline, String tags[])
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName.trim()));
        }
        System.out.print("deadline: " + deadline);
        this.toAdd = new DeadlineTask(new Name(name), new UniqueTagList(tagSet),
                deadline, false, false);
        this.toAdd.setAnimation(true);
    }

    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException
     *             if any of the raw values are invalid
     */
    public AddCommand(String name, Date deadline, Date startingTime,
            String tags[]) throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName.trim()));
        }
        this.toAdd = new EventTask(new Name(name), new UniqueTagList(tagSet),
                deadline, startingTime, false, false);
        this.toAdd.setAnimation(true);
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            model.addTask(toAdd);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd),
                    MESSAGE_SUCCESS_STATUS_BAR);
        } catch (UniqueTaskList.DuplicateTaskException e) {
            throw new CommandException(MESSAGE_DUPLICATE_PERSON);
        }
    }

    // For testing
    public Task getTask() {
        return toAdd;
    }

}
```
###### \java\seedu\address\logic\commands\EditCommand.java
``` java
/**
 * Edits the details of an existing task in the task manager.
 */
public class EditCommand extends Command {

    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Edits the details of the task identified "
            + "by the index number used in the last task listing. "
            + "Existing values will be overwritten by the input values.\n"
            + "Parameters: INDEX (must be a positive integer) [NAME] [due DEADLINE] [tag TAGS]...\n"
            + "Example: " + COMMAND_WORD + " 1 CS2103 Finish Tutorial";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Task: %1$s";
    public static final String MESSAGE_NOT_EDITED = "At least one field to edit must be provided.";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";
    public static final String MESSAGE_SUCCESS_STATUS_BAR = "Task edited successfully.";

    private final int filteredTaskListIndex;
    private final EditTaskDescriptor editTaskDescriptor;

    /**
     * @param filteredTaskListIndex
     *            the index of the task in the filtered task list to edit
     * @param editTaskDescriptor
     *            details to edit the task with
     */
    public EditCommand(int filteredTaskListIndex,
            EditTaskDescriptor editTaskDescriptor) {
        assert filteredTaskListIndex > 0;
        assert editTaskDescriptor != null;

        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;

        this.editTaskDescriptor = new EditTaskDescriptor(editTaskDescriptor);
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        assert filteredTaskListIndex < lastShownList.size();

        ReadOnlyTask taskToEdit = lastShownList.get(filteredTaskListIndex);
        Task editedTask;
        if (editTaskDescriptor.isAnyFieldEdited()) {
            try {
                editedTask = createEditedTask(taskToEdit, editTaskDescriptor);
            } catch (IllegalValueException e) {
                throw new CommandException(e.getMessage());
            }

            try {
                model.updateTask(filteredTaskListIndex, editedTask);
            } catch (UniqueTaskList.DuplicateTaskException dpe) {
                throw new CommandException(MESSAGE_DUPLICATE_TASK);
            }
            model.updateFilteredListToShowAll();
        }
        return new CommandResult(
                String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit),
                MESSAGE_SUCCESS_STATUS_BAR);
    }

```
###### \java\seedu\address\logic\commands\EditCommand.java
``` java
        public void setStartingTime(Optional<DateTime> startingTime) {
            this.startingTime = startingTime;
        }

        public Optional<DateTime> getStartingTime() {
            return this.startingTime;
        }

        public void setDeadline(Optional<DateTime> deadline) {
            this.deadline = deadline;
        }

        public Optional<DateTime> getDeadline() {
            return this.deadline;
        }
    }
}
```
###### \java\seedu\address\logic\commands\FindCommand.java
``` java
/**
 * Finds and lists all tasks in task manager whose name contains any of the
 * argument keywords. Keyword matching is case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Finds all tasks whose names contain any of "
            + "the specified keywords (case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n" + "Example: "
            + COMMAND_WORD + " alice bob charlie";

    public static final String MESSAGE_SUCCESS_STATUS_BAR = "%1$s task(s) found.";

    private final Set<String> keywords;
    private final Date date;
    private final Set<String> tagKeys;

    public FindCommand(Set<String> keywords, List<DateGroup> dates,
            Set<String> tagKeys) {
        this.keywords = keywords;
        if (dates != null && dates.size() > 0
                && dates.get(0).getDates().size() > 0) {
            this.date = dates.get(0).getDates().get(0);
        } else {
            this.date = null;
        }
        this.tagKeys = tagKeys;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskList(keywords, date, tagKeys);
        return new CommandResult(
                getMessageForTaskListShownSummary(
                        model.getFilteredTaskList().size()),
                String.format(MESSAGE_SUCCESS_STATUS_BAR,
                        model.getFilteredTaskList().size()));
    }

}
```
###### \java\seedu\address\logic\parser\AddCommandParser.java
``` java
/**
 * Parses input arguments and creates a new AddCommand object
 */
public class AddCommandParser extends SeperableParser {

    /**
     * Parses the given {@code String} of arguments in the context of the
     * AddCommand and returns an AddCommand object for execution.
     */
    public Command parse(String arguments) {

        this.args = arguments;

        // find and remove tags
        String[] tags = getTags();

        // find and remove starting time and deadline if the syntax is "<name>
        // from <starting time> to <deadline>"
        List<Date> startingTimeAndDeadline = getStartingTimeAndDeadline();
        if (startingTimeAndDeadline != null) {
            try {
                return new AddCommand(args.trim(),
                        startingTimeAndDeadline.get(1),
                        startingTimeAndDeadline.get(0), tags);
            } catch (IllegalValueException e) {
                return new IncorrectCommand(
                        String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                                AddCommand.MESSAGE_USAGE));
            }
        }

        // find and remove starting time and deadline if the syntax is "<name>
        // due <deadline>"
        Date deadline = getDeadline();
        if (deadline != null) {
            try {
                return new AddCommand(args.trim(), deadline, tags);
            } catch (IllegalValueException e) {
                return new IncorrectCommand(
                        String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                                AddCommand.MESSAGE_USAGE));
            }
        }
        try {
            return new AddCommand(args.trim(), tags);
        } catch (IllegalValueException e) {
            return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
    }

}
```
###### \java\seedu\address\logic\parser\CliSyntax.java
``` java
/**
 * Contains Command Line Interface (CLI) syntax definitions common to multiple
 * commands
 */
public class CliSyntax {

    /* Patterns definitions */
    public static final Pattern KEYWORDS_ARGS_FORMAT = Pattern
            .compile("(?<keywords>\\S+(?:\\s+\\S+)*)");
    public static final String DATE = "^|\\s(\\d{1,2}/\\d{1,2}/\\d{2,4})(?=$|\\s)";

    /* Add Command key words */
    public static final String WILDCARD = ".*";
    public static final String END_OF_A_WORD = "\\b";
    public static final String END_OF_A_WORD_REVERSE = "b\\";

    public static final String DEADLINE_ONLY = "due";

    public static final String[] STARTINGTIME_AND_DEADLINE = { "from", "to" };
    public static final int INDEX_OF_STARTINGTIME = 1;
    public static final int INDEX_OF_DEADLINE = 0;
    public static final String STARTINGTIME_AND_DEADLINE_REVERSE_REGEX = "(?<rest>.*)\\b+from\\b+"
            + "(?<startingTime>.*)\\b+to\\b+(?<deadline>.*)";
    public static final String[] CAPTURE_GROUPS_OF_EVENT = { "deadline",
            "startingTime" };

    public static final String STARTING_TIME = "from";
    public static final String DEADLINE = "to";

    public static final String TAGS = "(?:^|\\s)(#\\S*)";

    public static final String DEFAULT_DEADLINE = " at 2359";
    public static final String DEFAULT_STARTING_TIME = " at 0000";

    /* Find Command Keywords */
    public static final String FIND_NAME = "title";
    public static final String FIND_DEADLINE = "due";
    public static final String FIND_PERIOD = "during";
    public static final String FIND_TAG = "tag";
}
```
###### \java\seedu\address\logic\parser\EditCommandParser.java
``` java
/**
 * Parses input arguments and creates a new EditCommand object
 */
public class EditCommandParser extends SeperableParser {

    /**
     * Parses the given {@code String} of arguments in the context of the
     * EditCommand and returns an EditCommand object for execution.
     */
    public Command parse(String args, LogicManager logic) {
        assert args != null;
        this.args = args.trim();
        String[] indexAndArguments = this.args.split("\\s+", 2);
        if (indexAndArguments.length < 2) {
            return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        EditTaskDescriptor editTaskDescriptor = new EditTaskDescriptor();
        Optional<String> index = ParserUtil.parseIndex(indexAndArguments[0]);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }
        this.args = indexAndArguments[1];
        String tags[] = getTags();
        try {
            editTaskDescriptor.setTags(parseTagsForEdit(Arrays.asList(tags)));
        } catch (IllegalValueException e1) {
            return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }
        // find and remove tags

        // find and remove starting time and deadline if the syntax is "<name>
        // from <starting time> to <deadline>"
        List<Date> startingTimeAndDeadline = getStartingTimeAndDeadline();
        if (startingTimeAndDeadline != null) {
            editTaskDescriptor.setStartingTime(
                    Optional.of(new DateTime(startingTimeAndDeadline.get(0))));
            editTaskDescriptor.setDeadline(
                    Optional.of(new DateTime(startingTimeAndDeadline.get(1))));
        } else {
            // find and remove starting time and deadline if the syntax is
            // "<name> due <deadline>"
            Date deadline = getDeadline();
            if (deadline != null) {
                editTaskDescriptor
                        .setDeadline(Optional.of(new DateTime(deadline)));
            }
        }
        if (!this.args.trim().equals("")) {
            try {
                editTaskDescriptor
                        .setName(Optional.of(new Name(this.args.trim())));
            } catch (IllegalValueException e) {
                return new IncorrectCommand(e.getMessage());
            }
        }
        if (!logic.isValidUIIndex(index.get())) {
            return new IncorrectCommand(
                    Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        return new EditCommand(logic.parseUIIndex(index.get()),
                editTaskDescriptor);
    }

    /**
     * Parses {@code Collection<String> tags} into an
     * {@code Optional<UniqueTagList>} if {@code tags} is non-empty. If
     * {@code tags} contain only one element which is an empty string, it will
     * be parsed into a {@code Optional<UniqueTagList>} containing zero tags.
     */
    private Optional<UniqueTagList> parseTagsForEdit(Collection<String> tags)
            throws IllegalValueException {
        assert tags != null;

        if (tags.isEmpty()) {
            return Optional.empty();
        }
        Collection<String> tagSet = tags.size() == 1 && tags.contains("")
                ? Collections.emptySet() : tags;
        return Optional.of(ParserUtil.parseTags(tagSet));
    }

}
```
###### \java\seedu\address\logic\parser\FindCommandParser.java
``` java
/**
 * Parses input arguments and creates a new FindCommand object
 */
public class FindCommandParser {

    public static final String NO_ARGUMENT_ERROR = "Find command found no arguments";
    public static final String DATE_FORMAT_ERROR = "Wrong date time format";

    /**
     * Parses the given {@code String} of arguments in the context of the
     * FindCommand and returns an FindCommand object for execution.
     */
    public Command parse(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(
                    MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String key = matcher.group("keywords");
        final String[] keywords = key.split("\\s+", 2);
        if (keywords.length == 0) {
            return new IncorrectCommand(NO_ARGUMENT_ERROR);
        }
        final Set<String> keywordSet;
        List<DateGroup> dates;
        switch (keywords[0].trim()) {
        case CliSyntax.FIND_NAME:
            keywordSet = new HashSet<>(Arrays.asList(keywords));
            return new FindCommand(keywordSet, null, null);
        case CliSyntax.FIND_DEADLINE:
            dates = new PrettyTimeParser()
                    .parseSyntax(ParserUtil.correctDateFormat(key));
            if (dates.get(0).getText().equals(keywords[1].trim())) {
                return new FindCommand(null, dates, null);
            }
            break;
        case CliSyntax.FIND_TAG:
            keywordSet = new HashSet<>(Arrays.asList(keywords));
            return new FindCommand(null, null, keywordSet);
        }
        keywordSet = new HashSet<>(Arrays.asList(keywords));
        dates = new PrettyTimeParser().parseSyntax(key);
        return new FindCommand(keywordSet, dates, keywordSet);
    }

}
```
###### \java\seedu\address\model\ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowAll() {
        filteredTasks.setPredicate(null);
    }

    @Override
    public void updateFilteredTaskList(Set<String> keywords, Date date,
            Set<String> tagKeys) {
        Predicate<ReadOnlyTask> predicate = t -> false;
        if (keywords != null) {
            predicate = predicate.or(isTitleContainsKeyword(keywords));
        }
        if (date != null) {
            predicate = predicate.or(isDueOnThisDate(date));
        }
        if (tagKeys != null) {
            predicate = predicate.or(isTagsContainKeyword(tagKeys));
        }
        filteredTasks.setPredicate(predicate);
        indicateTaskManagerChanged(MESSAGE_ON_UPDATELIST);
    }
    // author
    // ========== Inner classes/interfaces used for filtering
    // =================================================

    public Predicate<ReadOnlyTask> isTitleContainsKeyword(
            Set<String> keywords) {
        assert !keywords
                .isEmpty() : "no keywords provided for a keyword search";
        return t -> {
            return keywords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(
                            t.getName().fullName, keyword))
                    .findAny().isPresent();
        };
    }

    public Predicate<ReadOnlyTask> isTagsContainKeyword(Set<String> keywords) {
        assert !keywords.isEmpty() : "no keywords provided for a tag search";
        return t -> {
            return keywords.stream().filter(keyword -> {
                boolean f = false;
                for (Tag tag : t.getTags()) {
                    f = f || StringUtil.containsWordIgnoreCase(tag.getTagName(),
                            keyword);
                }
                return f;
            }).findAny().isPresent();
        };
    }

```
###### \java\seedu\address\model\task\DateTime.java
``` java
/**
 * Represents a Task's date and time for a deadline or a starting time in the
 * task manager.
 */
public class DateTime implements Comparable<DateTime> {

    PrettyTime dateTime = new PrettyTime();

    public DateTime(Date date) {
        dateTime.setReference(date);
    }

    /**
     * Set the time and date to this deadline
     *
     * @param date
     *            the new Date object this StartingTime instance to be
     *            referenced to
     * @param isMissingTime
     *            whether the default starting time to be used
     * @param isMissingDate
     *            whether the default starting date to be used
     */
    public void set(Date date) {
        dateTime.setReference(date);
    }

    /**
     * @return a PrettyTime object
     */
    public PrettyTime getDateTime() {
        return this.dateTime;
    }

    /**
     * @return a copy of Date object referenced by this instance
     */
    public Date getDate() {
        return new Date(dateTime.getReference().getTime());
    }

    /**
     * @return the date & time in String
     */
    @Override
    public String toString() {
        return new PrettyTime().format(this.dateTime.getReference());
    }

    /**
     * get the duration between this date time and the specified date time
     *
     * @param date
     *            the other end of date
     * @return the duration in plain English
     */
    public String getDuration(Date date) {
        PrettyTime duration = new PrettyTime();
        return duration.format(this.dateTime.calculatePreciseDuration(date));
    }

```
###### \java\seedu\address\model\task\DeadlineTask.java
``` java
/**
 * Represents a Task in the task manager with deadline only. not null, field
 * values are validated.
 */
public class DeadlineTask extends Task {
    static final String MESSAGE_DATETIME_CONSTRAINTS = "Deadline should be after starting time.";

    DateTime deadline;

    public DeadlineTask(Name name, UniqueTagList tags, Date date,
            boolean isDone, boolean manualToday) throws IllegalValueException {
        super(name, tags, isDone, manualToday);
        this.deadline = new DateTime(date);
    }

    // (Obsolete)
    // public DeadlineTask(ReadOnlyTask source) throws IllegalValueException {
    // this(source.getName(), source.getTags(),
    // source.getDeadline().get().getDate(), source.isDone(),
    // source.isManualToday());
    // }

    /**
     * return the overdue status of the task
     *
     * @return true for overdue, false otherwise
     */
    @Override
    public boolean isOverdue() {
        return deadline.getDate().compareTo(new Date()) <= 0;
    }

    /**
     * @return the duration from now to the deadline (may be negative)
     */
    public String timeTilDeadline() {
        return deadline.getDuration(new Date());
    }

    @Override
    public String getTaskDateTime() {
        return "Due: " + deadline.toString();
    }

    @Override
    public boolean isToday() {
        SimpleDateFormat fmt = new SimpleDateFormat("yyyyMMdd");
        return manualToday || fmt.format(this.deadline.getDate())
                .equals(fmt.format(new Date())) || isOverdue();
    }

```
###### \java\seedu\address\model\task\DeadlineTask.java
``` java

    @Override
    public Optional<DateTime> getDeadline() {
        return Optional.of(new DateTime(deadline.getDate()));
    }

    @Override
    public Optional<DateTime> getStartingTime() {
        return Optional.empty();
    }
}
```
###### \java\seedu\address\model\task\EventTask.java
``` java
/**
 * Represents a Task in the task manager with deadline and starting time, also
 * known as an event. not null, field values are validated.
 */
public class EventTask extends Task {
    static final String MESSAGE_DATETIME_CONSTRAINTS = "Deadline should be after starting time.";

    DateTime deadline;
    DateTime startingTime;

    /**
     * starting time may be null
     */
    public EventTask(Name name, UniqueTagList tags, Date date1, Date date2,
            boolean isDone, boolean manualToday) throws IllegalValueException {
        super(name, tags, isDone, manualToday);
        this.deadline = new DateTime(date1);
        this.startingTime = new DateTime(date2);
        validateDateTime();
    }

    // (Obsolete)
    // public EventTask(ReadOnlyTask source) throws IllegalValueException {
    // this(source.getName(), source.getTags(),
    // source.getDeadline().get().getDate(),
    // source.getStartingTime().get().getDate(), source.isDone(),
    // source.isManualToday());
    // validateDateTime();
    // }

    /**
     * validates deadline and starting time
     *
     * @throws IllegalValueException
     */
    private void validateDateTime() throws IllegalValueException {
        if (this.startingTime != null
                && this.startingTime.getDate().after(this.deadline.getDate())) {
            throw new IllegalValueException(MESSAGE_DATETIME_CONSTRAINTS);
        }
    }

    /**
     * return the overdue status of the task
     *
     * @return true for overdue, false otherwise
     */
    @Override
    public boolean isOverdue() {
        return deadline.getDate().compareTo(new Date()) <= 0;
    }

    /**
     * @return the duration from now to the deadline (may be negative)
     */
    public String timeTilDeadline() {
        return deadline.getDuration(new Date());
    }

    @Override
    public String getTaskDateTime() {
        return "Begin: " + startingTime.toString() + "; Due: "
                + deadline.toString();
    }

```
###### \java\seedu\address\model\task\EventTask.java
``` java

    @Override
    public Optional<DateTime> getDeadline() {
        return Optional.of(new DateTime(deadline.getDate()));
    }

    @Override
    public Optional<DateTime> getStartingTime() {
        return Optional.of(new DateTime(startingTime.getDate()));
    }

    @Override
    public String getTaskAbsoluteDateTime() {
        SimpleDateFormat dateFormat = new SimpleDateFormat(
                "dd/MM/yyyy HH:mm:ss");
        return "Begin: " + dateFormat.format(startingTime.getDate())
                + "\n   Due: " + dateFormat.format(deadline.getDate());
    }

}
```
###### \java\seedu\address\model\task\FloatingTask.java
``` java
/**
 * Represents a Task in the task manager without deadline or starting time. not
 * null, field values are validated.
 */
public class FloatingTask extends Task {
    public FloatingTask(Name name, UniqueTagList tags, boolean isDone,
            boolean manualToday) {
        super(name, tags, isDone, manualToday);
    }

    public FloatingTask(ReadOnlyTask source) {
        super(source);
    }

    @Override
    public String getTaskDateTime() {
        return "";
    }

    @Override
    public String getTaskAbsoluteDateTime() {
        return "";
    }

```
###### \java\seedu\address\model\task\FloatingTask.java
``` java
    @Override
    public Optional<DateTime> getStartingTime() {
        return Optional.empty();
    }

    @Override
    public boolean isToday() {
        return manualToday || isOverdue();
    }

    @Override
    public boolean isOverdue() {
        return false;
    }
}
```
###### \java\seedu\address\model\task\Task.java
``` java
/**
 * Represents a Task in the task manager. not null, field values are validated.
 */
public abstract class Task implements ReadOnlyTask {

    public static final String ONLY_STARTING_DATE_AVAILABLE_ERROR = "Task should not contain"
            + " a starting time without a deadline";

    private Name name;
    private String id;
    private UniqueTagList tags;

    private boolean done;
    private boolean isAnimated = false;
    protected boolean manualToday = false;

    /**
     * Every field must be present and not null.
     */
    public Task(Name name, UniqueTagList tags, boolean done,
            boolean manualToday) {
        assert !CollectionUtil.isAnyNull(name, tags);
        this.name = name;
        this.tags = new UniqueTagList(tags); // protect internal tags from
                                             // changes in the arg list
        this.done = done;
        this.manualToday = manualToday;
        this.id = "";
    }

    /**
     * Creates a copy of the given ReadOnlyTask.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getTags(), source.isDone(),
                source.isManualToday());
    }

```
###### \java\seedu\address\model\task\Task.java
``` java
    public void setToday() {
        manualToday = true;
    }

    @Override
    public boolean isManualToday() {
        return manualToday;
    }

    @Override
    public abstract boolean isToday();

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                        && this.isSameStateAs((ReadOnlyTask) other));
    }

```
