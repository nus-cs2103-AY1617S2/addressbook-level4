# A0139161J
###### \java\seedu\task\logic\commands\AddCommand.java
``` java
        String fromDate = new String("");
        String fromTime = null;
        String toDate = new String("");
        String toTime = null;
        if (!deadline.equals("")) {
            Parser parser = new Parser();
            List <DateGroup> groups = parser.parse(deadline);
            List dates = null;
            int line;
            int column;
            String matchingValue;
            String syntaxTree;
            Map parseMap;
            boolean isRecurring;
            Date recursUntil;

            for (DateGroup group: groups) {
                dates = group.getDates();
                line = group.getLine();
                column = group.getPosition();
                matchingValue = group.getText();
                syntaxTree = group.getSyntaxTree().toStringTree();
                parseMap = group.getParseLocations();
                isRecurring = group.isRecurring();
                recursUntil = group.getRecursUntil();
            }

            if (dates != null) {
                fromDate = dates.get(0).toString();
                fromTime = getTime(fromDate);
                if (dates.size() != 1) {
                    toDate = dates.get(1).toString();
                    toTime = getTime(toDate);
                    isEvent = true;
                }
            }
            StringTokenizer st = new StringTokenizer(fromDate);
            List<String> listDeadline = new ArrayList<String>();
            while (st.hasMoreTokens()) {
                listDeadline.add(st.nextToken());
            }
            List<String> endOfEvent = new ArrayList<String>();
            if (isEvent) {
                st = new StringTokenizer(toDate);
                while (st.hasMoreTokens()) {
                    endOfEvent.add(st.nextToken());
                }
            }
            StringBuilder deadlineString = new StringBuilder();
            deadlineString.append(listDeadline.get(2) + "-" + listDeadline.get(1)
                + "-" + listDeadline.get(5) + " @ " + fromTime);
            if (isEvent) {
                deadlineString.append(" to " + endOfEvent.get(2) + "-" + endOfEvent.get(1) + "-" + endOfEvent.get(5)
                    + " @ " + toTime);
            }
            fromDate = deadlineString.toString();
        }
        this.toAdd = new Task(
                new TaskName(taskName),
                new Deadline(fromDate),
                new PriorityLevel(priorityLevel),
                new Information(info),
                new UniqueTagList(tagSet)
        );
        toAdd.setParserInfo("add");
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            model.addTask(toAdd);
            GlobalStack gStack = GlobalStack.getInstance();
            gStack.getUndoStack().push(toAdd);
            /**Debugging purpose
             * gStack.printStack();
             */
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }
    }

```
###### \java\seedu\task\logic\commands\AddCommand.java
``` java
    /* Returns String in format of hh:mm:ss
     * Precond: dateTime string formed by NattyParser required as input
     */
    public String getTime(String dateTime) {
        StringTokenizer st = new StringTokenizer(dateTime);
        List<String> list = new ArrayList<String>();
        while (st.hasMoreTokens()) {
            list.add(st.nextToken());
        }
        System.out.println(list.get(3));
        return list.get(3);
    }

    /*public Date timeFormatter(String time) throws ParseException {
        System.out.println("stop here");
        DateFormat sdf = new SimpleDateFormat("hh:mm:ss");
        Date date = sdf.parse(time);
        System.out.println(date.toString() + "STOP HERE");
        return date;
    }*/
}
```
###### \java\seedu\task\logic\commands\ClearCommand.java
``` java
        GlobalStack gStack = GlobalStack.getInstance();
        // Pushes the most updated list of the task manager into undo stack before wiping data
        TaskManager tm = new TaskManager(model.getTaskManager());
        gStack.getUndoStack().push(tm);
```
###### \java\seedu\task\logic\commands\CompleteCommand.java
``` java
package seedu.task.logic.commands;

import seedu.task.commons.core.Messages;
import seedu.task.commons.core.UnmodifiableObservableList;
import seedu.task.logic.commands.exceptions.CommandException;
import seedu.task.model.task.ReadOnlyTask;
import seedu.task.model.task.Task;
import seedu.task.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.task.model.task.UniqueTaskList.TaskNotFoundException;
public class CompleteCommand extends Command {
    public static final String COMMAND_WORD = "complete";

    public static final String MESSAGE_SUCCESS = "Task completed: %1$s";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks the task as completed, identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    private final int indexToComplete;

    public CompleteCommand(int targetIndex) {
        indexToComplete = targetIndex;
    }

    @Override
    public CommandResult execute() throws CommandException {

        assert model != null;

        UnmodifiableObservableList<ReadOnlyTask> list = model.getFilteredTaskList();

        if (list.size() < indexToComplete) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToComplete = list.get(indexToComplete - 1);
        Task task = new Task(taskToComplete);
        task.setParserInfo("complete");
        try {
            model.completeTask(task);
            return new CommandResult(String.format(MESSAGE_SUCCESS, task));
        } catch (DuplicateTaskException | TaskNotFoundException e) {
            throw new CommandException("Unable to complete specified task");
        }
    }
}
```
###### \java\seedu\task\logic\commands\DeleteCommand.java
``` java
        Task task = new Task (taskToDelete);
        task.setParserInfo("delete");
        task.setIndex(targetIndex - 1);
        try {
            GlobalStack gStack = GlobalStack.getInstance();
            gStack.getUndoStack().push(task); // task that got deleted, to be restored
            /**Debugging purpose
             * System.out.println("Parser Info : " + task.getParserInfo());
             * System.out.println("Index = " + index);
             * System.out.println("Task added to stack : " + gStack.getUndoStack().peek().toString());
            */
            model.deleteTask(taskToDelete);
            /**Debugging purpose
             * gStack.printStack();
             */
```
###### \java\seedu\task\logic\commands\DeleteCompleteCommand.java
``` java
public class DeleteCompleteCommand extends Command {

    public static final String COMMAND_WORD = "deletecompleted";

    public static final String MESSAGE_SUCCESS = "Completed Task deleted: %1$s";

    public static final Object MESSAGE_USAGE = COMMAND_WORD
            + ": Deletes the completed task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";;

    public final int indexToDelete;
    public DeleteCompleteCommand(Integer index) {
        indexToDelete = index;
    }
    @Override
    public CommandResult execute() throws CommandException, IllegalValueException {
        assert model != null;

        UnmodifiableObservableList<ReadOnlyTask> list = model.getCompletedTaskList();
        ReadOnlyTask deletedTask = list.get(indexToDelete - 1);
        try {
            model.deleteCompletedTask(deletedTask);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        }
        return new CommandResult(String.format(MESSAGE_SUCCESS, deletedTask));
    }
}
```
###### \java\seedu\task\logic\commands\RedoCommand.java
``` java
package seedu.task.logic.commands;

import seedu.task.logic.GlobalStack;
import seedu.task.logic.commands.exceptions.CommandException;
import seedu.task.model.TaskManager;
import seedu.task.model.task.ReadOnlyTask;
import seedu.task.model.task.Task;
import seedu.task.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.task.model.task.UniqueTaskList.TaskNotFoundException;

public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";
    public static final String MESSAGE_SUCCESS = "Last action reverted";
    public static final String MESSAGE_FAIL = "Failed to redo";
    public static final String COMMAND_WORD_ADD = "add";
    public static final String COMMAND_WORD_DELETE = "delete";
    public static final String COMMAND_WORD_EDIT = "edit";

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            GlobalStack gStack = GlobalStack.getInstance();
            if (gStack.getRedoStack().isEmpty()) {
                throw new CommandException(GlobalStack.MESSAGE_NOTHING_TO_REDO);
            }
            Object toRedo = gStack.getRedoStack().peek(); //needs improvement
            if (toRedo.getClass() == Task.class) { //add or edit command
                String parserInfo = ((Task) toRedo).getParserInfo();
                if (parserInfo.equals(COMMAND_WORD_ADD)) {
                    gStack.redoAdd();
                    model.addTask((Task) toRedo);
                    return new CommandResult(String.format(MESSAGE_SUCCESS, toRedo));
                } else if (parserInfo.equals(COMMAND_WORD_EDIT)) {
                    gStack.redoEdit();
                    model.updateTask(((Task) toRedo).getIndex(), (Task) toRedo);
                    return new CommandResult(String.format(MESSAGE_SUCCESS, toRedo));
                } else { //delete command
                    ReadOnlyTask unmutableTask = gStack.redoDelete();
                    model.deleteTask(unmutableTask);
                    return new CommandResult(String.format(MESSAGE_SUCCESS, toRedo));
                }
            } else {
                gStack.redoClear();
                model.resetData(new TaskManager());
                return new CommandResult(String.format(MESSAGE_SUCCESS, toRedo));
            }
        } catch (DuplicateTaskException e) {
            assert false : "not possible";
        } catch (TaskNotFoundException e) {
            assert false : "not possible";
        }
        assert false : "not possible";
        return null;
    }
}
```
###### \java\seedu\task\logic\commands\UncompleteCommand.java
``` java
package seedu.task.logic.commands;

import seedu.task.commons.core.Messages;
import seedu.task.commons.core.UnmodifiableObservableList;
import seedu.task.logic.commands.exceptions.CommandException;
import seedu.task.model.task.ReadOnlyTask;
import seedu.task.model.task.Task;
import seedu.task.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.task.model.task.UniqueTaskList.TaskNotFoundException;
public class UncompleteCommand extends Command {
    public static final String COMMAND_WORD = "uncomplete";

    public static final String MESSAGE_SUCCESS = "Task uncompleted: %1$s";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks the task as uncompleted, identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    private final int indexToUncomplete;

    public UncompleteCommand(int targetIndex) {
        indexToUncomplete = targetIndex;
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;

        UnmodifiableObservableList<ReadOnlyTask> list =
                (UnmodifiableObservableList<ReadOnlyTask>) model.getCompletedTaskList();

        if (list.size() < indexToUncomplete) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToUncomplete = list.get(indexToUncomplete - 1);
        Task task = new Task(taskToUncomplete);
        task.setParserInfo("uncomplete");
        try {
            model.uncompleteTask(task);
            return new CommandResult(String.format(MESSAGE_SUCCESS, task));
        } catch (DuplicateTaskException | TaskNotFoundException e) {
            assert false : "Not possible";
            throw new CommandException("Unable to uncomplete specified task");
        }
    }
}
```
###### \java\seedu\task\logic\commands\UndoCommand.java
``` java
package seedu.task.logic.commands;

import seedu.task.logic.GlobalStack;
import seedu.task.logic.commands.exceptions.CommandException;
import seedu.task.model.TaskManager;
import seedu.task.model.task.Task;
import seedu.task.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.task.model.task.UniqueTaskList.TaskNotFoundException;

public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";
    public static final String MESSAGE_SUCCESS = "Last action undone";
    public static final String MESSAGE_FAIL = "Failed to undo";
    public static final String COMMAND_WORD_ADD = "add";
    public static final String COMMAND_WORD_DELETE = "delete";
    public static final String COMMAND_WORD_EDIT = "edit";

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            GlobalStack gStack = GlobalStack.getInstance();
            if (gStack.getUndoStack().isEmpty()) {
                throw new CommandException(GlobalStack.MESSAGE_NOTHING_TO_UNDO);
            }
            Object toUndo = gStack.getUndoStack().peek(); //needs improvement
            gStack.printStack();
            if (toUndo.getClass() == Task.class) {
                String parserInfo = ((Task) toUndo).getParserInfo();
                System.out.println("Parser Info = " + parserInfo);
                if (parserInfo.equals(COMMAND_WORD_ADD)) {
                    gStack.undoAdd();
                    model.deleteTask((Task) toUndo);
                    return new CommandResult(String.format(MESSAGE_SUCCESS, toUndo));
                } else if (parserInfo.equals(COMMAND_WORD_EDIT)) {
                    gStack.undoEdit();
                    model.updateTask(((Task) toUndo).getIndex(), (Task) toUndo);
                    return new CommandResult(String.format(MESSAGE_SUCCESS, toUndo));
                } else if (parserInfo.equals(COMMAND_WORD_DELETE)) { // it'll be delete command
                    gStack.undoDelete(); // pushes task to redostack
                    /**Debugging purpose
                     * System.out.println("To be restored : " + toUndo.toString());
                     * System.out.println("Index to be restored" + ((Task) toUndo).getEditTaskIndex());
                    */
                    model.insertTasktoIndex(((Task) toUndo).getIndex(), (Task) toUndo);
                    return new CommandResult(String.format(MESSAGE_SUCCESS, toUndo));
                }
            } else {
                TaskManager undo = gStack.undoClear();
                //System.out.println(undo.toString());
                model.resetData(undo);
                return new CommandResult(String.format(MESSAGE_SUCCESS, toUndo));
            }
        } catch (TaskNotFoundException e) {
            assert false : "not possible";
        } catch (DuplicateTaskException e) {
            assert false : "not possible";
        }
        assert false : "not possible";
        return null;
    }
}
```
###### \java\seedu\task\logic\GlobalStack.java
``` java
package seedu.task.logic;

import java.util.NoSuchElementException;
import java.util.Stack;

import seedu.task.model.TaskManager;
import seedu.task.model.task.ReadOnlyTask;
import seedu.task.model.task.Task;

public class GlobalStack {

    private static GlobalStack instance = null;
    private Stack<Object> undoStack;
    private Stack<Object> redoStack;
    public static final String MESSAGE_NOTHING_TO_UNDO = "No commands left to undo";
    public static final String MESSAGE_NOTHING_TO_REDO = "No commands left to redo";

    private GlobalStack() {
        undoStack = new Stack<Object>();
        redoStack = new Stack<Object>();
    }

    public static GlobalStack getInstance() {
        if (instance == null) {
            instance = new GlobalStack();
        }
        return instance;
    }

    /*
     * Pre-condition : Top of stack contains 2 consecutive task objects to be popped
     * Usage : Undo Edit Command
     */
    public Task undoEdit() {
        Task originalTask = (Task) undoStack.pop();
        Task editedTask = (Task) undoStack.pop();
        redoStack.push(originalTask);
        redoStack.push(editedTask);
        return originalTask;
    }

    public Task redoEdit() {
        Task editedTask = (Task) redoStack.pop();
        Task originalTask = (Task) redoStack.pop();
        undoStack.push(editedTask);
        undoStack.push(originalTask);
        return editedTask;
    }

    /*
     * Pre-condition : Top of stack contains task object
     * Usage : Undo Add Command
     */
    public Task undoAdd() throws NoSuchElementException {
        try {
            Task temp = (Task) undoStack.pop();
            redoStack.push(temp);
            return temp;
        } catch (NoSuchElementException ne) {
            throw new NoSuchElementException(MESSAGE_NOTHING_TO_UNDO);
        }
    }

    public Task redoAdd() throws NoSuchElementException {
        try {
            Task temp = (Task) redoStack.pop();
            undoStack.push(temp);
            return temp;
        } catch (NoSuchElementException ne) {
            throw new NoSuchElementException(MESSAGE_NOTHING_TO_REDO);
        }
    }

    public ReadOnlyTask undoDelete() {
        ReadOnlyTask undoTask = (ReadOnlyTask) undoStack.pop();
        redoStack.push(undoTask);
        return undoTask;
    }

    public ReadOnlyTask redoDelete() {
        ReadOnlyTask redoTask = (ReadOnlyTask) redoStack.pop();
        undoStack.push(redoTask);
        return redoTask;
    }

    public TaskManager undoClear() {
        TaskManager toUndo = (TaskManager) undoStack.pop();
        redoStack.push(toUndo);
        return toUndo;
    }

    public void redoClear() {
        undoStack.push(redoStack.pop());
    }

    public Stack<Object> getUndoStack() {
        return undoStack;
    }

    public Stack<Object> getRedoStack() {
        return redoStack;
    }

    /** Debugging purpose */
    public void printStack () {
        @SuppressWarnings("unchecked")
        Stack<Object> temp = (Stack<Object>) undoStack.clone();
        for (int i = 0; i < temp.size(); i++) {
            System.out.println(temp.pop().toString());
        }
    }
}
```
###### \java\seedu\task\logic\Logic.java
``` java
    /** Returns the filtered list of completed tasks */
    ObservableList<ReadOnlyTask> getCompletedTaskList();
}
```
###### \java\seedu\task\logic\LogicManager.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getCompletedTaskList() {
        return model.getCompletedTaskList();
    }
}
```
###### \java\seedu\task\logic\parser\AddCommandParser.java
``` java
        try {
            String deadline = new String("");
            String priority = new String("");
            String info = new String("");
            if (argsTokenizer.getValue(PREFIX_DEADLINE).isPresent()) {
                deadline = argsTokenizer.getValue(PREFIX_DEADLINE).get();
            }
            if (argsTokenizer.getValue(PREFIX_PRIORITY_LEVEL).isPresent()) {
                priority = argsTokenizer.getValue(PREFIX_PRIORITY_LEVEL).get();
            }
            if (argsTokenizer.getValue(PREFIX_ANY_INFO).isPresent()) {
                info = argsTokenizer.getValue(PREFIX_ANY_INFO).get();
            }
```
###### \java\seedu\task\logic\parser\CompleteCommandParser.java
``` java
package seedu.task.logic.parser;

import static seedu.task.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Optional;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.CompleteCommand;
import seedu.task.logic.commands.IncorrectCommand;

public class CompleteCommandParser {

    public Command parse(String args) {
        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, CompleteCommand.MESSAGE_USAGE));
        }
        return new CompleteCommand(index.get());
    }
}
```
###### \java\seedu\task\logic\parser\DeleteCompleteCommandParser.java
``` java
public class DeleteCompleteCommandParser {

    public Command parse(String args) {

        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand (
                        String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCompleteCommand.MESSAGE_USAGE));
        }
        return new DeleteCompleteCommand(index.get());
    }
}
```
###### \java\seedu\task\logic\parser\Parser.java
``` java
        case UndoCommand.COMMAND_WORD:
            return new UndoCommand();

        case RedoCommand.COMMAND_WORD:
            return new RedoCommand();

        case CompleteCommand.COMMAND_WORD:
            return new CompleteCommandParser().parse(arguments);

        case UncompleteCommand.COMMAND_WORD:
            return new UncompleteCommandParser().parse(arguments);

        case DeleteCompleteCommand.COMMAND_WORD:
            return new DeleteCompleteCommandParser().parse(arguments);

```
###### \java\seedu\task\logic\parser\ParserUtil.java
``` java
    /* Returns String in format of hh:mm:ss
     * Precond: dateTime string formed by NattyParser required as input
     */
    public static String getTime(String dateTime) {
        StringTokenizer st = new StringTokenizer(dateTime);
        List<String> list = new ArrayList<String>();
        while (st.hasMoreTokens()) {
            list.add(st.nextToken());
        }
        System.out.println(list.get(3));
        return list.get(3);
    }
}
```
###### \java\seedu\task\logic\parser\UncompleteCommandParser.java
``` java
package seedu.task.logic.parser;

import static seedu.task.commons.core.Messages.MESSAGE_INVALID_COMMAND_FORMAT;

import java.util.Optional;

import seedu.task.logic.commands.Command;
import seedu.task.logic.commands.IncorrectCommand;
import seedu.task.logic.commands.UncompleteCommand;

public class UncompleteCommandParser {

    public Command parse(String args) {
        Optional<Integer> index = ParserUtil.parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                String.format(MESSAGE_INVALID_COMMAND_FORMAT, UncompleteCommand.MESSAGE_USAGE));
        }
        return new UncompleteCommand(index.get());
    }
}
```
###### \java\seedu\task\model\Model.java
``` java
    /** Adds an item into a specific index in the list of tasks*/
    void insertTasktoIndex(int index, Task task)
             throws UniqueTaskList.DuplicateTaskException;

    /** Replaces the current list of tasks with the specified list*/
    void loadList (ObservableList<ReadOnlyTask> list) throws DuplicateTaskException;
```
###### \java\seedu\task\model\Model.java
``` java
    /** Returns the filtered completed task list */
    UnmodifiableObservableList<ReadOnlyTask> getCompletedTaskList();

    /** Transfers the specified task to the completed task list section */
    void completeTask(Task t) throws DuplicateTaskException, TaskNotFoundException;

    void uncompleteTask(Task t) throws DuplicateTaskException, TaskNotFoundException;

```
###### \java\seedu\task\model\ModelManager.java
``` java
    @Override
    public void insertTasktoIndex(int indexToBeRestored, Task deletedTask)
            throws DuplicateTaskException {
        taskManager.addTaskToIndex(indexToBeRestored, deletedTask);
    }

    @Override
    public void loadList(ObservableList<ReadOnlyTask> list) throws DuplicateTaskException {
        taskManager.setTasks(list);
    }

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getCompletedTaskList() {
        return new UnmodifiableObservableList<>(completedTasks);
    }

    @Override
    public void completeTask(Task t) throws DuplicateTaskException, TaskNotFoundException {
        taskManager.transferTaskToComplete(t);
    }

    @Override
    public void uncompleteTask(Task t) throws DuplicateTaskException, TaskNotFoundException {
        taskManager.transferTaskFromComplete(t);
    }

    @Override
    public void deleteCompletedTask(ReadOnlyTask t) throws TaskNotFoundException {
        taskManager.deleteCompletedTask(t);
        indicateAddressBookChanged();
    }
```
###### \java\seedu\task\model\ReadOnlyTaskManager.java
``` java
    /**
     * Returns an unmodifiable view of the completed tasks list
     * This list will not contain any duplicate tasks.
     */
    ObservableList<ReadOnlyTask> getCompletedTaskList();

}
```
###### \java\seedu\task\model\task\Deadline.java
``` java
        if (date.equals("")) {
            this.value = date;
```
###### \java\seedu\task\model\task\PriorityLevel.java
``` java
        if (trimmedPriority.equals("")) {
            this.value = trimmedPriority;
```
###### \java\seedu\task\model\task\Task.java
``` java
    private String parserInfo;
    private int index;
```
###### \java\seedu\task\model\task\Task.java
``` java
    public void setParserInfo(String info) {
        this.parserInfo = info;
    }

    public String getParserInfo() {
        return this.parserInfo;
    }

    public void setIndex(int index) {
        this.index = index;
    }

    public int getIndex() {
        return this.index;
    }
```
###### \java\seedu\task\model\task\UniqueTaskList.java
``` java
    /**
     * Adds a task to the specified index in the list
     * @param index
     * @param toAdd
     */
    public void addToIndex(int index, Task toAdd) {
        assert toAdd != null;
        internalList.add(index, toAdd);
    }
```
###### \java\seedu\task\model\TaskManager.java
``` java
    public void setCompletedTasks(List<? extends ReadOnlyTask> completedTasks)
             throws UniqueTaskList.DuplicateTaskException {
        this.completedTasks.setTasks(completedTasks);
    }
```
###### \java\seedu\task\model\TaskManager.java
``` java
        try {
            setCompletedTasks(newData.getCompletedTaskList());
        } catch (UniqueTaskList.DuplicateTaskException e) {
            assert false : "Task Manager should not have duplicate tasks";
        }
```
###### \java\seedu\task\model\TaskManager.java
``` java
    /**
     * Transfers a task to from the main list to the completed list
     *
     * @param t
     * @throws TaskNotFoundException
     * @throws DuplicateTaskException
     */
    public void transferTaskToComplete(Task t) throws TaskNotFoundException, DuplicateTaskException {
        syncMasterTagListWith(t);
        tasks.remove(t);
        completedTasks.add(t);
    }

    /**
     * Transfer a task from completed list to main list
     * when user feels that he hasn't completed the task
     *
     * @param t
     * @throws TaskNotFoundException
     * @throws DuplicateTaskException
     */
    public void transferTaskFromComplete(Task t) throws TaskNotFoundException, DuplicateTaskException {
        syncMasterTagListWith(t);
        completedTasks.remove(t);
        tasks.add(t);
    }

    /**
     * Adds a task to the task manager at specified index
     * Adapted from addTask method
     *
     * @param index
     * @param t
     * @throws UniqueTaskList.DuplicateTaskException
     */
    public void addTaskToIndex (int index, Task t) throws UniqueTaskList.DuplicateTaskException {
        //syncMasterTagListWith(t);
        tasks.addToIndex(index, t);
    }

    public void deleteCompletedTask(ReadOnlyTask t) throws TaskNotFoundException {
        try {
            completedTasks.remove(t);
        } catch (TaskNotFoundException e) {
            throw new UniqueTaskList.TaskNotFoundException();
        }
    }
```
###### \java\seedu\task\model\TaskManager.java
``` java
    // Usage for undo/redo command
    public void loadTaskManagerList(UniqueTaskList tasks) {
        this.tasks.setTasks(tasks);
    }
```
###### \java\seedu\task\storage\XmlSerializableTaskManager.java
``` java
    @XmlElement
    private List<XmlAdaptedTask> completedTasks;
```
###### \java\seedu\task\storage\XmlSerializableTaskManager.java
``` java
        completedTasks.addAll((src.getCompletedTaskList().stream().map(XmlAdaptedTask::new))
                .collect(Collectors.toList()));
```
###### \java\seedu\task\storage\XmlSerializableTaskManager.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getCompletedTaskList() {
        final ObservableList<Task> tasks = this.completedTasks.stream().map(p -> {
            try {
                return p.toModelType();
            } catch (IllegalValueException e) {
                e.printStackTrace();
                //TODO: better error handling
                return null;
            }
        }).collect(Collectors.toCollection(FXCollections::observableArrayList));
        return new UnmodifiableObservableList<>(tasks);
    }
```
###### \java\seedu\task\ui\CompletedTaskList.java
``` java
/**
 * Panel containing list of tasks completed
 */
public class CompletedTaskList extends UiPart<Region> {
    private final Logger logger = LogsCenter.getLogger(CompletedTaskList.class);
    private static final String FXML = "CompletedTaskList.fxml";

    @FXML
    private ListView<ReadOnlyTask> completedTaskListView;

    public CompletedTaskList(AnchorPane completedTaskListPlaceHolder, ObservableList<ReadOnlyTask> taskList) {
        super(FXML);
        setConnections(taskList);
        addToPlaceholder(completedTaskListPlaceHolder);
    }

    private void setConnections(ObservableList<ReadOnlyTask> taskList) {
        completedTaskListView.setItems(taskList);
        completedTaskListView.setCellFactory(listView -> new TaskListViewCell());
        setEventHandlerForSelectionChangeEvent();
    }

    private void addToPlaceholder(AnchorPane completedTaskListPlaceHolder) {
        SplitPane.setResizableWithParent(completedTaskListPlaceHolder, false);
        FxViewUtil.applyAnchorBoundaryParameters(getRoot(), 0.0, 0.0, 0.0, 0.0);
        completedTaskListPlaceHolder.getChildren().add(getRoot());
    }

    private void setEventHandlerForSelectionChangeEvent() {
        completedTaskListView.getSelectionModel().selectedItemProperty()
                .addListener((observable, oldValue, newValue) -> {
                    if (newValue != null) {
                        logger.fine("Selection in task list panel changed to : '" + newValue + "'");
                        raise(new TaskPanelSelectionChangedEvent(newValue));
                    }
                });
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            completedTaskListView.scrollTo(index);
            completedTaskListView.getSelectionModel().clearAndSelect(index);
        });
    }

    class TaskListViewCell extends ListCell<ReadOnlyTask> {

        @Override
        protected void updateItem(ReadOnlyTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(new TaskCard(task, getIndex() + 1).getRoot());
            }
        }
    }
}
```
