# A0140063X
###### /java/seedu/task/commons/core/History.java
``` java
public class History {

    public static final int MAX_NUM_UNDO = 10;

    private static History instance;
    private int undoCount;
    private int redoCount;
    private String backupDirectory = "data/temp/";
    private final String backupFilePaths[] = {"backup0.xml", "backup1.xml", "backup2.xml", "backup3.xml", "backup4.xml",
        "backup5.xml", "backup6.xml", "backup7.xml", "backup8.xml", "backup9.xml", "backup10.xml"};
    private int currentFileIndex;

    public static History getInstance() {
        if (instance == null) {
            instance = new History();
        }
        return instance;
    }

    private History() {
        this.undoCount = 0;
        this.redoCount = 0;
        this.currentFileIndex = 0;
    }

    public int getUndoCount() {
        return undoCount;
    }

    private void increaseUndoCount() {
        if (this.undoCount < 10) {
            this.undoCount++;
        } else {
            this.undoCount = MAX_NUM_UNDO;
        }
    }

    private void decreaseUndoCount() {
        if (this.undoCount > 0) {
            this.undoCount--;
        } else {
            this.undoCount = 0;
        }
    }

    public int getRedoCount() {
        return redoCount;
    }

    private void increaseRedoCount() {
        if (this.redoCount < 10) {
            this.redoCount++;
        } else {
            this.redoCount = MAX_NUM_UNDO;
        }
    }

    private void decreaseRedoCount() {
        if (this.redoCount > 0) {
            this.redoCount--;
        } else {
            this.redoCount = 0;
        }
    }

    private void increaseCurrentFileIndex() {
        currentFileIndex = (currentFileIndex + 1) % (MAX_NUM_UNDO + 1);
    }

    private void decreaseCurrentFileIndex() {
        assert currentFileIndex >= 0;
        if (currentFileIndex == 0) {
            currentFileIndex = MAX_NUM_UNDO;
        } else {
            currentFileIndex--;
        }
    }

    /**
     * This method returns the filePath to save back up into. This is based on currentFileIndex.
     *
     * @return File path to back up into.
     */
    public String getBackupFilePath() {
        return backupDirectory + backupFilePaths[currentFileIndex];
    }

    /**
     * This method returns the filePath for undo to load from.
     * This method is only used when undo command is called, therefore undoCount must not be 0.
     * currentFileIndex must never be negative since it corresponds to a file.
     *
     * @return File path for undo to load from.
     */
    public String getUndoFilePath() {
        assert undoCount != 0;
        assert currentFileIndex >= 0;
        if (currentFileIndex == 0) {
            return backupDirectory + backupFilePaths[MAX_NUM_UNDO];
        } else {
            return backupDirectory + backupFilePaths[currentFileIndex - 1];
        }
    }

    /**
     * This method returns the filePath for redo to load from.
     * This method is only used when redo command is called, therefore redoCount must not be 0.
     *
     * @return File path for redo to load from.
     */
    public String getRedoFilePath() {
        assert redoCount != 0;
        if (currentFileIndex < MAX_NUM_UNDO) {
            return backupDirectory + backupFilePaths[currentFileIndex + 1];
        } else {
            return backupDirectory + backupFilePaths[0];
        }
    }

    /**
     * This method is called when a command that modifies taskmanager have been executed.
     * If backupFilePath is not empty, it means backup is done. Updates values to maintain proper status.
     *
     * @param backupFilePath    File path that backup was saved into.
     */
    public void handleTaskManagerChanged(String backupFilePath) {
        if (!backupFilePath.trim().equals("")) {
            increaseUndoCount();
            redoCount = 0;
            increaseCurrentFileIndex();
        }
    }

    /**
     * This method is called by UndoCommand and indicates that undo was successfully executed.
     * Updates the necessary values. undoCount must not be 0 since UndoCommand was successfully executed.
     */
    public void handleUndo() {
        assert undoCount != 0;
        decreaseUndoCount();
        increaseRedoCount();
        decreaseCurrentFileIndex();
    }

    /**
     * This method is called by RedoCommand and indicates that redo was successfully executed.
     * Updates the necessary values. redoCount must not be 0 since RedoCommand was successfully executed.
     */
    public void handleRedo() {
        assert redoCount != 0;
        decreaseRedoCount();
        increaseUndoCount();
        increaseCurrentFileIndex();
    }

    /**
     * This resets undoCount to 0. Used when an I/O error occurs.
     */
    public void resetUndoCount() {
        this.undoCount = 0;
    }

    /**
     * This resets redoCount to 0. Used when an I/O error occurs.
     */
    public void resetRedoCount() {
        this.redoCount = 0;
    }

    /**
     * This method is used for Junit testing only. Set up another directory for testing.
     *
     * @param backupDirectory   Directory for history to use.
     */
    public void test_setBackupDirectory(String backupDirectory) {
        this.backupDirectory = backupDirectory;
    }

    /**
     * This method is used for Junit testing only.
     * It resets the values of history class for separate tests.
     */
    public static History test_resetInstance() {
        instance = new History();
        return instance;
    }
}
```
###### /java/seedu/task/commons/events/model/TaskManagerChangedEvent.java
``` java
    public TaskManagerChangedEvent(ReadOnlyTaskManager data, String backupFilePath) {
        assert data != null;
        this.data = data;
        this.backupFilePath = backupFilePath;
    }

```
###### /java/seedu/task/logic/commands/AddCommand.java
``` java
    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name, String startDate, String endDate, String remark, String location, Set<String> tags)
            throws IllegalValueException {
        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        this.toAdd = new Task(
                new Name(name),
                new Date(startDate),
                new Date(endDate),
                new Remark(remark),
                new Location(location), new UniqueTagList(tagSet),
                false, "");
    }

```
###### /java/seedu/task/logic/commands/Command.java
``` java
    /**
     * Provides any needed dependencies to the command. Commands making use of any of these should override this method
     * to gain access to the dependencies.
     *
     * @param model     Model component of KIT.
     * @param storage   Storage component of KIT.
     */
    public void setData(Model model, Storage storage) {
        this.model = model;
        this.storage = storage;
    }

```
###### /java/seedu/task/logic/commands/Command.java
``` java
    /**
     * This method gets storage to read taskmanager data from the given filePath and returns the data back to caller.
     *
     * @param filePath      File path to read from.
     * @return              ReadOnlyTaskManager created from file.
     * @throws IOException  If file not found or unable to read.
     */
    protected ReadOnlyTaskManager readTaskManager(String filePath) throws IOException {
        assert storage != null;
        try {
            Optional<ReadOnlyTaskManager> taskManagerOptional = storage.readTaskManager(filePath);

            if (!taskManagerOptional.isPresent()) {
                throw new IOException("File not found.");
            }

            return taskManagerOptional.get();
        } catch (DataConversionException dce) {
            throw new IOException("Data conversion error.");
        } catch (IOException ioe) {
            throw new IOException("Unable to read from file.");
        }
    }

```
###### /java/seedu/task/logic/commands/Command.java
``` java
    /**
     * This method returns the task for the given index. CommandException is thrown if index is invalid.
     * Otherwise the correct task will be returned as a ReadOnlyTask.
     *
     * @param index     Index of desired task.
     * @return          Task that corresponds to index.
     * @throws CommandException     If index is invalid.
     */
    protected ReadOnlyTask getTaskFromIndex(int index) throws CommandException {
        assert model != null;
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (index >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        return lastShownList.get(index);
    }
}
```
###### /java/seedu/task/logic/commands/EditCommand.java
``` java
        public void setStartDate(Optional<Date> startDate) {
            this.startDate = startDate;
        }

```
###### /java/seedu/task/logic/commands/EditCommand.java
``` java
        public Optional<Date> getStartDate() {
            return startDate;
        }

```
###### /java/seedu/task/logic/commands/EditCommand.java
``` java
        public void setEndDate(Optional<Date> endDate) {
            this.endDate = endDate;
        }

```
###### /java/seedu/task/logic/commands/EditCommand.java
``` java
        public Optional<Date> getEndDate() {
            return endDate;
        }

```
###### /java/seedu/task/logic/commands/GetGoogleCalendarCommand.java
``` java
/**
 * Grabs upcoming events from google and save them as tasks.
 */
public class GetGoogleCalendarCommand extends Command {

    private static final Logger logger = LogsCenter.getLogger(LogsCenter.class);
    public static final String COMMAND_WORD_1 = "getgoogle";
    public static final String COMMAND_WORD_2 = "gg";
    public static final String MESSAGE_SUCCESS = "Upcoming events obtained from Google successfully!\n"
            + "Note that duplicate events or events without names are ignored.";
    public static final String MESSAGE_USAGE = COMMAND_WORD_2
            + ": Gets your events from your Google Calendar and add them to KIT."
            + " Please note that this will only get upcoming events and"
            + " duplicate events or events without names are ignored.\n" + "Example: " + COMMAND_WORD_2;

    @Override
    public CommandResult execute() {
        ArrayList<Task> tasks = new ArrayList<>();

        try {
            List<Event> events = getEventsFromGoogle();

            if (events.size() == 0) {
                return new CommandResult("No events found");
            }

            logger.info("Events retrieved from Google Calendar. Attempting to add.");
            for (Event event : events) {
                try {
                    tasks.add(LogicHelper.createTaskFromEvent(event));
                    logger.info("New event from google calendar sucessfully added.");
                } catch (IllegalValueException ive) {
                    logger.info(ive.getMessage());
                    // Continue to add next event even if one fails.
                }
            }
        } catch (IOException e) {
            return new CommandResult(GoogleCalendar.CONNECTION_FAIL_MESSAGE);
        }

        addMultipleTaskToModel(tasks);

        return new CommandResult(MESSAGE_SUCCESS);
    }

    /**
     * This method makes the query to google calendar and returns the list of events.
     * Will only get upcoming and non recurring events.
     *
     * @return List of obtained events.
     * @throws IOException  If connection failed.
     */
    private List<Event> getEventsFromGoogle() throws IOException {
        com.google.api.services.calendar.Calendar service = GoogleCalendar.getCalendarService();
        DateTime now = new DateTime(new java.util.Date());
        Events events = service.events().list(GoogleCalendar.CALENDAR_ID)
                .setTimeMin(now)
                .setSingleEvents(true)
                .execute();

        return events.getItems();
    }

    /**
     * This method adds the given list of tasks to model, sort and list them.
     *
     * @param tasks    The list of tasks to add.
     */
    private void addMultipleTaskToModel(ArrayList<Task> tasks) {
        assert model != null;
        model.addMultipleTasks(tasks);
        model.sortTaskList();
        model.updateFilteredListToShowAll();
    }
}
```
###### /java/seedu/task/logic/commands/PostGoogleCalendarCommand.java
``` java
/**
 * Post either selected or all task to Google Calendar.
 */
public class PostGoogleCalendarCommand extends Command {

    private static final Logger logger = LogsCenter.getLogger(LogsCenter.class);
    public static final int NO_INDEX = -1;
    public static final String COMMAND_WORD_1 = "postgoogle";
    public static final String COMMAND_WORD_2 = "pg";
    public static final String MESSAGE_SUCCESS = "Task posted: %1$s\n";
    public static final String MESSAGE_SUCCESS_MULTIPLE = "All eligible task in current listing posted.";
    public static final String MESSAGE_MISSING_DATE = "Both start and end dates are required"
            + " to post to Google Calendar";
    public static final String MESSAGE_ALREADY_POSTED = "Task already posted to Google Calendar";
    public static final String MESSAGE_USAGE = COMMAND_WORD_2 + ": Posts events to your Google Calendar.\n"
            + "Post the task identified by INDEX, if no index specified then posts all task in current listing.\n"
            + "If task have been posted before, it will update the event in Google Calendar.\n"
            + "Parameters: [INDEX]\n"
            + "Example: " + COMMAND_WORD_2;

    private final int filteredTaskListIndex;

    /**
     * Check if index was given and store the information.
     *
     * @param filteredTaskListIndex the index of the task in the filtered task list to post
     */
    public PostGoogleCalendarCommand(int filteredTaskListIndex) {
        if (filteredTaskListIndex == NO_INDEX) {
            this.filteredTaskListIndex = NO_INDEX;
        } else {
            this.filteredTaskListIndex = filteredTaskListIndex - 1;
        }
    }

    @Override
    public CommandResult execute() throws CommandException {
        if (filteredTaskListIndex == NO_INDEX) {
            try {
                postMultipleEvents();
            } catch (IOException ioe) {
                return new CommandResult(ioe.getMessage());
                //connection error will stop the command, otherwise tries to post all tasks.
            }

            return new CommandResult(MESSAGE_SUCCESS_MULTIPLE);
        } else {
            ReadOnlyTask taskToPost;
            try {
                taskToPost = postEvent(filteredTaskListIndex);
            } catch (IllegalValueException ive) {
                return new CommandResult(ive.getMessage());
            } catch (IOException ioe) {
                return new CommandResult(ioe.getMessage());
            } catch (TaskNotFoundException tnfe) {
                return new CommandResult(tnfe.getMessage());
            }

            return new CommandResult(String.format(MESSAGE_SUCCESS, taskToPost));
        }
    }

    /**
     * This method checks the number of event in the current listing and calls postEvent to post every event.
     *
     * @throws IOException  If connection failed.
     */
    private void postMultipleEvents() throws IOException {
        assert model != null;
        int max = model.getFilteredTaskList().size();

        for (int i = 0; i < max; i++) {
            try {
                postEvent(i);

            } catch (CommandException | TaskNotFoundException e) {
                logger.warning("Invalid index when posting multiple events to calendar. This should not happen!");
            } catch (IllegalValueException ive) {
                logger.info(ive.getMessage());
            }
            //continue to post next event even if one event fails
        }
    }

    /**
     * This method will post the task specified by index to Google Calendar as an event.
     * Any event posted to Google Calendar must have start and end dates.
     * Throw IllegalValueException if task do not have them.
     * If task is new, inserts a new event. Else update the corresponding event in Google Calendar.
     * Returns the posted task if operation successful.
     *
     * @param index         Index of task to post.
     * @return              Task that was posted.
     * @throws CommandException         If index is invalid.
     * @throws IllegalValueException    If either date is missing.
     * @throws IOException              If connection fails.
     * @throws TaskNotFoundException    If task is not found when updating eventId.
     */
    private ReadOnlyTask postEvent(int index) throws CommandException, IllegalValueException,
                                                    IOException, TaskNotFoundException {
        ReadOnlyTask taskToPost = getTaskFromIndex(index);

        if (taskToPost.getStartDate().isNull() || taskToPost.getEndDate().isNull()) {
            throw new IllegalValueException(MESSAGE_MISSING_DATE);
        }

        Event event = LogicHelper.createEventFromTask(taskToPost);

        try {
            com.google.api.services.calendar.Calendar service = GoogleCalendar.getCalendarService();

            //determine if insert or update by checking eventId.
            if (taskToPost.getEventId().trim().isEmpty()) {
                event = service.events().insert(GoogleCalendar.CALENDAR_ID, event).execute();
                setTaskEventId(taskToPost, event.getId());

                logger.info(String.format("Event created: %s\n", event.getHtmlLink()));
            } else {
                service.events().update(GoogleCalendar.CALENDAR_ID, event.getId(), event).execute();

                logger.info(String.format("Event updated: %s\n", event.getHtmlLink()));
            }
        } catch (IOException ioe) {
            logger.info("Failure due to " + ioe.getMessage());
            throw new IOException(GoogleCalendar.CONNECTION_FAIL_MESSAGE);
        }

        return taskToPost;
    }

    /**
     * This method sets the eventId of given task
     *
     * @param task      Task to edit.
     * @param eventId   EventId to change into.
     * @throws TaskNotFoundException    If task is not found in model.
     * @throws IllegalValueException    If eventId is not valid.
     */
    private void setTaskEventId(ReadOnlyTask task, String eventId)
            throws TaskNotFoundException, IllegalValueException {
        assert model != null;
        model.setTaskEventId(task, eventId);
    }

}
```
###### /java/seedu/task/logic/commands/RedoCommand.java
``` java
/**
 * Redo last undo.
 */
public class RedoCommand extends Command {

    public static final String COMMAND_WORD_1 = "redo";
    public static final String MESSAGE_SUCCESS = "Redo successful!";
    public static final String MESSAGE_FAIL_NOT_FOUND = "Unable to redo. Backup file not found.";
    public static final String MESSAGE_FAIL = "Nothing to redo. Already at latest state.";
    public static final String MESSAGE_USAGE = COMMAND_WORD_1
            + ": Redo the most recent undo.\n"
            + "Example: " + COMMAND_WORD_1;
    private History history = History.getInstance();

    @Override
    public CommandResult execute() {
        assert model != null;
        assert storage != null;

        //Check that redo call is valid.
        int redoCount = history.getRedoCount();
        if (redoCount <= 0) {
            return new CommandResult(MESSAGE_FAIL);
        }

        try {
            ReadOnlyTaskManager backupData = readTaskManager(history.getRedoFilePath());
            model.loadData(backupData);
        } catch (IOException io) {
            history.resetRedoCount();
            return new CommandResult(MESSAGE_FAIL_NOT_FOUND);
        } catch (IllegalValueException ive) {
            history.resetRedoCount();
            return new CommandResult(Task.MESSAGE_TASK_CONSTRAINTS);
        }

        history.handleRedo();
        return new CommandResult(MESSAGE_SUCCESS);
    }

}
```
###### /java/seedu/task/logic/commands/SmartAddCommand.java
``` java
    /**
     * Creates an SmartAddCommand using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     * @throws IOException if connection to google failed
     */
    public SmartAddCommand(String name, String remark, Set<String> tags)
            throws IllegalValueException, IOException {
        final Set<Tag> tagSet = new HashSet<>();

        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }

        try {
            this.toAdd = googleQuickAdd(name);
            toAdd.setTags(new UniqueTagList(tagSet));
            toAdd.setRemark(new Remark(remark));
        } catch (IOException ioe) {
            throw new IOException(GoogleCalendar.CONNECTION_FAIL_MESSAGE);
        }
    }

```
###### /java/seedu/task/logic/commands/SmartAddCommand.java
``` java
    /**
     * This method takes in the description string, creates and returns the corresponding task.
     * Requires Internet as it utilizes Google's Quick Add API. Throw IOException if otherwise.
     *
     * @param description   Query to send to Google.
     * @return              Task created from description.
     * @throws IOException              If connection fails.
     * @throws IllegalValueException    If created event has no name.
     */
    private Task googleQuickAdd(String description) throws IOException, IllegalValueException {
        com.google.api.services.calendar.Calendar service = GoogleCalendar.getCalendarService();
        Event createdEvent = service.events().quickAdd(GoogleCalendar.CALENDAR_ID, description).execute();
        service.events().delete(GoogleCalendar.CALENDAR_ID, createdEvent.getId()).execute();

        return LogicHelper.createTaskFromEvent(createdEvent);
    }

```
###### /java/seedu/task/logic/commands/UndoCommand.java
``` java
/**
 * Undo last task.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD_1 = "undo";
    public static final String COMMAND_WORD_2 = "uhoh";
    public static final String MESSAGE_SUCCESS = "Undo successful!";
    public static final String MESSAGE_FAIL_NOT_FOUND = "Unable to undo. Backup file not found.";
    public static final String MESSAGE_FAIL = "Unable to undo. Either max undo reached or nothing to undo.";
    public static final String MESSAGE_USAGE = COMMAND_WORD_1
            + ": Undo the most recent command that modifies the data. Commands like list,"
            + "find and findexact will not be affected.\n"
            + "Example: " + COMMAND_WORD_1;
    private History history = History.getInstance();

    @Override
    public CommandResult execute() {
        assert model != null;
        assert storage != null;

        //Check that undo call is valid.
        int undoCount = history.getUndoCount();
        if (undoCount <= 0) {
            return new CommandResult(MESSAGE_FAIL);
        }

        try {
            ReadOnlyTaskManager backupData = readTaskManager(history.getUndoFilePath());
            model.loadData(backupData);
        } catch (IOException io) {
            history.resetUndoCount();
            return new CommandResult(MESSAGE_FAIL_NOT_FOUND);
        } catch (IllegalValueException ive) {
            history.resetUndoCount();
            return new CommandResult(Task.MESSAGE_TASK_CONSTRAINTS);
        }

        history.handleUndo();
        return new CommandResult(MESSAGE_SUCCESS);
    }


}
```
###### /java/seedu/task/logic/LogicManager.java
``` java
    public LogicManager(Model model, Storage storage) {
        this.model = model;
        this.storage = storage;
        this.parser = new Parser();
    }

```
###### /java/seedu/task/logic/LogicManager.java
``` java
    @Override
    public CommandResult execute(String commandText) throws CommandException {
        logger.info("----------------[USER COMMAND][" + commandText + "]");
        Command command = parser.parseCommand(commandText);
        command.setData(model, storage);
        return command.execute();
    }

```
###### /java/seedu/task/logic/util/LogicHelper.java
``` java
public class LogicHelper {

    /**
     * This method returns a task from the given event. Name must not be empty, else IllegalValueException is thrown.
     *
     * @param event     Event to convert.
     * @return          Task that was converted.
     * @throws IllegalValueException    If event summary is empty.
     */
    public static Task createTaskFromEvent(Event event) throws IllegalValueException {
        assert event != null;

        if (event.getSummary() == null) {
            throw new IllegalValueException(Name.MESSAGE_NAME_CONSTRAINTS);
        }

        Name name = new Name(event.getSummary());
        Date startDate = new Date(event.getStart());
        Date endDate = new Date(event.getEnd());
        Remark remark = new Remark(event.getDescription());
        Location location = new Location(event.getLocation());
        final Set<Tag> tagSet = new HashSet<>();
        // No tags for event

        return new Task(name, startDate, endDate, remark, location, new UniqueTagList(tagSet), false, event.getId());
    }

    /**
     * This method returns an event for the given task. Task must have start and end date to be an event.
     *
     * @param task      Task to convert.
     * @return          Event that was converted.
     */
    public static Event createEventFromTask(ReadOnlyTask task) {
        assert task != null;
        assert task.getStartDate() != null;
        assert task.getEndDate() != null;

        Event event = new Event()
                .setSummary(task.getName().fullName)
                .setLocation(task.getLocation().value)
                .setDescription(task.getRemark().value);

        DateTime startDateTime = new DateTime(task.getStartDate().getDateValue());
        EventDateTime start = new EventDateTime()
                .setDateTime(startDateTime);
        event.setStart(start);

        DateTime endDateTime = new DateTime(task.getEndDate().getDateValue());
        EventDateTime end = new EventDateTime()
                .setDateTime(endDateTime);
        event.setEnd(end);

        event.setId(task.getEventId());

        return event;
    }
}
```
###### /java/seedu/task/MainApp.java
``` java
    /**
     * Initializes the History class. Also saves initial data into file.
     */
    private void initHistory() {
        this.history = History.getInstance();

        TaskManagerChangedEvent tmce = new TaskManagerChangedEvent(model.getTaskManager(), "");
        storage.handleTaskManagerChangedEvent(tmce);
    }

```
###### /java/seedu/task/model/Model.java
``` java
    /** Sets the eventId of task */
    void setTaskEventId(ReadOnlyTask target, String eventId) throws TaskNotFoundException, IllegalValueException;

```
###### /java/seedu/task/model/ModelManager.java
``` java
    /**
     * Resets data of taskManager.
     */
    @Override
    public void resetData(ReadOnlyTaskManager newData) throws IllegalValueException {
        taskManager.resetData(newData);
        indicateTaskManagerChanged(history.getBackupFilePath());
    }

```
###### /java/seedu/task/model/ModelManager.java
``` java
    /**
     * Load data into taskManager. Used by Undo/Redo Command.
     */
    @Override
    public void loadData(ReadOnlyTaskManager newData) throws IllegalValueException {
        taskManager.resetData(newData);
        raise(new TaskManagerChangedEvent(taskManager, history.getBackupFilePath()));
    }

```
###### /java/seedu/task/model/ModelManager.java
``` java
    /**
     *
     * @return taskManager of model.
     */
    @Override
    public ReadOnlyTaskManager getTaskManager() {
        return taskManager;
    }

```
###### /java/seedu/task/model/ModelManager.java
``` java
    /**
     * Raises an event to indicate the model has changed.
     *
     * @param backupFilePath
     *            File path to back up into.
     */
    private void indicateTaskManagerChanged(String backupFilePath) {
        history.handleTaskManagerChanged(backupFilePath);
        raise(new TaskManagerChangedEvent(taskManager, backupFilePath));
    }

```
###### /java/seedu/task/model/ModelManager.java
``` java
    /**
     *
     * @param target
     *            Target task to change.
     * @param eventId
     *            Event id to change into.
     */
    @Override
    public void setTaskEventId(ReadOnlyTask target, String eventId)
            throws TaskNotFoundException, IllegalValueException {
        taskManager.setTaskEventId(target, eventId);
        indicateTaskManagerChanged("");
    }

```
###### /java/seedu/task/model/ModelManager.java
``` java
    /**
     * This method adds every task in tasks to model.
     *
     * @param tasks
     *            ArrayList of task to add.
     */
    @Override
    public void addMultipleTasks(ArrayList<Task> tasks) {
        for (Task task : tasks) {
            try {
                taskManager.addTaskToFront(task);
            } catch (DuplicateTaskException e) {
                logger.info("Duplicate task " + task.getName() + " not added.");
            }
        }

        updateFilteredListToShowAll();
        indicateTaskManagerChanged(history.getBackupFilePath());
    }

```
###### /java/seedu/task/model/task/Date.java
``` java
    public Date() {
        this.value = null;
    }

```
###### /java/seedu/task/model/task/Date.java
``` java
    /**
     * Validates and creates date given a String.
     *
     * @param date  Date in String format.
     * @throws IllegalValueException If given date string is invalid.
     */
    public Date(String date) throws IllegalValueException {
        if (date == null || date.trim().equals("")) {
            this.value = null;

        } else {
            if (!isValidDate(date)) {
                throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS);
            }

            List<java.util.Date> dates = pretty.parse(date);

            // Ignore seconds
            Calendar cal = Calendar.getInstance();
            cal.setTime(dates.get(0));
            cal.set(Calendar.SECOND, 0);
            cal.set(Calendar.MILLISECOND, 0);
            long time = cal.getTimeInMillis();

            this.value = new java.util.Date(time);

            // used for find command
            extractedFrom = date;
        }
    }

```
###### /java/seedu/task/model/task/Date.java
``` java
    /**
     * Creates a Date object from given eventDateTime. Used for Google Calendar.
     *
     * @param eventDateTime    EventDateTime to convert from.
     */
    public Date(EventDateTime eventDateTime) {
        if (eventDateTime == null) {
            this.value = null;
            return;
        }

        // Event might not have time
        if (eventDateTime.getDateTime() != null) {
            this.value = new java.util.Date(eventDateTime.getDateTime().getValue());
        } else if (eventDateTime.getDate() != null) {
            this.value = new java.util.Date(eventDateTime.getDate().getValue());
        } else {
            this.value = null;
        }
    }

```
###### /java/seedu/task/model/task/Date.java
``` java
    /**
     *
     * @return  Date in java.util.Date format.
     */
    public java.util.Date getDateValue() {
        return this.value;
    }

```
###### /java/seedu/task/model/task/Date.java
``` java
    /**
     *
     * @return  True if value is null.
     */
    public boolean isNull() {
        return this.value == null;
    }

```
###### /java/seedu/task/model/task/Date.java
``` java
    /**
     * Returns true if a given string is a valid date.
     *
     * @param input     String to check.
     * @return          True if valid.
     */
    public static boolean isValidDate(String input) {
        List<java.util.Date> dates = pretty.parse(input);
        return !dates.isEmpty();
    }

```
###### /java/seedu/task/model/task/Date.java
``` java
    /**
     * Compares two dates and returns true if date1 is before date2
     *
     * @param date1     First Date to compare.
     * @param date2     Second Date to compare.
     * @return          True if date1 is before date2.
     */
    public static boolean isBefore(Date date1, Date date2) {
        return date1.value.before(date2.value);
    }

```
###### /java/seedu/task/model/task/Date.java
``` java
    /**
     * Display dates in this format: M/d/y h:mm a
     * Also adds relative time behind using PrettyTime display.
     *
     * @return Formatted date.
     */
    @Override
    public String toString() {
        if (value == null) {
            return new String("");
        }

        SimpleDateFormat displayFormat = new SimpleDateFormat("M/d/y h:mm a");
        PrettyTime pretty = new PrettyTime();
        return displayFormat.format(value) + ", " + pretty.format(value);
    }

```
###### /java/seedu/task/model/task/Date.java
``` java
    /**
     *
     * @return True if equals.
     */
    @Override
    public boolean equals(Object other) {
        Date otherDate = ((Date) other);

        if (otherDate.value == null && this.value == null) {
            return true;
        } else if (otherDate.value == null || this.value == null) {
            return false;
        }

        return other == this // short circuit if same object
                || (other instanceof Date // instanceof handles nulls
                        && this.value.equals(((Date) other).value)); // state
                                                                     // check
    }

```
###### /java/seedu/task/model/task/Task.java
``` java
    public void setStartDate(Date startDate) {
        assert startDate != null;
        this.startDate = startDate;
    }

```
###### /java/seedu/task/model/task/Task.java
``` java
    @Override
    public Date getStartDate() {
        return startDate;
    }

```
###### /java/seedu/task/model/task/Task.java
``` java
    public void setEndDate(Date endDate) {
        assert endDate != null;
        this.endDate = endDate;
    }

```
###### /java/seedu/task/model/task/Task.java
``` java
    @Override
    public Date getEndDate() {
        return endDate;
    }

```
###### /java/seedu/task/model/task/Task.java
``` java
    @Override
    public String getEventId() {
        return eventId;
    }

```
###### /java/seedu/task/model/task/Task.java
``` java
    /**
     *
     * @param eventId   Event Id to set.
     * @throws IllegalValueException    If eventId is invalid.
     */
    public void setEventId(String eventId) throws IllegalValueException {
        assert eventId != null && eventId.trim() != "";
        if (!isValidEventId(eventId)) {
            throw new IllegalValueException(MESSAGE_EVENTID_CONSTRAINTS);
        }
        this.eventId = eventId;
    }

```
###### /java/seedu/task/model/task/Task.java
``` java
    /**
     * Checks if eventId is valid
     *
     * @param eventId   Event Id to check.
     * @return          True if valid.
     */
    private boolean isValidEventId(String eventId) {
        if ((eventId.length() < 5) || (eventId.length() > 1024)) {
            return false;
        }

        return eventId.matches(EVENTID_VALIDATION_REGEX);
    }

```
###### /java/seedu/task/model/task/UniqueTaskList.java
``` java
    /**
     * Set target task's eventId.
     *
     * @param target    Target task to set.
     * @param eventId   Event Id to set.
     * @throws TaskNotFoundException    If Task is not found.
     * @throws IllegalValueException    If eventId is invalid.
     */
    public void setTaskEventId(ReadOnlyTask target, String eventId)
            throws TaskNotFoundException, IllegalValueException {
        assert target != null;

        if (!contains(target)) {
            throw new TaskNotFoundException();
        }

        int index = internalList.indexOf(target);

        Task task = internalList.get(index);
        task.setEventId(eventId);
        internalList.set(index, task);
    }

```
###### /java/seedu/task/model/TaskManager.java
``` java
    /**
     *
     * @param target    Target task to change.
     * @param eventId   Event id to change into.
     * @throws UniqueTaskList.TaskNotFoundException     If Task is not found.
     * @throws IllegalValueException                    If eventId is invalid.
     */
    public void setTaskEventId(ReadOnlyTask target, String eventId)
            throws UniqueTaskList.TaskNotFoundException, IllegalValueException {
        tasks.setTaskEventId(target, eventId);
    }

```
###### /java/seedu/task/storage/StorageManager.java
``` java
    /**
     * Saves backup into given backupFilePath.
     *
     * @param backupFilePath
     *            File path to back up into.
     * @throws IOException
     *             If input/output error.
     * @throws FileNotFoundException
     *             If file is not found.
     */
    @Override
    public void saveBackup(String backupFilePath) throws IOException, FileNotFoundException {
        logger.fine("Attempting to backup data from " + backupFilePath);
        taskManagerStorage.saveBackup(backupFilePath);
    }

```
###### /java/seedu/task/storage/StorageManager.java
``` java
    /**
     * Triggers whenever a command that modifies data is executed. Backup if required. Save data into file either way.
     *
     * @param event
     *            The event that represents taskmanager is changed.
     */
    @Override
    @Subscribe
    public void handleTaskManagerChangedEvent(TaskManagerChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event, "Local data changed, saving to file"));
        try {
            if (!event.backupFilePath.trim().equals("")) {
                saveBackup(event.backupFilePath);
            }
            saveTaskManager(event.data);
        } catch (IOException e) {
            raise(new DataSavingExceptionEvent(e));
        }
    }

```
###### /java/seedu/task/storage/XmlTaskManagerStorage.java
``` java
    /**
     * Reads from data and creates backup.
     *
     * @param backupFile Path           File path to back up into.
     * @throws IOException              If input/output error encountered.
     * @throws FileNotFoundException    If file is not found.
     */
    @Override
    public void saveBackup(String backupFilePath) throws IOException, FileNotFoundException {
        try {
            Optional<ReadOnlyTaskManager> optionalTaskManagerBackup = readTaskManager();
            ReadOnlyTaskManager taskManagerBackup;

            if (!optionalTaskManagerBackup.isPresent()) {
                throw new DataConversionException(null);
            }

            taskManagerBackup = optionalTaskManagerBackup.get();

            File file = new File(backupFilePath);
            FileUtil.createIfMissing(file);
            file.deleteOnExit();
            XmlFileStorage.saveDataToFile(file, new XmlSerializableTaskManager(taskManagerBackup));

        } catch (DataConversionException e) {
            logger.info("Data file not found. Unable to backup.");
        }
    }

}
```
###### /java/seedu/task/ui/BrowserPanel.java
``` java
    /**
     * Loads Google Calendar.
     */
    public void loadPage() {
        browser.getEngine().load("https://calendar.google.com/calendar/render#main_7%7Cmonth");
    }

```
###### /java/seedu/task/ui/StatusBarFooter.java
``` java
    /**
     * Displays last updated timing.
     *
     * @param tmce  TaskManagerChangedEvent that occurred.
     */
    @Subscribe
    public void handleTaskManagerChangedEvent(TaskManagerChangedEvent tmce) {
        PrettyTime pretty = new PrettyTime();
        Date now = new Date();
        String lastUpdated = (new Date()).toString() + ", " + pretty.format(now);
        logger.info(LogsCenter.getEventHandlingLogMessage(tmce, "Setting last updated status to " + lastUpdated));
        setSyncStatus("Last Updated: " + lastUpdated);
    }
}
```
