# A0139926R
###### \java\typetask\commons\core\Messages.java
``` java
    public static final String MESSAGE_INVALID_START_AND_END_DATE =
            "End date and time should not be before Start date and time";
    public static final String MESSAGE_INVALID_DATE_FORMAT_FOR_START_DATE = "Start date is invalid";
    public static final String MESSAGE_INVALID_DATE_FORMAT_FOR_END_DATE = "End date is invalid";
    public static final String MESSAGE_INVALID_DATE_FORMAT_FOR_DATE = "Deadline is invalid";

}
```
###### \java\typetask\logic\commands\AddCommand.java
``` java
/**
 * Adds a task to the TaskManager.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";
    public static final String COMMAND_WORD2 = "a";
    public static final String COMMAND_WORD3 = "+";
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Adds a task with or without date to the task list. \n"
            + "<> means compulsory [] means optional \n"
            + "Parameters: \"<NAME> by:[DATE][TIME]\"   "
            + "\"<NAME> from:[DATE][TIME] to: [DATE][TIME]\" \n"
            + "Example: " + COMMAND_WORD
            + " Read Harry Potter book 1 ";

```
###### \java\typetask\logic\commands\AddCommand.java
``` java
    /**
     * Creates an AddCommand using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    //Creates a Floating Task
    public AddCommand(String name, String priority)
            throws IllegalValueException {
        this.toAdd = new Task(new Name(name), new DueDate(""), new DueDate(""), false, new Priority(priority));
    }
    //Creates a Deadline Task
    public AddCommand(String name, String dateTime, String priority)
            throws IllegalValueException {
        this.toAdd = new Task(new Name(name), new DueDate(""), new DueDate(dateTime), false, new Priority(priority));
    }
    //Creates an Event
    public AddCommand(String name, String date, String endDate, String priority)
            throws IllegalValueException {
        this.toAdd = new Task(new Name(name), new DueDate(date), new DueDate(endDate), false, new Priority(priority));
    }

```
###### \java\typetask\logic\commands\AddCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        model.storeTaskManager(COMMAND_WORD);
        model.addTask(toAdd);
        //Shows the added task in the task list
        EventsCenter.getInstance().post(new JumpToListRequestEvent(model.getFilteredTaskListIndex(toAdd)));
        return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
    }

}
```
###### \java\typetask\logic\commands\EditCommand.java
``` java
/**
 * Edits the details of an existing task in the TaskManager.
 */
public class EditCommand extends Command {

    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Edits the details of the task identified "
            + "by the index number used in the last task listing. "
            + "Existing values will be overwritten by the input values.\n"
            + "Parameters: INDEX [NAME] [by:DATE] [@TIME] [from:DATE] [to:DATE]\n"
            + "Example: " + COMMAND_WORD + " 1 by: next week 11pm";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Task: %1$s";
    public static final String MESSAGE_NOT_EDITED = "At least one field to edit must be provided.";
    public static final String MESSAGE_INVALID_DATE = "Please check your dates again."
            + "Start date cannot be after End date. End date cannot be before Start date.";
    public static final String MESSAGE_MISSING_END_DATE = "There is no End date for the task."
            + "Please provide an End date as well.";

    private final int filteredTaskListIndex;
    private final EditTaskDescriptor editTaskDescriptor;

    /**
     * @param filteredTaskListIndex the index of the task in the filtered task list to edit
     * @param editTaskDescriptor details to edit the task with
     */
    public EditCommand(int filteredTaskListIndex, EditTaskDescriptor editTaskDescriptor) {
        assert filteredTaskListIndex > 0;
        assert editTaskDescriptor != null;

        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;

        this.editTaskDescriptor = new EditTaskDescriptor(editTaskDescriptor);
    }
```
###### \java\typetask\logic\commands\EditCommand.java
``` java
    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = lastShownList.get(filteredTaskListIndex);
        Task editedTask = createEditedTask(taskToEdit, editTaskDescriptor);
        //Checks for valid schedule after editing before updating taskManager
        if (!editedTask.getDate().value.equals("")) {
            if (editedTask.getEndDate().value.equals("")) {
                return new CommandResult(String.format(MESSAGE_MISSING_END_DATE));
            } else {
                List<Date> startDate = DateParser.parse(editedTask.getDate().value);
                List<Date> endDate = DateParser.parse(editedTask.getEndDate().value);
                if (!DateParser.isValidSchedule(startDate, endDate)) {
                    return new CommandResult(MESSAGE_INVALID_DATE);
                }
            }
        }
        model.storeTaskManager(COMMAND_WORD);
        model.updateTask(filteredTaskListIndex, editedTask);
        model.updateFilteredTaskList(false);
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
    }
```
###### \java\typetask\logic\commands\EditCommand.java
``` java
    /**
     * Creates and returns a {@code Task} with the details of {@code taskToEdit}
     * edited with {@code editTaskDescriptor}.
     */
    private static Task createEditedTask(ReadOnlyTask taskToEdit,
                                             EditTaskDescriptor editTaskDescriptor) {
        assert taskToEdit != null;

        Name updatedName = editTaskDescriptor.getName().orElseGet(taskToEdit::getName);
        DueDate updatedDate = editTaskDescriptor.getDate().orElseGet(taskToEdit::getDate);
        DueDate updatedEndDate = editTaskDescriptor.getEndDate().orElseGet(taskToEdit::getEndDate);
        Priority updatedPriority = editTaskDescriptor.getPriority().orElseGet(taskToEdit::getPriority);

        return new Task(updatedName, updatedDate, updatedEndDate, false, updatedPriority);
    }
```
###### \java\typetask\logic\commands\EditCommand.java
``` java
    /**
     * Stores the details to edit the task with. Each non-empty field value will replace the
     * corresponding field value of the task.
     */
    public static class EditTaskDescriptor {
        private Optional<Name> name = Optional.empty();
        private Optional<DueDate> date = Optional.empty();
        private Optional<DueDate> endDate = Optional.empty();
        private Optional<Priority> priority = Optional.empty();

        public EditTaskDescriptor() {}

        public EditTaskDescriptor(EditTaskDescriptor toCopy) {
            this.name = toCopy.getName();
            this.date = toCopy.getDate();
            this.endDate = toCopy.getEndDate();
            this.priority = toCopy.getPriority();
        }

        /**
         * Returns true if at least one field is edited.
         */
        public boolean isAnyFieldEdited() {
            return CollectionUtil.isAnyPresent(this.name, this.date,
                    this.endDate, this.priority);
        }

        public void setName(Optional<Name> name) {
            assert name != null;
            this.name = name;
        }

        public Optional<Name> getName() {
            return name;
        }

        public void setDate(Optional<DueDate> date) {
            assert date != null;
            this.date = date;
        }
        public void setEndDate(Optional<DueDate> endDate) {
            assert endDate != null;
            this.endDate = endDate;
        }

        public Optional<DueDate> getDate() {
            return date;
        }
        public Optional<DueDate> getEndDate() {
            return endDate;
        }
        //author A0144902L
        public void setPriority(Optional<Priority> priority) {
            assert priority != null;
            this.priority = priority;
        }

        public Optional<Priority> getPriority() {
            return priority;
        }

    }
}
```
###### \java\typetask\logic\commands\FindCommand.java
``` java
/**
 * Finds and lists all tasks in TaskManager whose name contains any of the argument keywords.
 * Keyword matching is case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";
    public static final String COMMAND_WORD2 = "search";
    public static final String COMMAND_WORD3 = "f";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks whose names contain any of "
            + "the specified keywords (case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n"
            + "Example: " + COMMAND_WORD + " alice bob charlie";

    private final Set<String> keywords;
    private String keywordsContainDate = "";

    public FindCommand(Set<String> keywords, String keywordsContainDate) {
        this.keywords = keywords;
        this.keywordsContainDate = keywordsContainDate;
    }

    @Override
    public CommandResult execute() {
        if (keywordsContainDate.equals("")) {
            model.updateFilteredTaskList(keywords);
        } else {
            model.updateFilteredTaskList(keywordsContainDate);
        }
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

}
```
###### \java\typetask\logic\commands\RedoCommand.java
``` java
/**
 * Redo recent command entered.
 */
public class RedoCommand extends Command {
    public static final String COMMAND_WORD = "redo";
    public static final String COMMAND_WORD_SHORT = "r";
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Redo a command that was previously undone." + "Example: "
            + COMMAND_WORD;
    public static final String MESSAGE_SUCCESS = "Redo previous command.";
    public static final String MESSAGE_FAILURE = "There is no command to redo.";

    private static final int STATUS_EMPTY_HISTORY = 0;

    @Override
    /**
     * Returns failure if there is no undo command executed before, otherwise returns true
     */
    public CommandResult execute() {
        switch (model.revertTaskManager()) {
        case STATUS_EMPTY_HISTORY:
            return new CommandResult(MESSAGE_FAILURE);
        default:
            return new CommandResult(MESSAGE_SUCCESS);
        }
    }
}
```
###### \java\typetask\logic\commands\RemoveDeadlineCommand.java
``` java
/**
 * Remove all the date and time for a task
 */
public class RemoveDeadlineCommand extends Command {

    public static final String COMMAND_WORD = "removedeadline";
    public static final String COMMAND_WORD_SHORT = "rd";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Removes the deadline of the task identified "
            + "by the index number used in the last task listing. "
            + "Parameters: INDEX \n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Task: %1$s";
    private final int filteredTaskListIndex;

    public RemoveDeadlineCommand(int filteredTaskListIndex) {
        assert filteredTaskListIndex > 0;

        // converts filteredTaskListIndex from one-based to zero-based.
        this.filteredTaskListIndex = filteredTaskListIndex - 1;

    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (filteredTaskListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        ReadOnlyTask taskToEdit = lastShownList.get(filteredTaskListIndex);
        Task editedTask = createEditedTask(taskToEdit);
        model.storeTaskManager(COMMAND_WORD);
        model.updateTask(filteredTaskListIndex, editedTask);
        model.updateFilteredTaskList(false);
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
    }

    private static Task createEditedTask(ReadOnlyTask taskToEdit) {
        assert taskToEdit != null;

        Name updatedName = taskToEdit.getName();
        DueDate updatedDate = taskToEdit.getDate();
        DueDate updatedEndDate = taskToEdit.getEndDate();
        Priority updatedPriority = taskToEdit.getPriority();
        //Accepts empty String for DueDate and will not lead to exception
        try {
            updatedDate = new DueDate("");
            updatedEndDate = new DueDate("");
        } catch (IllegalValueException e) {
        }
        return new Task(updatedName, updatedDate, updatedEndDate, false, updatedPriority);
    }
}
```
###### \java\typetask\logic\commands\UndoCommand.java
``` java
/**
 * Undo recent command entered.
 * Undo commands that makes modification to data
 * E.g add,delete,edit,clear,done
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";
    public static final String COMMAND_WORD_SHORT = "u";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undo the most recent command." + "\n\nExample: "
            + COMMAND_WORD;
    public static final String MESSAGE_SUCCESS = "Restored previous command.";
    public static final String MESSAGE_FAILURE = "No previous command to undo";

    private static final int STATUS_EMPTY_HISTORY = 0;

    /**
     * Returns failure if there is no command executed before
     * Returns success if a command is found to be executed before this command
     */
    @Override
    public CommandResult execute() {
        switch (model.restoreTaskManager()) {
        case STATUS_EMPTY_HISTORY:
            return new CommandResult(MESSAGE_FAILURE);
        default:
            return new CommandResult(MESSAGE_SUCCESS);
        }
    }
}
```
###### \java\typetask\logic\parser\AddCommandParser.java
``` java
/**
 * Parses input arguments and creates a new AddCommand object
 */
public class AddCommandParser {
    private final int floatingTask = 0;
    private final int deadlineTaskWithTime = 1;
    private final int deadlineTaskWithDate = 2;
    private final int eventTask = 3;
    private final int invalidEvent = 4;
    /**
     * Parses the given {@code String} of arguments in the context of the AddCommand
     * and returns an AddCommand object for execution.
     */
    public Command parse(String args) {
        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer(PREFIX_DATE, PREFIX_TIME, PREFIX_START_DATE, PREFIX_END_DATE, PREFIX_PRIORITY);
        argsTokenizer.tokenize(args);
        try {
            int taskType = checkTaskType(argsTokenizer);
            return getCorrectAddCommand(argsTokenizer, taskType);

        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }
    private Command getCorrectAddCommand(ArgumentTokenizer argsTokenizer, int taskType) throws IllegalValueException {
        if (taskType == eventTask) {
            return getCommandForEventTask(argsTokenizer);
        } else if (taskType == deadlineTaskWithDate) {
            return getCommandForDeadlineWithDate(argsTokenizer);
        } else if (taskType == deadlineTaskWithTime) {
            return getCommandForDeadlineWithTime(argsTokenizer);
        } else if (taskType == invalidEvent) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        } else {
            return getCommandForFloatingTask(argsTokenizer);
        }
    }
    private Command getCommandForFloatingTask(ArgumentTokenizer argsTokenizer) throws IllegalValueException {
        String priority = "Low";
        if (argsTokenizer.getValue(PREFIX_PRIORITY).isPresent())  {
            priority = argsTokenizer.getValue(PREFIX_PRIORITY).get();
        }
        return new AddCommand(
                argsTokenizer.getPreamble().get(), priority
                );
    }
    private Command getCommandForDeadlineWithTime(ArgumentTokenizer argsTokenizer) throws IllegalValueException {
        List<Date> deadline = DateParser.getDate(argsTokenizer.getValue(PREFIX_TIME).get());
        String priority = "Low";
        if (!DateParser.isValidDateFormat(deadline)) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_DATE_FORMAT_FOR_DATE));
        }
        if (argsTokenizer.getValue(PREFIX_PRIORITY).isPresent())  {
            priority = argsTokenizer.getValue(PREFIX_PRIORITY).get();
        }
        return new AddCommand(
                argsTokenizer.getPreamble().get(),
                DateParser.getDateString(deadline), priority
                );
    }
    private Command getCommandForDeadlineWithDate(ArgumentTokenizer argsTokenizer) throws IllegalValueException {
        List<Date> deadline = DateParser.getDate(argsTokenizer.getValue(PREFIX_DATE).get());
        String priority = "Low";
        if (!DateParser.isValidDateFormat(deadline)) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_DATE_FORMAT_FOR_DATE));
        }
        if (argsTokenizer.getValue(PREFIX_PRIORITY).isPresent())  {
            priority = argsTokenizer.getValue(PREFIX_PRIORITY).get();
        }
        if (argsTokenizer.getValue(PREFIX_PRIORITY).isPresent())  {
            priority = argsTokenizer.getValue(PREFIX_PRIORITY).get();
        }
        return new AddCommand(
                argsTokenizer.getPreamble().get(),
                DateParser.getDateString(deadline), priority
                );
    }
    private Command getCommandForEventTask(ArgumentTokenizer argsTokenizer) throws IllegalValueException {
        List<Date> startDate = DateParser.getDate(argsTokenizer.getValue(PREFIX_START_DATE).get());
        List<Date> endDate = DateParser.getDate(argsTokenizer.getValue(PREFIX_END_DATE).get());
        String priority = "Low";
        if (!DateParser.isValidDateFormat(startDate)) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_DATE_FORMAT_FOR_START_DATE));
        }
        if (!DateParser.isValidDateFormat(endDate)) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_DATE_FORMAT_FOR_END_DATE));
        }
        if (argsTokenizer.getValue(PREFIX_PRIORITY).isPresent())  {
            priority = argsTokenizer.getValue(PREFIX_PRIORITY).get();
        }
        if (DateParser.isValidSchedule(startDate, endDate)) {
            return new AddCommand(
                    argsTokenizer.getPreamble().get(),
                    DateParser.getDateString(startDate),
                    DateParser.getDateString(endDate), priority
                    );
        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_START_AND_END_DATE));
        }
    }
```
###### \java\typetask\logic\parser\AddCommandParser.java
``` java
    public int checkTaskType(ArgumentTokenizer argsTokenizer) {
        if (argsTokenizer.getValue(PREFIX_START_DATE).isPresent() &&
                argsTokenizer.getValue(PREFIX_END_DATE).isPresent()) {
            return eventTask;
        } else if (argsTokenizer.getValue(PREFIX_START_DATE).isPresent() ||
                argsTokenizer.getValue(PREFIX_END_DATE).isPresent()) {
            return invalidEvent;
        } else if (argsTokenizer.getValue(PREFIX_DATE).isPresent() &&
                argsTokenizer.getValue(PREFIX_TIME).isPresent()) {
            return invalidEvent;
        } else if (argsTokenizer.getValue(PREFIX_DATE).isPresent()) {
            return deadlineTaskWithDate;
        } else if (argsTokenizer.getValue(PREFIX_TIME).isPresent()) {
            return deadlineTaskWithTime;
        } else {
            return floatingTask;
        }
    }

}
```
###### \java\typetask\logic\parser\CliSyntax.java
``` java
/**
 * Contains Command Line Interface (CLI) syntax definitions common to multiple commands
 */
public class CliSyntax {

    /* Prefix definitions */
    public static final Prefix PREFIX_DATE = new Prefix("by:");
    public static final Prefix PREFIX_TIME = new Prefix("@");
    public static final Prefix PREFIX_START_DATE = new Prefix("from:");
    public static final Prefix PREFIX_END_DATE = new Prefix("to:");
```
###### \java\typetask\logic\parser\DateParser.java
``` java
/**
 * Parser class for handling date and time using the
 * Natty library.
 * @author Abel
 *
 */
public class DateParser {

    private static final int day = 0;
    private static final int month = 1;
    private static final int dayDate = 2;
    private static final int time = 3;
    private static final int year = 5;
    private static final int dateFromUser = 0;
    /**
     * Private constructor to prevent instantiation.
     */
    private DateParser() {
    }

    /**
     * Parses given date and time string and returns
     * an array of date time that we are interested in capturing.
     * Usually start and end dates or just deadline date.
     * If no dates are found, empty list is returned.
     * @param dateTimeString String containing date and time to be parsed.
     * @return A list of Dates found in String.
     */
    public static List<Date> parse(String dateTimeString) {
        assert dateTimeString != null && !dateTimeString.isEmpty();
        Parser parser = new Parser(TimeZone.getDefault());
        List<DateGroup> groups = parser.parse(dateTimeString);
        if (groups.isEmpty() || groups.get(0) == null) {
            return new ArrayList<>();
        }


        DateGroup group = groups.get(dateFromUser);
        List<Date> dates = group.getDates();

        // If time is inferred and not explicitly stated by user
        // Reset time because it would produce the current time
        boolean isTimeInferred = group.isTimeInferred();
        if (isTimeInferred) {
            resetTime(dates);
        }

        return dates;
    }

    /**
     * Resets the time fields in the list of dates to zeroes.
     * @param dates List of dates to be reset.
     */
    private static void resetTime(List<Date> dates) {
        if (dates == null) {
            return;
        }

        for (Date date: dates) {
            Calendar calendar = Calendar.getInstance();
            calendar.setTime(date);
            calendar.set(Calendar.HOUR_OF_DAY, 23);
            calendar.set(Calendar.MINUTE, 59);
            calendar.set(Calendar.SECOND, 59);
            calendar.set(Calendar.MILLISECOND, 0);
            date.setTime(calendar.getTime().getTime());
        }
    }
```
###### \java\typetask\logic\parser\DateParser.java
``` java
    /**
     * Uses @param date to get date and time
     * @return list of dates
     */
    public static List<Date> getDate(String date) {
        assert date != null;
        List<Date> dates = DateParser.parse(date);
        return dates;
    }
    /**
     * Gets the list of dates from @param dates
     * @return date in String format
     */
    public static String getDateString(List<Date> dates) {
        String finalizedDate;
        String nattyDate = dates.get(dateFromUser).toString();
        String[] splitDate = nattyDate.split(" ");
        finalizedDate = splitDate[day] + " " + splitDate[month] + " " + splitDate[dayDate] +
                " " + splitDate[year] + " " + splitDate[time];
        return finalizedDate;
    }
    /**
     * Compares @param startDate and @param endDate
     * Checks event schedule
     * Checks only if there is a startDate and endDate
     * @return true if endDate is not before startDate, otherwise false
     */
    public static boolean isValidSchedule(List<Date> startDate, List<Date> endDate) {
        boolean isValidDate = false;
        if (!startDate.isEmpty() && !endDate.isEmpty()) {
            Date sDate = startDate.get(dateFromUser);
            Date eDate = endDate.get(dateFromUser);
            isValidDate = isValidEventDate(sDate, eDate);
        }
        return isValidDate;
    }
    /**
     * Compares @param startDate and @param endDate
     * @return true if endDate is not before startDate, otherwise false
     */
    public static boolean isValidEventDate(Date startDate, Date endDate) {
        boolean isValidDate = false;
        if (startDate.before(endDate)) {
            isValidDate = true;
        }
        return isValidDate;
    }
    /**
     * Checks @param date if the list of dates is empty or not
     * @return true if there is a date in the list
     */
    public static boolean isValidDateFormat(List<Date> date) {
        boolean isValidDate = false;
        if (!date.isEmpty()) {
            isValidDate = true;
        }
        return isValidDate;
    }

}
```
###### \java\typetask\logic\parser\EditCommandParser.java
``` java
/**
 * Parses input arguments and creates a new EditCommand object
 */
public class EditCommandParser {

    private static final int day = 0;
    private static final int month = 1;
    private static final int dayDate = 2;
    private static final int time = 3;
    private static final int year = 5;
    /**
     * Parses the given {@code String} of arguments in the context of the EditCommand
     * and returns an EditCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;
        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer(PREFIX_DATE, PREFIX_TIME, PREFIX_START_DATE,
                        PREFIX_END_DATE, PREFIX_PRIORITY);
        argsTokenizer.tokenize(args);
        List<Optional<String>> preambleFields = ParserUtil.splitPreamble(argsTokenizer.getPreamble().orElse(""), 2);

        Optional<Integer> index = preambleFields.get(0).flatMap(ParserUtil::parseIndex);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, EditCommand.MESSAGE_USAGE));
        }

        return updateEditTaskDescriptor(argsTokenizer, preambleFields, index);
    }

    private Command updateEditTaskDescriptor(ArgumentTokenizer argsTokenizer, List<Optional<String>> preambleFields,
            Optional<Integer> index) {
        EditTaskDescriptor editTaskDescriptor = new EditTaskDescriptor();
        List<Date> endDateList;
        List<Date> startDateList;
        List<Date> timeList;
        List<Date> dateList;
        try {
            editTaskDescriptor.setName(ParserUtil.parseName(preambleFields.get(1)));
            //Checks for valid deadline. If valid, store new deadline for editing
            if (argsTokenizer.getValue(PREFIX_DATE).isPresent()) {
                dateList = DateParser.parse(argsTokenizer.getValue(PREFIX_DATE).get());
                if (!DateParser.isValidDateFormat(dateList)) {
                    return new IncorrectCommand(Messages.MESSAGE_INVALID_DATE_FORMAT_FOR_DATE);
                }
                setDeadlineWithDate(argsTokenizer, editTaskDescriptor);
            }
            //Checks for valid deadline. If valid, store new deadline for editing
            if (argsTokenizer.getValue(PREFIX_TIME).isPresent()) {
                timeList = DateParser.parse(argsTokenizer.getValue(PREFIX_TIME).get());
                if (!DateParser.isValidDateFormat(timeList)) {
                    return new IncorrectCommand(Messages.MESSAGE_INVALID_DATE_FORMAT_FOR_DATE);
                }
                setDeadlineWithTime(argsTokenizer, editTaskDescriptor);
            }
            //Checks for valid start date. If valid, store new start date for editing
            if (argsTokenizer.getValue(PREFIX_START_DATE).isPresent()) {
                startDateList = DateParser.parse(argsTokenizer.getValue(PREFIX_START_DATE).get());
                if (!DateParser.isValidDateFormat(startDateList)) {
                    return new IncorrectCommand(Messages.MESSAGE_INVALID_DATE_FORMAT_FOR_START_DATE);
                }
                setStartDate(argsTokenizer, editTaskDescriptor);
            }
            //Checks for valid end date. If valid, store new end date for editing
            if (argsTokenizer.getValue(PREFIX_END_DATE).isPresent()) {
                endDateList = DateParser.parse(argsTokenizer.getValue(PREFIX_END_DATE).get());
                if (!DateParser.isValidDateFormat(endDateList)) {
                    return new IncorrectCommand(Messages.MESSAGE_INVALID_DATE_FORMAT_FOR_END_DATE);
                }
                setEndDate(argsTokenizer, editTaskDescriptor);
            }
            //Checks for valid schedule
            if (argsTokenizer.getValue(PREFIX_START_DATE).isPresent() &&
                    argsTokenizer.getValue(PREFIX_END_DATE).isPresent()) {
                startDateList = DateParser.parse(argsTokenizer.getValue(PREFIX_START_DATE).get());
                endDateList = DateParser.parse(argsTokenizer.getValue(PREFIX_END_DATE).get());
                if (!DateParser.isValidSchedule(startDateList, endDateList)) {
                    return new IncorrectCommand(Messages.MESSAGE_INVALID_START_AND_END_DATE);
                }
            }
            if (argsTokenizer.getValue(PREFIX_PRIORITY).isPresent()) {
                editTaskDescriptor.setPriority(ParserUtil.parsePriority(argsTokenizer.getValue(PREFIX_PRIORITY)));
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }

        if (!editTaskDescriptor.isAnyFieldEdited()) {
            return new IncorrectCommand(EditCommand.MESSAGE_NOT_EDITED);
        }

        return new EditCommand(index.get(), editTaskDescriptor);
    }

    private void setEndDate(ArgumentTokenizer argsTokenizer, EditTaskDescriptor editTaskDescriptor)
            throws IllegalValueException {
        Optional<String> parseDate = Optional.of(getDate(argsTokenizer.getValue(PREFIX_END_DATE).get()));
        editTaskDescriptor.setEndDate(ParserUtil.parseDate(parseDate));
    }

    private void setStartDate(ArgumentTokenizer argsTokenizer, EditTaskDescriptor editTaskDescriptor)
            throws IllegalValueException {
        Optional<String> parseDate = Optional.of(getDate(argsTokenizer.getValue(PREFIX_START_DATE).get()));
        editTaskDescriptor.setDate(ParserUtil.parseDate(parseDate));
    }

    private void setDeadlineWithTime(ArgumentTokenizer argsTokenizer, EditTaskDescriptor editTaskDescriptor)
            throws IllegalValueException {
        Optional<String> parseDate = Optional.of(getDate(argsTokenizer.getValue(PREFIX_TIME).get()));
        Optional<String> emptyString = Optional.of("");
        editTaskDescriptor.setEndDate(ParserUtil.parseDate(parseDate));
        editTaskDescriptor.setDate(ParserUtil.parseDate(emptyString));
    }

    private void setDeadlineWithDate(ArgumentTokenizer argsTokenizer, EditTaskDescriptor editTaskDescriptor)
            throws IllegalValueException {
        Optional<String> parseDate = Optional.of(getDate(argsTokenizer.getValue(PREFIX_DATE).get()));
        Optional<String> emptyString = Optional.of("");
        editTaskDescriptor.setEndDate(ParserUtil.parseDate(parseDate));
        editTaskDescriptor.setDate(ParserUtil.parseDate(emptyString));
    }

```
###### \java\typetask\logic\parser\EditCommandParser.java
``` java
    public String getDate(String date) {
        assert date != "";
        List<Date> dates = DateParser.parse(date);
        String nattyDate = dates.get(0).toString();
        String[] splitDate = nattyDate.split(" ");
        String finalizedDate = splitDate[day] + " " + splitDate[month] + " " + splitDate[dayDate] +
                " " + splitDate[year] + " " + splitDate[time];
        return finalizedDate;
    }

}
```
###### \java\typetask\logic\parser\FindCommandParser.java
``` java
/**
 * Parses input arguments and creates a new FindCommand object
 */
public class FindCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the FindCommand
     * and returns an FindCommand object for execution.
     */
    public Command parse(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindCommand.MESSAGE_USAGE));
        }
        //checks if keyword contains potential dates
        List<Date> listOfDates = DateParser.parse(args);
        String wantedDate = "";
        if (DateParser.isValidDateFormat(listOfDates)) {
            wantedDate = DateParser.getDateString(listOfDates);
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindCommand(keywordSet, wantedDate);
    }

}
```
###### \java\typetask\logic\parser\Parser.java
``` java
        case UndoCommand.COMMAND_WORD:
            return new UndoCommandParser().parse();
        case UndoCommand.COMMAND_WORD_SHORT:
            return new UndoCommandParser().parse();

        case RedoCommand.COMMAND_WORD:
            return new RedoCommandParser().parse();
        case RedoCommand.COMMAND_WORD_SHORT:
            return new RedoCommandParser().parse();

        case RemoveDeadlineCommand.COMMAND_WORD:
            return new RemoveDeadlineCommandParser().parse(arguments);
        case RemoveDeadlineCommand.COMMAND_WORD_SHORT:
            return new RemoveDeadlineCommandParser().parse(arguments);

        default:
            return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
        }
    }

}
```
###### \java\typetask\logic\parser\RedoCommandParser.java
``` java
/**
 * Creates a new RedoCommand object
 */
public class RedoCommandParser {

    public Command parse() {
        return new RedoCommand();
    }
}
```
###### \java\typetask\logic\parser\RemoveDeadlineCommandParser.java
``` java
/**
 * Parses input arguments and creates a new RemoveDeadlineCommand object
 */
public class RemoveDeadlineCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the EditCommand
     * and returns an RemoveDeadlineCommand object for execution.
     */
    public Command parse(String args) {
        assert args != null;
        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer();
        argsTokenizer.tokenize(args);
        List<Optional<String>> preambleFields = ParserUtil.splitPreamble(argsTokenizer.getPreamble().orElse(""), 2);

        Optional<Integer> index = preambleFields.get(0).flatMap(ParserUtil::parseIndex);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    RemoveDeadlineCommand.MESSAGE_USAGE));
        }

        return new RemoveDeadlineCommand(index.get());
    }
}
```
###### \java\typetask\logic\parser\UndoCommandParser.java
``` java
/**
 * Creates a new UndoCommand object
 */
public class UndoCommandParser {

    public Command parse() {
        return new UndoCommand();
    }
}
```
###### \java\typetask\model\Model.java
``` java
    /** Retrieves the tasks with similar date */
    void updateFilteredTaskList(String date);

    /** Stores current TaskManager state */
    void storeTaskManager(String command);

    /** Restores most recently stored TaskManager state */
    int restoreTaskManager();

    /** Undo most recently restored TaskManager state */
    int revertTaskManager();

    /** Removes most recently stored TaskManager state upon fail in check */
    void rollBackTaskManager(boolean isStorageOperation);

    /** Retrieves the index for task */
    int getFilteredTaskListIndex(ReadOnlyTask targetTask);

}
```
###### \java\typetask\model\ModelManager.java
``` java
    private Stack<TaskManager> taskManagerHistory = new Stack<TaskManager>();
    private Stack<TaskManager> redoTaskManagerHistory = new Stack<TaskManager>();

    public static final Integer STATUS_EMPTY_HISTORY = 0;
    public static final Integer STATUS_AVAILABLE_HISTORY = 1;
    public static final Integer STATUS_ERROR_HISTORY = -1;

    public static final int WANTED_DATE = 0;
```
###### \java\typetask\model\ModelManager.java
``` java
    /**
     * Stores current TaskManager state for undo and redo features
     */
    @Override
    public synchronized void storeTaskManager(String command) {

        StorageUtil.storeConfig(null);
        taskManagerHistory.push(new TaskManager(taskManager));
        redoTaskManagerHistory.clear();
        StorageUtil.clearRedoConfig();
    }
```
###### \java\typetask\model\ModelManager.java
``` java
    /**
     * Reverts changes made from restoring recently saved TaskManager state for redo command
     */
    @Override
    public synchronized int revertTaskManager() {
        if (StorageUtil.isRedoConfigHistoryEmpty() && redoTaskManagerHistory.isEmpty()) {
            return STATUS_EMPTY_HISTORY;
        } else if (!redoTaskManagerHistory.isEmpty() && redoTaskManagerHistory.peek() == null) {
            redoTaskManagerHistory.pop();
            taskManagerHistory.push(null);
            return STATUS_AVAILABLE_HISTORY;
        } else {
            TaskManager redoTaskManager = redoTaskManagerHistory.pop();
            taskManagerHistory.push(new TaskManager(taskManager));
            this.resetData(redoTaskManager);
            return STATUS_AVAILABLE_HISTORY;
        }
    }
```
###### \java\typetask\model\ModelManager.java
``` java
    /**
     * Restores recently saved TaskManager state for undo command
     */
    @Override
    public synchronized int restoreTaskManager() {
        if (StorageUtil.isConfigHistoryEmpty() && taskManagerHistory.isEmpty()) {
            return STATUS_EMPTY_HISTORY;
        } else if (!taskManagerHistory.isEmpty() && taskManagerHistory.peek() == null) {
            taskManagerHistory.pop();
            redoTaskManagerHistory.push(null);
            return STATUS_AVAILABLE_HISTORY;
        } else {
            TaskManager recentTaskManager = taskManagerHistory.pop();
            redoTaskManagerHistory.push(new TaskManager(taskManager));
            this.resetData(recentTaskManager);
            return STATUS_AVAILABLE_HISTORY;
        }

    }
```
###### \java\typetask\model\ModelManager.java
``` java
    /**
     * Restores configuration to the previous configuration
     * Not implemented yet
     */
    @Override
    public synchronized void rollBackTaskManager(boolean isStorageOperation) {

        taskManagerHistory.pop();
        if (isStorageOperation) {
            StorageUtil.undoConfig();
        }
    }
    //=========== Filtered Task List Accessors =============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        return new UnmodifiableObservableList<>(filteredTasks);
    }

    @Override
    public void updateFilteredTaskList(Set<String> keywords) {
        updateFilteredTaskList(new PredicateExpression(new NameQualifier(keywords)));
    }

    private void updateFilteredTaskList(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
    }
```
###### \java\typetask\model\ModelManager.java
``` java
    /** Filters related dates for find command */
    @Override
    public void updateFilteredTaskList(String date) {
        updateFilteredTaskList(new PredicateExpression(new DateQualifier(date)));
    }
```
###### \java\typetask\model\ModelManager.java
``` java
    @Override
    public int getFilteredTaskListIndex(ReadOnlyTask targetTask) {
        return getFilteredTaskList().indexOf(targetTask);
    }
```
###### \java\typetask\model\ModelManager.java
``` java
    private class NameQualifier implements Qualifier {
        private Set<String> nameKeyWords;

        NameQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            boolean result = false;
            boolean date = false;
            boolean endDate = false;
            boolean name = false;
            date = nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(task.getDate().value, keyword))
                    .findAny()
                    .isPresent();
            endDate = nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(task.getEndDate().value, keyword))
                    .findAny()
                    .isPresent();
            name = nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(task.getName().fullName, keyword))
                    .findAny()
                    .isPresent();
            if (date || endDate || name) {
                result = true;
            }
            return result;
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords);
        }
    }

```
###### \java\typetask\model\ModelManager.java
``` java
    /** Examines if the task is qualified to be in list of tasks that consist similar date*/
    private class DateQualifier implements Qualifier {
        private String date;
        boolean result = false;
        DateQualifier(String date) {
            this.date = date;
        }
        @Override
        public boolean run(ReadOnlyTask task) {
            if (!task.getEndDate().value.equals("")) {
                result = task.getEndDate().value.contains(date);
                if (!task.getDate().value.equals("")) {
                    List<Date> endDates = DateParser.parse(task.getEndDate().value);
                    List<Date> startDates = DateParser.parse(task.getDate().value);
                    DateFormat format = new SimpleDateFormat("EEE MMM dd yyyy HH:mm:ss");
                    Date keywordDate;
                    try {
                        keywordDate = format.parse(date);
                    } catch (ParseException e) {
                        return false;
                    }
                    Date taskEndDate = endDates.get(WANTED_DATE);
                    Date taskStartDate = startDates.get(WANTED_DATE);
                    if (keywordDate.before(taskEndDate) && keywordDate.after(taskStartDate)) {
                        result = true;
                    }
                    if (keywordDate.equals(taskStartDate) || keywordDate.equals(taskEndDate)) {
                        result = true;
                    }
                }
            }
            return result;
        }
    }
```
###### \java\typetask\model\task\DueDate.java
``` java
public class DueDate {
    public static final String MESSAGE_DATE_CONSTRAINTS = "Examples of task's dates: by tmr , today, next week 5pm";
    public final String value;

    /**
     * Validates given date.
     *
     * @throws IllegalValueException if given date string is invalid.
     */
    public DueDate(String date) throws IllegalValueException {
        assert date != null;
        String trimmedDate = date.trim();
        this.value = trimmedDate;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DueDate // instanceof handles nulls
                && this.value.equals(((DueDate) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }
}
```
###### \java\typetask\model\task\ReadOnlyTask.java
``` java
    DueDate getDate();
    DueDate getEndDate();
```
###### \java\typetask\model\task\Task.java
``` java
    /**
     * Every field must be present and not null.
     */
    public Task(Name name, DueDate date, DueDate endDate, boolean isCompleted, Priority priority) {

        assert !CollectionUtil.isAnyNull(name);
        this.name = name;
        this.date = date;
        this.endDate = endDate;
```
###### \java\typetask\model\task\Task.java
``` java
    public void setDate(DueDate date) {
        this.date = date;
    }
```
###### \java\typetask\model\task\Task.java
``` java
    public void setEndDate(DueDate endDate) {
        this.endDate = endDate;
    }

```
###### \java\typetask\model\task\Task.java
``` java
    @Override
    public DueDate getDate() {
        return date;
    }
```
###### \java\typetask\model\task\Task.java
``` java
    @Override
    public DueDate getEndDate() {
        return endDate;
    }

```
###### \java\typetask\model\task\Task.java
``` java

    /**
     * Updates this task with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;
        this.setName(replacement.getName());
        this.setDate(replacement.getDate());
        this.setEndDate(replacement.getEndDate());
        this.setPriority(replacement.getPriority());
    }

```
###### \java\typetask\storage\XmlAdaptedTask.java
``` java
    @XmlElement(required = true)
    private String name;
    @XmlElement(required = true)
    private String date;
    @XmlElement(required = true)
    private String endDate;
```
###### \java\typetask\storage\XmlAdaptedTask.java
``` java
    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        name = source.getName().fullName;
        date = source.getDate().value;
        if (source.getEndDate() != null) {
            endDate = source.getEndDate().value;
        } else {
            endDate = "";
        }
```
###### \java\typetask\storage\XmlAdaptedTask.java
``` java
    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException {
        final Name name = new Name(this.name);
        final DueDate date = new DueDate(this.date);
        final DueDate endDate = new DueDate(this.endDate);
```
###### \java\typetask\ui\TaskCard.java
``` java
    /**
     * Takes @param task to check if this task is overdue or not
     * Compares using current date
     * Sets color for overdue task and pending task
     */
    private void setStatusForTask(ReadOnlyTask task) {
        if (!task.getEndDate().value.equals("")) {
            List<Date> dates = DateParser.parse(task.getEndDate().value);
            Date taskDeadline = dates.get(0);
            Calendar calendar = Calendar.getInstance();
            Date nowDate = calendar.getTime();
            if (nowDate.after(taskDeadline)) {
                setStyleToIndicateOverdue();
            } else {
                setStyleToIndicatePending();
            }
        }
        if (task.getIsCompleted()) {
            setStyleToIndicateCompleted(task);
        }
    }

```
