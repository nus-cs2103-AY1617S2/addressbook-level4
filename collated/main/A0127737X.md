# A0127737X
###### /resources/view/EventListCard.fxml
``` fxml
<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.ColumnConstraints?>
<?import javafx.scene.layout.FlowPane?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.RowConstraints?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.image.Image?>

<HBox id="cardPane" fx:id="cardPane" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
    <children>
        <GridPane HBox.hgrow="ALWAYS">
            <columnConstraints>
                <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="150.0" />
            </columnConstraints>
            <children>
                <VBox alignment="CENTER_LEFT" minHeight="50.0" GridPane.columnIndex="0">
                    <stylesheets>
                        <URL value="@DarkTheme.css" />
                        <URL value="@Extensions.css" />
                    </stylesheets>
                    <padding>
                        <Insets bottom="5" left="15" right="5" top="5" />
                    </padding>
                    <children>
                        <HBox spacing="5" alignment="CENTER_LEFT">
                            <Label fx:id="id" styleClass="cell_big_label"></Label>
                            <ImageView fx:id="overdueIcon" fitHeight="16.0" fitWidth="16.0">
                                    <image>
                                        <Image url = "images/overdue.png" ></Image>
                                    </image>
                            </ImageView>
                            <Label fx:id="name" text="\$event_name" styleClass="cell_big_label"/>
                            <Label fx:id="priority" styleClass="priority" text="\$priority" />
                            <Label fx:id="eventLocation" styleClass="cell_big_label" text="\$location" />
                            <FlowPane fx:id="tags" />
                            <ImageView fx:id="tickIcon" fitHeight="25.0" fitWidth="25.0">
                            <image>
                                <Image url = "images/tick_icon.png" ></Image>
                            </image>
                            </ImageView>
                        </HBox>
                        <FlowPane fx:id="timeslots" styleClass = "timeslots"/>
                        <Label fx:id="description" text="\$description" />
                    </children>
                </VBox>
            </children>
        </GridPane>
    </children>
</HBox>
```
###### /resources/view/DarkTheme.css
``` css

/*padding added to align tags vertically with the name */
#tags {
    -fx-hgap: 7;
    -fx-vgap: 0;
    -fx-padding: 3 0 0 0;
}

#tags .label {
    -fx-text-fill: white;
    -fx-background-color: #205077;
    -fx-padding: 1 3 1 3;
    -fx-border-radius: 2;
    -fx-background-radius: 2;
    -fx-font-size: 13;
}

/*for the header labels */

.list_header {
    -fx-text-fill: black;
    -fx-padding: 3 10 7 10;
    -fx-font-size: 17px;
}

#id {
   -fx-min-width: 20px;
}

#name {
    -fx-padding: 0 10 0 5;
    -fx-min-width: 180px;
}

#timeslots {
    -fx-hgap: 7;
    -fx-vgap: 0;
}

#description {
    -fx-font-size: 13px;
    -fx-text-fill: #252c36;
    -fx-padding: 0 0 0 0;
}

.priority {
    -fx-text-fill: white;
    -fx-padding: 1 3 1 3;
    -fx-border-radius: 2;
    -fx-background-radius: 2;
    -fx-font-size: 13;
}

.priority-one {
    -fx-background-color: derive(#fff54e, 30%);
}

.priority-two {
    -fx-background-color: derive(#ffbd00, 30%);
}

.priority-three {
    -fx-background-color: derive(#ff3f36, 30%);
}

#timeslots .label, #deadline {
    -fx-text-fill: black;
    -fx-background-color: derive(#d3d8e4, 10%);
    -fx-padding: 1 3 1 3;
    -fx-border-radius: 2;
    -fx-background-radius: 2;
    -fx-font-size: 12;
}

#resultDisplayPlaceholder {
    -fx-min-height: 103px;
}

```
###### /resources/view/UserInboxPanel.fxml
``` fxml
<?import javafx.scene.control.ListView?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.layout.HBox?>
<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.image.Image?>
<?import javafx.scene.layout.*?>
<?import javafx.scene.control.*?>

<VBox xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
    <stylesheets>
        <URL value="@DarkTheme.css" />
        <URL value="@Extensions.css" />
    </stylesheets>
    <children>
    <SplitPane fx:id ="listSplitter" dividerPositions="0.5" VBox.vgrow="ALWAYS">
    <items>
    <VBox xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
    <padding>
        <Insets bottom="0" left="5" right="8" top="0" />
    </padding>
    <children>
        <Label fx:id="taskHeader" text="Tasks: " styleClass="list_header">
        <graphic>
           <ImageView fitHeight="23.0" fitWidth="23.0">
                <image>
                <Image url = "images/sand_glass_icon.png" ></Image>
                </image>
            </ImageView>
        </graphic>
        </Label>
        <ListView fx:id="taskListView" VBox.vgrow="ALWAYS" />
        </children>
        </VBox>
        <VBox xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
        <padding>
           <Insets bottom="0" left="8" right="5" top="0" />
        </padding>
        <children>
        <Label fx:id="eventHeader" text="Events: " styleClass="list_header">
        <graphic>
        <ImageView fitHeight="23.0" fitWidth="23.0">
        <image>
        <Image url = "images/calendar.png" ></Image>
        </image>
        </ImageView>
        </graphic>
        </Label>
        <ListView fx:id="eventListView" VBox.vgrow="ALWAYS" />
        </children>
        </VBox>
        </items>
    </SplitPane>
    </children>
</VBox>
```
###### /resources/view/TaskListCard.fxml
``` fxml
<?import java.lang.*?>
<?import java.net.*?>
<?import javafx.geometry.*?>
<?import javafx.scene.control.*?>
<?import javafx.scene.layout.*?>
<?import java.net.URL?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.layout.ColumnConstraints?>
<?import javafx.scene.layout.FlowPane?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.HBox?>
<?import javafx.scene.layout.RowConstraints?>
<?import javafx.scene.layout.VBox?>
<?import javafx.scene.image.ImageView?>
<?import javafx.scene.image.Image?>

<HBox id="cardPane" fx:id="cardPane" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
    <children>
        <GridPane HBox.hgrow="ALWAYS">
            <columnConstraints>
                <ColumnConstraints hgrow="SOMETIMES" minWidth="10.0" prefWidth="150.0" />
            </columnConstraints>
            <children>
                <VBox alignment="CENTER_LEFT" minHeight="45.0" GridPane.columnIndex="0">
                    <stylesheets>
                        <URL value="@DarkTheme.css" />
                        <URL value="@Extensions.css" />
                    </stylesheets>
                    <padding>
                        <Insets bottom="5" left="15" right="5" top="5" />
                    </padding>
                    <children>
                        <HBox alignment="CENTER_LEFT" spacing="5">
                            <children>
                                <Label fx:id="id" styleClass="cell_big_label" />
                                <ImageView fx:id="overdueIcon" fitHeight="16.0" fitWidth="16.0">
                                    <image>
                                        <Image url = "images/overdue.png" ></Image>
                                    </image>
                                </ImageView>
                                <Label fx:id="name" styleClass="cell_big_label" text="\$first" />
                                <Label fx:id="priority" styleClass="priority" text="\$priority" />
                                <FlowPane fx:id="tags" />
                                <ImageView fx:id="tickIcon" fitHeight="25.0" fitWidth="25.0">
                                    <image>
                                        <Image url = "images/tick_icon.png" ></Image>
                                    </image>
                                </ImageView>
                            </children>
                        </HBox>
                        <Label fx:id="deadline" text="\$deadline" />
                        <Label fx:id="description" text="\$description" />
                    </children>
                </VBox>
            </children>
         <rowConstraints>
            <RowConstraints />
         </rowConstraints>
        </GridPane>
    </children>
</HBox>
```
###### /java/project/taskcrusher/model/event/UniqueEventList.java
``` java
    public void sortEventsByEarliestTimeslot() {
        internalList.sort(null);
    }

    /**
     *  Checks and marks any active events that are out-dated as overdue
     */
    public boolean updateOverdueStatus() {
        boolean isAnyUpdate = false;
        Date now = new Date();
        for (Event event: internalList) {
            if (!event.isComplete() && !event.isOverdue()) {
                isAnyUpdate = isAnyUpdate || event.updateOverdueStatus(now);
            }
        }
        return isAnyUpdate;
    }

    public void markEvent(int targetIndex, int markFlag) {
        Event target = internalList.get(targetIndex);
        if (markFlag == MarkCommand.MARK_COMPLETE) {
            target.markComplete();
        } else {
            target.markIncomplete();
        }
        sortEventsByEarliestTimeslot();
    }

    public void confirmEventTime(int eventListIndex, int timeslotIndex) {
        internalList.get(eventListIndex).confirmTimeslot(timeslotIndex);
        sortEventsByEarliestTimeslot();
    }

```
###### /java/project/taskcrusher/model/event/Event.java
``` java
/**
 * Represents a user event that is bound to one or more specific timeslots
 */
public class Event extends UserToDo implements ReadOnlyEvent {

    public static final String EVENT_FLAG = "e";

    private List<Timeslot> timeslots;
    private Location location;
    private boolean isOverdue;

    public Event(Name name, List<Timeslot> timeslots, Location location, Description description, UniqueTagList tags) {
        super(name, null, description, tags); // TODO: remove this stub priority
                                              // later

        assert !CollectionUtil.isAnyNull(timeslots, location);

        this.timeslots = timeslots;
        this.location = location;
        this.isOverdue = false;
    }

    public Event(Name name, List<Timeslot> timeslots, Priority priority, Location location, Description description,
            UniqueTagList tags) {
        super(name, priority, description, tags);  //added priority

        assert !CollectionUtil.isAnyNull(timeslots, location);

        this.timeslots = timeslots;
        this.location = location;
        this.isOverdue = false;
    }

    public Event(Name name, List<Timeslot> timeslots, Location location, Description description, UniqueTagList tags,
            boolean isComplete, boolean isOverdue) {
        super(name, null, description, tags); // TODO: remove this stub priority
        // later

        assert !CollectionUtil.isAnyNull(timeslots, location);

        this.timeslots = timeslots;
        this.location = location;
        this.isComplete = isComplete;
        this.isOverdue = isOverdue;
    }

    /**
     * Creates a copy of the given ReadOnlyEvent.
     */
    public Event(ReadOnlyEvent source) {
        this(source.getName(), source.getTimeslots(), source.getLocation(), source.getDescription(), source.getTags(),
                source.isComplete(), source.isOverdue());
    }

    /**
     * Checks if any of the Timeslot object in the timeslots list has
     * overlapping start and end date with {@code another}
     *
     * @param another
     * @return true if overlapping, false otherwise
     */
    public boolean hasOverlappingTimeslot(Timeslot another) {
        assert another != null;
        for (Timeslot ts : timeslots) {
            if (ts.isOverlapping(another)) {
                return true;
            }
        }
        return false;
    }

    public boolean confirmTimeslot(int timeslotIndex) {
        Timeslot confirmed = timeslots.get(timeslotIndex);
        // this approach, as opposed to timeslots.clear(), is taken so that we
        // can maintain the reference
        // to timeslot elements in the undo/redo saved states
        timeslots = new ArrayList<Timeslot>();
        timeslots.add(confirmed);
        return true;
    }

    public boolean updateOverdueStatus(Date now) {
        boolean isAnyUpdate = false;
        for (Timeslot timeslot : getTimeslots()) {
            if (now.after(timeslot.end)) {
                markOverdue();
                isAnyUpdate = true;
            }
        }
        return isAnyUpdate;
    }

    public Date getEarliestBookedTime() {
        Date earliest = timeslots.get(0).start;
        for (int i = 1; i < timeslots.size(); i++) {
            if (timeslots.get(i).start.before(earliest)) {
                earliest = timeslots.get(i).start;
            }
        }
        return earliest;
    }

    public List<Timeslot> getTimeslots() {
        return this.timeslots;
    }

    public void setTimeslots(List<Timeslot> timeslots) {
        assert timeslots != null;
        this.timeslots = timeslots;
    }

    public Location getLocation() {
        return this.location;
    }

    public void setLocation(Location location) {
        assert location != null;
        this.location = location;
    }

    public void markOverdue() {
        isOverdue = true;
    }

    public void unmarkOverdue() {
        isOverdue = false;
    }

    public boolean isOverdue() {
        return this.isOverdue;
    }

    @Override
    public void markComplete() {
        super.markComplete();
        isOverdue = false;
    }

    public void resetData(ReadOnlyEvent replacement) {
        assert replacement != null;

        this.setName(replacement.getName());
        this.setTimeslots(replacement.getTimeslots());
        this.setLocation(replacement.getLocation());
        this.setDescription(replacement.getDescription());
        this.setTags(replacement.getTags());
        if (replacement.isComplete()) {
            this.markComplete();
        }
        if (replacement.isOverdue()) {
            this.markOverdue();
        }

        this.isOverdue = false;
        updateOverdueStatus(new Date());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyEvent // instanceof handles nulls
                        && this.isSameStateAs((ReadOnlyEvent) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing
        // your own
        return Objects.hash(name, timeslots, location, description, tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }

    @Override
    public int compareTo(ReadOnlyEvent another) {
        if (this.isComplete) {
            if (another.isComplete()) {
                return 0;
            } else {
                return 1;
            }
        } else if (another.isComplete()) {
            return -1;
        }

        return this.getEarliestBookedTime().compareTo(another.getEarliestBookedTime());
    }

    public boolean hasOverlappingEvent(List<? extends ReadOnlyEvent> preexistingEvents) {
        for (ReadOnlyEvent roe : preexistingEvents) {
            for (Timeslot roet : roe.getTimeslots()) {
                if (this.hasOverlappingTimeslot(roet)) {
                    return true;
                }
            }
        }
        return false;
    }

}
```
###### /java/project/taskcrusher/model/UserInbox.java
``` java
    public boolean updateOverdueStatus() {
        return this.events.updateOverdueStatus() || this.tasks.updateOverdueStatus();
    }

    public void markTask(int index, int markFlag) {
        tasks.markTask(index, markFlag);
    }

    public void markEvent(int index, int markFlag) {
        events.markEvent(index, markFlag);
    }

    public void confirmEventTime(int eventListIndex, int timeslotIndex) {
        events.confirmEventTime(eventListIndex, timeslotIndex);
    }

    //@author

    //// task-level operations

    /**
     * Adds a task to the user inbox.
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     */
    public void addTask(Task p) throws UniqueTaskList.DuplicateTaskException {
        syncMasterTagListWith(p);
        tasks.add(p);
    }

    /**
     * Updates the task in the list at position {@code index} with {@code editedReadOnlyPerson}.
     * {@code AddressBook}'s tag list will be updated with the tags of {@code editedReadOnlyPerson}.
     * @see #syncMasterTagListWith(Task)
     *
     * @throws DuplicateTaskException if updating the task's details causes the task to be equivalent to
     *      another existing task in the list.
     * @throws IndexOutOfBoundsException if {@code index} < 0 or >= the size of the list.
     */
    public void updateTask(int index, ReadOnlyTask editedReadOnlyTask)
            throws UniqueTaskList.DuplicateTaskException {
        assert editedReadOnlyTask != null;

        Task editedTask = new Task(editedReadOnlyTask);
        syncMasterTagListWith(editedTask);
        // TODO: the tags master list will be updated even though the below line fails.
        // This can cause the tags master list to have additional tags that are not tagged to any task
        // in the task list.
        tasks.updateTask(index, editedTask);
    }

    public boolean removeTask(ReadOnlyTask key) throws UniqueTaskList.TaskNotFoundException {
        if (tasks.remove(key)) {
            return true;
        } else {
            throw new UniqueTaskList.TaskNotFoundException();
        }
    }



    /**
     * Ensures that every tag in this task:
     *  - exists in the master list {@link #tags}
     *  - points to a Tag object in the master list
     */
    private void syncMasterTagListWith(Task task) {
        final UniqueTagList taskTags = task.getTags();
        tags.mergeFrom(taskTags);

        // Create map with values = tag object references in the master list
        // used for checking person tag references
        final Map<Tag, Tag> masterTagObjects = new HashMap<>();
        tags.forEach(tag -> masterTagObjects.put(tag, tag));

        // Rebuild the list of person tags to point to the relevant tags in the master tag list.
        final Set<Tag> correctTagReferences = new HashSet<>();
        taskTags.forEach(tag -> correctTagReferences.add(masterTagObjects.get(tag)));
        task.setTags(new UniqueTagList(correctTagReferences));
    }

    /**
     * Ensures that every tag in these tasks:
     *  - exists in the master list {@link #tags}
     *  - points to a Tag object in the master list
     *  @see #syncMasterTagListWith(Task)
     */
    private void syncMasterTagListWith(UniqueTaskList tasks) {
        tasks.forEach(this::syncMasterTagListWith);
    }

    /**
     * Ensures that every tag in this task:
     *  - exists in the master list {@link #tags}
     *  - points to a Tag object in the master list
     */
    private void syncMasterTagListWith(Event event) {
        final UniqueTagList eventTags = event.getTags();
        tags.mergeFrom(eventTags);

        // Create map with values = tag object references in the master list
        // used for checking person tag references
        final Map<Tag, Tag> masterTagObjects = new HashMap<>();
        tags.forEach(tag -> masterTagObjects.put(tag, tag));

        // Rebuild the list of person tags to point to the relevant tags in the master tag list.
        final Set<Tag> correctTagReferences = new HashSet<>();
        eventTags.forEach(tag -> correctTagReferences.add(masterTagObjects.get(tag)));
        event.setTags(new UniqueTagList(correctTagReferences));
    }

    /**
     * Ensures that every tag in these tasks:
     *  - exists in the master list {@link #tags}
     *  - points to a Tag object in the master list
     *  @see #syncMasterTagListWith(Task)
     */
    private void syncMasterTagListWith(UniqueEventList events) {
        events.forEach(this::syncMasterTagListWith);
    }

    //// event-level operations

    /**
     * Adds a task to the user inbox.
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     */
    public void addEvent(Event e) throws UniqueEventList.DuplicateEventException {
        syncMasterTagListWith(e);
        events.add(e);
    }

    /**
     * Updates the task in the list at position {@code index} with {@code editedReadOnlyPerson}.
     * {@code AddressBook}'s tag list will be updated with the tags of {@code editedReadOnlyPerson}.
     * @see #syncMasterTagListWith(Task)
     *
     * @throws DuplicateTaskException if updating the task's details causes the task to be equivalent to
     *      another existing task in the list.
     * @throws IndexOutOfBoundsException if {@code index} < 0 or >= the size of the list.
     */
    public void updateEvent(int index, ReadOnlyEvent editedReadOnlyEvent)
            throws UniqueEventList.DuplicateEventException {
        assert editedReadOnlyEvent != null;

        Event editedEvent = new Event(editedReadOnlyEvent);
        syncMasterTagListWith(editedEvent);
        // TODO: the tags master list will be updated even though the below line fails.
        // This can cause the tags master list to have additional tags that are not tagged to any task
        // in the task list.
        events.updateEvent(index, editedEvent);
    }

    public boolean removeEvent(ReadOnlyEvent key) throws UniqueEventList.EventNotFoundException {
        if (events.remove(key)) {
            return true;
        } else {
            throw new UniqueEventList.EventNotFoundException();
        }
    }

    public ObservableList<ReadOnlyEvent> getEventsWithOverlappingTimeslots(Timeslot candidate) {
        return events.getEventsWithOverlapingTimeslots(candidate);
    }

    //// tag-level operations

    public void addTag(Tag t) throws UniqueTagList.DuplicateTagException {
        tags.add(t);
    }

    //// util methods

    @Override
    public String toString() {
        return tasks.asObservableList().size() + " tasks, " + events.asObservableList().size() +
                "events, " + tags.asObservableList().size() +  " tags";
        // TODO: refine later
    }

    @Override
    public ObservableList<ReadOnlyTask> getTaskList() {
        return new UnmodifiableObservableList<>(tasks.asObservableList());
    }

    @Override
    public ObservableList<ReadOnlyEvent> getEventList() {
        return new UnmodifiableObservableList<>(events.asObservableList());
    }

    @Override
    public ObservableList<Tag> getTagList() {
        return new UnmodifiableObservableList<>(tags.asObservableList());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UserInbox // instanceof handles nulls
                        && this.tasks.equals(((UserInbox) other).tasks)
                        && this.events.equals(((UserInbox) other).events)
                        && this.tags.equalsOrderInsensitive(((UserInbox) other).tags));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(tasks, events, tags);
    }


}
```
###### /java/project/taskcrusher/model/shared/UserToDo.java
``` java
/** Acts as a parent class of Event and Task. Represents some "thing" that user is going to do
 *  at "some point in time" i.e. no notion of time introduced yet.
 */
public class UserToDo implements ReadOnlyUserToDo {
    protected Name name;
    protected Description description;
    protected Priority priority;
    protected UniqueTagList tags;
    protected boolean isComplete;

    public UserToDo (Name name, Priority priority, Description description,  UniqueTagList tags) {
        //assert !CollectionUtil.isAnyNull(name, description, priority, tags);
        assert !CollectionUtil.isAnyNull(name, description, tags);
        if (priority == null) {
            try {
                this.priority = new Priority(Priority.NO_PRIORITY); //CHANGED THIS FOR CONSISTENCY
            } catch (IllegalValueException e) {
                // TODO Auto-generated catch block. Used for events in the future that supports priority
                e.printStackTrace();
            }
        } else {
            this.priority = priority;
        }

        this.name = name;
        this.description = description;
        this.tags = new UniqueTagList(tags);
        this.isComplete = false;
    }

    @Override
    public Name getName() {
        return name;
    }

    public void setName(Name name) {
        this.name = name;
    }

    public Description getDescription() {
        return description;
    }

    public void setDescription(Description description) {
        this.description = description;
    }

    public Priority getPriority() {
        return priority;
    }

    public void setPriority(Priority priority) {
        this.priority = priority;
    }

    public UniqueTagList getTags() {
        return tags;
    }

    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
    }

    public void markComplete() {
        this.isComplete = true;
    }

    public void markIncomplete() {
        this.isComplete = false;
    }

    public boolean isComplete() {
        return this.isComplete;
    }


}
```
###### /java/project/taskcrusher/model/shared/DateUtilApache.java
``` java
    /**
     * returns a string representation of the given Date in a user-friendly
     * format
     */
    public static String deadlineAsStringForUi(Date date) {
        assert date != null;
        SimpleDateFormat formatter;
        String prepend = "";
        if (isToday(date)) {
            formatter = new SimpleDateFormat(PARSE_PATTERNS[FORMAT_DATE_RELATIVE]);
            prepend = "Today ";
        } else if (isThisYear(date)) {
            formatter = new SimpleDateFormat(PARSE_PATTERNS[FORMAT_THIS_YEAR]);
        } else {
            formatter = new SimpleDateFormat(PARSE_PATTERNS[0]);
        }
        return prepend + formatter.format(date);
    }

    private static boolean isThisYear(Date d) {
        Date now = new Date();
        SimpleDateFormat yearChecker = new SimpleDateFormat("yyyy");
        return yearChecker.format(now).equals(yearChecker.format(d));
    }

    private static boolean isToday(Date d) {
        Date now = new Date();
        SimpleDateFormat dateChecker = new SimpleDateFormat("yyyyMMdd");
        return dateChecker.format(now).equals(dateChecker.format(d));
    }

    public static String dateAsStringForStorage(Date date) {
        assert date != null;
        SimpleDateFormat sdf = new SimpleDateFormat(PARSE_PATTERNS[0]);
        return sdf.format(date);
    }

    public static String timeslotAsStringForUi(Timeslot timeslot) {
        assert timeslot != null;
        String endFormat, startFormat, prepend = "";
        if (isSameDate(timeslot.start, timeslot.end)) {
            endFormat = PARSE_PATTERNS[FORMAT_DATE_RELATIVE];
        } else {
            endFormat = PARSE_PATTERNS[FORMAT_DATE_ABSOLUTE];
        }
        if (isToday(timeslot.start)) {
            startFormat = PARSE_PATTERNS[FORMAT_DATE_RELATIVE];
            prepend = "Today ";
        } else if (isThisYear(timeslot.start)) {
            startFormat = PARSE_PATTERNS[FORMAT_THIS_YEAR];
            if (isThisYear(timeslot.end)) {
                endFormat = PARSE_PATTERNS[FORMAT_THIS_YEAR];
            }
        } else {
            startFormat = PARSE_PATTERNS[FORMAT_DATE_ABSOLUTE];
        }

        SimpleDateFormat sdf = new SimpleDateFormat(startFormat);
        prepend += sdf.format(timeslot.start) + " to ";
        sdf.applyPattern(endFormat);
        prepend += sdf.format(timeslot.end);
        return prepend;
    }

    private static boolean isSameDate(Date d1, Date d2) {
        SimpleDateFormat dateChecker = new SimpleDateFormat("yyyyMMdd");
        return dateChecker.format(d1).equals(dateChecker.format(d2));
    }
}
```
###### /java/project/taskcrusher/model/shared/ReadOnlyUserToDo.java
``` java
/**Parent interface of ReadOnlyEvent and ReadOnlyTask. This interface is used avoid duplicate codes
 * for run() method of Qualifier class inside ModelManager.
 */

public interface ReadOnlyUserToDo {
    Name getName();
    Priority getPriority();
    Description getDescription();

    /**
     * The returned TagList is a deep copy of the internal TagList,
     * changes on the returned list will not affect the task's internal tags.
     */
    UniqueTagList getTags();
    void markComplete();
    void markIncomplete();
    boolean isComplete();
    String toString();
}
```
###### /java/project/taskcrusher/model/task/Task.java
``` java
/**
 * Represents an active task. Guarantees: details are present and not null (just
 * empty in <Optional>), field values are validated.
 */
public class Task extends UserToDo implements ReadOnlyTask {

    public static final String TASK_FLAG = "t";

    private Deadline deadline;
    private boolean isOverdue;

    /**
     * Modified for Task.
     */
    public Task(Name name, Deadline deadline, Priority priority, Description description, UniqueTagList tags) {
        super(name, priority, description, tags);
        assert deadline != null;

        this.deadline = deadline;
        this.isOverdue = false;
    }

    /**
     * This constructor is used when loading from storage
     */
    public Task(Name name, Deadline deadline, Priority priority, Description description, UniqueTagList tags,
            boolean isComplete, boolean isOverdue) {
        super(name, priority, description, tags);
        assert deadline != null;

        this.deadline = deadline;
        this.isOverdue = isOverdue;
        this.isComplete = isComplete;
    }

    /**
     * Creates a copy of the given ReadOnlyTask.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getDeadline(), source.getPriority(), source.getDescription(),
                source.getTags(), source.isComplete(), source.isOverdue());
    }

    public boolean updateOverdueStatus(Date now) {
        boolean isAnyUpdate = false;
        if (hasDeadline() && now.after(getDeadline().getDate().get())) {
            markOverdue();
            isAnyUpdate = true;
        }
        return isAnyUpdate;
    }

    @Override
    public Deadline getDeadline() {
        return deadline;
    }

    public void setDeadline(Deadline deadline) {
        assert deadline != null;
        this.deadline = deadline;
    }

    public boolean hasDeadline() {
        return this.deadline.hasDeadline();
    }

    public boolean isOverdue() {
        return this.isOverdue;
    }

    public void markOverdue() {
        this.isOverdue = true;
    }

    public void unmarkOverdue() {
        this.isOverdue = false;
    }

    @Override
    public void markComplete() {
        super.markComplete();
        isOverdue = false;
    }

    /**
     * Updates this task with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        this.setName(replacement.getName());
        this.setPriority(replacement.getPriority());
        this.setDeadline(replacement.getDeadline());
        this.setDescription(replacement.getDescription());
        this.setTags(replacement.getTags());
        this.isOverdue = false;
        updateOverdueStatus(new Date());
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                        && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, deadline, priority, description, tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }

    @Override
    public int compareTo(ReadOnlyTask another) {
        if (this.isComplete) {
            if (another.isComplete()) {
                return 0;
            } else {
                return 1;
            }
        } else if (another.isComplete()) {
            return -1;
        }
        //neither is complete

        if (!this.getDeadline().hasDeadline() && !another.getDeadline().hasDeadline()) {
            return this.getPriority().compareTo(another.getPriority());
        } else if (!this.getDeadline().hasDeadline() && another.getDeadline().hasDeadline()) {
            return 1;
        } else if (this.getDeadline().hasDeadline() && !another.getDeadline().hasDeadline()) {
            return -1;
        } else {
            //both has deadline
            Date thisDate = this.getDeadline().getDate().get();
            assert thisDate != null;
            Date anotherDate = another.getDeadline().getDate().get();
            assert anotherDate != null;
            return thisDate.compareTo(anotherDate);
        }
    }

}
```
###### /java/project/taskcrusher/model/ModelManager.java
``` java
/**
 * Represents the in-memory model of the user inbox data.
 * All changes to any model should be synchronized.
 */
public class ModelManager extends ComponentManager implements Model {
    private static final Logger logger = LogsCenter.getLogger(ModelManager.class);
    private static final boolean LIST_EMPTY = true;
    private static final boolean LIST_NOT_EMPTY = false;

    private final UserInbox userInbox;
    private final FilteredList<ReadOnlyTask> filteredTasks;
    private final FilteredList<ReadOnlyEvent> filteredEvents;
    private final Stack<UserInbox> undoStack = new Stack<>();
    private final Stack<UserInbox> redoStack = new Stack<>();
    private boolean isLastPerformedActionIsUndo = false;

    /**
     * Initialises a ModelManager with the given userInbox and userPrefs.
     */
    public ModelManager(ReadOnlyUserInbox userInbox, UserPrefs userPrefs) {
        super();
        assert !CollectionUtil.isAnyNull(userInbox, userPrefs);

        logger.fine("Initializing with user inbox: " + userInbox + " and user prefs " + userPrefs);

        this.userInbox = new UserInbox(userInbox);
        filteredTasks = new FilteredList<>(this.userInbox.getTaskList());
        filteredEvents = new FilteredList<>(this.userInbox.getEventList());
        updateFilteredListsToShowActiveToDo();
    }

    public ModelManager() {
        this(new UserInbox(), new UserPrefs());
    }

    public boolean undo() {
        if (undoStack.isEmpty()) {
            return false;
        } else {
            redoStack.push(new UserInbox(this.userInbox));
            UserInbox stateToRecover = undoStack.pop();
            resetData(stateToRecover);
            isLastPerformedActionIsUndo = true;
            return true;
        }
    }

    public boolean redo() {
        if (!isLastPerformedActionIsUndo) {
            return false;
        } else if (redoStack.isEmpty()) {
            return false;
        } else {
            undoStack.push(new UserInbox(this.userInbox));
            UserInbox stateToRecover = redoStack.pop();
            resetData(stateToRecover);
            return true;
        }
    }

```
###### /java/project/taskcrusher/model/ModelManager.java
``` java
    public void prepareListsForUi() {
        boolean isTaskListToShowEmpty = LIST_NOT_EMPTY, isEventListToShowEmpty = LIST_NOT_EMPTY;
        if (filteredEvents.isEmpty()) {
            isEventListToShowEmpty = LIST_EMPTY;
        }
        if (filteredTasks.isEmpty()) {
            isTaskListToShowEmpty = LIST_EMPTY;
        }
        raise(new ListsToShowUpdatedEvent(isEventListToShowEmpty, isTaskListToShowEmpty));
    }

    @Override
    public synchronized void updateOverdueStatus() {
        boolean isAnyUpdate = userInbox.updateOverdueStatus();
        if (isAnyUpdate) {
            indicateUserInboxChanged();
        }
    }

    //=========== Task operations =========================================================================

    @Override
    public synchronized void deleteTask(ReadOnlyTask target) throws TaskNotFoundException {
        saveUserInboxStateForUndo();
        userInbox.removeTask(target);
        indicateUserInboxChanged();
        updateFilteredListsToShowActiveToDo();
        prepareListsForUi();
    }

    @Override
    public synchronized void addTask(Task task) throws UniqueTaskList.DuplicateTaskException {
        saveUserInboxStateForUndo();
        userInbox.addTask(task);
        updateFilteredTaskListToShowAll();
        updateFilteredListsToShowActiveToDo();
        indicateUserInboxChanged();
    }

    @Override
    public synchronized void updateTask(int filteredTaskListIndex, ReadOnlyTask editedTask)
            throws UniqueTaskList.DuplicateTaskException {
        assert editedTask != null;
        saveUserInboxStateForUndo();
        int taskListIndex = filteredTasks.getSourceIndex(filteredTaskListIndex);
        userInbox.updateTask(taskListIndex, editedTask);
        indicateUserInboxChanged();
        updateFilteredListsToShowActiveToDo();
        prepareListsForUi();
    }

    @Override
    public synchronized void markTask(int filteredTaskListIndex, int markFlag) {
        saveUserInboxStateForUndo();
        userInbox.markTask(filteredTaskListIndex, markFlag);
        indicateUserInboxChanged();
        prepareListsForUi();
    }

    @Override
    public synchronized void markEvent(int filteredEventListIndex, int markFlag) {
        saveUserInboxStateForUndo();
        userInbox.markEvent(filteredEventListIndex, markFlag);
        indicateUserInboxChanged();
        prepareListsForUi();
    }

    //=========== Event operations =========================================================================

    @Override
    public synchronized void deleteEvent(ReadOnlyEvent target) throws EventNotFoundException {
        saveUserInboxStateForUndo();
        userInbox.removeEvent(target);
        indicateUserInboxChanged();
        updateFilteredListsToShowActiveToDo();
        prepareListsForUi();
    }

    @Override
    public synchronized void updateEvent(int filteredEventListIndex, ReadOnlyEvent editedEvent)
            throws DuplicateEventException {
        assert editedEvent != null;
        saveUserInboxStateForUndo();
        int eventListIndex = filteredEvents.getSourceIndex(filteredEventListIndex);
        userInbox.updateEvent(eventListIndex, editedEvent);
        indicateUserInboxChanged();
        updateFilteredListsToShowActiveToDo();
        prepareListsForUi();
    }

    @Override
    public synchronized void addEvent(Event event) throws DuplicateEventException {
        saveUserInboxStateForUndo();
        userInbox.addEvent(event);
        updateFilteredListsToShowActiveToDo();
        indicateUserInboxChanged();
    }

    @Override
    public synchronized void confirmEventTime(int filteredEventListIndex, int timeslotIndex) {
        saveUserInboxStateForUndo();
        int eventListIndex = filteredEvents.getSourceIndex(filteredEventListIndex);
        userInbox.confirmEventTime(eventListIndex, timeslotIndex);
        updateFilteredListsToShowActiveToDo();
        indicateUserInboxChanged();
    }

    @Override
    public synchronized void switchTaskToEvent(ReadOnlyTask toDelete, Event toAdd) throws
        DuplicateEventException, TaskNotFoundException {
        assert toDelete != null && toAdd != null;
        saveUserInboxStateForUndo();
        userInbox.removeTask(toDelete);
        userInbox.addEvent(toAdd);
        indicateUserInboxChanged();
        updateFilteredListsToShowActiveToDo();
        prepareListsForUi();
    }

    @Override
    public synchronized void switchEventToTask(ReadOnlyEvent toDelete, Task toAdd) throws
        DuplicateTaskException, EventNotFoundException {
        assert toDelete != null && toAdd != null;
        saveUserInboxStateForUndo();
        userInbox.removeEvent(toDelete);
        userInbox.addTask(toAdd);
        indicateUserInboxChanged();
        updateFilteredListsToShowActiveToDo();
        prepareListsForUi();
    }

    public UnmodifiableObservableList<ReadOnlyEvent> getEventsWithOverlappingTimeslots(Timeslot candidate) {
        return new UnmodifiableObservableList<>(userInbox.getEventsWithOverlappingTimeslots(candidate));
    }

    @Override
    public void saveUserInboxStateForUndo() {
        undoStack.push(new UserInbox(this.userInbox));
        isLastPerformedActionIsUndo = false;
    }

    //=========== Filtered Task List Accessors =============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        return new UnmodifiableObservableList<>(filteredTasks);
    }

    @Override
    public void updateFilteredTaskListToShowAll() {
        filteredTasks.setPredicate(null);
        prepareListsForUi();
    }

    //=========== Filtered Event List Accessors =============================================================

    @Override
    public UnmodifiableObservableList<ReadOnlyEvent> getFilteredEventList() {
        return new UnmodifiableObservableList<>(filteredEvents);
    }

    @Override
    public void updateFilteredEventListToShowAll() {
        filteredEvents.setPredicate(null);
        prepareListsForUi();
    }

    //====================== Combined filtering =================================================

    @Override
    public void updateFilteredListsShowAll() {
        filteredEvents.setPredicate(null);
        filteredTasks.setPredicate(null);
        prepareListsForUi();
    }

    @Override
    public void updateFilteredListsToShowActiveToDo() {
        updateFilteredLists(new PredicateExpression(new CompletionQualifier(false)));
    }

    @Override
    public void updateFilteredListsToShowCompleteToDo() {
        updateFilteredLists(new PredicateExpression(new CompletionQualifier(true)));
    }

    private void updateFilteredLists(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
        filteredEvents.setPredicate(expression::satisfies);
        prepareListsForUi();
    }

    @Override
    public void updateFilteredLists(Set<String> keywords, boolean showCompletedToo) {
        updateFilteredLists(new PredicateExpression(new KeywordQualifier(keywords, showCompletedToo)));
    }

    @Override
    public void updateFilteredLists(Timeslot userInterestedTimeslot) {
        updateFilteredLists(new PredicateExpression(new TimeslotQualifier(userInterestedTimeslot)));
    }

    //========== Inner classes/interfaces used for filtering =================================================

    interface Expression {
        boolean satisfies(ReadOnlyUserToDo item);
        String toString();
    }

    private class PredicateExpression implements Expression {

        private final Qualifier qualifier;

        PredicateExpression(Qualifier qualifier) {
            this.qualifier = qualifier;
        }

        @Override
        public boolean satisfies(ReadOnlyUserToDo item) {
            return qualifier.run(item);
        }

        @Override
        public String toString() {
            return qualifier.toString();
        }
    }

    interface Qualifier {
        boolean run(ReadOnlyUserToDo item);
        String toString();
    }

    private class KeywordQualifier implements Qualifier {
        private Set<String> nameKeyWords;
        private boolean showCompletedToo;

        KeywordQualifier(Set<String> nameKeyWords, boolean showCompletedToo) {
            this.nameKeyWords = nameKeyWords;
            this.showCompletedToo = showCompletedToo;
        }

        @Override
        public boolean run(ReadOnlyUserToDo item) {
            if (showCompletedToo) {
                return nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(item.toString(), keyword))
                    .findAny()
                    .isPresent();
            } else {
                return !item.isComplete() && nameKeyWords.stream()
                        .filter(keyword -> StringUtil.containsWordIgnoreCase(item.toString(), keyword))
                        .findAny()
                        .isPresent();
            }
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords);
        }
    }

    /**
     * checks if:
     * (1) if the ToDo item is an active task, its deadline falls within the given timeslot
     * (2) if the ToDO item is an active event, its timeslots overlaps with the given timeslot
     */
    private class TimeslotQualifier implements Qualifier {
        private Timeslot userInterestedTimeslot;

        TimeslotQualifier(Timeslot timeslot) {
            assert timeslot != null;
            this.userInterestedTimeslot = timeslot;
        }

        @Override
        public boolean run(ReadOnlyUserToDo item) {
            if (item instanceof ReadOnlyEvent) {
                ReadOnlyEvent event = (ReadOnlyEvent) item;
                if (event.isComplete()) {
                    return false;
                } else if (event.hasOverlappingTimeslot(userInterestedTimeslot)) {
                    return true;
                } else {
                    return false;
                }
            } else if (item instanceof ReadOnlyTask) {
                ReadOnlyTask task = (ReadOnlyTask) item;
                if (task.isComplete()) {
                    return false;
                } else if (task.getDeadline().isWithin(userInterestedTimeslot)) { // more OOP way
                    return true;
                } else {
                    return false;
                }
            }
            assert false;
            return false; //should not reach here
        }

        @Override
        public String toString() {
            return "user-interested timeslot is " + userInterestedTimeslot.toString();
        }
    }
    /**
     * checks if the given UserToDo is marked as complete or incomplete
     */
    private class CompletionQualifier implements Qualifier {
        boolean showComplete;
        CompletionQualifier(boolean showComplete) {
            this.showComplete = showComplete;
        }

        @Override
        public boolean run(ReadOnlyUserToDo item) {
            if (item.isComplete()) {
                return this.showComplete ? true : false;
            }
            return this.showComplete ? false : true;
        }

        @Override
        public String toString() {
            return "separate between ongoing and completed tasks and events";
        }
    }
}
```
###### /java/project/taskcrusher/ui/TaskListCard.java
``` java
/**
 * Controller for TaskListCard.fxml. Reads a ReadOnlyTask and create the layout accordingly.
 */
public class TaskListCard extends UiPart<Region> {

    private static final String FXML = "TaskListCard.fxml";
    private static final String MESSAGE_NO_DEADLINE = "no deadline";
    private static final String MESSAGE_DEADLINE_BY = "By ";
    private static final String OVERDUE_STYLE_CLASS = "overdue";

    @FXML
    private HBox cardPane;
    @FXML
    private Label name;
    @FXML
    private Label id;
    @FXML
    private Label priority;
    @FXML
    private Label deadline;
    @FXML
    private Label description;
    @FXML
    private FlowPane tags;
    @FXML
    private ImageView tickIcon;
    @FXML
    private ImageView overdueIcon;

    public TaskListCard(ReadOnlyTask task, int displayedIndex) {
        super(FXML);
        name.setText(task.getName().toString());
        name.setMinWidth(Region.USE_PREF_SIZE);
        id.setText(displayedIndex + ". ");
        showDeadline(task);
        showPriority(task);
        showDescription(task);
        displayComplete(task);
        displayOverdueStatusIfAny(task);

        initTags(task);
    }

    private void displayComplete(ReadOnlyTask task) {
        if (!task.isComplete()) {
            tickIcon.setVisible(false);
        }
    }

    private void displayOverdueStatusIfAny(ReadOnlyTask task) {
        if (task.isOverdue()) {
            overdueIcon.setVisible(true);
            overdueIcon.setManaged(true);
            deadline.setStyle("-fx-text-fill: red"); //should not be done this way
        } else {
            overdueIcon.setVisible(false);
            overdueIcon.setManaged(false);
        }
    }

    private void showDescription(ReadOnlyTask task) {
        if (task.getDescription().hasDescription()) {
            description.setText(task.getDescription().toString());
            description.setMinWidth(Region.USE_PREF_SIZE);
        } else {
            description.setVisible(false);;
        }
    }

    private void showPriority(ReadOnlyTask task) {
        priority.setText("p=" + task.getPriority().priority);
        switch (task.getPriority().priority) {
        case "1":
            priority.getStyleClass().add("priority-one");
            break;
        case "2":
            priority.getStyleClass().add("priority-two");
            break;
        case "3":
            priority.getStyleClass().add("priority-three");
            break;
        default:
            priority.setVisible(false);
            priority.setManaged(false);
        }
        priority.setMinWidth(Region.USE_PREF_SIZE);
    }

    private void showDeadline(ReadOnlyTask task) {
        if (task.getDeadline().hasDeadline()) {
            deadline.setText(MESSAGE_DEADLINE_BY +
                    DateUtilApache.deadlineAsStringForUi(task.getDeadline().getDate().get()));
        } else {
            deadline.setText(MESSAGE_NO_DEADLINE);
        }
        deadline.setMinWidth(Region.USE_PREF_SIZE);
    }

    private void initTags(ReadOnlyTask person) {
        person.getTags().forEach(tag -> tags.getChildren().add(new Label(tag.tagName)));
    }
}
```
###### /java/project/taskcrusher/ui/UserInboxPanel.java
``` java
    @Subscribe
    public void handleListsToShowUpdatedEvent(ListsToShowUpdatedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        if (event.eventListToShowEmpty) {
            eventListView.setManaged(SET_LIST_HIDDEN);
            eventListView.setVisible(SET_LIST_HIDDEN);
            eventHeader.setText("Events: Nothing to Show!");
            System.out.println("he");
        } else {
            eventListView.setManaged(SET_LIST_VISIBLE);
            eventListView.setVisible(SET_LIST_VISIBLE);
            eventHeader.setText("Events: ");
        }

        if (event.taskListToShowEmpty) {
            taskListView.setManaged(SET_LIST_HIDDEN);
            taskListView.setVisible(SET_LIST_HIDDEN);
            taskHeader.setText("Tasks: Nothing to Show!");
            System.out.println("ho");
        } else {
            taskListView.setManaged(SET_LIST_VISIBLE);
            taskListView.setVisible(SET_LIST_VISIBLE);
            taskHeader.setText("Tasks: ");
        }
    }

}
```
###### /java/project/taskcrusher/ui/EventListCard.java
``` java
/**
 * Controller for EventListCard.fxml. Reads a ReadOnlyEvent and create the layout accordingly.
 */
public class EventListCard extends UiPart<Region> {

    private static final String FXML = "EventListCard.fxml";
    private static final String LOCATION_AT = "@ ";
//    private static final String OVERDUE_STYLE_CLASS = "overdue";

    @FXML
    private HBox cardPane;
    @FXML
    private Label name;
    @FXML
    private Label id;
    @FXML
    private Label eventLocation; //named like this to avoid collision between the builtin name
    @FXML
    private Label description;
    @FXML
    private Label priority;
    @FXML
    private FlowPane timeslots;
    @FXML
    private FlowPane tags;
    @FXML
    private ImageView tickIcon;
    @FXML
    private ImageView overdueIcon;

    public EventListCard(ReadOnlyEvent event, int displayedIndex) {
        super(FXML);
        name.setText(event.getName().name);
        name.setMinWidth(Region.USE_PREF_SIZE);
        id.setText(displayedIndex + ". ");
        showLocation(event);
        showDescription(event);
        showPriority(event);
        showEventTimeSlots(event);
        displayComplete(event);
        displayOverdueStatusIfAny(event);

        initTags(event);
    }

    private void displayComplete(ReadOnlyEvent event) {
        if (!event.isComplete()) {
            tickIcon.setVisible(false);
        }
    }

    private void displayOverdueStatusIfAny(ReadOnlyEvent event) {
        if (event.isOverdue()) {
            overdueIcon.setVisible(true);
            overdueIcon.setManaged(true);
            for (Node child: timeslots.getChildren()) {
                child.setStyle("-fx-text-fill: red"); //should not be done this way
            }
        } else {
            overdueIcon.setVisible(false);
            overdueIcon.setManaged(false);
        }
    }

    private void showDescription(ReadOnlyEvent event) {
        if (event.getDescription().hasDescription()) {
            description.setText(event.getDescription().toString());
        } else {
            description.setVisible(false);
        }
        description.setMinWidth(Region.USE_PREF_SIZE);
    }

    private void showPriority(ReadOnlyEvent event) {
        priority.setText("p=" + event.getPriority().priority);
        switch (event.getPriority().priority) {
        case "1":
            priority.getStyleClass().add("priority-one");
            break;
        case "2":
            priority.getStyleClass().add("priority-two");
            break;
        case "3":
            priority.getStyleClass().add("priority-three");
            break;
        default:
            priority.setVisible(false);
        }
        priority.setMinWidth(Region.USE_PREF_SIZE);
    }

    private void showLocation(ReadOnlyEvent event) {
        if (event.getLocation().hasLocation()) {
            eventLocation.setText(LOCATION_AT + event.getLocation().location);
        } else {
            eventLocation.setText("");
        }
        eventLocation.setMinWidth(Region.USE_PREF_SIZE);
    }

    private void showEventTimeSlots(ReadOnlyEvent event) {
        event.getTimeslots().forEach(timeslot -> timeslots.getChildren().add(new Label(
                DateUtilApache.timeslotAsStringForUi(timeslot))));
    }

    private void initTags(ReadOnlyEvent event) {
        event.getTags().forEach(tag -> tags.getChildren().add(new Label(tag.tagName)));
    }
}
```
###### /java/project/taskcrusher/logic/commands/LoadCommand.java
``` java
/** loads a new xml storage file. If the file does not exist, create a new one and set it as the storage file
 *  This is achieved by posting LoadNewStorageFileEvent which is handled at the high-level MainApp instance.
 */
public class LoadCommand extends Command {
    public static final String COMMAND_WORD = "load";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": loads the storage file with the name given\n "
            + "if the file does not exist, a new file will be created and set as the new storage file\n"
            + "Parameters: XML_FILE_NAME";

    public static final String MESSAGE_LOAD_SUCCESS = "Loaded file %1$s";
    public static final String MESSAGE_INVALID_FILENAME = "Invalid file name given";
    public static final String MESSAGE_INVALID_EXTENSION = "Only xml files are supported for data storage";
    public static final String XML_EXTENSION = ".xml";

    public final String filenameToLoad;

    public LoadCommand(String filenameToLoad) {
        assert filenameToLoad != null;
        this.filenameToLoad = filenameToLoad.trim();
    }

    @Override
    public CommandResult execute() throws CommandException {
        if (!filenameToLoad.endsWith(XML_EXTENSION)) {
            throw new CommandException(MESSAGE_INVALID_EXTENSION);
        }

        try {
            FileUtil.createIfMissing(new File(filenameToLoad));
            raise (new LoadNewStorageFileEvent(filenameToLoad));
            return new CommandResult(String.format(MESSAGE_LOAD_SUCCESS, filenameToLoad));
        } catch (IOException ioe) {
            throw new CommandException(MESSAGE_INVALID_FILENAME);
        }
    }

    private void raise(BaseEvent e) {
        EventsCenter.getInstance().post(e);
    }

}
```
###### /java/project/taskcrusher/MainApp.java
``` java
    @Subscribe
    public void handleLoadNewStorageFileEvent(LoadNewStorageFileEvent lnsfe) {
        logger.info("Attempting to change storage file to  " + lnsfe.filePathToLoad);
        String currentStorageFilePath = config.getUserInboxFilePath();
        try {
            setStoragePathInConfig(lnsfe.filePathToLoad);
        } catch (IOException e) {
            logger.warning(LoadNewStorageFileEvent.MESSAGE_LOAD_FAILED);
            config.setUserInboxFilePath(currentStorageFilePath); //set it back to old path
            return;
        }
        reinitialiseMainAppWithNewStorage(lnsfe.filePathToLoad);
        logger.info("New storage file successfully loaded");
    }

    private void setStoragePathInConfig(String newStorageFile) throws IOException {
        config.setUserInboxFilePath(newStorageFile);
        ConfigUtil.saveConfig(config, Config.DEFAULT_CONFIG_FILE);
    }

    private void reinitialiseMainAppWithNewStorage(String newStorageFile) {
        EventsCenter.getInstance().unregisterHandler(storage);
        storage = new StorageManager(newStorageFile, config.getUserPrefsFilePath());
        model.resetData(loadInitialUserInboxFromStorage(storage));
        logic = new LogicManager(model, storage);
        ui.setLogic(logic);
    }

    public static void main(String[] args) {
        launch(args);
    }
}
```
###### /java/project/taskcrusher/storage/XmlAdaptedTimeslot.java
``` java
/**
 * JAXB-friendly version of Timeslot.
 */
public class XmlAdaptedTimeslot {

    @XmlElement(required = true)
    public String startDate;
    @XmlElement(required = true)
    public String endDate;

    /**
     * Constructs an XmlAdaptedTimeslot.
     * This is the no-arg constructor that is required by JAXB.
     */
    public XmlAdaptedTimeslot() {}

    /**
     * Converts a given Timeslot into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created
     */
    public XmlAdaptedTimeslot(Timeslot timeslot) {
//        startDate = timeslot.start.toString();
//        endDate = timeslot.end.toString();
        startDate = DateUtilApache.dateAsStringForStorage(timeslot.start);
        endDate = DateUtilApache.dateAsStringForStorage(timeslot.end);
    }

    /**
     * Converts this jaxb-friendly adapted timeslot object into the model's Timeslot object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted timeslot
     */
    public Timeslot toModelType() throws IllegalValueException {
        return new Timeslot(startDate, endDate, Timeslot.IS_LOADING_FROM_STORAGE);
    }
}
```
###### /java/project/taskcrusher/storage/XmlAdaptedEvent.java
``` java
/**
 * JAXB-friendly version of Event.
 */
public class XmlAdaptedEvent {

    /* Inherited attributes from UserToDo*/
    @XmlElement(required = true)
    private String name;
    @XmlElement(required = true)
    private String priority;
    @XmlElement(required = true)
    private String description;
    @XmlElement(required = true)
    private boolean isComplete;
    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();

    /* Event-specific attributes */
    @XmlElement(required = true)
    private List<XmlAdaptedTimeslot> timeslots = new ArrayList<>();
    @XmlElement(required = true)
    private boolean isOverdue;
    @XmlElement(required = true)
    private String location;

    /**
     * Constructs an XmlAdaptedTask.
     * This is the no-arg constructor that is required by JAXB.
     */
    public XmlAdaptedEvent() {}


    /**
     * Converts a given Event into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedEvent
     */
    public XmlAdaptedEvent(ReadOnlyEvent source) {
        name = source.getName().name;
        priority = source.getPriority().priority;
        description = source.getDescription().description;
        isComplete = source.isComplete();

        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }

        timeslots = new ArrayList<>();
        for (Timeslot timeslot: source.getTimeslots()) {
            timeslots.add(new XmlAdaptedTimeslot(timeslot));
        }

        location = source.getLocation().location;
        isOverdue = source.isOverdue();
    }

    /**
     * Converts this jaxb-friendly adapted event object into the model's Event object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted event
     */
    public Event toModelType() throws IllegalValueException {
        final List<Tag> eventTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            eventTags.add(tag.toModelType());
        }

        final List<Timeslot> eventTimeslots = new ArrayList<>();
        for (XmlAdaptedTimeslot timeslot: timeslots) {
            eventTimeslots.add(timeslot.toModelType());
        }

        final Name name = new Name(this.name);
        final Priority priority = new Priority(this.priority);
        final Description description = new Description(this.description);
        final UniqueTagList tags = new UniqueTagList(eventTags);

        final Location location = new Location(this.location);

        return new Event(name, eventTimeslots, location, description, tags, isComplete, isOverdue);
    }

}
```
###### /java/project/taskcrusher/storage/XmlAdaptedTask.java
``` java
/**
 * JAXB-friendly version of Task.
 */
public class XmlAdaptedTask {

    /* Inherited attributes from UserToDo*/
    @XmlElement(required = true)
    private String name;
    @XmlElement(required = true)
    private String priority;
    @XmlElement(required = true)
    private String description;
    @XmlElement(required = true)
    private boolean isComplete;
    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();

    /* Task-specific attributes */
    @XmlElement(required = true)
    private String deadline;
    @XmlElement(required = true)
    private boolean isOverdue;

    /**
     * Constructs an XmlAdaptedTask.
     * This is the no-arg constructor that is required by JAXB.
     */
    public XmlAdaptedTask() {}


    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        name = source.getName().name;
        priority = source.getPriority().priority;
        description = source.getDescription().description;
        isComplete = source.isComplete();

        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }

        deadline = source.getDeadline().deadline;
        isOverdue = source.isOverdue();
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException {
        final List<Tag> personTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            personTags.add(tag.toModelType());
        }
        final Name name = new Name(this.name);
        final Priority priority = new Priority(this.priority);
        final Description description = new Description(this.description);
        final UniqueTagList tags = new UniqueTagList(personTags);

        final Deadline deadline = new Deadline(this.deadline, Deadline.IS_LOADING_FROM_STORAGE);
        return new Task(name, deadline, priority, description, tags, isComplete, isOverdue);
    }
}
```
###### /java/project/taskcrusher/commons/events/model/ListsToShowUpdatedEvent.java
``` java
/**
 * Used to signal UserInboxPanel when one or both of the lists to show is/are empty.
 */
public class ListsToShowUpdatedEvent extends BaseEvent {

    public final boolean eventListToShowEmpty;
    public final boolean taskListToShowEmpty;

    public ListsToShowUpdatedEvent(boolean eventListToShowEmpty, boolean taskListToShowEmpty) {
        this.eventListToShowEmpty = eventListToShowEmpty;
        this.taskListToShowEmpty = taskListToShowEmpty;
    }

    @Override
    public String toString() {
        return "eventList empty =  " + eventListToShowEmpty + " taskList empty =  " + taskListToShowEmpty;
    }

}
```
