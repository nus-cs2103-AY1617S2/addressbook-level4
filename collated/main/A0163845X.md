# A0163845X
###### /src/main/java/seedu/task/commons/core/FileNameHandler.java
``` java
public class FileNameHandler {
    private static String filePath = "fileName.txt";
    public static final String DEFAULT_FILEPATH = "data/TaskManagerData.xml";

    public static String getFileName() {
        try {
            FileInputStream fis = new FileInputStream(filePath);
            BufferedInputStream bis = new BufferedInputStream(fis);
            byte[] data = new byte[256];
            bis.read(data);
            String retString = new String(data).trim();
            if (isValid(retString)) {
                System.out.println("isValid");
                return retString;
            } else {
                return DEFAULT_FILEPATH;
            }
        } catch (IOException ioe) {
            System.out.println("IOException");
            return DEFAULT_FILEPATH;
        }

    }

    public static void setFileName(String fileName) {
        FileOutputStream fos;
        try {
            fos = new FileOutputStream(filePath, false);
            BufferedOutputStream bos = new BufferedOutputStream(fos);
            bos.write(fileName.getBytes());
            bos.close();
        } catch (IOException ioe) {
            System.out.println("IOException");
        }
    }

    public static boolean isValid(String FileName) {
        final File File = new File(FileName);
        boolean isValid = true;
        try {
            if (File.createNewFile()) {
                File.delete();
            }
        } catch (IOException e) {
            isValid = false;
        }

        System.out.println(isValid);
        return isValid;
    }
}
```
###### /src/main/java/seedu/task/commons/events/storage/LoadDataEvent.java
``` java
public class LoadDataEvent extends BaseEvent {
    private String pathName;

    public LoadDataEvent(String pathName) {
        this.pathName = pathName;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public String getPathName() {
        return pathName;
    }
}
```
###### /src/main/java/seedu/task/commons/events/ui/ChangePathNameEvent.java
``` java
public class ChangePathNameEvent extends BaseEvent {
    private String pathName;

    public ChangePathNameEvent(String pathName) {
        this.pathName = pathName;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

    public String getPathName() {
        return pathName;
    }
}
```
###### /src/main/java/seedu/task/commons/util/CollectionUtil.java
``` java
    public static boolean isAnyPresent(Optional<?>... items) {
        // return Stream.of(items).anyMatch(Optional != null &&
        // Optional::isPresent);
        for (Optional<?> optional : items) {
            if (optional == null || optional.isPresent()) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns true if every element in a collection are unique by
     * {@link Object#equals(Object)}.
     */
    public static boolean elementsAreUnique(Collection<?> items) {
        final Set<Object> testSet = new HashSet<>();
        for (Object item : items) {
            final boolean itemAlreadyExists = !testSet.add(item); // see Set
                                                                  // documentation
            if (itemAlreadyExists) {
                return false;
            }
        }
        return true;
    }
}
```
###### /src/main/java/seedu/task/logic/commands/AddCommand.java
``` java
    public AddCommand(TaskName parseTaskName, Optional<TaskDate> parseDate,
            Optional<TaskTime> parseStartTime, Optional<TaskTime> parseEndTime,
            Optional<String> parseString) throws IllegalValueException {
        this.taskToAdd = new Task(parseTaskName, parseDate, parseStartTime, parseEndTime,
                parseString, new TaskStatus("Ongoing"));

    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            model.addTask(taskToAdd);
            return new CommandResult(String.format(MESSAGE_SUCCESS, taskToAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            throw new CommandException(MESSAGE_DUPLICATE_TASK);
        }

    }

    @Override
    public boolean isUndoable() {
        return true;
    }

}
```
###### /src/main/java/seedu/task/logic/commands/EditCommand.java
``` java
    private static Task createEditedTask(ReadOnlyTask taskToEdit, EditTaskDescriptor editTaskDescriptor) {
        assert taskToEdit != null;

        TaskName updatedTaskName = editTaskDescriptor.getTaskName().orElseGet(taskToEdit::getTaskName);
        TaskDate updatedDate;
        if (editTaskDescriptor.getTaskDate() == null) {
            updatedDate = null;
        } else if (editTaskDescriptor.getTaskDate().isPresent()) {
            updatedDate = editTaskDescriptor.getTaskDate().get();
        } else {
            updatedDate = taskToEdit.getTaskDate();
        }

        TaskTime updatedStartTime;
        if (editTaskDescriptor.getTaskStartTime() == null) {
            updatedStartTime = null;
        } else if (editTaskDescriptor.getTaskStartTime().isPresent()) {
            updatedStartTime = editTaskDescriptor.getTaskStartTime().get();
        } else {
            updatedStartTime = taskToEdit.getTaskStartTime();
        }

        TaskTime updatedEndTime;
        if (editTaskDescriptor.getTaskEndTime() == null) {
            updatedEndTime = null;
        } else if (editTaskDescriptor.getTaskEndTime().isPresent()) {
            updatedEndTime = editTaskDescriptor.getTaskEndTime().get();
        } else {
            updatedEndTime = taskToEdit.getTaskEndTime();
        }

        String updatedDescription = editTaskDescriptor.getTaskDescription().orElseGet(taskToEdit::getTaskDescription);
        TaskStatus remainStatus = new TaskStatus("Ongoing");
        UniqueTagList updatedTags = editTaskDescriptor.getTags().orElseGet(taskToEdit::getTags);

        return new Task(updatedTaskName, updatedDate, updatedStartTime, updatedEndTime, updatedDescription,
                remainStatus, updatedTags);

    }

    /**
     * Stores the details to edit the task with. Each non-empty field value will
     * replace the corresponding field value of the task.
     */
    public static class EditTaskDescriptor {
        private Optional<TaskName> taskName = Optional.empty();
        private Optional<TaskDate> taskDate = Optional.empty();
        private Optional<TaskTime> taskStartTime = Optional.empty();
        private Optional<TaskTime> taskEndTime = Optional.empty();
        private Optional<String> taskDescription = Optional.empty();
        private Optional<UniqueTagList> tags = Optional.empty();

        public EditTaskDescriptor() {
        }

        public EditTaskDescriptor(EditTaskDescriptor toCopy) {
            this.taskName = toCopy.getTaskName();
            this.taskDate = toCopy.getTaskDate();
            this.taskStartTime = toCopy.getTaskStartTime();
            this.taskEndTime = toCopy.getTaskEndTime();
            this.taskDescription = toCopy.getTaskDescription();
            this.tags = toCopy.getTags();
        }

        /**
         * Returns true if at least one field is edited.
         */
        public boolean isAnyFieldEdited() {
            return CollectionUtil.isAnyPresent(this.taskName, this.taskDate, this.taskStartTime, this.taskEndTime,
                    this.taskDescription, this.tags);
        }

        public void setTaskName(Optional<TaskName> taskName) {
            assert taskName != null;
            this.taskName = taskName;
        }

        public Optional<TaskName> getTaskName() {
            return taskName;
        }

        public void setTaskDate(Optional<TaskDate> date) {
            // allowing for two different nulls to remove fields for edit
            // command
            this.taskDate = date;
        }

        public Optional<TaskDate> getTaskDate() {
            return taskDate;
        }

        public void setTaskStartTime(Optional<TaskTime> startTime) {
            // assert startTime != null;
            this.taskStartTime = startTime;
        }

        public Optional<TaskTime> getTaskStartTime() {
            return taskStartTime;
        }

        public void setTaskEndTime(Optional<TaskTime> endTime) {
            // assert endTime != null;
            this.taskEndTime = endTime;
        }

        public Optional<TaskTime> getTaskEndTime() {
            return taskEndTime;
        }

        public void setTaskDescription(Optional<String> description) {
            assert description != null;
            this.taskDescription = description;
        }

        public Optional<String> getTaskDescription() {
            return taskDescription;
        }

        public void setTags(Optional<UniqueTagList> tags) {
            assert tags != null;
            this.tags = tags;
        }

        public Optional<UniqueTagList> getTags() {
            return tags;
        }
    }
}
```
###### /src/main/java/seedu/task/logic/commands/FilterCommand.java
``` java
public class FilterCommand extends Command {
    private Predicate<Object> predicate;
    public static final String COMMAND_WORD = "filter";
    public static final String MESSAGE_SUCCESS = "Results filtered";
    public static final String MESSAGE_FAILURE = "Failed to filter";

    public FilterCommand(Predicate<Object> predicate) {
        this.predicate = predicate;
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        // try {
        model.filter(predicate);
        return new CommandResult(MESSAGE_SUCCESS);

    }

}
```
###### /src/main/java/seedu/task/logic/commands/LoadCommand.java
``` java
public class LoadCommand extends Command {

    private final String path;

    public static final String COMMAND_WORD = "load";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": loads a save file for "
            + "Fast Task data \n" + "Parameters: PATHNAME\n" + "Example: " + COMMAND_WORD
            + " C:\\Program Files\\DropBox\\saveFile.xml\n " + "               " + COMMAND_WORD
            + " /Users/name/Desktop/MyTasks.xml";

    public static final String MESSAGE_SUCCESS = "Successfully loaded the save file.";
    public static final String MESSAGE_FAIL = "Not a valid path";

    public LoadCommand(String path) {
        this.path = path;
    }

    @Override
    public CommandResult execute() throws CommandException {
        System.out.println("test");
        try {
            EventsCenter.getInstance().post(new LoadDataEvent(path));
            return new CommandResult(MESSAGE_SUCCESS);
        } catch (Exception e) {
            return new CommandResult(MESSAGE_FAIL);
        }
    }

}
```
###### /src/main/java/seedu/task/logic/commands/RedoCommand.java
``` java
public class RedoCommand extends Command {
    public static final String COMMAND_WORD = "redo";
    public static final String MESSAGE_SUCCESS = "redo successful";
    public static final String MESSAGE_FAIL = "redo failure";

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            model.redo();
            return new CommandResult(String.format(MESSAGE_SUCCESS));
        } catch (Exception e) {
            throw new CommandException(MESSAGE_FAIL);
        }
    }

}
```
###### /src/main/java/seedu/task/logic/commands/ShowcaseCommand.java
``` java
public class ShowcaseCommand extends Command {

    private int numberOfTasks;
    private String MESSAGE_SUCCESS = "Sample data generated";
    private String MESSAGE_FAILURE = "Sample data failed to generate";
    public static final String COMMAND_WORD = "showcase";

    public ShowcaseCommand(int numberOfTasks) {
        this.numberOfTasks = numberOfTasks;
    }

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            model.showcase(numberOfTasks);
            return new CommandResult(MESSAGE_SUCCESS);
        } catch (DuplicateTaskException dte) {
            return new CommandResult(MESSAGE_FAILURE);
        }
    }

    public boolean isUndoable() {
        return true;
    }
}
```
###### /src/main/java/seedu/task/logic/commands/SortCommand.java
``` java
public class SortCommand extends Command {
    public static final String COMMAND_WORD = "sort";
    private String sortMethod;
    // public static final String MESSAGE_USAGE = "can either use 'sort name' or
    // 'sort time' or 'sort cd' or 'sort status'";
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": can sort the tasks in Fast Task by alphabetical order, "
            + "by the date that is closest to the current date, by the date the task was created, "
            + "or by the task status\n" + "Parameters: KEYWORD\n" + "Examples: " + COMMAND_WORD
            + " name, " + COMMAND_WORD + " time, " + COMMAND_WORD + " cd, " + COMMAND_WORD
            + " status";

    public static final String MESSAGE_FAILURE = "Sorting failed";
    public static final String MESSAGE_SUCCESS = "Sorting success";

    public SortCommand(String sortMethod) {
        this.sortMethod = sortMethod;
    }

    @Override
    public CommandResult execute() throws CommandException {
        // try {
        assert model != null;
        TaskComparable t;
        if (sortMethod.equals("name")) {
            t = new TaskNameComparable();
        } else if (sortMethod.equals("time")) {
            t = new TaskTimeComparable();
        } else if (sortMethod.equals("cd")) {
            t = new TaskCreationDateComparator();
        } else if (sortMethod.equals("status")) {
            t = new TaskStatusComparable();
        } else {
            return new CommandResult(MESSAGE_FAILURE);
        }
        model.sort(t);
        return new CommandResult(MESSAGE_SUCCESS);
        // } catch (Exception e) {
        // throw new CommandException(MESSAGE_FAILURE);
        // }
    }

    @Override
    public boolean isUndoable() {
        return true;
    }

}
```
###### /src/main/java/seedu/task/logic/commands/UndoCommand.java
``` java
public class UndoCommand extends Command {
    public static final String COMMAND_WORD = "undo";
    public static final String MESSAGE_SUCCESS = "Undo successful";
    public static final String MESSAGE_FAIL = "Undo failure";

    @Override
    public CommandResult execute() throws CommandException {
        assert model != null;
        try {
            model.undo();
            return new CommandResult(String.format(MESSAGE_SUCCESS));
        } catch (Exception e) {
            throw new CommandException(MESSAGE_FAIL);
        }
    }

}
```
###### /src/main/java/seedu/task/logic/commands/UpdateBackupCommand.java
``` java
public class UpdateBackupCommand extends Command {

    public final String COMMAND_MESSAGE = "Backing up task list";

    @Override
    public CommandResult execute() throws CommandException {
        // TODO Auto-generated method stub
        assert model != null;
        try {
            model.updateBackup();
        } catch (DuplicateTaskException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return new CommandResult(COMMAND_MESSAGE);
    }

}
```
###### /src/main/java/seedu/task/logic/parser/DoneCommandParser.java
``` java
    public static int[] sort(int[] input) {
        for (int i = 0; i < input.length - 1; i++) {
            for (int j = i; j < input.length; j++) {
                if (input[i] < input[j]) {
                    int temp = input[i];
                    input[i] = input[j];
                    input[j] = temp;
                }
            }
        }
        return input;
    }
}
```
###### /src/main/java/seedu/task/logic/parser/FilterCommandParser.java
``` java
public class FilterCommandParser {

    public static final String MESSAGE_INCORRECT_FORMAT = "Invalid format for filter.";
    public static final String MESSAGE_USAGE =
              "\nFormat: filter [FILTER_TYPE] [FILTER_ARGUMENT] "
            + "\n[FILTER_TYPE] can be name, desc (description), status, before, after."
            + "\n[FILTER_ARGUMENT] can include a date, a status, a task description, or the name of a task."
            + "\nExample: filter after today / filter status completed";


    public Command parse(String arguments) {
        try {
            arguments = arguments.toLowerCase();
            arguments = arguments.trim();
            int predicateSplitPoint = arguments.indexOf(' ');
            String predicateType = arguments.substring(0, predicateSplitPoint);
            String predicateArgument = arguments.substring(predicateSplitPoint, arguments.length());
            predicateArgument = predicateArgument.trim();
            predicateType = predicateType.trim();
            System.out.println(predicateType);
            System.out.println(predicateArgument);
            Predicate<Object> pred;
            switch (predicateType) {
            case TaskStatusPredicate.PREDICATE_WORD:
                pred = new TaskStatusPredicate(predicateArgument);
                break;
            case TaskNamePredicate.PREDICATE_WORD:
                pred = new TaskNamePredicate(predicateArgument);
                break;
            case TaskDateBeforePredicate.PREDICATE_WORD:
                pred = new TaskDateBeforePredicate(predicateArgument);
                break;
            case TaskDateAfterPredicate.PREDICATE_WORD:
                pred = new TaskDateAfterPredicate(predicateArgument);
                break;
            case TaskDescriptionPredicate.PREDICATE_WORD:
                pred = new TaskDescriptionPredicate(predicateArgument);
                break;
            default:
                return new IncorrectCommand("Invalid predicate type, can use status or name");
            }
            return new FilterCommand(pred);
        } catch (StringIndexOutOfBoundsException e) {
            return new IncorrectCommand(MESSAGE_INCORRECT_FORMAT + MESSAGE_USAGE);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand("Invalid argument");
        }
    }

}
```
###### /src/main/java/seedu/task/logic/parser/ParserUtil.java
``` java
    public static Optional<TaskName> parseTaskName(Optional<String> taskName)
            throws IllegalValueException {
        assert taskName != null;
        return taskName.isPresent() ? Optional.of(new TaskName(taskName.get())) : Optional.empty();
    }

```
###### /src/main/java/seedu/task/logic/parser/ParserUtil.java
``` java
    public static Optional<TaskDate> parseDate(Optional<String> date) throws IllegalValueException {
        assert date != null;
        return date.isPresent() ? Optional.of(new TaskDate(date.get())) : Optional.empty();
    }

```
###### /src/main/java/seedu/task/logic/parser/ParserUtil.java
``` java
    public static Optional<TaskTime> parseTime(Optional<String> time) throws IllegalValueException {
        assert time != null;
        return time.isPresent() ? Optional.of(new TaskTime(time.get())) : Optional.empty();
    }

```
###### /src/main/java/seedu/task/logic/parser/ParserUtil.java
``` java
    public static Optional<String> parseString(Optional<String> str) throws IllegalValueException {
        assert str != null;
        return str;
    }
}
```
###### /src/main/java/seedu/task/logic/parser/SortCommandParser.java
``` java
public class SortCommandParser {
    public static final String byTime = "time";
    public static final String byName = "name";
    public static final String byCreationDate = "cd";
    public static final String byStatus = "status";

    public Command parse(String arguments) {
        arguments = arguments.toLowerCase();
        arguments = arguments.trim();
        switch (arguments) {
        case byTime:
            return new SortCommand(arguments);
        case byName:
            return new SortCommand(arguments);
        case byCreationDate:
            return new SortCommand(arguments);
        case byStatus:
            return new SortCommand(arguments);
        default:
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SortCommand.MESSAGE_USAGE));
        }
    }

}
```
###### /src/main/java/seedu/task/MainApp.java
``` java
    @Subscribe
    public void handleChangePathNameEvent(ChangePathNameEvent event) {
        System.out.println("working cpne");
        storage.setPathName(event.getPathName());
        FileNameHandler.setFileName(event.getPathName());
        try {
            storage.saveTaskManager(model.getTaskManager());
        } catch (IOException e) {
            System.out.println("Unexpected IOE in main app");
            storage.setPathName(FileNameHandler.DEFAULT_FILEPATH);
            FileNameHandler.setFileName(FileNameHandler.DEFAULT_FILEPATH);
        }
    }

```
###### /src/main/java/seedu/task/MainApp.java
``` java
    @Subscribe
    public void handleLoadDataEvent(LoadDataEvent event) {
        System.out.println("working lde");
        for (int i = 0; i < 4; i++) {
            try {
                StorageManager temp = new StorageManager(event.getPathName(), config.getUserPrefsFilePath());
                System.out.println(temp.equals(storage));
                if (!temp.readTaskManager().isPresent()) {
                    throw new Exception();
                }
                model.setTaskManager(temp.readTaskManager());
                FileNameHandler.setFileName(event.getPathName());
            } catch (Exception e) {
                System.out.println("Unexpected exception");
                storage.setPathName(FileNameHandler.DEFAULT_FILEPATH);
                FileNameHandler.setFileName(FileNameHandler.DEFAULT_FILEPATH);
            }
        }
    }
```
###### /src/main/java/seedu/task/model/Model.java
``` java
    void undo() throws Exception;

```
###### /src/main/java/seedu/task/model/Model.java
``` java
    void updateBackup() throws DuplicateTaskException;

```
###### /src/main/java/seedu/task/model/Model.java
``` java
    void sort(TaskComparable t);
```
###### /src/main/java/seedu/task/model/Model.java
``` java

    void setTaskManager(Optional<ReadOnlyTaskManager> readTaskManager);
```
###### /src/main/java/seedu/task/model/Model.java
``` java

    void redo() throws Exception;
```
###### /src/main/java/seedu/task/model/Model.java
``` java

    public void filterStatus(String status);

```
###### /src/main/java/seedu/task/model/Model.java
``` java
    void showcase(int numberOfTasks) throws DuplicateTaskException;

```
###### /src/main/java/seedu/task/model/Model.java
``` java
    public void filter(Predicate<Object> pred);

}
```
###### /src/main/java/seedu/task/model/ModelManager.java
``` java
    // brute force pattern matching algorithm
    public static boolean patternStringMatch(String p, String t) {
        int i = 0;
        int j = 0;
        while (i <= t.length() - p.length()) {
            if (p.substring(j, j + 1).equalsIgnoreCase(t.substring(i + j, i + j + 1))) {
                j++;
                if (j >= p.length()) {
                    return true;
                }
            } else {
                j = 0;
                i++;
            }
        }
        return false;
    }

    public ModelManager() {
        this(new TaskManager(), new UserPrefs());
    }

    @Override
    public void resetData(ReadOnlyTaskManager newData) {
        taskManager.resetData(newData);
        indicateTaskManagerChanged();
    }

    @Override
    public ReadOnlyTaskManager getTaskManager() {
        return taskManager;
    }

    /** Raises an event to indicate the model has changed */
    private void indicateTaskManagerChanged() {
        raise(new TaskManagerChangedEvent(taskManager));
    }

    @Override
    public synchronized void deleteTask(ReadOnlyTask target) throws TaskNotFoundException {
        taskManager.removeTask(target);
        indicateTaskManagerChanged();
    }

```
###### /src/main/java/seedu/task/model/ModelManager.java
``` java
    private void updateFilteredTaskList(Predicate<Object> predicate) {
        if (filteredTasks.getPredicate() == null) {
            filteredTasks.setPredicate(predicate);
        } else {
            filteredTasks.setPredicate(predicate.and((Predicate<? super Object>) filteredTasks.getPredicate()));
        }
    }

    private void updateFilteredTaskList(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
    }

    // ========== Inner classes/interfaces used for filtering
    // =================================================

    interface Expression {
        boolean satisfies(ReadOnlyTask task);

        String toString();
    }

    private class PredicateExpression implements Expression {

        private final Qualifier qualifier;

        PredicateExpression(Qualifier qualifier) {
            this.qualifier = qualifier;
        }

        @Override
        public boolean satisfies(ReadOnlyTask task) {
            return qualifier.run(task);
        }

        @Override
        public String toString() {
            return qualifier.toString();
        }
    }

    interface Qualifier {
        boolean run(ReadOnlyTask task);

        String toString();
    }

    private class NameQualifier implements Qualifier {
        private Set<String> nameKeyWords;

        NameQualifier(Set<String> nameKeyWords) {
            this.nameKeyWords = nameKeyWords;
        }

```
###### /src/main/java/seedu/task/model/ModelManager.java
``` java
        @Override
        public boolean run(ReadOnlyTask task) {
            for (String s : nameKeyWords) {
                assert s.length() > 0;
                if (patternStringMatch(s, task.getTaskName().fullTaskName)) {
                    return true;
                }
            }
            return false;
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords);
        }
    }

```
###### /src/main/java/seedu/task/model/ModelManager.java
``` java
    @Override
    public void undo() throws Exception {
        taskManager.undo();
        indicateTaskManagerChanged();
    }

```
###### /src/main/java/seedu/task/model/ModelManager.java
``` java
    @Override
    public void updateBackup() throws DuplicateTaskException {
        taskManager.updateBackup();
    }

```
###### /src/main/java/seedu/task/model/ModelManager.java
``` java
    @Override
    public void sort(TaskComparable t) {
        taskManager.sort(t);
    }
```
###### /src/main/java/seedu/task/model/ModelManager.java
``` java

    @Override
    public void setTaskManager(Optional<ReadOnlyTaskManager> readTaskManager) {
        if (readTaskManager.isPresent()) {
            taskManager.loadNewTaskList(readTaskManager);
        }
    }

```
###### /src/main/java/seedu/task/model/ModelManager.java
``` java
    public void redo() throws Exception {
        taskManager.redo();
        indicateTaskManagerChanged();
    }
```
###### /src/main/java/seedu/task/model/ModelManager.java
``` java

    public void filterStatus(String status) {
        filteredTasks.setPredicate(new TaskStatusPredicate(status));
    }

    @Override
    public void showcase(int numberOfTasks) throws DuplicateTaskException {
        taskManager.showcase(numberOfTasks);
        indicateTaskManagerChanged();
    }
```
###### /src/main/java/seedu/task/model/ModelManager.java
``` java

    @Override
    public void filter(Predicate<Object> pred) {
        updateFilteredTaskList(pred);
    }
}
```
###### /src/main/java/seedu/task/model/task/Task.java
``` java
    public Task(TaskName parseTaskName, Optional<TaskDate> parseDate, Optional<TaskTime> parseTime,

            Optional<TaskTime> parseTime2, Optional<String> parseString, TaskStatus parseTaskStatus)
            throws IllegalValueException {

        this.taskName = parseTaskName;
        if (parseDate.isPresent()) {
            this.taskDate = parseDate.get();
        }
        if (parseTime.isPresent()) {
            this.taskStartTime = parseTime.get();
        }
        if (parseTime2.isPresent()) {
            if (this.taskStartTime != null && this.taskStartTime.compareTo(parseTime2.get()) < 0) {
                this.taskEndTime = parseTime2.get();
            } else {
                throw new IllegalValueException(MESSAGE_INVALID_TIME);
            }
        }
        if (parseString.isPresent()) {
            this.taskDescription = parseString.get();
        }
        this.taskStatus = new TaskStatus(TaskStatus.MESSAGE_INCOMPLETE);
        this.tags = new UniqueTagList();
        if (localTime == null) {
            setCreationTime();
        }

    }

```
###### /src/main/java/seedu/task/model/task/Task.java
``` java
    public Task(TaskName parseTaskName, Optional<TaskDate> parseDate, Optional<TaskTime> parseTime,
            Optional<TaskTime> parseTime2, Optional<String> parseString,
            Optional<TaskStatus> parseTaskStatus, UniqueTagList tags) throws IllegalValueException {
        this.taskName = parseTaskName;
        if (parseDate.isPresent()) {
            this.taskDate = parseDate.get();
        }
        if (parseTime.isPresent()) {
            this.taskStartTime = parseTime.get();
        }
        if (parseTime2.isPresent()) {
            if (this.taskStartTime != null && this.taskStartTime.compareTo(parseTime2.get()) < 0) {
                this.taskEndTime = parseTime2.get();
            } else {
                throw new IllegalValueException(MESSAGE_INVALID_TIME);
            }
        }
        if (parseString.isPresent()) {
            this.taskDescription = parseString.get();
        }
        if (parseTaskStatus.isPresent()) {
            this.taskStatus = parseTaskStatus.get();
        }
        this.tags = tags;
        if (localTime == null) {
            setCreationTime();
        }
    }

    public Task(TaskName taskName, TaskDate taskDate, TaskTime taskStartTime, TaskTime taskEndTime,
            String taskDescription, TaskStatus taskStatus) {
        this(taskName, taskDate, taskStartTime, taskEndTime, taskDescription, taskStatus,
                new UniqueTagList());

    }

    /**
     * Creates a copy of the given ReadOnlyTask.
     */
    public Task(ReadOnlyTask source) {
        this(source.getTaskName(), source.getTaskDate(), source.getTaskStartTime(),
                source.getTaskEndTime(), source.getTaskDescription(), source.getTaskStatus(),
                source.getTags());
        this.setLocalDate(source.getLocalDate());
        this.setLocalTime(source.getLocalTime());
    }

    @Override
    public UniqueTagList getTags() {
        return new UniqueTagList(tags);
    }

    /**
     * Replaces this task's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
    }

    /**
     * Updates this task with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyTask replacement) {
        assert replacement != null;

        try {
            this.setTaskName(replacement.getTaskName());
            this.setTaskDate(replacement.getTaskDate());
            this.setTaskStartTime(replacement.getTaskStartTime());
            this.setTaskEndTime(replacement.getTaskEndTime());
            this.setTaskDescription(replacement.getTaskDescription());
            this.setTaskStatus(replacement.getTaskStatus());
            this.setTags(replacement.getTags());

        } catch (IllegalValueException ive) {
            System.out.println("error resetting data in read only task"); // phrase
                                                                          // better
                                                                          // for
                                                                          // message
        }
    }

    @Override
    public boolean equals(Object other) {

        if (other == null)
            return false;
        if (other == this)
            return true;
        Task otherTask = (Task) other;
        if (!otherTask.getTaskName().fullTaskName.equals(this.getTaskName().fullTaskName)) {
            System.out.println("names arent equal");
            return false;
        }
        if ((otherTask.getTaskDate() == null && this.getTaskDate() != null)
                || (otherTask.getTaskDate() != null && this.getTaskDate() == null)
                || (otherTask.getTaskDate() != this.getTaskDate())
                        && !(otherTask.getTaskDate().compareTo(this.getTaskDate()) == 0)) {
            System.out.println("dates arent equal");
            return false;
        }
        if ((otherTask.getTaskStartTime() == null && this.getTaskStartTime() != null)
                || (otherTask.getTaskStartTime() != null && this.getTaskStartTime() == null)
                || (otherTask.getTaskStartTime() != this.getTaskStartTime()) && !(otherTask
                        .getTaskStartTime().compareTo(this.getTaskStartTime()) == 0)) {
            System.out.println("start times arent equal");
            return false;
        }
        if ((otherTask.getTaskEndTime() == null && this.getTaskEndTime() != null)
                || (otherTask.getTaskEndTime() != null && this.getTaskEndTime() == null)
                || (otherTask.getTaskEndTime() != this.getTaskEndTime())
                        && !(otherTask.getTaskEndTime().compareTo(this.getTaskEndTime()) == 0)) {
            System.out.println("end times arent equal");
            return false;
        }
        if ((otherTask.getTaskDescription() == null && this.getTaskDescription() == null)
                || (otherTask.getTaskDescription() == null && this.getTaskDescription() != null)
                || (otherTask.getTaskDescription() == null && this.getTaskDescription() == null)
                    && !(otherTask.getTaskDescription().trim().equals(this.getTaskDescription().trim()))) {
            System.out.println("descriptions arent equal");
            return false;
        }
        return true;

    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing
        // your own
        return Objects.hash(taskName, taskDate, taskStartTime, taskEndTime, taskDescription,
                taskStatus, tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }

    public TaskName getTaskName() {
        return taskName;
    }

    public TaskDate getTaskDate() {
        return taskDate;
    }

    public TaskTime getTaskStartTime() {
        return taskStartTime;
    }

    public TaskTime getTaskEndTime() {
        return taskEndTime;
    }

```
###### /src/main/java/seedu/task/model/task/Task.java
``` java

    public void setTaskStartTime(TaskTime taskStartTime) throws IllegalValueException {
        if (taskStartTime == null) {
            this.taskStartTime = null;
        } else if (this.taskEndTime == null || this.taskEndTime.compareTo(taskStartTime) >= 0) {
            this.taskStartTime = taskStartTime;
        } else {
            throw new IllegalValueException(MESSAGE_INVALID_TIME);
        }
    }
```
###### /src/main/java/seedu/task/model/task/Task.java
``` java

    public void setTaskEndTime(TaskTime taskEndTime) throws IllegalValueException {
        if (taskEndTime == null) {
            this.taskEndTime = null;
        } else if (this.taskStartTime == null || taskEndTime.compareTo(taskStartTime) >= 0) {
            this.taskEndTime = taskEndTime;
        } else {
            throw new IllegalValueException(MESSAGE_INVALID_TIME);
        }
    }

```
###### /src/main/java/seedu/task/model/task/Task.java
``` java
    public void setCreationTime() {
        localDate = LocalDate.now();
        localTime = LocalTime.now();
    }

```
###### /src/main/java/seedu/task/model/task/Task.java
``` java
    public LocalDate getLocalDate() {
        if (localDate == null) {
            setCreationTime();
        }
        return localDate;
    }

```
###### /src/main/java/seedu/task/model/task/Task.java
``` java
    public LocalTime getLocalTime() {
        if (localTime == null) {
            setCreationTime();
        }
        return localTime;
    }

```
###### /src/main/java/seedu/task/model/task/Task.java
``` java
    private void setLocalDate(LocalDate localDate) {
        this.localDate = localDate;
    }

```
###### /src/main/java/seedu/task/model/task/Task.java
``` java
    private void setLocalTime(LocalTime localTime) {
        this.localTime = localTime;
    }
}
```
###### /src/main/java/seedu/task/model/task/TaskComparable.java
``` java
public interface TaskComparable {
    public int compareTo(Task x, Task y);

}
```
###### /src/main/java/seedu/task/model/task/TaskCreationDateComparator.java
``` java
public class TaskCreationDateComparator implements TaskComparable {

    @Override
    public int compareTo(Task x, Task y) {
        if (x.getLocalDate().compareTo(y.getLocalDate()) < 0) {
            return -1;
        } else if (x.getLocalDate().compareTo(y.getLocalDate()) > 0) {
            return 1;
        }
        if (x.getLocalTime().compareTo(y.getLocalTime()) < 0) {
            return -1;
        }
        // assumes tasks arent made at the same time
        return 1;
    }

}
```
###### /src/main/java/seedu/task/model/task/TaskDate.java
``` java
public class TaskDate {

    private List<Date> dates;
    private SimpleDateFormat formatter;
    public final String OUTPUT_FORMAT = " dd/mm/yy";

    private int day;
    private int month;
    private int year;
    private int dayTwo = 0;
    private int monthTwo = 0;
    private int yearTwo = 0;
    public final String value;
    private final String DATE_DELIMITER_SLASH = "/";
    private final String DATE_DELIMITER_DASH = "-";
    private final int DAY_ARRAY_INDEX = 0;
    private final int MONTH_ARRAY_INDEX = 1;
    private final int YEAR_ARRAY_INDEX = 2;
    private final int DAY2_ARRAY_INDEX = 3;
    private final int MONTH2_ARRAY_INDEX = 4;
    private final int YEAR2_ARRAY_INDEX = 5;

    private static final int DAY_START_INDEX = 0;
    private static final int DAY_END_INDEX = 2;
    private static final int MONTH_START_INDEX = 2;
    private static final int MONTH_END_INDEX = 4;
    private static final int YEAR_START_INDEX = 4;
    private static final int YEAR_END_INDEX = 6;

    private static final int DAY2_START_INDEX = 7;
    private static final int DAY2_END_INDEX = 9;
    private static final int MONTH2_START_INDEX = 9;
    private static final int MONTH2_END_INDEX = 11;
    private static final int YEAR2_START_INDEX = 11;
    private static final int YEAR2_END_INDEX = 13;

    public static final String MESSAGE_INVALID_DATE_FORMAT = "Invaid date, try ddmmyy-ddmmyy ";

    public TaskDate(String input) throws IllegalValueException {

        System.out.println(input);
        value = input.trim();
        try {
            int[] dateArray = dateFormatConverter(input);
            if (input.length() == 6) {
                setDay(dateArray[DAY_ARRAY_INDEX]);
                setMonth(dateArray[MONTH_ARRAY_INDEX]);
                setYear(dateArray[YEAR_ARRAY_INDEX]);
            }
            if (input.length() == 13) {
                setDay(dateArray[DAY_ARRAY_INDEX]);
                setMonth(dateArray[MONTH_ARRAY_INDEX]);
                setYear(dateArray[YEAR_ARRAY_INDEX]);
                setSecondDay(dateArray[DAY2_ARRAY_INDEX]);
                setSecondMonth(dateArray[MONTH2_ARRAY_INDEX]);
                setSecondYear(dateArray[YEAR2_ARRAY_INDEX]);
            }
        } catch (Exception e) {
            System.out.println(input);
            formatter = new SimpleDateFormat(OUTPUT_FORMAT);
            NattyParser natty = new NattyParser();
            dates = natty.parse(input);

            if (dates == null) {
                throw new IllegalValueException(MESSAGE_INVALID_DATE_FORMAT);
            }
            if (dates.size() >= 1 && dates.get(0) != null) {
                setDay(dates.get(0).getDate());
                setMonth(dates.get(0).getMonth() + 1);
                System.out.println(dates.get(0).getMonth() + 1);
                setYear(dates.get(0).getYear() - 100);
            }
            if (dates.size() >= 2 && dates.get(1) != null) {
                setSecondDay(dates.get(1).getDate());
                setSecondMonth(dates.get(1).getMonth() + 1);
                setSecondYear(dates.get(1).getYear() - 100);
            }
        }
    }

    public TaskDate(int inputDay, int inputMonth, int inputYear) {
        this.setDay(inputDay);
        this.setMonth(inputMonth);
        this.setYear(inputYear);
        value = day + "" + month + "";
    }

    public void setDay(int day) {
        if (day > 0 && day <= 31) {
            this.day = day;
        } else {
            throw new IllegalArgumentException("Invalid day");
        }
    }

    public void setMonth(int month) {
        if (month > 0 && month <= 12) {
            this.month = month;
        } else {
            throw new IllegalArgumentException("Invalid month");
        }
    }

    public void setYear(int year) {
        if (year > 0) {
            this.year = year;
        } else {
            throw new IllegalArgumentException("Invalid year");
        }
    }

```
###### /src/main/java/seedu/task/model/task/TaskDate.java
``` java
    public int compareTo(TaskDate other) {
        if (this.year > other.year) {
            return 1;
        } else if (this.year < other.year) {
            return -1;
        }
        if (this.month > other.month) {
            return 1;
        } else if (this.month < other.month) {
            return -1;
        }
        if (this.day > other.day) {
            return 1;
        } else if (this.day < other.day) {
            return -1;
        }
        return 0;
    }
```
###### /src/main/java/seedu/task/model/task/TaskDateAfterPredicate.java
``` java

    private TaskDate date;

    public TaskDateAfterPredicate(String date) throws IllegalValueException {
        this.date = new TaskDate(date);
        System.out.println(date);
    }

    @Override
    public boolean test(Object arg0) {

        Task task = (Task) arg0;
        System.out.println(date);

        System.out.println(task.getTaskDate());
        if (task.getTaskDate() != null)
            System.out.println(task.getTaskDate().compareTo(date));

        if (task.getTaskDate() != null && date.compareTo(task.getTaskDate()) <= 0) {
            return true;
        } else {
            return false;
        }
    }

}
```
###### /src/main/java/seedu/task/model/task/TaskDateBeforePredicate.java
``` java

    private TaskDate date;

    public TaskDateBeforePredicate(String date) throws IllegalValueException {
        this.date = new TaskDate(date);
        System.out.println(date);
    }

    @Override
    public boolean test(Object arg0) {

        Task task = (Task) arg0;
        System.out.println(date);

        System.out.println(task.getTaskDate());
        if (task.getTaskDate() != null)
            System.out.println(task.getTaskDate().compareTo(date));

        if (task.getTaskDate() != null && date.compareTo(task.getTaskDate()) >= 0) {
            return true;
        } else {
            return false;
        }
    }

}
```
###### /src/main/java/seedu/task/model/task/TaskDescriptionPredicate.java
``` java

    private String desc;

    public TaskDescriptionPredicate(String desc) {
        this.desc = desc;
    }

    public static boolean patternStringMatch(String p, String t) {
        int i = 0;
        int j = 0;
        while (i <= t.length() - p.length()) {
            if (p.substring(j, j + 1).equalsIgnoreCase(t.substring(i + j, i + j + 1))) {
                j++;
                if (j >= p.length()) {
                    return true;
                }
            } else {
                j = 0;
                i++;
            }
        }
        return false;
    }

    @Override
    public boolean test(Object t) {
        Task task = (Task) t;
        if (task.getTaskDescription().length() < desc.length()) {
            return false;
        }
        return patternStringMatch(desc, task.getTaskDescription());
    }

}
```
###### /src/main/java/seedu/task/model/task/TaskNamePredicate.java
``` java

    private String name;

    public TaskNamePredicate(String name) {
        this.name = name;
    }

    public static boolean patternStringMatch(String p, String t) {
        int i = 0;
        int j = 0;
        while (i <= t.length() - p.length()) {
            if (p.substring(j, j + 1).equalsIgnoreCase(t.substring(i + j, i + j + 1))) {
                j++;
                if (j >= p.length()) {
                    return true;
                }
            } else {
                j = 0;
                i++;
            }
        }
        return false;
    }

    @Override
    public boolean test(Object t) {
        Task task = (Task) t;
        if (task.getTaskName().fullTaskName.length() < name.length()) {
            return false;
        }
        return patternStringMatch(name, task.getTaskName().fullTaskName);
    }

}
```
###### /src/main/java/seedu/task/model/task/TaskStatusComparable.java
``` java
public class TaskStatusComparable implements TaskComparable {

    @Override
    public int compareTo(Task x, Task y) {
        return y.getTaskStatus().toString().compareTo(x.getTaskStatus().toString());
    }

}
```
###### /src/main/java/seedu/task/model/task/TaskStatusPredicate.java
``` java

    private String status;

    public TaskStatusPredicate(String status) {
        this.status = status;
    }

    @Override
    public boolean test(Object arg0) {
        try {
            if (((Task) arg0).getTaskStatus().toString().toLowerCase().trim().equals(status)) {
                return true;
            }
        } catch (Exception E) {
            return false;
        }
        return false;
    }

}
```
###### /src/main/java/seedu/task/model/task/TaskTime.java
``` java
public class TaskTime {

    private List<Date> dates;
    private Date time;
    private SimpleDateFormat formatter;
    private final String OUTPUT_FORMAT = "HH:mm";

    public final String value;
    private int hour;
    private int minute;
    private String hourStr;
    private String minuteStr;
    public final String TIME_DELIMITER = ":";
    public final int MINUTE_ARRAY_INDEX = 0;
    public final int HOUR_ARRAY_INDEX = 1;

    public static final String MESSAGE_INVALID_TIME_FORMAT = "Invalid time format, be more prcise or try "
            + "hhmm, hh:mm, or h:mm";

    public TaskTime(String input) throws IllegalValueException {

        value = input.trim();

        try {
            int[] timeArray = timeFormatConverter(input);
            setMinute(timeArray[MINUTE_ARRAY_INDEX]);
            setHour(timeArray[HOUR_ARRAY_INDEX]);
            time = null;
        } catch (Exception e) {
            formatter = new SimpleDateFormat(OUTPUT_FORMAT);
            NattyParser natty = new NattyParser();
            dates = natty.parse(input);
            if (dates == null) {
                throw new IllegalValueException(MESSAGE_INVALID_TIME_FORMAT);
            }
            time = dates.get(0);
            setMinute(time.getMinutes());
            setHour(time.getHours());
        }

    }

    public TaskTime(int hour, int minute) throws IllegalValueException {
        setHour(hour);
        setMinute(minute);
        hourStr = String.valueOf(hour);
        minuteStr = String.valueOf(minute);
        value = this.toString();
    }

    @Override
    public String toString() {
        if (time == null) {
            return hourStr + TIME_DELIMITER + minuteStr;
        } else {
            return formatter.format(dates.get(0));
        }

    }

    public void setHour(int hour) throws IllegalValueException {
        if (0 <= hour && hour <= 23) {
            this.hour = hour;
        } else {
            throw new IllegalValueException(MESSAGE_INVALID_TIME_FORMAT);
        }
    }

    public void setMinute(int minute) throws IllegalValueException {
        if (0 <= minute && minute <= 59) {
            this.minute = minute;
        } else {
            throw new IllegalValueException(MESSAGE_INVALID_TIME_FORMAT);
        }
    }

    public int[] timeFormatConverter(String time) throws IllegalValueException {
        if (time.length() < 3 || time.length() > 5) {
            throw new IllegalValueException(MESSAGE_INVALID_TIME_FORMAT);
        } else if (time.length() == 3) {
            this.minuteStr = time.substring(1, 3);
            this.hourStr = time.substring(0, 1);
        } else if (time.length() == 4) {
            if (time.substring(1, 2).equals(TIME_DELIMITER)) {
                this.minuteStr = time.substring(2, 4);
                this.hourStr = "0" + time.substring(0, 1);
            } else {
                this.minuteStr = time.substring(2, 4);
                this.hourStr = time.substring(0, 2);
            }
        } else {
            if (!time.substring(2, 3).equals(TIME_DELIMITER)) {
                throw new IllegalValueException(MESSAGE_INVALID_TIME_FORMAT);
            }
            this.minuteStr = time.substring(3, 5);
            this.hourStr = time.substring(0, 2);
        }
        int minute = Integer.parseInt(minuteStr);
        int hour = Integer.parseInt(hourStr);
        int[] timeArray = { minute, hour };
        return timeArray;
    }

    public int compareTo(TaskTime other) {
        return ((this.hour * 60 + this.minute) - (other.hour * 60 + other.minute));
    }
}
```
###### /src/main/java/seedu/task/model/task/TaskTimeComparable.java
``` java
public class TaskTimeComparable implements TaskComparable {

    @Override
    public int compareTo(Task task1, Task task2) {
        if (task1.getTaskDate() == null) {
            if (task2.getTaskDate() != null) {
                return 1;
            }
        }
        if (task2.getTaskDate() == null) {
            if (task1.getTaskDate() != null) {
                return -1;
            }
        }
        if (task1.getTaskDate() != null && task2.getTaskDate() != null) {
            if (task1.getTaskDate().compareTo(task2.getTaskDate()) > 0) {
                return -1;
            } else if (task1.getTaskDate().compareTo(task2.getTaskDate()) < 0) {
                return 1;
            }
        }
        if (task1.getTaskStartTime() == null && task1.getTaskEndTime() == null) {
            if (task2.getTaskStartTime() != null || task2.getTaskEndTime() != null) {
                return 1;
            }
            return 0;
        }
        if (task2.getTaskStartTime() == null && task2.getTaskEndTime() == null) {
            if (task1.getTaskStartTime() != null || task1.getTaskEndTime() != null) {
                return -1;
            }
            return 0;
        }
        if (task1.getTaskStartTime() != null && task2.getTaskStartTime() != null) {
            if (task1.getTaskStartTime().compareTo(task2.getTaskStartTime()) > 0) {
                return -1;
            } else if (task1.getTaskStartTime().compareTo(task2.getTaskStartTime()) < 0) {
                return 0;
            } else {
                if (task1.getTaskEndTime() == null) {
                    if (task2.getTaskEndTime() == null) {
                        return 0;
                    }
                    return 1;
                } // task1.getTaskEndTime() != null
                if (task2.getTaskEndTime() == null) {
                    return -1;
                }
                return task2.getTaskEndTime().compareTo(task1.getTaskEndTime());
            }
        }
        System.out.println("Error in tasktimecomparable");
        return 0;
        // should be unreachable

    }

}
```
###### /src/main/java/seedu/task/model/task/UniqueTaskList.java
``` java
    public void clear() {
        while (!internalList.isEmpty()) {
            internalList.remove(0);
        }
        // TODO Auto-generated method stub

    }

```
###### /src/main/java/seedu/task/model/task/UniqueTaskList.java
``` java
    public void addAll(UniqueTaskList toAdd) {
        for (Task t : toAdd) {
            internalList.add(t);
        }
    }

```
###### /src/main/java/seedu/task/model/task/UniqueTaskList.java
``` java
    public static UniqueTaskList copy(UniqueTaskList toCopy) {
        UniqueTaskList ret = new UniqueTaskList();
        ret.addAll(toCopy);
        return ret;
    }

    /**
     * Updates the task in the list at position {@code index} with {@code editedTask}.
     *
     * @throws DuplicateTaskException
     *             if updating the task's details causes the task to be equivalent to another
     *             existing task in the list.
     * @throws IndexOutOfBoundsException
     *             if {@code index} < 0 or >= the size of the list.
     */

    public void updateTask(int index, ReadOnlyTask editedTask) throws DuplicateTaskException {
        assert editedTask != null;

        Task taskToUpdate = internalList.get(index);
        if (!taskToUpdate.equals(editedTask) && internalList.contains(editedTask)) {
            throw new DuplicateTaskException();
        }

        taskToUpdate.resetData(editedTask);
        // TODO: The code below is just a workaround to notify observers of the
        // updated person.
        // The right way is to implement observable properties in the Person
        // class.
        // Then, TaskCard should then bind its text labels to those observable
        // properties.
        internalList.set(index, taskToUpdate);
    }

    /**
     * Removes the equivalent task from the list.
     *
     * @throws TaskNotFoundException
     *             if no such person could be found in the list.
     */
    public boolean remove(ReadOnlyTask toRemove) throws TaskNotFoundException {
        assert toRemove != null;

        final boolean taskFoundAndDeleted = internalList.remove(toRemove);
        if (!taskFoundAndDeleted) {

            throw new TaskNotFoundException();
        }
        return taskFoundAndDeleted;
    }

    /**
     * Complete the equivalent task from the list.
     *
     * @throws TaskNotFoundException
     *             if no such task could be found in the list.
     */
```
###### /src/main/java/seedu/task/model/task/UniqueTaskList.java
``` java
    public void complete(int index) {
        Task temp = internalList.get(index);
        temp.setTaskStatus(new TaskStatus(TaskStatus.MESSAGE_DONE));
        internalList.remove(index);
        internalList.add(temp);
    }

    public void setTasks(UniqueTaskList replacement) {
        this.internalList.setAll(replacement.internalList);
    }

    public void setTasks(List<? extends ReadOnlyTask> tasks) throws DuplicateTaskException {

        final UniqueTaskList replacement = new UniqueTaskList();
        for (final ReadOnlyTask task : tasks) {
            replacement.add(new Task(task));
        }
        setTasks(replacement);
    }

    public UnmodifiableObservableList<Task> asObservableList() {
        return new UnmodifiableObservableList<>(internalList);
    }

    @Override
    public Iterator<Task> iterator() {
        return internalList.iterator();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof UniqueTaskList // instanceof handles nulls
                        && this.internalList.equals(((UniqueTaskList) other).internalList));
    }

    @Override
    public int hashCode() {
        return internalList.hashCode();
    }

    /**
     * Signals that an operation would have violated the 'no duplicates' property of the list.
     */
    public static class DuplicateTaskException extends DuplicateDataException {
        protected DuplicateTaskException() {
            super("Operation would result in duplicate tasks");
        }
    }

    /**
     * Signals that an operation targeting a specified task in the list would fail because there is
     * no such matching task in the list.
     */
    public static class TaskNotFoundException extends Exception {
    }

}
```
###### /src/main/java/seedu/task/model/TaskManager.java
``` java
    public void undo() throws Exception {
        if (backupTasks == null || backupTasks.size() == 0) {
            throw new Exception("Can't undo without undo state");
        } else {
            redoBackup.addLast(UniqueTaskList.copy(tasks));
            tasks.clear();
            for (Task t : backupTasks.getLast()) {
                tasks.add(t);
            }
            backupTasks.removeLast();
        }
    }

```
###### /src/main/java/seedu/task/model/TaskManager.java
``` java
    public void updateBackup() throws DuplicateTaskException {
        redoBackup.clear();
        if (backupTasks == null) {
            backupTasks = new LinkedList<UniqueTaskList>();
        }
        if (backupTasks.size() < BACKUP_LIST_MAX_SIZE) {
            UniqueTaskList temp = new UniqueTaskList();
            for (Task t : tasks) {
                temp.add(new Task(t));
            }
            backupTasks.addLast(temp);
        } else if (backupTasks.size() == BACKUP_LIST_MAX_SIZE) {
            UniqueTaskList temp = new UniqueTaskList();
            for (Task t : tasks) {
                temp.add(new Task(t));
            }
            backupTasks.addLast(temp);
            backupTasks.removeFirst();
        } else {
            backupTasks = new LinkedList<UniqueTaskList>();
            System.out.println("error in updateBackup, backup list deleted");
        }
    }
```
###### /src/main/java/seedu/task/model/TaskManager.java
``` java

    public static LinkedList<Task> quickSort(TaskComparable comparator, LinkedList<Task> taskList) {
        if (taskList.size() <= 1) {
            return taskList;
        }
        Random rand = new Random();
        int pivot = rand.nextInt(taskList.size());
        Task pivotTask = taskList.remove(pivot);
        LinkedList<Task> previous = new LinkedList<Task>();
        LinkedList<Task> next = new LinkedList<Task>();
        for (Task t : taskList) {
            if (comparator.compareTo(t, pivotTask) < 0) {
                previous.addFirst(t);
            } else {
                next.addFirst(t);
            }
        }
        previous = quickSort(comparator, previous);
        next = quickSort(comparator, next);
        previous.add(pivotTask);
        previous.addAll(next);
        return previous;
    }

```
###### /src/main/java/seedu/task/model/TaskManager.java
``` java
    public void sort(TaskComparable comparator) {
        LinkedList<Task> taskList = new LinkedList<Task>();
        for (Task t : tasks) {
            taskList.add(t);
        }
        taskList = quickSort(comparator, taskList);
        tasks.clear();
        for (Task t : taskList) {
            try {
                tasks.add(t);
            } catch (DuplicateTaskException dte) {
                System.out.println("Unexpected error in TASKMANAGER sort by name");
            }
        }

    }
```
###### /src/main/java/seedu/task/model/TaskManager.java
``` java

    public void loadNewTaskList(Optional<ReadOnlyTaskManager> readTaskManager) {

        tasks.clear();
        for (ReadOnlyTask t : readTaskManager.get().getTaskList()) {
            Task temp = new Task(t);
            try {
                tasks.add(temp);
            } catch (DuplicateTaskException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }

```
###### /src/main/java/seedu/task/model/TaskManager.java
``` java
    public void redo() throws Exception {
        if (redoBackup.isEmpty()) {
            throw new Exception("Can't redo");
        } else {
            UniqueTaskList temp = redoBackup.getLast();
            backupTasks.addLast(UniqueTaskList.copy(tasks));
            redoBackup.removeLast();
            tasks.clear();
            for (Task t : temp) {
                tasks.add(t);
            }
        }
    }
```
###### /src/main/java/seedu/task/model/TaskManager.java
``` java

    public void showcase(int numberOfTasks) throws DuplicateTaskException {
        UniqueTaskList temp = new UniqueTaskList();
        for (int i = 0; i < numberOfTasks; i++) {
            temp.add(RandomTaskGenerator.generateTask());
        }
        tasks.clear();
        for (Task t : temp) {
            tasks.add(t);
        }
    }
}
```
###### /src/main/java/seedu/task/ui/StatusBarFooter.java
``` java
    @Subscribe
    private void handleChangePathNameEvent(ChangePathNameEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        setSaveLocation("./" + event.getPathName());
    }

```
###### /src/main/java/seedu/task/ui/StatusBarFooter.java
``` java
    @Subscribe
    private void loadDataEvent(LoadDataEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        setSaveLocation("./" + event.getPathName());
    }
}
```
