# A0116219L
###### \src\main\java\org\teamstbf\yats\logic\commands\AddCommand.java
``` java
/**
 * Adds a task to the TaskManager.
 */
public class AddCommand extends Command {

	public static final String COMMAND_WORD = "add";

	public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds an task or event to the task manager. "
			+ "Parameters: task name @location ,TIME DATE  //description [#TAG]...\n" + "Example: " + COMMAND_WORD
			+ " meeting with boss @work, 7:00pm to 9pm tomorrow " + "//get scolded for being lazy #kthxbye";

	public static final String MESSAGE_SUCCESS = "New event added: %1$s";

	private final Event toAdd;

	/**
	 * Creates an AddCommand using raw values.
	 *
	 * @param string2
	 * @param string
	 *
	 * @throws IllegalValueException
	 *             if any of the raw values are invalid
	 */
	public AddCommand(String name, String location, String period, String startTime, String endTime, String deadline,
			String description, Set<String> tags) throws IllegalValueException {
		final Set<Tag> tagSet = new HashSet<>();
		for (String tagName : tags) {
			tagSet.add(new Tag(tagName));
		}
		this.toAdd = new Event(new Title(name), new Location(location), new Schedule(startTime), new Schedule(endTime),
				new Schedule(deadline), new Description(description), new UniqueTagList(tagSet), new IsDone(), false,
				new Recurrence());
	}

	/**
	 * Creates an addCommand using a map of parameters
	 *
	 * @param addParam
	 * @throws IllegalValueException
	 *             if any of the parameters are invalid
	 */
	public AddCommand(HashMap<String, Object> parameters) throws IllegalValueException {
		final Set<Tag> tagSet = new HashSet<>();
		for (String tagName : (Set<String>) parameters.get("tag")) {
			tagSet.add(new Tag(tagName));
		}
		this.toAdd = new Event(parameters, new UniqueTagList(tagSet));
	}

	@Override
	public CommandResult execute() throws CommandException {
		assert model != null;
		model.saveImageOfCurrentTaskManager();
		model.addEvent(toAdd);
		// model.updateCalendarFilteredListToShowStartTime();
		return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
	}

}
```
###### \src\main\java\org\teamstbf\yats\logic\commands\EditCommand.java
``` java
/**
 * Edits the details of an existing task in the task scheduler.
 */
public class EditCommand extends Command {

	public static final String COMMAND_WORD = "edit";

	public static final String MESSAGE_USAGE = COMMAND_WORD + ": Edits the details of the task identified "
			+ "by the index number used in the last task listing. "
			+ "Existing values will be overwritten by the input values.\n"
			+ "Parameters: INDEX (must be a positive integer) [, START to END TIME] [//DESCRIPTION] [#TAGS]...\n"
			+ "Example: " + COMMAND_WORD + " 1 s/10:00am,10/10/2017 e/5:00pm,10/10/2017 d/lots of work to do t/school";

	public static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited Task: %1$s";
	public static final String MESSAGE_NOT_EDITED = "At least one field to edit must be provided.";
	public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the task manager.";
	public static final String MESSAGE_ILLEGAL_EDIT_RECURRING_TASK = "Date, time, periodicity of recurring task cannot be edited.";
	public static final String MESSAGE_ILLEGAL_EDIT_RECURRENCE = "Recurrence/periodicity is not editable.";

	public static final String MESSAGE_ILLEGAL_DEADLINE_AND_EVENT_OBJECT = "Object Cannot Have Both a Deadline and a Start and End Time";

	protected final int filteredTaskListIndex;
	protected final EditTaskDescriptor editTaskDescriptor;

	/**
	 * @param filteredTaskListIndex
	 *            the index of the task in the filtered task list to edit
	 * @param editTaskDescriptor
	 *            details to edit the task
	 */
	public EditCommand(int filteredTaskListIndex, EditTaskDescriptor editTaskDescriptor) {
		assert filteredTaskListIndex > 0;
		assert editTaskDescriptor != null;

		// converts filteredTaskListIndex from one-based to zero-based.
		this.filteredTaskListIndex = filteredTaskListIndex - 1;

		this.editTaskDescriptor = new EditTaskDescriptor(editTaskDescriptor);
	}

	@Override
	public CommandResult execute() throws CommandException {
		List<ReadOnlyEvent> lastShownList = model.getFilteredTaskList();

		if (filteredTaskListIndex >= lastShownList.size()) {
			throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
		}

		ReadOnlyEvent taskToEdit = lastShownList.get(filteredTaskListIndex);
		Event editedTask = createEditedTask(taskToEdit, editTaskDescriptor);
		model.updateEvent(filteredTaskListIndex, editedTask);
		model.updateFilteredListToShowAll();
		return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
	}

	/**
	 * Creates and returns a {@code Task} with the details of {@code taskToEdit}
	 * edited with {@code editTaskDescriptor}.
	 *
	 * @throws IllegalValueException
	 */
	protected static Event createEditedTask(ReadOnlyEvent taskToEdit, EditTaskDescriptor editTaskDescriptor)
			throws CommandException {
		assert taskToEdit != null;

		if (taskToEdit.isRecurring()) {
			if (editTaskDescriptor.getStartTime().isPresent() || editTaskDescriptor.getEndTime().isPresent()
					|| editTaskDescriptor.getDeadline().isPresent()) {
				throw new CommandException(MESSAGE_ILLEGAL_EDIT_RECURRING_TASK);
			}
		}


		if (editTaskDescriptor.getRecurrence().isPresent()) {
			throw new CommandException(MESSAGE_ILLEGAL_EDIT_RECURRENCE);
		}

		Title updatedName = editTaskDescriptor.getName().orElseGet(taskToEdit::getTitle);
		Location updatedLocation = editTaskDescriptor.getLocation().orElseGet(taskToEdit::getLocation);
		Schedule updatedStartTime = editTaskDescriptor.getStartTime().orElseGet(taskToEdit::getStartTime);
		Schedule updatedEndTime = editTaskDescriptor.getEndTime().orElseGet(taskToEdit::getEndTime);
		Schedule updatedDeadline = editTaskDescriptor.getDeadline().orElseGet(taskToEdit::getDeadline);
		Description updatedDescription = editTaskDescriptor.getDescription().orElseGet(taskToEdit::getDescription);
		UniqueTagList updatedTags = editTaskDescriptor.getTags().orElseGet(taskToEdit::getTags);
		if (editTaskDescriptor.tags.isPresent() && updatedTags.isTagPresent()) {
			updatedTags.removeAndMerge(taskToEdit.getTags());
		}

		IsDone isDone = taskToEdit.getIsDone();
		// these fields are not editable therefore unchanged
		boolean isRecurring = taskToEdit.isRecurring();
		Recurrence recurrence = taskToEdit.getRecurrence();

		if ((editTaskDescriptor.getStartTime().isPresent() && editTaskDescriptor.getDeadline().isPresent())
				|| (editTaskDescriptor.getEndTime().isPresent() && editTaskDescriptor.getDeadline().isPresent())) {
			throw new CommandException(MESSAGE_ILLEGAL_DEADLINE_AND_EVENT_OBJECT);
		}

		if (editTaskDescriptor.getStartTime().isPresent() || editTaskDescriptor.getEndTime().isPresent()) {
			updatedDeadline = new Schedule("");
		}

		if (editTaskDescriptor.getDeadline().isPresent()) {
			updatedStartTime = new Schedule("");
			updatedEndTime = new Schedule("");
		}
		System.out.println(updatedStartTime.toString() + "||"+ updatedEndTime.toString() +"||"+ updatedDeadline.toString());
		return new Event(updatedName, updatedLocation, updatedStartTime, updatedEndTime, updatedDeadline,
				updatedDescription, updatedTags, isDone, isRecurring, recurrence);
	}

	/**
	 * Stores the details to edit the task with. Each non-empty field value will
	 * replace the corresponding field value of the task.
	 */
	public static class EditTaskDescriptor {
		private Optional<Title> name = Optional.empty();
		private Optional<Location> location = Optional.empty();
		private Optional<Schedule> deadline = Optional.empty();
		private Optional<Schedule> startTime = Optional.empty();
		private Optional<Schedule> endTime = Optional.empty();
		private Optional<Description> description = Optional.empty();
		Optional<UniqueTagList> tags = Optional.empty();
		private Optional<String> recurrence = Optional.empty();
		private IsDone isDone = new IsDone();

		public EditTaskDescriptor() {
		}

		public EditTaskDescriptor(EditTaskDescriptor toCopy) {
			this.name = toCopy.getName();
			this.location = toCopy.getLocation();
			this.deadline = toCopy.getDeadline();
			this.startTime = toCopy.getStartTime();
			this.endTime = toCopy.getEndTime();
			this.recurrence = toCopy.getRecurrence();
			this.description = toCopy.getDescription();
			this.tags = toCopy.getTags();
			this.isDone = toCopy.getIsDone();
		}

		/**
		 * Returns true if at least one field is edited.
		 */
		public boolean isAnyFieldEdited() {
			return CollectionUtil.isAnyPresent(this.name, this.location, this.startTime, this.endTime, this.deadline, this.description, this.tags, this.recurrence);
		}

		public void setName(Optional<Title> name) {
			assert name != null;
			this.name = name;
		}

		public Optional<Title> getName() {
			return name;
		}

		public void setLocation(Optional<Location> location) {
			assert location != null;
			this.location = location;
		}

		public Optional<Location> getLocation() {
			return location;
		}

		public void setStartTime(Optional<Date> dateTime) {
			if (dateTime.isPresent()) {
				this.startTime = Optional.of(new Schedule(dateTime.get()));
			} else {
				this.startTime = Optional.empty();
			}
		}

		public void setEndTime(Optional<Date> dateTime) {
			if (dateTime.isPresent()) {
				this.endTime = Optional.of(new Schedule(dateTime.get()));
			} else {
				this.endTime = Optional.empty();
			}
		}

		public void setDeadline(Optional<Date> dateTime) {
			if (dateTime.isPresent()) {
				this.deadline = Optional.of(new Schedule(dateTime.get()));
			} else {
				this.deadline = Optional.empty();
			}
		}

		public void setRecurrence(Optional<String> periodicity) {
			if (periodicity.isPresent()) {
				// this should not happen!
				this.recurrence = Optional.of(MESSAGE_ILLEGAL_EDIT_RECURRENCE);
			}
		}

		public Optional<Schedule> getStartTime() {
			return startTime;
		}

		public Optional<Schedule> getEndTime() {
			return endTime;
		}

		public void setDescription(Optional<Description> description) {
			assert description != null;
			this.description = description;
		}

		public Optional<Description> getDescription() {
			return description;
		}

		public Optional<Schedule> getDeadline() {
			return deadline;
		}

		public Optional<String> getRecurrence() {
			return this.recurrence;
		}

		public void setTags(Optional<UniqueTagList> tags) {
			assert tags != null;
			this.tags = tags;
		}

		public Optional<UniqueTagList> getTags() {
			return tags;
		}

		public IsDone getIsDone() {
			return isDone;
		}

		public IsDone markDone() {
			isDone.markDone();
			return isDone;
		}
	}

}
```
###### \src\main\java\org\teamstbf\yats\logic\parser\AddCommandParser.java
``` java
/**
 * Parses input arguments and creates a new AddCommand object
 */
public class AddCommandParser {

	public static final String MESSAGE_ADD_CONFLICTING_TIME = "Either -s/-e/-by OR -time should be used in add command.";
	public static final String MESSAGE_INCORRECT_TIME_SLOTS = "There can only be 1 or 2 time points after -time flag.";
	/**
	 * Parses the given {@code String} of arguments in the context of the
	 * AddCommand and returns an AddCommand object for execution.
	 */
	public Command parse(String args) {
		ArgumentTokenizer argsTokenizer = new ArgumentTokenizer(PREFIX_START_TIME, PREFIX_END_TIME, PREFIX_DEADLINE,
				PREFIX_LOCATION, PREFIX_DESCRIPTION, PREFIX_RECURRENCE, PREFIX_TAG, PREFIX_TIME_MULTIPLE);
		argsTokenizer.tokenize(args);
		try {
			HashMap<String, Object> addParam = new HashMap<>();
			addParam.put("name", argsTokenizer.getPreamble().get());
			addParam.put("location", argsTokenizer.getValue(PREFIX_LOCATION).orElse(null));
			addParam.put("start", ParserUtil.parseDateSingle(argsTokenizer.getValue(PREFIX_START_TIME)).orElse(null));
			addParam.put("end", ParserUtil.parseDateSingle(argsTokenizer.getValue(PREFIX_END_TIME)).orElse(null));
			addParam.put("deadline", ParserUtil.parseDateSingle(argsTokenizer.getValue(PREFIX_DEADLINE)).orElse(null));
			if ((ParserUtil.parseDateList(argsTokenizer.getValue(PREFIX_TIME_MULTIPLE)).isPresent())) {
				if (hasConflictingTimes(addParam)) {
					throw new IllegalValueException(MESSAGE_ADD_CONFLICTING_TIME);
				} else {
					fillTimeParameters(ParserUtil.parseDateList(argsTokenizer.getValue(PREFIX_TIME_MULTIPLE)).get(), addParam);
				}
			}
			addParam.put("description", argsTokenizer.getValue(PREFIX_DESCRIPTION).orElse(null));
			addParam.put("tag", ParserUtil.toSet(argsTokenizer.getAllValues(PREFIX_TAG)));
			addParam.put("recurrence", argsTokenizer.getValue(PREFIX_RECURRENCE).orElse(null));
			return new AddCommand(addParam);
		} catch (NoSuchElementException nsee) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
		} catch (IllegalValueException ive) {
			return new IncorrectCommand(ive.getMessage());
		}
	}

	/*
	 * Puts date contents inside list into addParam "start", "end", or "deadline"
	 */
	private void fillTimeParameters(List<Date> list, HashMap<String, Object> addParam) throws IllegalValueException {
		if (list.size() > SIZE_EVENT_TASK) {
			throw new IllegalValueException(MESSAGE_TOO_MANY_TIME);
		}
		if (list.size() == SIZE_DEADLINE_TASK) {
			addParam.put("deadline", list.get(INDEX_FIRST_DATE));
		} else if (list.size() == SIZE_EVENT_TASK) {
			addParam.put("start", list.get(INDEX_FIRST_DATE));
			addParam.put("end", list.get(INDEX_SECOND_DATE));
		} else {
			throw new IllegalValueException(MESSAGE_INCORRECT_TIME_SLOTS);
		}
	}

	private boolean hasConflictingTimes(HashMap<String, Object> addParam) {
		if (addParam.get("start") != null
				|| addParam.get("end") != null
				|| addParam.get("deadline") != null) {
			return true;
		}
		return false;
	}

}
```
###### \src\main\java\org\teamstbf\yats\model\item\Event.java
``` java
	/**
	 * Creates an Event object using map of parameters, only name is compulsory,
	 * others are optional
	 *
	 * @param map
	 *            of parameters
	 * @param tags
	 * @throws IllegalValueException
	 */

	public Event(HashMap<String, Object> parameters, UniqueTagList tags) throws IllegalValueException {
		assert !CollectionUtil.isAnyNull(parameters.get("name"));
		this.name = new Title((String) parameters.get("name"));
		// check optional parameters' existence
		if (parameters.get("location") != null) {
			this.location = new Location((String) parameters.get("location"));
		} else {
			this.location = new Location(" ");
		}
		if (parameters.get("description") != null) {
			this.description = new Description((String) parameters.get("description"));
		} else {
			this.description = new Description(" ");
		}
		this.isDone = new IsDone();
		this.tags = new UniqueTagList(tags);
		this.setPriority(1);
		// recurring task has start&end or a deadline
		fillStartEndDateAndDeadline(parameters);
		if (parameters.get("recurrence") != null) {
			this.isRecurring = true;
			fillRecurrence((String) parameters.get("recurrence"));
		} else {
			this.isRecurring = false;
			this.recurrence = new Recurrence();
		}
	}

	/**
	 *
	 * Every field must be present and not null.
	 *
	 */
	public Event(Title name, Location location, Schedule startTime, Schedule endTime, Schedule deadline,
			Description description, UniqueTagList tags, IsDone isDone) {
		assert !CollectionUtil.isAnyNull(name);
		this.name = name;
		this.location = location;
		this.startTime = startTime;
		this.endTime = endTime;
		this.deadline = deadline;
		this.description = description;
		this.isDone = isDone;
		this.tags = new UniqueTagList(tags); // protect internal tags from
		// changes in the arg list
	}

	@Override
	public boolean equals(Object other) {
		return other == this // short circuit if same object
				|| (other instanceof ReadOnlyEvent // instanceof handles nulls
						&& this.isSameStateAs((ReadOnlyEvent) other));
	}

	private void fillRecurrence(String period) throws IllegalValueException {
		// get current date and time
		Date startDate = new Date();
		// recurring event task
		if (this.hasStartAndEndTime()) {
			startDate = this.startTime.getDate();
		}
		// recurring deadline task will take current date as starting date
		this.recurrence = new Recurrence(startDate, period);
	}

	private void fillStartEndDateAndDeadline(HashMap<String, Object> parameters) throws IllegalValueException {
		// set start and end if present
		if (parameters.get("start") != null) {
			this.startTime = new Schedule((Date) parameters.get("start"));
		} else {
			this.startTime = new Schedule("");
		}
		if (parameters.get("end") != null) {
			this.endTime = new Schedule((Date) parameters.get("end"));
		} else {
			this.endTime = new Schedule("");
		}
		// set deadline if present
		if (parameters.get("deadline") != null) {
			this.deadline = new Schedule((Date) parameters.get("deadline"));
		} else {
			this.deadline = new Schedule("");
		}
		// assign default end if only start is given
		if (parameters.get("start") != null && parameters.get("end") == null) {
			this.endTime = new Schedule(addHoursToDate(this.startTime.getDate(), STEP_END_TIME));
		}
		// assign default start if only end is given
		if (parameters.get("start") == null && parameters.get("end") != null) {
			this.startTime = new Schedule(addHoursToDate(this.endTime.getDate(), STEP_START_TIME));
		}
	}

	private Date addHoursToDate(Date date, int hours) {
		Calendar tempCal = Calendar.getInstance();
		tempCal.setTime(date);
		tempCal.add(Calendar.HOUR_OF_DAY, hours);
		return tempCal.getTime();
	}

	public Event(ReadOnlyEvent editedReadOnlyEvent) {
		assert !CollectionUtil.isAnyNull(editedReadOnlyEvent.getTitle());
		this.name = editedReadOnlyEvent.getTitle();
		this.location = editedReadOnlyEvent.getLocation();
		this.startTime = editedReadOnlyEvent.getStartTime();
		this.endTime = editedReadOnlyEvent.getEndTime();
		this.deadline = editedReadOnlyEvent.getDeadline();
		this.description = editedReadOnlyEvent.getDescription();
		this.isDone = editedReadOnlyEvent.getIsDone();
		this.tags = new UniqueTagList(editedReadOnlyEvent.getTags()); // protect
		// internal
		// tags
		// from
		this.isRecurring = editedReadOnlyEvent.isRecurring();
		this.recurrence = editedReadOnlyEvent.getRecurrence();
	}

	/**
	 *
	 * Every field must be present and not null.
	 *
	 */
	public Event(Title name, Location location, Schedule startTime, Schedule endTime, Schedule deadline,
			Description description, UniqueTagList tags, IsDone isDone, boolean isRecurring, Recurrence recurrence) {
		assert !CollectionUtil.isAnyNull(name);
		this.name = name;
		this.location = location;
		this.startTime = startTime;
		this.endTime = endTime;
		this.deadline = deadline;
		this.description = description;
		this.isDone = isDone;
		this.tags = new UniqueTagList(tags); // protect internal tags from
		this.isRecurring = isRecurring;
		this.recurrence = recurrence;
		// changes in the arg list
	}

	@Override
	public Description getDescription() {
		return description;
	}

	@Override
	public Schedule getEndTime() {
		return endTime;
	}

	@Override
	public Location getLocation() {
		return location;
	}

	@Override
	public Schedule getStartTime() {
		return startTime;
	}

	@Override
	public UniqueTagList getTags() {
		return new UniqueTagList(tags);
	}

	@Override
	public Title getTitle() {
		return name;
	}

	@Override
	public Recurrence getRecurrence() {
		return this.recurrence;
	}

	@Override
	public int hashCode() {
		// use this method for custom fields hashing instead of implementing
		// your own
		return Objects.hash(name, location, startTime, endTime, description, tags, recurrence);
	}

	/**
	 *
	 * Updates this person with the details of {@code replacement}.
	 *
	 */

	public void resetData(ReadOnlyEvent replacement) {
		assert replacement != null;
		this.setTitle(replacement.getTitle());
		this.setLocation(replacement.getLocation());
		this.setStartTime(replacement.getStartTime());
		this.setEndTime(replacement.getEndTime());
		this.setDeadline(replacement.getDeadline());
		this.setDescription(replacement.getDescription());
		this.setTags(replacement.getTags());
		this.setIsDone(replacement.getIsDone());
		this.isRecurring = replacement.isRecurring();
		this.recurrence = replacement.getRecurrence();
	}

	private void setIsDone(IsDone done) {
		this.isDone = done;
	}

	public void setDescription(Description description) {
		assert description != null;
		this.description = description;
	}

	public void setEndTime(Schedule schedule) {
		assert schedule != null;
		this.endTime = schedule;
	}

	public void setLocation(Location location) {
		assert location != null;
		this.location = location;
	}

	public void setStartTime(Schedule schedule) {
		assert schedule != null;
		this.startTime = schedule;
	}

	public void setDeadline(Schedule schedule) {
		assert schedule != null;
		this.deadline = schedule;
	}

	public void setRecurrence(Recurrence recurrence) {
		assert recurrence != null;
		this.recurrence = recurrence;
	}

	/**
	 *
	 * Replaces this person's tags with the tags in the argument tag list.
	 *
	 */
	public void setTags(UniqueTagList replacement) {
		tags.setTags(replacement);
	}

	public void setTitle(Title name) {
		assert name != null;
		this.name = name;
	}

	@Override
	public String toString() {
		return getAsText();
	}

	@Override
	public IsDone getIsDone() {
		return this.isDone;
	}

	@Override
	public void markDone() {
		if (this.isRecurring) {
			this.recurrence.markOccurenceDone();
		} else {
			this.isDone.markDone();
		}
	}

	@Override
	public Schedule getDeadline() {
		return this.deadline;
	}

	public Integer getPriority() {
		return priority;
	}

	public void setPriority(Integer priority) {
		this.priority = priority;
	}

	@Override
	public boolean hasDeadline() {
		if (this.deadline.toString().equals("")) {
			return false;
		}
		return true;
	}

	@Override
	public boolean hasStartAndEndTime() {
		if (this.startTime.toString().equals("") || this.endTime.toString().equals("")) {
			return false;
		}
		return true;
	}

	@Override
	public boolean hasStartOrEndTime() {
		if (this.startTime.toString().equals("") && this.endTime.toString().equals("")) {
			return false;
		}
		return true;
	}

	@Override
	public boolean isRecurring() {
		return this.isRecurring;
	}

}
```
###### \src\main\java\org\teamstbf\yats\model\item\Recurrence.java
``` java
public class Recurrence {

	public static final String RECURRENCE_NONE = "none";
	public static final String RECURRENCE_DAY = "daily";
	public static final String RECURRENCE_WEEK = "weekly";
	public static final String RECURRENCE_MONTH = "monthly";
	public static final String RECURRENCE_YEAR = "yearly";
	public static final int RECURRENCE_INCREMENT = 1;
	public static final String MESSAGE_RECURRENCE_DATE_CONSTRAINTS = "Recurrence date must be in dd/MM/yyyy format.";
	public static final String MESSAGE_RECURRENCE_CONSTRAINTS = "Recurrence must be none, daily, weekly, monthly or yearly";
	public static final String RECURRENCE_VALIDATION_REGEX = ".*(none|daily|weekly|monthly|yearly).*";
	public static final String RECURRENCE_DATE_FORMAT = "dd/MM/yyyy";
	public static final String DELIMITER_DONE_LIST = ",";
	public static final String STRING_EMPTY = "";

	Date startDate;
	String periodicity;
	List<String> doneList;
	static SimpleDateFormat dateFormat = new SimpleDateFormat(RECURRENCE_DATE_FORMAT);
	int recurrencePeriod;

	/*
	 * Creates an empty Recurrence object
	 */
	public Recurrence() {
		this.startDate = new Date(Long.MIN_VALUE);
		this.periodicity = RECURRENCE_NONE;
		this.doneList = new ArrayList<String>();
	}

	public Recurrence(Date date, String recurrence) throws IllegalValueException {
		if (!isValidPeriod(recurrence)) {
			throw new IllegalValueException(MESSAGE_RECURRENCE_CONSTRAINTS);
		}

		this.startDate = date;
		this.periodicity = recurrence;
		setPeriod(recurrence);
		this.doneList = new ArrayList<String>();
	}

	public Recurrence(String startDate, String periodicity, String doneList) throws IllegalValueException {
		try {
			this.startDate = dateFormat.parse(startDate);
		} catch (ParseException pe) {
			throw new IllegalValueException(MESSAGE_RECURRENCE_DATE_CONSTRAINTS);
		}
		if (!isValidPeriod(periodicity)) {
			throw new IllegalValueException(MESSAGE_RECURRENCE_CONSTRAINTS);
		}
		this.periodicity = periodicity;
		setPeriod(periodicity);
		this.doneList = getDoneListFromString(doneList);
	}

	private List<String> getDoneListFromString(String doneListString) {
		// return an empty List if string is empty
		if (doneListString.equals(STRING_EMPTY)) {
			return new ArrayList<String>();
		}
		return new ArrayList<String>(Arrays.asList(doneListString.split(DELIMITER_DONE_LIST)));
	}

	public static boolean isValidPeriod(String recurrence) {
		return recurrence.matches(RECURRENCE_VALIDATION_REGEX);
	}

	private void setPeriod(String recurrence) throws IllegalValueException {
		if (this.periodicity.equals(RECURRENCE_DAY)) {
			this.recurrencePeriod = Calendar.DAY_OF_WEEK;
		} else if (this.periodicity.equals(RECURRENCE_WEEK)) {
			this.recurrencePeriod = Calendar.WEEK_OF_YEAR;
		} else if (this.periodicity.equals(RECURRENCE_MONTH)) {
			this.recurrencePeriod = Calendar.MONTH;
		} else if (this.periodicity.equals(RECURRENCE_YEAR)) {
			this.recurrencePeriod = Calendar.YEAR;
		} else {
			throw new IllegalValueException(MESSAGE_RECURRENCE_CONSTRAINTS);
		}
	}

	public boolean hasOccurenceOn(Date day) {
		throw new UnsupportedOperationException();
	}

	public String getStartTimeString() {
		return this.dateFormat.format(startDate);
	}

	public String getPeriodicity() {
		return this.periodicity;
	}

	public String getDoneListString() {
		if (this.doneList.isEmpty()) {
			return STRING_EMPTY;
		}
		StringBuilder sb = new StringBuilder();
		for (String doneDate : this.doneList) {
			sb.append(doneDate);
			sb.append(DELIMITER_DONE_LIST);
		}
		return sb.toString();
	}

	public List<Date> getOccurenceBetween(Date start, Date end) {
		List<Date> occurenceList = new ArrayList<Date>();
		Calendar startTime = Calendar.getInstance();
		Calendar startBound = Calendar.getInstance();
		Calendar endBound = Calendar.getInstance();
		startTime.setTime(this.startDate);
		startBound.setTime(start);
		endBound.setTime(end);

		for (Date date = startTime.getTime(); startTime.before(endBound); startTime.add(recurrencePeriod,
				RECURRENCE_INCREMENT), date = startTime.getTime()) {
			if (date.before(end) && date.after(start)) {
				occurenceList.add(date);
			}
		}

		return occurenceList;
	}

	public String getLatestUndoneDateString() {
		if (doneList.isEmpty()) {
			return dateFormat.format(startDate);
		}
		String lastDateString = doneList.get(doneList.size() - 1);
		Calendar lastCalendar = Calendar.getInstance();
		try {
			lastCalendar.setTime(dateFormat.parse(lastDateString));
		} catch (ParseException pe) {
			// TODO: handle parse exception
			;
		}
		return dateFormat.format(getNextOccurence(lastCalendar).getTime());
	}

	public Date getLatestUndoneDate() throws ParseException {
		return dateFormat.parse(getLatestUndoneDateString());
	}

	public Calendar getNextOccurence(Calendar occurence) {
		occurence.add(this.recurrencePeriod, RECURRENCE_INCREMENT);
		return occurence;
	}

	public void markOccurenceDone() {
		// if no occurence yet, mark the start date as done
		if (doneList.isEmpty()) {
			doneList.add(dateFormat.format(this.startDate));
		} else {
			doneList.add(getLatestUndoneDateString());
		}
	}

	public void markOccurenceUndone() throws NoSuchElementException {
		if (this.doneList.isEmpty()) {
			throw new NoSuchElementException();
		}
		// remove last occurence
		this.doneList.remove(doneList.size() - 1);
	}

	public boolean hasDoneOccurence() {
		return !doneList.isEmpty();
	}

}
```
###### \src\main\java\org\teamstbf\yats\model\item\Schedule.java
``` java
	/*
	 * Creates a Schedule object from the Date object given. Date can be null.
	 */
	public Schedule(Date dateObject) {
		this.scheduleDate = dateObject;
	}

	public String getTimeOnlyString() {
		return FORMATTER_TIME.format(scheduleDate);
	}

	public Schedule(String timeString) {
		validateDate(timeString);
		try {
			this.scheduleDate = STRING_EMPTY.equals(timeString) ? null : FORMATTER_DATE.parse(timeString);
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	@Override
	public boolean equals(Object other) {
		return other == this // short circuit if same object
				|| (other instanceof Schedule // instanceof handles nulls
						&& this.toString().equals(((Schedule) other).toString())); // state
		// check
	}

	/*
	 * public SimpleDate getDate() { return this.date; } public Timing getTime()
	 * { return this.time; } public String getValue() { return this.value; }
	 */

	@Override
	public int hashCode() {
		return this.scheduleDate.hashCode();
	}

	/*
	 * public void setDate(SimpleDate endTime) { this.date = endTime; } public
	 * void setTime(Timing startTime) { this.time = startTime; }
	 */

	@Override
	public String toString() {
		if (this.scheduleDate == null) {
			return STRING_EMPTY;
		} else if (this.scheduleDate.equals("")) {
			return STRING_EMPTY;
		}

		String dateString = FORMATTER_DATE.format(this.scheduleDate);
		return dateString;
	}

	public Date getDate() {
		return this.scheduleDate;
	}

```
