# A0163848R
###### /java/seedu/address/logic/Logic.java
``` java
    /**
     * Retrieves the current YTomorrow state.
     */
    ReadOnlyAddressBook getYTomorrow();
    
    /**
     * Overwrites the current YTomorrow.
     * @param YTomorrow to overwrite with
     */
    void setYTomorrow(ReadOnlyAddressBook set);
    
    /**
     * Adds entries to the current YTomorrow.
     * @param YTomorrow to add entries from
     */
    void importYTomorrow(ReadOnlyAddressBook add);
    
}
```
###### /java/seedu/address/logic/LogicManager.java
``` java
    @Override
    public ReadOnlyAddressBook getYTomorrow() {
        return model.getAddressBook();
    }
    
    @Override
    public void setYTomorrow(ReadOnlyAddressBook set) {
        model.resetData(set);
    }
    
    @Override
    public void importYTomorrow(ReadOnlyAddressBook add) {
        model.mergeYTomorrow(add);
    }
}
```
###### /java/seedu/address/logic/parser/RedoCommandParser.java
``` java
/**
 * Parses input arguments and creates a new DeleteCommand object
 */
public class RedoCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the RedoCommand
     * and returns an RedoCommand object for execution.
     */
    public Command parse(String args) {
        try {
            return new RedoCommand();
        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
    }

}
```
###### /java/seedu/address/logic/parser/DeleteCommandParser.java
``` java
        ArgumentTokenizer argsTokenizer =
                new ArgumentTokenizer();
        argsTokenizer.tokenize(args);
```
###### /java/seedu/address/logic/parser/UnmarkCommandParser.java
``` java
        return new UnmarkCommand(index.get());
    }
}
```
###### /java/seedu/address/logic/parser/Parser.java
``` java
        case MarkCommand.COMMAND_WORD:
            return new MarkCommandParser().parse(arguments);

        case UnmarkCommand.COMMAND_WORD:
            return new UnmarkCommandParser().parse(arguments);

        case UndoCommand.COMMAND_WORD:
            return new UndoCommandParser().parse(arguments);

        case RedoCommand.COMMAND_WORD:
            return new RedoCommandParser().parse(arguments);
```
###### /java/seedu/address/logic/parser/UndoCommandParser.java
``` java
/**
 * Parses input arguments and creates a new DeleteCommand object
 */
public class UndoCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the UndoCommand
     * and returns an UndoCommand object for execution.
     */
    public Command parse(String args) {
        try {
            return new UndoCommand();
        } catch (NoSuchElementException nsee) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }
    }

}
```
###### /java/seedu/address/logic/parser/MarkCommandParser.java
``` java
        return new MarkCommand(index.get());
    }
}
```
###### /java/seedu/address/logic/commands/RedoCommand.java
``` java
/**
 * Command that redoes changes caused by the last command.
 */
public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Undoes the changes made by the last command.\n";
    public static final String REDO_SUCCESS = "Redo!";
    public static final String REDO_FAILURE = "Nothing to redo!";

    public RedoCommand() {
    }

    @Override
    public CommandResult execute() throws CommandException {
        boolean result = model.redoLastModification();

        return new CommandResult(result ? REDO_SUCCESS : REDO_FAILURE);
    }

}
```
###### /java/seedu/address/logic/commands/UndoCommand.java
``` java
/**
 * Command that undoes changes caused by the last command.
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Undoes the changes made by the last command.\n";
    public static final String UNDO_SUCCESS = "Undo!";
    public static final String UNDO_FAILURE = "Nothing to undo!";

    public UndoCommand() {
    }

    @Override
    public CommandResult execute() throws CommandException {
        boolean result = model.undoLastModification();

        return new CommandResult(result ? UNDO_SUCCESS : UNDO_FAILURE);
    }

}
```
###### /java/seedu/address/logic/commands/DeleteCommand.java
``` java
        try {
            this.targetIndex = Integer.parseInt(token);
        } catch (NumberFormatException e) {
            this.targetName = token;
        }
```
###### /java/seedu/address/logic/commands/DeleteCommand.java
``` java
        if (targetIndex != null && lastShownList.size() < targetIndex) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyPerson personToDelete = null;
        if (targetIndex != null) personToDelete = lastShownList.get(targetIndex - 1);
        if (targetName != null) personToDelete = getPersonByName(lastShownList, targetName);
```
###### /java/seedu/address/logic/commands/UnmarkCommand.java
``` java
/**
 * Command that marks task as incomplete
 */
public class UnmarkCommand extends Command {

    public static final String COMMAND_WORD = "unmark";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Marks as incomplete the task identified "
            + "by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_MARK_PERSON_SUCCESS = "Unmarked task: %1$s";
    public static final String MESSAGE_DUPLICATE_PERSON = "This task is already incomplete.";

    private final int filteredPersonListIndex;

    /**
     * @param filteredPersonListIndex the index of the person in the filtered person list to edit
     * @param editPersonDescriptor details to edit the person with
     */
    public UnmarkCommand(int filteredPersonListIndex) {
        assert filteredPersonListIndex > 0;

        // converts filteredPersonListIndex from one-based to zero-based.
        this.filteredPersonListIndex = filteredPersonListIndex - 1;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyPerson> lastShownList = model.getFilteredPersonList();

        if (filteredPersonListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyPerson personToEdit = lastShownList.get(filteredPersonListIndex);
        Task editedPerson = createUnmarkedPerson(personToEdit);

        try {
            model.updatePerson(filteredPersonListIndex, editedPerson);
        } catch (UniquePersonList.DuplicatePersonException dpe) {
            throw new CommandException(MESSAGE_DUPLICATE_PERSON);
        }
        model.updateFilteredListToShowAll();
        return new CommandResult(String.format(MESSAGE_MARK_PERSON_SUCCESS, personToEdit));
    }

    /**
     * Creates and returns a {@code Person} with the details of {@code personToEdit}
     * edited to be complete.
     */
    private static Task createUnmarkedPerson(ReadOnlyPerson personToEdit) {
        assert personToEdit != null;

        UniqueTagList updatedTags =
                personToEdit
                .getTags()
                .except(UniqueTagList.build(
                                Tag.TAG_COMPLETE,
                                Tag.TAG_INCOMPLETE));

        try {
            updatedTags.add(new Tag(Tag.TAG_INCOMPLETE));
        } catch (DuplicateTagException e) {
            e.printStackTrace();
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }

        return new Task(personToEdit.getName(),
                personToEdit.getStartDate(), personToEdit.getEndDate(), personToEdit.getEmail(), personToEdit.getGroup(), updatedTags);
    }
}
```
###### /java/seedu/address/logic/commands/MarkCommand.java
``` java
/**
 * Command that marks a task as complete.
 */
public class MarkCommand extends Command {

    public static final String COMMAND_WORD = "mark";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Marks as complete the task identified "
            + "by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_MARK_PERSON_SUCCESS = "Marked task: %1$s";
    public static final String MESSAGE_DUPLICATE_PERSON = "This task is already complete.";

    private final int filteredPersonListIndex;

    /**
     * @param filteredPersonListIndex the index of the person in the filtered person list to edit
     * @param editPersonDescriptor details to edit the person with
     */
    public MarkCommand(int filteredPersonListIndex) {
        assert filteredPersonListIndex > 0;

        // converts filteredPersonListIndex from one-based to zero-based.
        this.filteredPersonListIndex = filteredPersonListIndex - 1;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyPerson> lastShownList = model.getFilteredPersonList();

        if (filteredPersonListIndex >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyPerson personToEdit = lastShownList.get(filteredPersonListIndex);
        Task editedPerson = createMarkedPerson(personToEdit);

        try {
            model.updatePerson(filteredPersonListIndex, editedPerson);
        } catch (UniquePersonList.DuplicatePersonException dpe) {
            throw new CommandException(MESSAGE_DUPLICATE_PERSON);
        }
        model.updateFilteredListToShowAll();
        return new CommandResult(String.format(MESSAGE_MARK_PERSON_SUCCESS, personToEdit));
    }

    /**
     * Creates and returns a {@code Person} with the details of {@code personToEdit}
     * edited to be complete.
     */
    private static Task createMarkedPerson(ReadOnlyPerson personToEdit) {
        assert personToEdit != null;

        UniqueTagList updatedTags =
                personToEdit
                .getTags()
                .except(UniqueTagList.build(
                                Tag.TAG_COMPLETE,
                                Tag.TAG_INCOMPLETE));

        try {
            updatedTags.add(new Tag(Tag.TAG_COMPLETE));
        } catch (DuplicateTagException e) {
            e.printStackTrace();
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }

        return new Task(personToEdit.getName(),
                personToEdit.getStartDate(), personToEdit.getEndDate(), personToEdit.getEmail(), personToEdit.getGroup(), updatedTags);
}
}
```
###### /java/seedu/address/commons/core/GuiSettings.java
``` java
    public String getStyleSheet() {
        return styleSheet;
    }
    
    public String getLastLoadedYTomorrow() {
        return lastLoadedYTomorrow;
    }
    
    public void setStyleSheet(String path) {
        styleSheet = path;
    }
    
    public void setLastLoadedYTomorrow(String path) {
        lastLoadedYTomorrow = path;
    }
```
###### /java/seedu/address/commons/events/ui/ImportRequestEvent.java
``` java
/**
* Represents a request to retrieve the file at the stored path.
*/
public class ImportRequestEvent extends BaseEvent {

    private YTomorrow toImport;
    private File target;
    
    public ImportRequestEvent(YTomorrow toImport, File target) {
        this.toImport = toImport;
        this.target = target;
    }
    
    public void writeYTomorrow(YTomorrow toWrite) {
        toImport.resetData(toWrite);;
    }
    
    public File getTargetFile() {
        return target;
    }

    @Override
    public String toString() {
        return "Imported YTomorrow: " + target.toString();
    }
}
```
###### /java/seedu/address/commons/events/ui/ExportRequestEvent.java
``` java
/**
 * Represents a request to export the stored YTomorrow.
 */
public class ExportRequestEvent extends BaseEvent {
    
    private ReadOnlyAddressBook toExport;
    private File target;
    
    public ExportRequestEvent(ReadOnlyAddressBook toExport, File target) {
        this.toExport = toExport;
        this.target = target;
    }
    
    public ReadOnlyAddressBook getYTomorrowToExport() {
        return toExport;
    }
    
    public File getTargetFile() {
        return target;
    }

    @Override
    public String toString() {
        return "Exported YTomorrow: " + target.toString();
    }

}
```
###### /java/seedu/address/commons/events/ui/TargetFileRequestEvent.java
``` java
/**
* Represents a request to save changes to the stored path.
*/
public class TargetFileRequestEvent extends BaseEvent {

    File target;
    UserPrefs prefs;
    
    public TargetFileRequestEvent(File target, UserPrefs prefs) {
        this.target = target;
        this.prefs = prefs;
    }
    
    public File getTargetFile() {
        return target;
    }
    
    public UserPrefs getUserPrefs() {
        return prefs;
    }
    
    @Override
    public String toString() {
        return "Targeting new YTomorrow file: " + target.toString();
    }

}
```
###### /java/seedu/address/commons/util/DateUtil.java
``` java
public class DateUtil {
    public static Date parse(String rawDate) throws IllegalValueException {
        try {
            Parser parser = new Parser();
            List<DateGroup> groups = parser.parse(rawDate);
            Date date = groups.get(0).getDates().get(0);
            return date;
        } catch (IndexOutOfBoundsException e) {
            throw new IllegalValueException("Date not valid!");
        }
    }
    
    public static Date add(Date date, int days) {
        Calendar c = Calendar.getInstance();
        c.setTime(date);
        c.add(Calendar.DATE, days);
        return c.getTime();
    }
}
```
###### /java/seedu/address/commons/util/CollectionUtil.java
``` java
    /**
     * Returns first occurrence of the given type in the array.
     * @param Collection to search.
     * @param Type to find.
     * @return First object of given type, or null if not found.
     */
    public static <T> T firstOf(Object[] items, Class<T> type) {
        for (Object el : items) {
            if (type.isInstance(el)) {
                return type.cast(el);
            }
        }
        return null;
    }
    
    public static String getRandom(String[] strs, Random r) {
        return strs[r.nextInt(strs.length)];
    }
    
}
```
###### /java/seedu/address/commons/util/FileUtil.java
``` java
    /**
     * Creates a localized window to create a file for saving.
     * @param Window title
     * @param File extension filters
     * @return Chosen file
     */
    public static File promptSaveFileDialog(String title, Stage stage, ExtensionFilter ...extensionFilters) {
        return getFileChooser(title, extensionFilters).showSaveDialog(stage);
    }
    
    /**
     * Creates a localized window to select a file for loading.
     * @param Window title
     * @param File extension filters
     * @return Chosen file
     */
    public static File promptOpenFileDialog(String title, Stage stage, ExtensionFilter ...extensionFilters) {
        return getFileChooser(title, extensionFilters).showOpenDialog(stage);
    }

    private static FileChooser getFileChooser(String title, ExtensionFilter ...extensionFilters) {
        FileChooser fileChooser = new FileChooser();
        
        fileChooser.setTitle(title);
        fileChooser.getExtensionFilters().addAll(extensionFilters);
        
        return fileChooser;
    }
}
```
###### /java/seedu/address/model/task/DeadlineTask.java
``` java
/**
 * Represents a Deadline Task in the YTomorrow.
 */
public class DeadlineTask extends Task {
    public DeadlineTask(Name name, EndDate end, Email email, Group group, UniqueTagList tags) {
        super(name, null, end, email, group, tags);
    }
}
```
###### /java/seedu/address/model/task/Task.java
``` java
    public static Task factory(Object ...properties) throws IllegalValueException {
        Name name = CollectionUtil.firstOf(properties, Name.class);
        Email email = CollectionUtil.firstOf(properties, Email.class);
        Group group = CollectionUtil.firstOf(properties, Group.class);
        UniqueTagList tags = CollectionUtil.firstOf(properties, UniqueTagList.class);
        StartDate start = CollectionUtil.firstOf(properties, StartDate.class);
        EndDate end = CollectionUtil.firstOf(properties, EndDate.class);
        
        if (CollectionUtil.isAnyNull(name, group, tags)) {
            throw new IllegalValueException("Task Factory: new task requires a name, group, and tag list");
        }
        
        if (start != null && end != null) {
            return new Task(name, start, end, email, group, tags);
        } else if (start == null && end != null) {
            return new DeadlineTask(name, end, email, group, tags);
        } else if (start == null && end == null) {
            return new FloatingTask(name, email, group, tags);
        }
        
        return null;
    }

}
```
###### /java/seedu/address/model/task/EndDate.java
``` java
/**
* Represents an End Date in the YTomorrow.
*/
public class EndDate extends Date {
    public EndDate(String date) throws IllegalValueException {
        super(date);
    }
}
```
###### /java/seedu/address/model/task/FloatingTask.java
``` java
/**
 * Represents a Floating Task in the YTommorow.
 */
public class FloatingTask extends Task {
    public FloatingTask(Name name, Email email, Group group, UniqueTagList tags) {
        super(name, null, null, email, group, tags);
    }
}
```
###### /java/seedu/address/model/task/StartDate.java
``` java
/**
 * Represents a Start Date in the YTomorrow.
 */
public class StartDate extends Date {
    public StartDate(String date) throws IllegalValueException {
        super(date);
    }
}
```
###### /java/seedu/address/model/History.java
``` java
/**
 * Data structure for undo/redo history
 * @param <T> State type to save
 */
public class History<T> {

    private Node<T> current = null;

    /**
     * Moves current state back one push.
     * @return State after undo
     */
    public T undo() {
        if (current == null) {
            return null;
        }

        Node<T> prev = current.getPrevious();
        if (prev == null) {
            return null;
        } else {
            current = prev;
            return prev.getElement();
        }
    }

    /**
     * Moves current state forward one push.
     * @return State after redo
     */
    public T redo() {
        if (current == null) {
            return null;
        }

        Node<T> next = current.getNext();
        if (next == null) {
            return null;
        } else {
            current = next;
            return next.getElement();
        }
    }

    /**
     * @return Current state
     */
    public T at() {
        if (current != null) {
            return current.getElement();
        } else {
            return null;
        }
    }

    public void push(T next) {
        Node<T> nextNode = new Node<T>(next);

        if (current != null) {
            nextNode.setPrevious(current);
            current.setNext(nextNode);
        }

        current = nextNode;
    }

    /**
     * @return Total number of saved states
     */
    public int size() {
        return 1 + sizePrev(current) + sizeNext(current);
    }

    private int sizePrev(Node source) {
        return source.getPrevious() == null ? 0 : 1 + sizePrev(source.getPrevious());
    }

    private int sizeNext(Node source) {
        return source.getNext() == null ? 0 : 1 + sizePrev(source.getNext());
    }

    /**
     * Double linked list node
     * @param <T> Element type to store
     */
    private class Node<T> {

        private T element;

        private Node<T> prev = null;
        private Node<T> next = null;

        public Node(T element) {
            this.element = element;
        }

        public T getElement() {
            return element;
        }

        public Node<T> getPrevious() {
            return prev;
        }

        public Node<T> getNext() {
            return next;
        }

        public void setNext(Node<T> next) {
            this.next = next;
        }

        public void setPrevious(Node<T> prev) {
            this.prev = prev;
        }

    }
}
```
###### /java/seedu/address/model/ModelManager.java
``` java
        history.push(addressBook);
```
###### /java/seedu/address/model/ModelManager.java
``` java
    @Override
    public boolean undoLastModification() {
        ReadOnlyAddressBook undone = history.undo();
        if (undone != null) {
            addressBook.resetData(undone);
            return true;
        }
        return false;
    }

    @Override
    public boolean redoLastModification() {
        ReadOnlyAddressBook redone = history.redo();
        if (redone != null) {
            addressBook.resetData(redone);
            return true;
        }
        return false;
    }
    
    @Override
    public void mergeYTomorrow(ReadOnlyAddressBook add) {
        for (ReadOnlyPerson readOnlyTask : add.getPersonList()) {
            Task task = new Task(readOnlyTask);
            try {
                addressBook.addPerson(task);
            } catch (DuplicatePersonException e) {
                try {
                    addressBook.removePerson(task);
                    addressBook.addPerson(task);
                } catch (PersonNotFoundException | DuplicatePersonException el) {
                }
                
            }
        }
        indicateAddressBookChanged();
    }
```
###### /java/seedu/address/model/Model.java
``` java

    /** Undoes the last modification made to the AddressBook. Returns if there is anything to undo. */
    boolean undoLastModification();

    /** Redoes the last modification made to the AddressBook. Returns if there is anything to redo. */
    boolean redoLastModification();

    /** Adds the current AddressBook state to the undo/redo history */
    void addToHistory(ReadOnlyAddressBook state);
    
    /** Adds entries from the given YTomorrow to the current YTomorrow and updates equivalent entries. */
    void mergeYTomorrow(ReadOnlyAddressBook add);

}
```
###### /java/seedu/address/model/util/TaskNameGenerator.java
``` java
public class TaskNameGenerator {
    private static final String[] ACTIONS = {
            "Walk",
            "Study",
            "Talk",
            "Chat",
            "Take photos",
            "Eat",
            "Parkour",
            "Makan",
            "Cram study",
            "Take test",
            "Meet",
            "Exercise",
            "Shop",
            "Play Minecraft",
            "Figure out travel plans",
    };
    
    private static final String[] NAMES = {
            "George P. Burdell",
            "Tony",
            "Malik",
            "Cheuk Ting",
            "Ali",
            "Rabab",
            "Alia",
            "Mohsin",
            "Ellie",
            "Sarah",
            "Satoshi",
            "Mars",
            "Elon Musk",
            "Jaden",
            "Chris",
            "Cristina",
            "Husain",
            "class",
            "project group",
    };
    
    private static final String[] PLACES = {
            "Woodys",
            "Tech Tower",
            "MBS",
            "PGP",
            "Techno Edge",
            "japanese restaurant",
            "hotpot restaurant",
            "Central Library",
            "Yishun",
            "Punggol",
            "Sentosa",
    };
    
    private static Random r;
    
    private TaskNameGenerator previous;
    private String state;
    
    private TaskNameGenerator(TaskNameGenerator previous, String state) {
        this.previous = previous;
        this.state = state;
    }
    
    @Override
    public String toString() {
        return (previous != null ? previous.toString() + " " : "") + state;
    }
    
    public static TaskNameGenerator doAction(Random r) {
        return doAction(r, CollectionUtil.getRandom(ACTIONS, r));
    }
    
    public static TaskNameGenerator doAction(Random r, String action) {
        TaskNameGenerator.r = r;
        return new TaskNameGenerator(null, action);
    }
    
    public TaskNameGenerator with() {
        return with(CollectionUtil.getRandom(NAMES, r));
    }
    
    public TaskNameGenerator with(String name) {
        return new TaskNameGenerator(this, "with " + name);
    }
    
    public TaskNameGenerator in() {
        return in(CollectionUtil.getRandom(PLACES, r));
    }
    
    public TaskNameGenerator in(String place) {
        return new TaskNameGenerator(this, "in " + place);
    }
    
    public TaskNameGenerator maybe() {
        return maybe(0.5f);
    }
    
    public TaskNameGenerator maybe(float chance) {
        if (r.nextFloat() > chance) {
            if (previous == null) {
                state = "";
            } else {
                return previous;
            }
        }
        return this;
    }
    
}
```
###### /java/seedu/address/model/util/TaskGroupGenerator.java
``` java
public class TaskGroupGenerator {
    
    private static final String[] GROUPS = {
            "Vacation",
            "School",
            "Family",
            "Plans",
            "Hobbies",
            "ES",
    };
    
    public static String getGroup(Random r) {
        return CollectionUtil.getRandom(GROUPS, r);
    }
    
}
```
###### /java/seedu/address/model/util/SampleDataUtil.java
``` java

public class SampleDataUtil {
    
    private static final int SAMPLE_SIZE = 50;
    
    Random r;
    
    public static Iterable<Task> getSampleTasks(int n) {
        List<Task> generated = new ArrayList<Task>(n);
        for (int i = 0; i < n; i++) {
            Task t = generateRandomTask();
            if (!generated.contains(t)) {
                generated.add(t);
            } else {
                i--;
            }
        }
        return generated;
    }
    
    /**
     * @return a randomly-generated task
     * @throws IllegalValueException
     */
    private static Task generateRandomTask() {
        Random r = new Random();
        boolean addStartDate = r.nextBoolean();
        boolean addEndDate = r.nextBoolean();
        
        try {
            
            return Task.factory(
                    new Name(TaskNameGenerator.doAction(r).with().maybe(0.75f).in().maybe(0.75f).toString()),
                    addStartDate && addEndDate ?  new StartDate(TaskDateGenerator.getStartDate(r)) : null,
                    addEndDate ? new EndDate(TaskDateGenerator.getEndDate(r)) : null,
                    new Group(TaskGroupGenerator.getGroup(r)),
                    UniqueTagList.build(r.nextBoolean() ? Tag.TAG_COMPLETE : Tag.TAG_INCOMPLETE));
          
        } catch (IllegalValueException e) {
            return generateRandomTask();
        }
    }
```
###### /java/seedu/address/model/util/TaskDateGenerator.java
``` java
public class TaskDateGenerator {

    private static final int MAX_DAYS_TO_ADD = 255;

    private static final String[] STARTDATES = {
            "today",
            "tomorrow",
            "yesterday",
            "day after tomorrow",
            "next year",
            "last year",
            "this year",
            "april 1",
            "may 28",
            "monday",
            "tuesday",
            "wednesday",
            "thursday",
            "friday",
            "saturday",
            "sunday",
            "0000-00-00",
            "1000-00-00",
            "1234-12-12",
            "1977-05-15",
            "2024-09-22",
            "2199-02-05",
            "12017.04.06",
    };
    
    private static Random r;
    
    private static Date lastStartDate;
    
    public static String getStartDate(Random r) {
        TaskDateGenerator.r = r;
        
        try {
            lastStartDate = DateUtil.parse(CollectionUtil.getRandom(STARTDATES, r));
        } catch (IllegalValueException e) {
            return getStartDate(r);
        }
        
        return lastStartDate.toString();
    }
    
    public static String getEndDate(Random r) {
        if (lastStartDate == null) {
            getStartDate(r);
        }
        
        return DateUtil.add(lastStartDate, r.nextInt(MAX_DAYS_TO_ADD + 1)).toString();
    }
}
```
###### /java/seedu/address/model/tag/Tag.java
``` java
    public static final String TAG_COMPLETE = "complete";
    public static final String TAG_INCOMPLETE = "incomplete";
```
###### /java/seedu/address/model/tag/UniqueTagList.java
``` java
    /**
     * Creates copy of this tag list containing all tags except those in the passed tag list
     */
    public UniqueTagList except(UniqueTagList except) {
        UniqueTagList remaining = new UniqueTagList();

        for (Tag tag : except) {
            if (except.contains(tag)) continue;

            try {
                remaining.add(new Tag(tag.tagName));
            } catch (DuplicateTagException e) {
                e.printStackTrace();
            } catch (IllegalValueException e) {
                e.printStackTrace();
            }
        }

        return remaining;
    }
```
###### /java/seedu/address/model/tag/UniqueTagList.java
``` java
    /**
     * Constructs a tag list from a variadic parameter list of strings
     */
    public static UniqueTagList build(String ... tagNames) {
        UniqueTagList tags = new UniqueTagList();

        try {
            for (String tagName : tagNames) {
                tags.add(new Tag(tagName));
            }
        } catch (DuplicateTagException e) {
            e.printStackTrace();
        } catch (IllegalValueException e) {
            e.printStackTrace();
        }

        return tags;
    }

}
```
###### /java/seedu/address/storage/XmlAddressBookStorage.java
``` java
    @Override
    public void setAddressBookFilePath(String path) {
        this.filePath = path;
    }

}
```
###### /java/seedu/address/storage/AddressBookStorage.java
``` java
    /** Sets the Address Book file path */
    void setAddressBookFilePath(String path);

}
```
###### /java/seedu/address/storage/StorageManager.java
``` java
    @Override
    @Subscribe
    public void handleExportRequestEvent(ExportRequestEvent ere) {
        try {
            saveAddressBook(ere.getYTomorrowToExport(), ere.getTargetFile().getPath());
        } catch (IOException e) {
            raise(new DataSavingExceptionEvent(e));
        }
    }
    
    @Override
    @Subscribe
    public void handleImportRequestEvent(ImportRequestEvent ire) {
        try {
            readAddressBook(ire.getTargetFile().getPath());
        } catch (DataConversionException | IOException e) {
            //TODO
        }
    }
    
    @Override
    @Subscribe
    public void handleTargetFileRequestEvent(TargetFileRequestEvent tfre) {
        addressBookStorage.setAddressBookFilePath(tfre.getTargetFile().getPath());
        tfre.getUserPrefs().getGuiSettings().setLastLoadedYTomorrow(tfre.getTargetFile().getPath());
    }

    @Override
    public void setAddressBookFilePath(String path) {
        addressBookStorage.setAddressBookFilePath(path);
    }

}
```
###### /java/seedu/address/storage/Storage.java
``` java
    /**
     * Saves the current version of the Address Book to the hard disk at a specified path.
     *   Creates the data file if it is missing.
     * Raises {@link DataSavingExceptionEvent} if there was an error during saving.
     */
    void handleExportRequestEvent(ExportRequestEvent ere);
    
    /**
     * Retrieves an Address Book at the specified path.
     */
    void handleImportRequestEvent(ImportRequestEvent ire);
    
    /**
     * Sets the file to which Address Book saving is done.
     */
    void handleTargetFileRequestEvent(TargetFileRequestEvent tfre);
    
}
```
###### /java/seedu/address/ui/ThemeManager.java
``` java
/**
 * The theme manager of the App.
 */
public class ThemeManager extends UiPart<Region> {

    public static final String THEME_FILE_FOLDER = "/themes/";
    public static final String STYLESHEET_EXTENSION = ".css";
    public static final String DEFAULT_STYLESHEET = "LimeTheme";

    private static final String FXML = "ThemeManager.fxml";

    @FXML
    private Parent fxmlToApply;

    private UserPrefs prefs;

    @FXML
    private ListView<String> cssList = new ListView<String>();

    /**
     * @param placeholder The AnchorPane where the ThemeManager must be inserted
     */
    public ThemeManager(AnchorPane placeholder, Parent fxmlToApply, UserPrefs prefs) {
        super(FXML);
        //setStyleSheet(DEFAULT_STYLESHEET);

        this.fxmlToApply = fxmlToApply;
        this.prefs = prefs;

        setConnections(THEME_FILE_FOLDER);
        addToPlaceholder(placeholder);
        setEventHandlerForSelectionChangeEvent();
    }

    /**
     *
     * @param Parent to set theme of.
     * @param Theme filename (without path or extension) to be applied.
     */
    public static void changeTheme(Parent root, String theme) {
        root.getStylesheets().clear();
        root.getStylesheets().add(MainApp.class.getResource(
                THEME_FILE_FOLDER
                + theme
                + STYLESHEET_EXTENSION)
                .toString());
    }

    private void setConnections(String path) {
        cssList.setItems(getThemes());
    }

    private void addToPlaceholder(AnchorPane placeholder) {
        SplitPane.setResizableWithParent(placeholder, false);
        placeholder.getChildren().add(cssList);
    }

    private void setEventHandlerForSelectionChangeEvent() {
        cssList.getSelectionModel().selectedItemProperty()
                .addListener((observable, oldValue, newValue) -> {
                    if (newValue != null) {
                        LOGGER.fine("Theme has changed to : '" + newValue + "'");
                        changeTheme(fxmlToApply, newValue);
                    }
                });
    }

    /**
     * @return Prewritten list of acceptable theme filenames (without path or extension).
     */
    private ObservableList<String> getThemes() {
        ObservableList<String> items = FXCollections.observableArrayList(
                "BlandTheme",
                "DarkTheme",
                "LimeTheme");
        return items;
    }
    
}
```
###### /java/seedu/address/ui/ThemeWindow.java
``` java
/**
 * The Theme Window. Provides a list of css files to load in order to change the application theme.
 * Under the list, a file browsing entry allows usage of an external css file.
 * The chosen configuration option is saved.
 */
public class ThemeWindow extends Window {

    protected static final String ICON = "/images/theme_icon.png";
    protected static final String FXML = "ThemeWindow.fxml";
    private static final String TITLE = "Theme Manager";

    @FXML
    private AnchorPane themeManagerPlaceholder;

    @FXML
    Parent fxmlToApply;

    private UserPrefs prefs;

    public ThemeWindow(Parent fxmlToApply, UserPrefs prefs) {
        super(FXML);

        setTitle(TITLE);
        FxViewUtil.setStageIcon(stage, ICON);
        this.fxmlToApply = fxmlToApply;
        this.prefs = prefs;
    }

    private AnchorPane getThemeManagerPlaceholder() {
        return themeManagerPlaceholder;
    }

    public void fillInnerParts() {
        new ThemeManager(getThemeManagerPlaceholder(), fxmlToApply, prefs);
    }

}
```
###### /java/seedu/address/ui/MainWindow.java
``` java
        ThemeManager.changeTheme(getRoot(), prefs.getGuiSettings().getStyleSheet());
```
###### /java/seedu/address/ui/MainWindow.java
``` java
    @FXML
    public void handleSave() {
        File selected = FileUtil.promptSaveFileDialog("Save and Use YTomorrow File", getStage(),
                new ExtensionFilter("YTomorrow XML Files", "*.xml"));
        
        if (selected != null) {
            ReadOnlyAddressBook current = logic.getYTomorrow();
            raise(new ExportRequestEvent(current, selected));
            raise(new TargetFileRequestEvent(selected, prefs));
        }
    }
    
    @FXML
    public void handleLoad() {
        File selected = FileUtil.promptOpenFileDialog("Load and Use YTomorrow File", getStage(),
                new ExtensionFilter("YTomorrow XML Files", "*.xml"));
        
        if (selected != null) {
            YTomorrow readIn = new YTomorrow();
            raise(new ImportRequestEvent(readIn, selected));
            logic.importYTomorrow(readIn);
            raise(new TargetFileRequestEvent(selected, prefs));
        }
    }
    
    @FXML
    public void handleExport() {
        File selected = FileUtil.promptSaveFileDialog("Export YTomorrow File", getStage(),
                new ExtensionFilter("YTomorrow XML Files", "*.xml"));
        
        if (selected != null) {
            ReadOnlyAddressBook current = logic.getYTomorrow();
            raise(new ExportRequestEvent(current, selected));
        }
    }
    
    @FXML
    public void handleImport() {
        File selected = FileUtil.promptOpenFileDialog("Import YTomorrow File", getStage(),
                new ExtensionFilter("YTomorrow XML Files", "*.xml"));
        
        if (selected != null) {
            YTomorrow readIn = new YTomorrow();
            raise(new ImportRequestEvent(readIn, selected));
            logic.importYTomorrow(readIn);
        }
    }
    
    @FXML
    public void handleTheme() {
        ThemeWindow themeWindow = new ThemeWindow(getRoot(), prefs);
        themeWindow.fillInnerParts();
        themeWindow.show();
    }
```
###### /java/seedu/address/ui/HelpWindow.java
``` java
    private static final String HELP_HTML =
            "CS2103JAN2017-F11-B3.github.io/main/util/offdoc.html"
            + "?mdfile=https://raw.githubusercontent.com/"
            + "CS2103JAN2017-F11-B3/main/master/docs/UserGuide.md";
```
###### /java/seedu/address/ui/UiPart.java
``` java
    /**
     * Sets the css file used for the UIPart's FXML.
     */
    public void setStyleSheet(String path) {
        ((Parent) fxmlLoader.getRoot()).getStylesheets().add(path);
    }
```
###### /resources/view/ThemeManager.fxml
``` fxml
		<ListView fx:id="themeListView" VBox.vgrow="ALWAYS" />
	</children>
</VBox>
```
